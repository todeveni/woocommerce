(self["webpackChunk_woocommerce_storybook"] = self["webpackChunk_woocommerce_storybook"] || []).push([[292],{

/***/ "../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4B73HROV.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cr: () => (/* binding */ TabScopedContextProvider),
/* harmony export */   M_: () => (/* binding */ useTabScopedContext),
/* harmony export */   np: () => (/* binding */ useTabProviderContext)
/* harmony export */ });
/* unused harmony exports useTabContext, TabContextProvider */
/* harmony import */ var _IB7YUKH5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/IB7YUKH5.js");
/* harmony import */ var _3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3ORBWXWF.js");
"use client";



// src/tab/tab-context.tsx
var ctx = (0,_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_0__/* .createStoreContext */ .B0)(
  [_IB7YUKH5_js__WEBPACK_IMPORTED_MODULE_1__/* .CompositeContextProvider */ .ws],
  [_IB7YUKH5_js__WEBPACK_IMPORTED_MODULE_1__/* .CompositeScopedContextProvider */ .aN]
);
var useTabContext = ctx.useContext;
var useTabScopedContext = ctx.useScopedContext;
var useTabProviderContext = ctx.useProviderContext;
var TabContextProvider = ctx.ContextProvider;
var TabScopedContextProvider = ctx.ScopedContextProvider;




/***/ }),

/***/ "../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/CQMDBRG5.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  W: () => (/* binding */ useTabStore)
});

// UNUSED EXPORTS: useTabStoreProps

// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7GBW5FLS.js + 1 modules
var _7GBW5FLS = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7GBW5FLS.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/EKQEJRUF.js
var EKQEJRUF = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/EKQEJRUF.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/6O5OEQGF.js
var _6O5OEQGF = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/6O5OEQGF.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4R3V3JGP.js
var _4R3V3JGP = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4R3V3JGP.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/IERTEJ3A.js
var IERTEJ3A = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/IERTEJ3A.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/22K762VQ.js
var _22K762VQ = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/22K762VQ.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/EAHJFCU4.js
var EAHJFCU4 = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/EAHJFCU4.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/Y3OOHFCN.js
var Y3OOHFCN = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/Y3OOHFCN.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/4R3V3JGP.js
var _chunks_4R3V3JGP = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/4R3V3JGP.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/tab/tab-store.js
"use client";








// src/tab/tab-store.ts
function createTabStore(props = {}) {
  var _a;
  const syncState = (_a = props.store) == null ? void 0 : _a.getState();
  const composite = (0,IERTEJ3A/* createCompositeStore */.z)((0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, props), {
    orientation: (0,Y3OOHFCN/* defaultValue */.Jh)(
      props.orientation,
      syncState == null ? void 0 : syncState.orientation,
      "horizontal"
    ),
    focusLoop: (0,Y3OOHFCN/* defaultValue */.Jh)(props.focusLoop, syncState == null ? void 0 : syncState.focusLoop, true)
  }));
  const panels = (0,_22K762VQ/* createCollectionStore */.I)();
  const initialState = (0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, composite.getState()), {
    selectedId: (0,Y3OOHFCN/* defaultValue */.Jh)(
      props.selectedId,
      syncState == null ? void 0 : syncState.selectedId,
      props.defaultSelectedId,
      void 0
    ),
    selectOnMove: (0,Y3OOHFCN/* defaultValue */.Jh)(
      props.selectOnMove,
      syncState == null ? void 0 : syncState.selectOnMove,
      true
    )
  });
  const tab = (0,EAHJFCU4/* createStore */.y$)(initialState, composite, props.store);
  (0,EAHJFCU4/* setup */.mj)(
    tab,
    () => (0,EAHJFCU4/* sync */.OH)(tab, ["moves"], () => {
      const { activeId, selectOnMove } = tab.getState();
      if (!selectOnMove)
        return;
      if (!activeId)
        return;
      const tabItem = composite.item(activeId);
      if (!tabItem)
        return;
      if (tabItem.dimmed)
        return;
      if (tabItem.disabled)
        return;
      tab.setState("selectedId", tabItem.id);
    })
  );
  (0,EAHJFCU4/* setup */.mj)(
    tab,
    () => (0,EAHJFCU4/* batch */.vA)(
      tab,
      ["selectedId"],
      (state) => tab.setState("activeId", state.selectedId)
    )
  );
  (0,EAHJFCU4/* setup */.mj)(
    tab,
    () => (0,EAHJFCU4/* sync */.OH)(tab, ["selectedId", "renderedItems"], (state) => {
      if (state.selectedId !== void 0)
        return;
      const { activeId, renderedItems } = tab.getState();
      const tabItem = composite.item(activeId);
      if (tabItem && !tabItem.disabled && !tabItem.dimmed) {
        tab.setState("selectedId", tabItem.id);
      } else {
        const tabItem2 = renderedItems.find(
          (item) => !item.disabled && !item.dimmed
        );
        tab.setState("selectedId", tabItem2 == null ? void 0 : tabItem2.id);
      }
    })
  );
  (0,EAHJFCU4/* setup */.mj)(
    tab,
    () => (0,EAHJFCU4/* sync */.OH)(tab, ["renderedItems"], (state) => {
      const tabs = state.renderedItems;
      if (!tabs.length)
        return;
      return (0,EAHJFCU4/* sync */.OH)(panels, ["renderedItems"], (state2) => {
        const items = state2.renderedItems;
        const hasOrphanPanels = items.some((panel) => !panel.tabId);
        if (!hasOrphanPanels)
          return;
        items.forEach((panel, i) => {
          if (panel.tabId)
            return;
          const tabItem = tabs[i];
          if (!tabItem)
            return;
          panels.renderItem((0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, panel), { tabId: tabItem.id }));
        });
      });
    })
  );
  return (0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, composite), tab), {
    panels,
    setSelectedId: (id) => tab.setState("selectedId", id),
    select: (id) => {
      tab.setState("selectedId", id);
      composite.move(id);
    }
  });
}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/CQMDBRG5.js
"use client";





// src/tab/tab-store.ts


function useTabStoreProps(store, update, props) {
  store = (0,_7GBW5FLS/* useCompositeStoreProps */.Y)(store, update, props);
  (0,EKQEJRUF/* useStoreProps */.Tz)(store, props, "selectedId", "setSelectedId");
  (0,EKQEJRUF/* useStoreProps */.Tz)(store, props, "selectOnMove");
  const [panels, updatePanels] = (0,EKQEJRUF/* useStore */.Pj)(() => store.panels, {});
  (0,_6O5OEQGF/* useUpdateEffect */.w5)(updatePanels, [store, updatePanels]);
  return (0,react.useMemo)(() => (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, store), { panels }), [store, panels]);
}
function useTabStore(props = {}) {
  const [store, update] = (0,EKQEJRUF/* useStore */.Pj)(createTabStore, props);
  return useTabStoreProps(store, update, props);
}




/***/ }),

/***/ "../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/tab/tab-list.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ TabList)
/* harmony export */ });
/* unused harmony export useTabList */
/* harmony import */ var _chunks_4B73HROV_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4B73HROV.js");
/* harmony import */ var _chunks_7QTPYGNZ_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7QTPYGNZ.js");
/* harmony import */ var _chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3ORBWXWF.js");
/* harmony import */ var _chunks_6O5OEQGF_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/6O5OEQGF.js");
/* harmony import */ var _chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4R3V3JGP.js");
/* harmony import */ var _ariakit_core_utils_misc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/Y3OOHFCN.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
"use client";












// src/tab/tab-list.tsx


var useTabList = (0,_chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_1__/* .createHook */ .ab)((_a) => {
  var _b = _a, { store } = _b, props = (0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__objRest */ .YG)(_b, ["store"]);
  const context = (0,_chunks_4B73HROV_js__WEBPACK_IMPORTED_MODULE_3__/* .useTabProviderContext */ .np)();
  store = store || context;
  (0,_ariakit_core_utils_misc__WEBPACK_IMPORTED_MODULE_4__/* .invariant */ .V1)(
    store,
     false && 0
  );
  const orientation = store.useState(
    (state) => state.orientation === "both" ? void 0 : state.orientation
  );
  props = (0,_chunks_6O5OEQGF_js__WEBPACK_IMPORTED_MODULE_5__/* .useWrapElement */ .w7)(
    props,
    (element) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_chunks_4B73HROV_js__WEBPACK_IMPORTED_MODULE_3__/* .TabScopedContextProvider */ .Cr, { value: store, children: element }),
    [store]
  );
  props = (0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__spreadValues */ .IA)({
    role: "tablist",
    "aria-orientation": orientation
  }, props);
  props = (0,_chunks_7QTPYGNZ_js__WEBPACK_IMPORTED_MODULE_6__/* .useComposite */ .T)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__spreadValues */ .IA)({ store }, props));
  return props;
});
var TabList = (0,_chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_1__/* .createComponent */ .a0)((props) => {
  const htmlProps = useTabList(props);
  return (0,_chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_1__/* .createElement */ .n)("div", htmlProps);
});
if (false) {}



/***/ }),

/***/ "../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/tab/tab-panel.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ TabPanel)
/* harmony export */ });
/* unused harmony export useTabPanel */
/* harmony import */ var _chunks_UH3I23HL_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/UH3I23HL.js");
/* harmony import */ var _chunks_4B73HROV_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4B73HROV.js");
/* harmony import */ var _chunks_CLE7NTOY_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/CLE7NTOY.js");
/* harmony import */ var _chunks_KK7H3W2B_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/KK7H3W2B.js");
/* harmony import */ var _chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3ORBWXWF.js");
/* harmony import */ var _chunks_SFCBA2JZ_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/SFCBA2JZ.js");
/* harmony import */ var _chunks_6O5OEQGF_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/6O5OEQGF.js");
/* harmony import */ var _chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4R3V3JGP.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _ariakit_core_utils_focus__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/utils/focus.js");
/* harmony import */ var _ariakit_core_utils_misc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/Y3OOHFCN.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
"use client";
















// src/tab/tab-panel.tsx




var useTabPanel = (0,_chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_2__/* .createHook */ .ab)(
  (_a) => {
    var _b = _a, { store, tabId: tabIdProp, getItem: getItemProp } = _b, props = (0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__/* .__objRest */ .YG)(_b, ["store", "tabId", "getItem"]);
    const context = (0,_chunks_4B73HROV_js__WEBPACK_IMPORTED_MODULE_4__/* .useTabProviderContext */ .np)();
    store = store || context;
    (0,_ariakit_core_utils_misc__WEBPACK_IMPORTED_MODULE_5__/* .invariant */ .V1)(
      store,
       false && 0
    );
    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    const id = (0,_chunks_6O5OEQGF_js__WEBPACK_IMPORTED_MODULE_6__/* .useId */ .Bi)(props.id);
    const [hasTabbableChildren, setHasTabbableChildren] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
      const element = ref.current;
      if (!element)
        return;
      const tabbable = (0,_ariakit_core_utils_focus__WEBPACK_IMPORTED_MODULE_7__/* .getAllTabbableIn */ .a9)(element);
      setHasTabbableChildren(!!tabbable.length);
    }, []);
    const getItem = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
      (item) => {
        const nextItem = (0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__/* .__spreadProps */ .ko)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__/* .__spreadValues */ .IA)({}, item), { id: id || item.id, tabId: tabIdProp });
        if (getItemProp) {
          return getItemProp(nextItem);
        }
        return nextItem;
      },
      [id, tabIdProp, getItemProp]
    );
    props = (0,_chunks_6O5OEQGF_js__WEBPACK_IMPORTED_MODULE_6__/* .useWrapElement */ .w7)(
      props,
      (element) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_chunks_4B73HROV_js__WEBPACK_IMPORTED_MODULE_4__/* .TabScopedContextProvider */ .Cr, { value: store, children: element }),
      [store]
    );
    const tabId = store.panels.useState(
      () => {
        var _a2;
        return tabIdProp || ((_a2 = store == null ? void 0 : store.panels.item(id)) == null ? void 0 : _a2.tabId);
      }
    );
    const open = store.useState(
      (state) => !!tabId && state.selectedId === tabId
    );
    props = (0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__/* .__spreadProps */ .ko)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__/* .__spreadValues */ .IA)({
      id,
      role: "tabpanel",
      "aria-labelledby": tabId || void 0
    }, props), {
      ref: (0,_chunks_6O5OEQGF_js__WEBPACK_IMPORTED_MODULE_6__/* .useMergeRefs */ .SV)(ref, props.ref)
    });
    const disclosure = (0,_chunks_SFCBA2JZ_js__WEBPACK_IMPORTED_MODULE_8__/* .useDisclosureStore */ .E)({ open });
    props = (0,_chunks_KK7H3W2B_js__WEBPACK_IMPORTED_MODULE_9__/* .useFocusable */ .W)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__/* .__spreadValues */ .IA)({ focusable: !hasTabbableChildren }, props));
    props = (0,_chunks_CLE7NTOY_js__WEBPACK_IMPORTED_MODULE_10__/* .useDisclosureContent */ .aT)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__/* .__spreadValues */ .IA)({ store: disclosure }, props));
    props = (0,_chunks_UH3I23HL_js__WEBPACK_IMPORTED_MODULE_11__/* .useCollectionItem */ .v)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__/* .__spreadProps */ .ko)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_3__/* .__spreadValues */ .IA)({ store: store.panels }, props), { getItem }));
    return props;
  }
);
var TabPanel = (0,_chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_2__/* .createComponent */ .a0)((props) => {
  const htmlProps = useTabPanel(props);
  return (0,_chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_2__/* .createElement */ .n)("div", htmlProps);
});
if (false) {}



/***/ }),

/***/ "../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/tab/tab.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ Tab)
/* harmony export */ });
/* unused harmony export useTab */
/* harmony import */ var _chunks_QZLXIDNP_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/QZLXIDNP.js");
/* harmony import */ var _chunks_4B73HROV_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4B73HROV.js");
/* harmony import */ var _chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3ORBWXWF.js");
/* harmony import */ var _chunks_6O5OEQGF_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/6O5OEQGF.js");
/* harmony import */ var _chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4R3V3JGP.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _ariakit_core_utils_misc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/Y3OOHFCN.js");
"use client";















// src/tab/tab.ts


var useTab = (0,_chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_1__/* .createHook */ .ab)(
  (_a) => {
    var _b = _a, {
      store,
      accessibleWhenDisabled = true,
      getItem: getItemProp
    } = _b, props = (0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__objRest */ .YG)(_b, [
      "store",
      "accessibleWhenDisabled",
      "getItem"
    ]);
    const context = (0,_chunks_4B73HROV_js__WEBPACK_IMPORTED_MODULE_3__/* .useTabScopedContext */ .M_)();
    store = store || context;
    (0,_ariakit_core_utils_misc__WEBPACK_IMPORTED_MODULE_4__/* .invariant */ .V1)(
      store,
       false && 0
    );
    const defaultId = (0,_chunks_6O5OEQGF_js__WEBPACK_IMPORTED_MODULE_5__/* .useId */ .Bi)();
    const id = props.id || defaultId;
    const dimmed = (0,_ariakit_core_utils_misc__WEBPACK_IMPORTED_MODULE_4__/* .disabledFromProps */ .$f)(props);
    const getItem = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
      (item) => {
        const nextItem = (0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__spreadProps */ .ko)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__spreadValues */ .IA)({}, item), { dimmed });
        if (getItemProp) {
          return getItemProp(nextItem);
        }
        return nextItem;
      },
      [dimmed, getItemProp]
    );
    const onClickProp = props.onClick;
    const onClick = (0,_chunks_6O5OEQGF_js__WEBPACK_IMPORTED_MODULE_5__/* .useEvent */ ._q)((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (event.defaultPrevented)
        return;
      store == null ? void 0 : store.setSelectedId(id);
    });
    const panelId = store.panels.useState(
      (state) => {
        var _a2;
        return (_a2 = state.items.find((item) => item.tabId === id)) == null ? void 0 : _a2.id;
      }
    );
    const selected = store.useState((state) => !!id && state.selectedId === id);
    props = (0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__spreadProps */ .ko)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__spreadValues */ .IA)({
      id,
      role: "tab",
      "aria-selected": selected,
      "aria-controls": panelId || void 0
    }, props), {
      onClick
    });
    props = (0,_chunks_QZLXIDNP_js__WEBPACK_IMPORTED_MODULE_6__/* .useCompositeItem */ .k)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__spreadProps */ .ko)((0,_chunks_4R3V3JGP_js__WEBPACK_IMPORTED_MODULE_2__/* .__spreadValues */ .IA)({
      store
    }, props), {
      accessibleWhenDisabled,
      getItem,
      shouldRegisterItem: !!defaultId ? props.shouldRegisterItem : false
    }));
    return props;
  }
);
var Tab = (0,_chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_1__/* .createMemoComponent */ .MA)((props) => {
  const htmlProps = useTab(props);
  return (0,_chunks_3ORBWXWF_js__WEBPACK_IMPORTED_MODULE_1__/* .createElement */ .n)("button", htmlProps);
});
if (false) {}



/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  oS: () => (/* reexport */ provider),
  m9: () => (/* reexport */ BlockList),
  LJ: () => (/* reexport */ BlockTools),
  us: () => (/* reexport */ observe_typing),
  Pe: () => (/* reexport */ writing_flow),
  M_: () => (/* reexport */ store_store)
});

// UNUSED EXPORTS: AlignmentControl, AlignmentToolbar, Autocomplete, BlockAlignmentControl, BlockAlignmentToolbar, BlockBreadcrumb, BlockCanvas, BlockColorsStyleSelector, BlockContextProvider, BlockControls, BlockEdit, BlockEditorKeyboardShortcuts, BlockFormatControls, BlockIcon, BlockInspector, BlockMover, BlockNavigationDropdown, BlockPopover, BlockPreview, BlockSelectionClearer, BlockSettingsMenu, BlockSettingsMenuControls, BlockStyles, BlockTitle, BlockToolbar, BlockVerticalAlignmentControl, BlockVerticalAlignmentToolbar, ButtonBlockAppender, ButtonBlockerAppender, ColorPalette, ColorPaletteControl, ContrastChecker, CopyHandler, DefaultBlockAppender, FontSizePicker, HeadingLevelDropdown, HeightControl, InnerBlocks, Inserter, InspectorAdvancedControls, InspectorControls, JustifyContentControl, JustifyToolbar, LineHeightControl, MediaPlaceholder, MediaReplaceFlow, MediaUpload, MediaUploadCheck, MultiSelectScrollIntoView, NavigableToolbar, PanelColorSettings, PlainText, RecursionProvider, ReusableBlocksRenameHint, RichText, RichTextShortcut, RichTextToolbarButton, SETTINGS_DEFAULTS, SkipToSelectedBlock, ToolSelector, Typewriter, URLInput, URLInputButton, URLPopover, Warning, __experimentalBlockAlignmentMatrixControl, __experimentalBlockFullHeightAligmentControl, __experimentalBlockPatternSetup, __experimentalBlockPatternsList, __experimentalBlockVariationPicker, __experimentalBlockVariationTransforms, __experimentalBorderRadiusControl, __experimentalColorGradientControl, __experimentalColorGradientSettingsDropdown, __experimentalDateFormatPicker, __experimentalDuotoneControl, __experimentalFontAppearanceControl, __experimentalFontFamilyControl, __experimentalGetBorderClassesAndStyles, __experimentalGetColorClassesAndStyles, __experimentalGetElementClassName, __experimentalGetGapCSSValue, __experimentalGetGradientClass, __experimentalGetGradientObjectByGradientValue, __experimentalGetShadowClassesAndStyles, __experimentalGetSpacingClassesAndStyles, __experimentalImageEditor, __experimentalImageSizeControl, __experimentalImageURLInputUI, __experimentalInspectorPopoverHeader, __experimentalLetterSpacingControl, __experimentalLibrary, __experimentalLinkControl, __experimentalLinkControlSearchInput, __experimentalLinkControlSearchItem, __experimentalLinkControlSearchResults, __experimentalListView, __experimentalPanelColorGradientSettings, __experimentalPreviewOptions, __experimentalPublishDateTimePicker, __experimentalRecursionProvider, __experimentalResponsiveBlockControl, __experimentalSpacingSizesControl, __experimentalTextDecorationControl, __experimentalTextTransformControl, __experimentalUnitControl, __experimentalUseBlockOverlayActive, __experimentalUseBlockPreview, __experimentalUseBorderProps, __experimentalUseColorProps, __experimentalUseCustomSides, __experimentalUseGradient, __experimentalUseHasRecursion, __experimentalUseMultipleOriginColorsAndGradients, __experimentalUseResizeCanvas, __experimentalWritingModeControl, __unstableBlockNameContext, __unstableBlockSettingsMenuFirstItem, __unstableBlockToolbarLastItem, __unstableEditorStyles, __unstableIframe, __unstableInserterMenuExtension, __unstableRichTextInputEvent, __unstableUseBlockSelectionClearer, __unstableUseClipboardHandler, __unstableUseMouseMoveTypingReset, __unstableUseTypewriter, __unstableUseTypingObserver, createCustomColorsHOC, getColorClassName, getColorObjectByAttributeValues, getColorObjectByColorValue, getComputedFluidTypographyValue, getCustomValueFromPreset, getFontSize, getFontSizeClass, getFontSizeObjectByValue, getGradientSlugByValue, getGradientValueBySlug, getPxFromCssUnit, getSpacingPresetCssVar, getTypographyClassesAndStyles, isValueSpacingPreset, privateApis, storeConfig, transformStyles, useBlockCommands, useBlockDisplayInformation, useBlockEditContext, useBlockEditingMode, useBlockProps, useCachedTruthy, useHasRecursion, useInnerBlocksProps, useSetting, useSettings, useZoomOut, withColorContext, withColors, withFontSizes

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/private-selectors.js
var private_selectors_namespaceObject = {};
__webpack_require__.r(private_selectors_namespaceObject);
__webpack_require__.d(private_selectors_namespaceObject, {
  getAllPatterns: () => (getAllPatterns),
  getBlockRemovalRules: () => (getBlockRemovalRules),
  getBlockSettings: () => (getBlockSettings),
  getBlockWithoutAttributes: () => (getBlockWithoutAttributes),
  getContentLockingParent: () => (getContentLockingParent),
  getEnabledBlockParents: () => (getEnabledBlockParents),
  getEnabledClientIdsTree: () => (getEnabledClientIdsTree),
  getExpandedBlock: () => (getExpandedBlock),
  getInserterMediaCategories: () => (getInserterMediaCategories),
  getLastFocus: () => (getLastFocus),
  getLastInsertedBlocksClientIds: () => (getLastInsertedBlocksClientIds),
  getOpenedBlockSettingsMenu: () => (getOpenedBlockSettingsMenu),
  getPatternBySlug: () => (getPatternBySlug),
  getRegisteredInserterMediaCategories: () => (getRegisteredInserterMediaCategories),
  getRemovalPromptData: () => (getRemovalPromptData),
  getReusableBlocks: () => (getReusableBlocks),
  getStyleOverrides: () => (getStyleOverrides),
  getTemporarilyEditingAsBlocks: () => (getTemporarilyEditingAsBlocks),
  getTemporarilyEditingFocusModeToRevert: () => (getTemporarilyEditingFocusModeToRevert),
  hasAllowedPatterns: () => (hasAllowedPatterns),
  isBlockInterfaceHidden: () => (private_selectors_isBlockInterfaceHidden),
  isBlockSubtreeDisabled: () => (isBlockSubtreeDisabled),
  isDragging: () => (private_selectors_isDragging),
  isResolvingPatterns: () => (isResolvingPatterns)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/selectors.js
var selectors_namespaceObject = {};
__webpack_require__.r(selectors_namespaceObject);
__webpack_require__.d(selectors_namespaceObject, {
  __experimentalGetActiveBlockIdByBlockNames: () => (__experimentalGetActiveBlockIdByBlockNames),
  __experimentalGetAllowedBlocks: () => (__experimentalGetAllowedBlocks),
  __experimentalGetAllowedPatterns: () => (__experimentalGetAllowedPatterns),
  __experimentalGetBlockListSettingsForBlocks: () => (__experimentalGetBlockListSettingsForBlocks),
  __experimentalGetDirectInsertBlock: () => (__experimentalGetDirectInsertBlock),
  __experimentalGetGlobalBlocksByName: () => (__experimentalGetGlobalBlocksByName),
  __experimentalGetLastBlockAttributeChanges: () => (__experimentalGetLastBlockAttributeChanges),
  __experimentalGetParsedPattern: () => (__experimentalGetParsedPattern),
  __experimentalGetPatternTransformItems: () => (__experimentalGetPatternTransformItems),
  __experimentalGetPatternsByBlockTypes: () => (__experimentalGetPatternsByBlockTypes),
  __experimentalGetReusableBlockTitle: () => (__experimentalGetReusableBlockTitle),
  __unstableGetBlockWithoutInnerBlocks: () => (__unstableGetBlockWithoutInnerBlocks),
  __unstableGetClientIdWithClientIdsTree: () => (__unstableGetClientIdWithClientIdsTree),
  __unstableGetClientIdsTree: () => (__unstableGetClientIdsTree),
  __unstableGetContentLockingParent: () => (__unstableGetContentLockingParent),
  __unstableGetEditorMode: () => (__unstableGetEditorMode),
  __unstableGetSelectedBlocksWithPartialSelection: () => (__unstableGetSelectedBlocksWithPartialSelection),
  __unstableGetTemporarilyEditingAsBlocks: () => (__unstableGetTemporarilyEditingAsBlocks),
  __unstableGetTemporarilyEditingFocusModeToRevert: () => (__unstableGetTemporarilyEditingFocusModeToRevert),
  __unstableGetVisibleBlocks: () => (__unstableGetVisibleBlocks),
  __unstableHasActiveBlockOverlayActive: () => (__unstableHasActiveBlockOverlayActive),
  __unstableIsFullySelected: () => (__unstableIsFullySelected),
  __unstableIsLastBlockChangeIgnored: () => (__unstableIsLastBlockChangeIgnored),
  __unstableIsSelectionCollapsed: () => (__unstableIsSelectionCollapsed),
  __unstableIsSelectionMergeable: () => (__unstableIsSelectionMergeable),
  __unstableIsWithinBlockOverlay: () => (__unstableIsWithinBlockOverlay),
  __unstableSelectionHasUnmergeableBlock: () => (__unstableSelectionHasUnmergeableBlock),
  areInnerBlocksControlled: () => (areInnerBlocksControlled),
  canEditBlock: () => (canEditBlock),
  canInsertBlockType: () => (canInsertBlockType),
  canInsertBlocks: () => (canInsertBlocks),
  canLockBlockType: () => (canLockBlockType),
  canMoveBlock: () => (canMoveBlock),
  canMoveBlocks: () => (canMoveBlocks),
  canRemoveBlock: () => (canRemoveBlock),
  canRemoveBlocks: () => (canRemoveBlocks),
  didAutomaticChange: () => (didAutomaticChange),
  getAdjacentBlockClientId: () => (getAdjacentBlockClientId),
  getAllowedBlocks: () => (getAllowedBlocks),
  getBlock: () => (getBlock),
  getBlockAttributes: () => (getBlockAttributes),
  getBlockCount: () => (getBlockCount),
  getBlockEditingMode: () => (getBlockEditingMode),
  getBlockHierarchyRootClientId: () => (getBlockHierarchyRootClientId),
  getBlockIndex: () => (getBlockIndex),
  getBlockInsertionPoint: () => (getBlockInsertionPoint),
  getBlockListSettings: () => (getBlockListSettings),
  getBlockMode: () => (getBlockMode),
  getBlockName: () => (getBlockName),
  getBlockNamesByClientId: () => (getBlockNamesByClientId),
  getBlockOrder: () => (getBlockOrder),
  getBlockParents: () => (getBlockParents),
  getBlockParentsByBlockName: () => (getBlockParentsByBlockName),
  getBlockRootClientId: () => (getBlockRootClientId),
  getBlockSelectionEnd: () => (getBlockSelectionEnd),
  getBlockSelectionStart: () => (getBlockSelectionStart),
  getBlockTransformItems: () => (getBlockTransformItems),
  getBlocks: () => (getBlocks),
  getBlocksByClientId: () => (getBlocksByClientId),
  getBlocksByName: () => (getBlocksByName),
  getClientIdsOfDescendants: () => (getClientIdsOfDescendants),
  getClientIdsWithDescendants: () => (getClientIdsWithDescendants),
  getDirectInsertBlock: () => (getDirectInsertBlock),
  getDraggedBlockClientIds: () => (getDraggedBlockClientIds),
  getFirstMultiSelectedBlockClientId: () => (getFirstMultiSelectedBlockClientId),
  getGlobalBlockCount: () => (getGlobalBlockCount),
  getInserterItems: () => (getInserterItems),
  getLastMultiSelectedBlockClientId: () => (getLastMultiSelectedBlockClientId),
  getLowestCommonAncestorWithSelectedBlock: () => (getLowestCommonAncestorWithSelectedBlock),
  getMultiSelectedBlockClientIds: () => (getMultiSelectedBlockClientIds),
  getMultiSelectedBlocks: () => (getMultiSelectedBlocks),
  getMultiSelectedBlocksEndClientId: () => (getMultiSelectedBlocksEndClientId),
  getMultiSelectedBlocksStartClientId: () => (getMultiSelectedBlocksStartClientId),
  getNextBlockClientId: () => (getNextBlockClientId),
  getPatternsByBlockTypes: () => (getPatternsByBlockTypes),
  getPreviousBlockClientId: () => (getPreviousBlockClientId),
  getSelectedBlock: () => (getSelectedBlock),
  getSelectedBlockClientId: () => (getSelectedBlockClientId),
  getSelectedBlockClientIds: () => (getSelectedBlockClientIds),
  getSelectedBlockCount: () => (getSelectedBlockCount),
  getSelectedBlocksInitialCaretPosition: () => (getSelectedBlocksInitialCaretPosition),
  getSelectionEnd: () => (getSelectionEnd),
  getSelectionStart: () => (getSelectionStart),
  getSettings: () => (getSettings),
  getTemplate: () => (getTemplate),
  getTemplateLock: () => (getTemplateLock),
  hasBlockMovingClientId: () => (selectors_hasBlockMovingClientId),
  hasDraggedInnerBlock: () => (hasDraggedInnerBlock),
  hasInserterItems: () => (hasInserterItems),
  hasMultiSelection: () => (hasMultiSelection),
  hasSelectedBlock: () => (hasSelectedBlock),
  hasSelectedInnerBlock: () => (hasSelectedInnerBlock),
  isAncestorBeingDragged: () => (isAncestorBeingDragged),
  isAncestorMultiSelected: () => (isAncestorMultiSelected),
  isBlockBeingDragged: () => (isBlockBeingDragged),
  isBlockHighlighted: () => (isBlockHighlighted),
  isBlockInsertionPointVisible: () => (isBlockInsertionPointVisible),
  isBlockMultiSelected: () => (isBlockMultiSelected),
  isBlockSelected: () => (isBlockSelected),
  isBlockValid: () => (isBlockValid),
  isBlockVisible: () => (isBlockVisible),
  isBlockWithinSelection: () => (isBlockWithinSelection),
  isCaretWithinFormattedText: () => (isCaretWithinFormattedText),
  isDraggingBlocks: () => (isDraggingBlocks),
  isFirstMultiSelectedBlock: () => (isFirstMultiSelectedBlock),
  isGroupable: () => (isGroupable),
  isLastBlockChangePersistent: () => (isLastBlockChangePersistent),
  isMultiSelecting: () => (selectors_isMultiSelecting),
  isNavigationMode: () => (isNavigationMode),
  isSelectionEnabled: () => (selectors_isSelectionEnabled),
  isTyping: () => (selectors_isTyping),
  isUngroupable: () => (isUngroupable),
  isValidTemplate: () => (isValidTemplate),
  wasBlockJustInserted: () => (wasBlockJustInserted)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/private-actions.js
var private_actions_namespaceObject = {};
__webpack_require__.r(private_actions_namespaceObject);
__webpack_require__.d(private_actions_namespaceObject, {
  __experimentalUpdateSettings: () => (__experimentalUpdateSettings),
  clearBlockRemovalPrompt: () => (clearBlockRemovalPrompt),
  deleteStyleOverride: () => (deleteStyleOverride),
  ensureDefaultBlock: () => (ensureDefaultBlock),
  expandBlock: () => (expandBlock),
  hideBlockInterface: () => (hideBlockInterface),
  modifyContentLockBlock: () => (modifyContentLockBlock),
  privateRemoveBlocks: () => (privateRemoveBlocks),
  setBlockRemovalRules: () => (setBlockRemovalRules),
  setLastFocus: () => (setLastFocus),
  setOpenedBlockSettingsMenu: () => (setOpenedBlockSettingsMenu),
  setStyleOverride: () => (setStyleOverride),
  showBlockInterface: () => (showBlockInterface),
  startDragging: () => (startDragging),
  stopDragging: () => (stopDragging),
  stopEditingAsBlocks: () => (stopEditingAsBlocks),
  syncDerivedUpdates: () => (syncDerivedUpdates)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+notices@5.0.2_react@18.3.1/node_modules/@wordpress/notices/build-module/store/actions.js
var actions_namespaceObject = {};
__webpack_require__.r(actions_namespaceObject);
__webpack_require__.d(actions_namespaceObject, {
  createErrorNotice: () => (createErrorNotice),
  createInfoNotice: () => (createInfoNotice),
  createNotice: () => (createNotice),
  createSuccessNotice: () => (createSuccessNotice),
  createWarningNotice: () => (createWarningNotice),
  removeAllNotices: () => (removeAllNotices),
  removeNotice: () => (removeNotice),
  removeNotices: () => (removeNotices)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+notices@5.0.2_react@18.3.1/node_modules/@wordpress/notices/build-module/store/selectors.js
var store_selectors_namespaceObject = {};
__webpack_require__.r(store_selectors_namespaceObject);
__webpack_require__.d(store_selectors_namespaceObject, {
  getNotices: () => (getNotices)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/actions.js
var store_actions_namespaceObject = {};
__webpack_require__.r(store_actions_namespaceObject);
__webpack_require__.d(store_actions_namespaceObject, {
  __unstableDeleteSelection: () => (__unstableDeleteSelection),
  __unstableExpandSelection: () => (__unstableExpandSelection),
  __unstableMarkAutomaticChange: () => (__unstableMarkAutomaticChange),
  __unstableMarkLastChangeAsPersistent: () => (__unstableMarkLastChangeAsPersistent),
  __unstableMarkNextChangeAsNotPersistent: () => (__unstableMarkNextChangeAsNotPersistent),
  __unstableSaveReusableBlock: () => (__unstableSaveReusableBlock),
  __unstableSetEditorMode: () => (__unstableSetEditorMode),
  __unstableSetTemporarilyEditingAsBlocks: () => (__unstableSetTemporarilyEditingAsBlocks),
  __unstableSplitSelection: () => (__unstableSplitSelection),
  clearSelectedBlock: () => (clearSelectedBlock),
  duplicateBlocks: () => (duplicateBlocks),
  enterFormattedText: () => (enterFormattedText),
  exitFormattedText: () => (exitFormattedText),
  flashBlock: () => (flashBlock),
  hideInsertionPoint: () => (hideInsertionPoint),
  insertAfterBlock: () => (insertAfterBlock),
  insertBeforeBlock: () => (insertBeforeBlock),
  insertBlock: () => (insertBlock),
  insertBlocks: () => (insertBlocks),
  insertDefaultBlock: () => (insertDefaultBlock),
  mergeBlocks: () => (mergeBlocks),
  moveBlockToPosition: () => (moveBlockToPosition),
  moveBlocksDown: () => (moveBlocksDown),
  moveBlocksToPosition: () => (moveBlocksToPosition),
  moveBlocksUp: () => (moveBlocksUp),
  multiSelect: () => (multiSelect),
  receiveBlocks: () => (receiveBlocks),
  registerInserterMediaCategory: () => (registerInserterMediaCategory),
  removeBlock: () => (removeBlock),
  removeBlocks: () => (removeBlocks),
  replaceBlock: () => (replaceBlock),
  replaceBlocks: () => (replaceBlocks),
  replaceInnerBlocks: () => (replaceInnerBlocks),
  resetBlocks: () => (resetBlocks),
  resetSelection: () => (resetSelection),
  selectBlock: () => (selectBlock),
  selectNextBlock: () => (selectNextBlock),
  selectPreviousBlock: () => (selectPreviousBlock),
  selectionChange: () => (selectionChange),
  setBlockEditingMode: () => (setBlockEditingMode),
  setBlockMovingClientId: () => (setBlockMovingClientId),
  setBlockVisibility: () => (setBlockVisibility),
  setHasControlledInnerBlocks: () => (setHasControlledInnerBlocks),
  setNavigationMode: () => (setNavigationMode),
  setTemplateValidity: () => (setTemplateValidity),
  showInsertionPoint: () => (showInsertionPoint),
  startDraggingBlocks: () => (startDraggingBlocks),
  startMultiSelect: () => (startMultiSelect),
  startTyping: () => (startTyping),
  stopDraggingBlocks: () => (stopDraggingBlocks),
  stopMultiSelect: () => (stopMultiSelect),
  stopTyping: () => (stopTyping),
  synchronizeTemplate: () => (synchronizeTemplate),
  toggleBlockHighlight: () => (toggleBlockHighlight),
  toggleBlockMode: () => (toggleBlockMode),
  toggleSelection: () => (toggleSelection),
  unsetBlockEditingMode: () => (unsetBlockEditingMode),
  updateBlock: () => (updateBlock),
  updateBlockAttributes: () => (updateBlockAttributes),
  updateBlockListSettings: () => (updateBlockListSettings),
  updateSettings: () => (updateSettings),
  validateBlocksToTemplate: () => (validateBlocksToTemplate)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-base/styles.js
var toggle_group_control_option_base_styles_namespaceObject = {};
__webpack_require__.r(toggle_group_control_option_base_styles_namespaceObject);
__webpack_require__.d(toggle_group_control_option_base_styles_namespaceObject, {
  ButtonContentView: () => (ButtonContentView),
  LabelView: () => (LabelView),
  ou: () => (backdropView),
  uG: () => (buttonView),
  eh: () => (labelBlock)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+preferences@4.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_sgab4ar2tci4ud4kulkqwbhmly/node_modules/@wordpress/preferences/build-module/store/actions.js
var build_module_store_actions_namespaceObject = {};
__webpack_require__.r(build_module_store_actions_namespaceObject);
__webpack_require__.d(build_module_store_actions_namespaceObject, {
  set: () => (set),
  setDefaults: () => (setDefaults),
  setPersistenceLayer: () => (setPersistenceLayer),
  toggle: () => (toggle)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+preferences@4.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_sgab4ar2tci4ud4kulkqwbhmly/node_modules/@wordpress/preferences/build-module/store/selectors.js
var build_module_store_selectors_namespaceObject = {};
__webpack_require__.r(build_module_store_selectors_namespaceObject);
__webpack_require__.d(build_module_store_selectors_namespaceObject, {
  get: () => (get)
});

// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/index.js + 71 modules
var build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/use-dispatch/use-dispatch.js
var use_dispatch = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/use-dispatch/use-dispatch.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/registry-provider/use-registry.js
var use_registry = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/registry-provider/use-registry.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/create-higher-order-component/index.js
var create_higher_order_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/create-higher-order-component/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+hooks@4.0.1/node_modules/@wordpress/hooks/build-module/index.js + 10 modules
var hooks_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+hooks@4.0.1/node_modules/@wordpress/hooks/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-edit/context.js
/**
 * WordPress dependencies
 */

const mayDisplayControlsKey = Symbol('mayDisplayControls');
const mayDisplayParentControlsKey = Symbol('mayDisplayParentControls');
const blockEditingModeKey = Symbol('blockEditingMode');
const blockBindingsKey = Symbol('blockBindings');
const isPreviewModeKey = Symbol('isPreviewMode');
const DEFAULT_BLOCK_EDIT_CONTEXT = {
  name: '',
  isSelected: false
};
const Context = (0,react.createContext)(DEFAULT_BLOCK_EDIT_CONTEXT);
const {
  Provider
} = Context;


/**
 * A hook that returns the block edit context.
 *
 * @return {Object} Block edit context
 */
function context_useBlockEditContext() {
  return (0,react.useContext)(Context);
}
//# sourceMappingURL=context.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/use-select/index.js + 1 modules
var use_select = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/use-select/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/redux-store/index.js + 18 modules
var redux_store = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/redux-store/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/index.js
var data_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/es6/index.js
var es6 = __webpack_require__("../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/es6/index.js");
var es6_default = /*#__PURE__*/__webpack_require__.n(es6);
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/pipe.js
var pipe = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/pipe.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/select.js
var build_module_select = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/select.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+i18n@5.0.1/node_modules/@wordpress/i18n/build-module/index.js + 3 modules
var i18n_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+i18n@5.0.1/node_modules/@wordpress/i18n/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/defaults.js
/**
 * WordPress dependencies
 */

const PREFERENCES_DEFAULTS = {
  insertUsage: {}
};

/**
 * The default editor settings
 *
 * @typedef {Object} SETTINGS_DEFAULT
 * @property {boolean}       alignWide                              Enable/Disable Wide/Full Alignments
 * @property {boolean}       supportsLayout                         Enable/disable layouts support in container blocks.
 * @property {boolean}       imageEditing                           Image Editing settings set to false to disable.
 * @property {Array}         imageSizes                             Available image sizes
 * @property {number}        maxWidth                               Max width to constraint resizing
 * @property {boolean|Array} allowedBlockTypes                      Allowed block types
 * @property {boolean}       hasFixedToolbar                        Whether or not the editor toolbar is fixed
 * @property {boolean}       distractionFree                        Whether or not the editor UI is distraction free
 * @property {boolean}       focusMode                              Whether the focus mode is enabled or not
 * @property {Array}         styles                                 Editor Styles
 * @property {boolean}       keepCaretInsideBlock                   Whether caret should move between blocks in edit mode
 * @property {string}        bodyPlaceholder                        Empty post placeholder
 * @property {string}        titlePlaceholder                       Empty title placeholder
 * @property {boolean}       canLockBlocks                          Whether the user can manage Block Lock state
 * @property {boolean}       codeEditingEnabled                     Whether or not the user can switch to the code editor
 * @property {boolean}       generateAnchors                        Enable/Disable auto anchor generation for Heading blocks
 * @property {boolean}       enableOpenverseMediaCategory           Enable/Disable the Openverse media category in the inserter.
 * @property {boolean}       clearBlockSelection                    Whether the block editor should clear selection on mousedown when a block is not clicked.
 * @property {boolean}       __experimentalCanUserUseUnfilteredHTML Whether the user should be able to use unfiltered HTML or the HTML should be filtered e.g., to remove elements considered insecure like iframes.
 * @property {boolean}       __experimentalBlockDirectory           Whether the user has enabled the Block Directory
 * @property {Array}         __experimentalBlockPatterns            Array of objects representing the block patterns
 * @property {Array}         __experimentalBlockPatternCategories   Array of objects representing the block pattern categories
 * @property {boolean}       __unstableGalleryWithImageBlocks       Whether the user has enabled the refactored gallery block which uses InnerBlocks
 */
const SETTINGS_DEFAULTS = {
  alignWide: false,
  supportsLayout: true,
  // colors setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  colors: [{
    name: (0,i18n_build_module.__)('Black'),
    slug: 'black',
    color: '#000000'
  }, {
    name: (0,i18n_build_module.__)('Cyan bluish gray'),
    slug: 'cyan-bluish-gray',
    color: '#abb8c3'
  }, {
    name: (0,i18n_build_module.__)('White'),
    slug: 'white',
    color: '#ffffff'
  }, {
    name: (0,i18n_build_module.__)('Pale pink'),
    slug: 'pale-pink',
    color: '#f78da7'
  }, {
    name: (0,i18n_build_module.__)('Vivid red'),
    slug: 'vivid-red',
    color: '#cf2e2e'
  }, {
    name: (0,i18n_build_module.__)('Luminous vivid orange'),
    slug: 'luminous-vivid-orange',
    color: '#ff6900'
  }, {
    name: (0,i18n_build_module.__)('Luminous vivid amber'),
    slug: 'luminous-vivid-amber',
    color: '#fcb900'
  }, {
    name: (0,i18n_build_module.__)('Light green cyan'),
    slug: 'light-green-cyan',
    color: '#7bdcb5'
  }, {
    name: (0,i18n_build_module.__)('Vivid green cyan'),
    slug: 'vivid-green-cyan',
    color: '#00d084'
  }, {
    name: (0,i18n_build_module.__)('Pale cyan blue'),
    slug: 'pale-cyan-blue',
    color: '#8ed1fc'
  }, {
    name: (0,i18n_build_module.__)('Vivid cyan blue'),
    slug: 'vivid-cyan-blue',
    color: '#0693e3'
  }, {
    name: (0,i18n_build_module.__)('Vivid purple'),
    slug: 'vivid-purple',
    color: '#9b51e0'
  }],
  // fontSizes setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  fontSizes: [{
    name: (0,i18n_build_module._x)('Small', 'font size name'),
    size: 13,
    slug: 'small'
  }, {
    name: (0,i18n_build_module._x)('Normal', 'font size name'),
    size: 16,
    slug: 'normal'
  }, {
    name: (0,i18n_build_module._x)('Medium', 'font size name'),
    size: 20,
    slug: 'medium'
  }, {
    name: (0,i18n_build_module._x)('Large', 'font size name'),
    size: 36,
    slug: 'large'
  }, {
    name: (0,i18n_build_module._x)('Huge', 'font size name'),
    size: 42,
    slug: 'huge'
  }],
  // Image default size slug.
  imageDefaultSize: 'large',
  imageSizes: [{
    slug: 'thumbnail',
    name: (0,i18n_build_module.__)('Thumbnail')
  }, {
    slug: 'medium',
    name: (0,i18n_build_module.__)('Medium')
  }, {
    slug: 'large',
    name: (0,i18n_build_module.__)('Large')
  }, {
    slug: 'full',
    name: (0,i18n_build_module.__)('Full Size')
  }],
  // Allow plugin to disable Image Editor if need be.
  imageEditing: true,
  // This is current max width of the block inner area
  // It's used to constraint image resizing and this value could be overridden later by themes
  maxWidth: 580,
  // Allowed block types for the editor, defaulting to true (all supported).
  allowedBlockTypes: true,
  // Maximum upload size in bytes allowed for the site.
  maxUploadFileSize: 0,
  // List of allowed mime types and file extensions.
  allowedMimeTypes: null,
  // Allows to disable block locking interface.
  canLockBlocks: true,
  // Allows to disable Openverse media category in the inserter.
  enableOpenverseMediaCategory: true,
  clearBlockSelection: true,
  __experimentalCanUserUseUnfilteredHTML: false,
  __experimentalBlockDirectory: false,
  __mobileEnablePageTemplates: false,
  __experimentalBlockPatterns: [],
  __experimentalBlockPatternCategories: [],
  __unstableGalleryWithImageBlocks: false,
  __unstableIsPreviewMode: false,
  // These settings will be completely revamped in the future.
  // The goal is to evolve this into an API which will instruct
  // the block inspector to animate transitions between what it
  // displays based on the relationship between the selected block
  // and its parent, and only enable it if the parent is controlling
  // its children blocks.
  blockInspectorAnimation: {
    animationParent: 'core/navigation',
    'core/navigation': {
      enterDirection: 'leftToRight'
    },
    'core/navigation-submenu': {
      enterDirection: 'rightToLeft'
    },
    'core/navigation-link': {
      enterDirection: 'rightToLeft'
    },
    'core/search': {
      enterDirection: 'rightToLeft'
    },
    'core/social-links': {
      enterDirection: 'rightToLeft'
    },
    'core/page-list': {
      enterDirection: 'rightToLeft'
    },
    'core/spacer': {
      enterDirection: 'rightToLeft'
    },
    'core/home-link': {
      enterDirection: 'rightToLeft'
    },
    'core/site-title': {
      enterDirection: 'rightToLeft'
    },
    'core/site-logo': {
      enterDirection: 'rightToLeft'
    }
  },
  generateAnchors: false,
  // gradients setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  gradients: [{
    name: (0,i18n_build_module.__)('Vivid cyan blue to vivid purple'),
    gradient: 'linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%)',
    slug: 'vivid-cyan-blue-to-vivid-purple'
  }, {
    name: (0,i18n_build_module.__)('Light green cyan to vivid green cyan'),
    gradient: 'linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%)',
    slug: 'light-green-cyan-to-vivid-green-cyan'
  }, {
    name: (0,i18n_build_module.__)('Luminous vivid amber to luminous vivid orange'),
    gradient: 'linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%)',
    slug: 'luminous-vivid-amber-to-luminous-vivid-orange'
  }, {
    name: (0,i18n_build_module.__)('Luminous vivid orange to vivid red'),
    gradient: 'linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%)',
    slug: 'luminous-vivid-orange-to-vivid-red'
  }, {
    name: (0,i18n_build_module.__)('Very light gray to cyan bluish gray'),
    gradient: 'linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%)',
    slug: 'very-light-gray-to-cyan-bluish-gray'
  }, {
    name: (0,i18n_build_module.__)('Cool to warm spectrum'),
    gradient: 'linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%)',
    slug: 'cool-to-warm-spectrum'
  }, {
    name: (0,i18n_build_module.__)('Blush light purple'),
    gradient: 'linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%)',
    slug: 'blush-light-purple'
  }, {
    name: (0,i18n_build_module.__)('Blush bordeaux'),
    gradient: 'linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%)',
    slug: 'blush-bordeaux'
  }, {
    name: (0,i18n_build_module.__)('Luminous dusk'),
    gradient: 'linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%)',
    slug: 'luminous-dusk'
  }, {
    name: (0,i18n_build_module.__)('Pale ocean'),
    gradient: 'linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%)',
    slug: 'pale-ocean'
  }, {
    name: (0,i18n_build_module.__)('Electric grass'),
    gradient: 'linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%)',
    slug: 'electric-grass'
  }, {
    name: (0,i18n_build_module.__)('Midnight'),
    gradient: 'linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%)',
    slug: 'midnight'
  }],
  __unstableResolvedAssets: {
    styles: [],
    scripts: []
  }
};
//# sourceMappingURL=defaults.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/array.js
/**
 * Insert one or multiple elements into a given position of an array.
 *
 * @param {Array}  array    Source array.
 * @param {*}      elements Elements to insert.
 * @param {number} index    Insert Position.
 *
 * @return {Array} Result.
 */
function insertAt(array, elements, index) {
  return [...array.slice(0, index), ...(Array.isArray(elements) ? elements : [elements]), ...array.slice(index)];
}

/**
 * Moves an element in an array.
 *
 * @param {Array}  array Source array.
 * @param {number} from  Source index.
 * @param {number} to    Destination index.
 * @param {number} count Number of elements to move.
 *
 * @return {Array} Result.
 */
function moveTo(array, from, to, count = 1) {
  const withoutMovedElements = [...array];
  withoutMovedElements.splice(from, count);
  return insertAt(withoutMovedElements, array.slice(from, from + count), to);
}
//# sourceMappingURL=array.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/reducer.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const identity = x => x;

/**
 * Given an array of blocks, returns an object where each key is a nesting
 * context, the value of which is an array of block client IDs existing within
 * that nesting context.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */
function mapBlockOrder(blocks, rootClientId = '') {
  const result = new Map();
  const current = [];
  result.set(rootClientId, current);
  blocks.forEach(block => {
    const {
      clientId,
      innerBlocks
    } = block;
    current.push(clientId);
    mapBlockOrder(innerBlocks, clientId).forEach((order, subClientId) => {
      result.set(subClientId, order);
    });
  });
  return result;
}

/**
 * Given an array of blocks, returns an object where each key contains
 * the clientId of the block and the value is the parent of the block.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */
function mapBlockParents(blocks, rootClientId = '') {
  const result = [];
  const stack = [[rootClientId, blocks]];
  while (stack.length) {
    const [parent, currentBlocks] = stack.shift();
    currentBlocks.forEach(({
      innerBlocks,
      ...block
    }) => {
      result.push([block.clientId, parent]);
      if (innerBlocks?.length) {
        stack.push([block.clientId, innerBlocks]);
      }
    });
  }
  return result;
}

/**
 * Helper method to iterate through all blocks, recursing into inner blocks,
 * applying a transformation function to each one.
 * Returns a flattened object with the transformed blocks.
 *
 * @param {Array}    blocks    Blocks to flatten.
 * @param {Function} transform Transforming function to be applied to each block.
 *
 * @return {Array} Flattened object.
 */
function flattenBlocks(blocks, transform = identity) {
  const result = [];
  const stack = [...blocks];
  while (stack.length) {
    const {
      innerBlocks,
      ...block
    } = stack.shift();
    stack.push(...innerBlocks);
    result.push([block.clientId, transform(block)]);
  }
  return result;
}
function getFlattenedClientIds(blocks) {
  const result = {};
  const stack = [...blocks];
  while (stack.length) {
    const {
      innerBlocks,
      ...block
    } = stack.shift();
    stack.push(...innerBlocks);
    result[block.clientId] = true;
  }
  return result;
}

/**
 * Given an array of blocks, returns an object containing all blocks, without
 * attributes, recursing into inner blocks. Keys correspond to the block client
 * ID, the value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Array} Flattened block attributes object.
 */
function getFlattenedBlocksWithoutAttributes(blocks) {
  return flattenBlocks(blocks, block => {
    const {
      attributes,
      ...restBlock
    } = block;
    return restBlock;
  });
}

/**
 * Given an array of blocks, returns an object containing all block attributes,
 * recursing into inner blocks. Keys correspond to the block client ID, the
 * value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Array} Flattened block attributes object.
 */
function getFlattenedBlockAttributes(blocks) {
  return flattenBlocks(blocks, block => block.attributes);
}

/**
 * Returns true if the two object arguments have the same keys, or false
 * otherwise.
 *
 * @param {Object} a First object.
 * @param {Object} b Second object.
 *
 * @return {boolean} Whether the two objects have the same keys.
 */
function hasSameKeys(a, b) {
  return es6_default()(Object.keys(a), Object.keys(b));
}

/**
 * Returns true if, given the currently dispatching action and the previously
 * dispatched action, the two actions are updating the same block attribute, or
 * false otherwise.
 *
 * @param {Object} action     Currently dispatching action.
 * @param {Object} lastAction Previously dispatched action.
 *
 * @return {boolean} Whether actions are updating the same block attribute.
 */
function isUpdatingSameBlockAttribute(action, lastAction) {
  return action.type === 'UPDATE_BLOCK_ATTRIBUTES' && lastAction !== undefined && lastAction.type === 'UPDATE_BLOCK_ATTRIBUTES' && es6_default()(action.clientIds, lastAction.clientIds) && hasSameKeys(action.attributes, lastAction.attributes);
}
function updateBlockTreeForBlocks(state, blocks) {
  const treeToUpdate = state.tree;
  const stack = [...blocks];
  const flattenedBlocks = [...blocks];
  while (stack.length) {
    const block = stack.shift();
    stack.push(...block.innerBlocks);
    flattenedBlocks.push(...block.innerBlocks);
  }
  // Create objects before mutating them, that way it's always defined.
  for (const block of flattenedBlocks) {
    treeToUpdate.set(block.clientId, {});
  }
  for (const block of flattenedBlocks) {
    treeToUpdate.set(block.clientId, Object.assign(treeToUpdate.get(block.clientId), {
      ...state.byClientId.get(block.clientId),
      attributes: state.attributes.get(block.clientId),
      innerBlocks: block.innerBlocks.map(subBlock => treeToUpdate.get(subBlock.clientId))
    }));
  }
}
function updateParentInnerBlocksInTree(state, updatedClientIds, updateChildrenOfUpdatedClientIds = false) {
  const treeToUpdate = state.tree;
  const uncontrolledParents = new Set([]);
  const controlledParents = new Set();
  for (const clientId of updatedClientIds) {
    let current = updateChildrenOfUpdatedClientIds ? clientId : state.parents.get(clientId);
    do {
      if (state.controlledInnerBlocks[current]) {
        // Should stop on controlled blocks.
        // If we reach a controlled parent, break out of the loop.
        controlledParents.add(current);
        break;
      } else {
        // Else continue traversing up through parents.
        uncontrolledParents.add(current);
        current = state.parents.get(current);
      }
    } while (current !== undefined);
  }

  // To make sure the order of assignments doesn't matter,
  // we first create empty objects and mutates the inner blocks later.
  for (const clientId of uncontrolledParents) {
    treeToUpdate.set(clientId, {
      ...treeToUpdate.get(clientId)
    });
  }
  for (const clientId of uncontrolledParents) {
    treeToUpdate.get(clientId).innerBlocks = (state.order.get(clientId) || []).map(subClientId => treeToUpdate.get(subClientId));
  }

  // Controlled parent blocks, need a dedicated key for their inner blocks
  // to be used when doing getBlocks( controlledBlockClientId ).
  for (const clientId of controlledParents) {
    treeToUpdate.set('controlled||' + clientId, {
      innerBlocks: (state.order.get(clientId) || []).map(subClientId => treeToUpdate.get(subClientId))
    });
  }
}

/**
 * Higher-order reducer intended to compute full block objects key for each block in the post.
 * This is a denormalization to optimize the performance of the getBlock selectors and avoid
 * recomputing the block objects and avoid heavy memoization.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */
const withBlockTree = reducer => (state = {}, action) => {
  const newState = reducer(state, action);
  if (newState === state) {
    return state;
  }
  newState.tree = state.tree ? state.tree : new Map();
  switch (action.type) {
    case 'RECEIVE_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        newState.tree = new Map(newState.tree);
        updateBlockTreeForBlocks(newState, action.blocks);
        updateParentInnerBlocksInTree(newState, action.rootClientId ? [action.rootClientId] : [''], true);
        break;
      }
    case 'UPDATE_BLOCK':
      newState.tree = new Map(newState.tree);
      newState.tree.set(action.clientId, {
        ...newState.tree.get(action.clientId),
        ...newState.byClientId.get(action.clientId),
        attributes: newState.attributes.get(action.clientId)
      });
      updateParentInnerBlocksInTree(newState, [action.clientId], false);
      break;
    case 'SYNC_DERIVED_BLOCK_ATTRIBUTES':
    case 'UPDATE_BLOCK_ATTRIBUTES':
      {
        newState.tree = new Map(newState.tree);
        action.clientIds.forEach(clientId => {
          newState.tree.set(clientId, {
            ...newState.tree.get(clientId),
            attributes: newState.attributes.get(clientId)
          });
        });
        updateParentInnerBlocksInTree(newState, action.clientIds, false);
        break;
      }
    case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      {
        const inserterClientIds = getFlattenedClientIds(action.blocks);
        newState.tree = new Map(newState.tree);
        action.replacedClientIds.forEach(clientId => {
          newState.tree.delete(clientId);
          // Controlled inner blocks are only removed
          // if the block doesn't move to another position
          // otherwise their content will be lost.
          if (!inserterClientIds[clientId]) {
            newState.tree.delete('controlled||' + clientId);
          }
        });
        updateBlockTreeForBlocks(newState, action.blocks);
        updateParentInnerBlocksInTree(newState, action.blocks.map(b => b.clientId), false);

        // If there are no replaced blocks, it means we're removing blocks so we need to update their parent.
        const parentsOfRemovedBlocks = [];
        for (const clientId of action.clientIds) {
          const parentId = state.parents.get(clientId);
          if (parentId !== undefined && (parentId === '' || newState.byClientId.get(parentId))) {
            parentsOfRemovedBlocks.push(parentId);
          }
        }
        updateParentInnerBlocksInTree(newState, parentsOfRemovedBlocks, true);
        break;
      }
    case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      const parentsOfRemovedBlocks = [];
      for (const clientId of action.clientIds) {
        const parentId = state.parents.get(clientId);
        if (parentId !== undefined && (parentId === '' || newState.byClientId.get(parentId))) {
          parentsOfRemovedBlocks.push(parentId);
        }
      }
      newState.tree = new Map(newState.tree);
      action.removedClientIds.forEach(clientId => {
        newState.tree.delete(clientId);
        newState.tree.delete('controlled||' + clientId);
      });
      updateParentInnerBlocksInTree(newState, parentsOfRemovedBlocks, true);
      break;
    case 'MOVE_BLOCKS_TO_POSITION':
      {
        const updatedBlockUids = [];
        if (action.fromRootClientId) {
          updatedBlockUids.push(action.fromRootClientId);
        } else {
          updatedBlockUids.push('');
        }
        if (action.toRootClientId) {
          updatedBlockUids.push(action.toRootClientId);
        }
        newState.tree = new Map(newState.tree);
        updateParentInnerBlocksInTree(newState, updatedBlockUids, true);
        break;
      }
    case 'MOVE_BLOCKS_UP':
    case 'MOVE_BLOCKS_DOWN':
      {
        const updatedBlockUids = [action.rootClientId ? action.rootClientId : ''];
        newState.tree = new Map(newState.tree);
        updateParentInnerBlocksInTree(newState, updatedBlockUids, true);
        break;
      }
    case 'SAVE_REUSABLE_BLOCK_SUCCESS':
      {
        const updatedBlockUids = [];
        newState.attributes.forEach((attributes, clientId) => {
          if (newState.byClientId.get(clientId).name === 'core/block' && attributes.ref === action.updatedId) {
            updatedBlockUids.push(clientId);
          }
        });
        newState.tree = new Map(newState.tree);
        updatedBlockUids.forEach(clientId => {
          newState.tree.set(clientId, {
            ...newState.byClientId.get(clientId),
            attributes: newState.attributes.get(clientId),
            innerBlocks: newState.tree.get(clientId).innerBlocks
          });
        });
        updateParentInnerBlocksInTree(newState, updatedBlockUids, false);
      }
  }
  return newState;
};

/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isPersistentChange` property value corresponding to whether a change in
 * state can be considered as persistent. All changes are considered persistent
 * except when updating the same block attribute as in the previous action.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */
function withPersistentBlockChange(reducer) {
  let lastAction;
  let markNextChangeAsNotPersistent = false;
  let explicitPersistent;
  return (state, action) => {
    let nextState = reducer(state, action);
    let nextIsPersistentChange;
    if (action.type === 'SET_EXPLICIT_PERSISTENT') {
      var _state$isPersistentCh;
      explicitPersistent = action.isPersistentChange;
      nextIsPersistentChange = (_state$isPersistentCh = state.isPersistentChange) !== null && _state$isPersistentCh !== void 0 ? _state$isPersistentCh : true;
    }
    if (explicitPersistent !== undefined) {
      nextIsPersistentChange = explicitPersistent;
      return nextIsPersistentChange === nextState.isPersistentChange ? nextState : {
        ...nextState,
        isPersistentChange: nextIsPersistentChange
      };
    }
    const isExplicitPersistentChange = action.type === 'MARK_LAST_CHANGE_AS_PERSISTENT' || markNextChangeAsNotPersistent;

    // Defer to previous state value (or default) unless changing or
    // explicitly marking as persistent.
    if (state === nextState && !isExplicitPersistentChange) {
      var _state$isPersistentCh2;
      markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
      nextIsPersistentChange = (_state$isPersistentCh2 = state?.isPersistentChange) !== null && _state$isPersistentCh2 !== void 0 ? _state$isPersistentCh2 : true;
      if (state.isPersistentChange === nextIsPersistentChange) {
        return state;
      }
      return {
        ...nextState,
        isPersistentChange: nextIsPersistentChange
      };
    }
    nextState = {
      ...nextState,
      isPersistentChange: isExplicitPersistentChange ? !markNextChangeAsNotPersistent : !isUpdatingSameBlockAttribute(action, lastAction)
    };

    // In comparing against the previous action, consider only those which
    // would have qualified as one which would have been ignored or not
    // have resulted in a changed state.
    lastAction = action;
    markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
    return nextState;
  };
}

/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isIgnoredChange` property value corresponding to whether a change in state
 * can be considered as ignored. A change is considered ignored when the result
 * of an action not incurred by direct user interaction.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */
function withIgnoredBlockChange(reducer) {
  /**
   * Set of action types for which a blocks state change should be ignored.
   *
   * @type {Set}
   */
  const IGNORED_ACTION_TYPES = new Set(['RECEIVE_BLOCKS']);
  return (state, action) => {
    const nextState = reducer(state, action);
    if (nextState !== state) {
      nextState.isIgnoredChange = IGNORED_ACTION_TYPES.has(action.type);
    }
    return nextState;
  };
}

/**
 * Higher-order reducer targeting the combined blocks reducer, augmenting
 * block client IDs in remove action to include cascade of inner blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */
const withInnerBlocksRemoveCascade = reducer => (state, action) => {
  // Gets all children which need to be removed.
  const getAllChildren = clientIds => {
    let result = clientIds;
    for (let i = 0; i < result.length; i++) {
      if (!state.order.get(result[i]) || action.keepControlledInnerBlocks && action.keepControlledInnerBlocks[result[i]]) {
        continue;
      }
      if (result === clientIds) {
        result = [...result];
      }
      result.push(...state.order.get(result[i]));
    }
    return result;
  };
  if (state) {
    switch (action.type) {
      case 'REMOVE_BLOCKS':
        action = {
          ...action,
          type: 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          removedClientIds: getAllChildren(action.clientIds)
        };
        break;
      case 'REPLACE_BLOCKS':
        action = {
          ...action,
          type: 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          replacedClientIds: getAllChildren(action.clientIds)
        };
        break;
    }
  }
  return reducer(state, action);
};

/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `RESET_BLOCKS` action. When dispatched, this action will replace all
 * blocks that exist in the post, leaving blocks that exist only in state (e.g.
 * reusable blocks and blocks controlled by inner blocks controllers) alone.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */
const withBlockReset = reducer => (state, action) => {
  if (action.type === 'RESET_BLOCKS') {
    const newState = {
      ...state,
      byClientId: new Map(getFlattenedBlocksWithoutAttributes(action.blocks)),
      attributes: new Map(getFlattenedBlockAttributes(action.blocks)),
      order: mapBlockOrder(action.blocks),
      parents: new Map(mapBlockParents(action.blocks)),
      controlledInnerBlocks: {}
    };
    newState.tree = new Map(state?.tree);
    updateBlockTreeForBlocks(newState, action.blocks);
    newState.tree.set('', {
      innerBlocks: action.blocks.map(subBlock => newState.tree.get(subBlock.clientId))
    });
    return newState;
  }
  return reducer(state, action);
};

/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `REPLACE_INNER_BLOCKS` action. When dispatched, this action the state
 * should become equivalent to the execution of a `REMOVE_BLOCKS` action
 * containing all the child's of the root block followed by the execution of
 * `INSERT_BLOCKS` with the new blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */
const withReplaceInnerBlocks = reducer => (state, action) => {
  if (action.type !== 'REPLACE_INNER_BLOCKS') {
    return reducer(state, action);
  }

  // Finds every nested inner block controller. We must check the action blocks
  // and not just the block parent state because some inner block controllers
  // should be deleted if specified, whereas others should not be deleted. If
  // a controlled should not be deleted, then we need to avoid deleting its
  // inner blocks from the block state because its inner blocks will not be
  // attached to the block in the action.
  const nestedControllers = {};
  if (Object.keys(state.controlledInnerBlocks).length) {
    const stack = [...action.blocks];
    while (stack.length) {
      const {
        innerBlocks,
        ...block
      } = stack.shift();
      stack.push(...innerBlocks);
      if (!!state.controlledInnerBlocks[block.clientId]) {
        nestedControllers[block.clientId] = true;
      }
    }
  }

  // The `keepControlledInnerBlocks` prop will keep the inner blocks of the
  // marked block in the block state so that they can be reattached to the
  // marked block when we re-insert everything a few lines below.
  let stateAfterBlocksRemoval = state;
  if (state.order.get(action.rootClientId)) {
    stateAfterBlocksRemoval = reducer(stateAfterBlocksRemoval, {
      type: 'REMOVE_BLOCKS',
      keepControlledInnerBlocks: nestedControllers,
      clientIds: state.order.get(action.rootClientId)
    });
  }
  let stateAfterInsert = stateAfterBlocksRemoval;
  if (action.blocks.length) {
    stateAfterInsert = reducer(stateAfterInsert, {
      ...action,
      type: 'INSERT_BLOCKS',
      index: 0
    });

    // We need to re-attach the controlled inner blocks to the blocks tree and
    // preserve their block order. Otherwise, an inner block controller's blocks
    // will be deleted entirely from its entity.
    const stateAfterInsertOrder = new Map(stateAfterInsert.order);
    Object.keys(nestedControllers).forEach(key => {
      if (state.order.get(key)) {
        stateAfterInsertOrder.set(key, state.order.get(key));
      }
    });
    stateAfterInsert.order = stateAfterInsertOrder;
    stateAfterInsert.tree = new Map(stateAfterInsert.tree);
    Object.keys(nestedControllers).forEach(_key => {
      const key = `controlled||${_key}`;
      if (state.tree.has(key)) {
        stateAfterInsert.tree.set(key, state.tree.get(key));
      }
    });
  }
  return stateAfterInsert;
};

/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `SAVE_REUSABLE_BLOCK_SUCCESS` action. This action can't be handled by
 * regular reducers and needs a higher-order reducer since it needs access to
 * both `byClientId` and `attributes` simultaneously.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */
const withSaveReusableBlock = reducer => (state, action) => {
  if (state && action.type === 'SAVE_REUSABLE_BLOCK_SUCCESS') {
    const {
      id,
      updatedId
    } = action;

    // If a temporary reusable block is saved, we swap the temporary id with the final one.
    if (id === updatedId) {
      return state;
    }
    state = {
      ...state
    };
    state.attributes = new Map(state.attributes);
    state.attributes.forEach((attributes, clientId) => {
      const {
        name
      } = state.byClientId.get(clientId);
      if (name === 'core/block' && attributes.ref === id) {
        state.attributes.set(clientId, {
          ...attributes,
          ref: updatedId
        });
      }
    });
  }
  return reducer(state, action);
};
/**
 * Higher-order reducer which removes blocks from state when switching parent block controlled state.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */
const withResetControlledBlocks = reducer => (state, action) => {
  if (action.type === 'SET_HAS_CONTROLLED_INNER_BLOCKS') {
    // when switching a block from controlled to uncontrolled or inverse,
    // we need to remove its content first.
    const tempState = reducer(state, {
      type: 'REPLACE_INNER_BLOCKS',
      rootClientId: action.clientId,
      blocks: []
    });
    return reducer(tempState, action);
  }
  return reducer(state, action);
};

/**
 * Reducer returning the blocks state.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
const blocks = (0,pipe/* default */.h)(data_build_module/* combineReducers */.HY, withSaveReusableBlock,
// Needs to be before withBlockCache.
withBlockTree,
// Needs to be before withInnerBlocksRemoveCascade.
withInnerBlocksRemoveCascade, withReplaceInnerBlocks,
// Needs to be after withInnerBlocksRemoveCascade.
withBlockReset, withPersistentBlockChange, withIgnoredBlockChange, withResetControlledBlocks)({
  // The state is using a Map instead of a plain object for performance reasons.
  // You can run the "./test/performance.js" unit test to check the impact
  // code changes can have on this reducer.
  byClientId(state = new Map(), action) {
    switch (action.type) {
      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        {
          const newState = new Map(state);
          getFlattenedBlocksWithoutAttributes(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }
      case 'UPDATE_BLOCK':
        {
          // Ignore updates if block isn't known.
          if (!state.has(action.clientId)) {
            return state;
          }

          // Do nothing if only attributes change.
          const {
            attributes,
            ...changes
          } = action.updates;
          if (Object.values(changes).length === 0) {
            return state;
          }
          const newState = new Map(state);
          newState.set(action.clientId, {
            ...state.get(action.clientId),
            ...changes
          });
          return newState;
        }
      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          if (!action.blocks) {
            return state;
          }
          const newState = new Map(state);
          action.replacedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          getFlattenedBlocksWithoutAttributes(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }
      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state);
          action.removedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          return newState;
        }
    }
    return state;
  },
  // The state is using a Map instead of a plain object for performance reasons.
  // You can run the "./test/performance.js" unit test to check the impact
  // code changes can have on this reducer.
  attributes(state = new Map(), action) {
    switch (action.type) {
      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        {
          const newState = new Map(state);
          getFlattenedBlockAttributes(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }
      case 'UPDATE_BLOCK':
        {
          // Ignore updates if block isn't known or there are no attribute changes.
          if (!state.get(action.clientId) || !action.updates.attributes) {
            return state;
          }
          const newState = new Map(state);
          newState.set(action.clientId, {
            ...state.get(action.clientId),
            ...action.updates.attributes
          });
          return newState;
        }
      case 'SYNC_DERIVED_BLOCK_ATTRIBUTES':
      case 'UPDATE_BLOCK_ATTRIBUTES':
        {
          // Avoid a state change if none of the block IDs are known.
          if (action.clientIds.every(id => !state.get(id))) {
            return state;
          }
          let hasChange = false;
          const newState = new Map(state);
          for (const clientId of action.clientIds) {
            var _action$attributes;
            const updatedAttributeEntries = Object.entries(action.uniqueByBlock ? action.attributes[clientId] : (_action$attributes = action.attributes) !== null && _action$attributes !== void 0 ? _action$attributes : {});
            if (updatedAttributeEntries.length === 0) {
              continue;
            }
            let hasUpdatedAttributes = false;
            const existingAttributes = state.get(clientId);
            const newAttributes = {};
            updatedAttributeEntries.forEach(([key, value]) => {
              if (existingAttributes[key] !== value) {
                hasUpdatedAttributes = true;
                newAttributes[key] = value;
              }
            });
            hasChange = hasChange || hasUpdatedAttributes;
            if (hasUpdatedAttributes) {
              newState.set(clientId, {
                ...existingAttributes,
                ...newAttributes
              });
            }
          }
          return hasChange ? newState : state;
        }
      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          if (!action.blocks) {
            return state;
          }
          const newState = new Map(state);
          action.replacedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          getFlattenedBlockAttributes(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }
      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state);
          action.removedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          return newState;
        }
    }
    return state;
  },
  // The state is using a Map instead of a plain object for performance reasons.
  // You can run the "./test/performance.js" unit test to check the impact
  // code changes can have on this reducer.
  order(state = new Map(), action) {
    switch (action.type) {
      case 'RECEIVE_BLOCKS':
        {
          var _state$get;
          const blockOrder = mapBlockOrder(action.blocks);
          const newState = new Map(state);
          blockOrder.forEach((order, clientId) => {
            if (clientId !== '') {
              newState.set(clientId, order);
            }
          });
          newState.set('', ((_state$get = state.get('')) !== null && _state$get !== void 0 ? _state$get : []).concat(blockOrder['']));
          return newState;
        }
      case 'INSERT_BLOCKS':
        {
          const {
            rootClientId = ''
          } = action;
          const subState = state.get(rootClientId) || [];
          const mappedBlocks = mapBlockOrder(action.blocks, rootClientId);
          const {
            index = subState.length
          } = action;
          const newState = new Map(state);
          mappedBlocks.forEach((order, clientId) => {
            newState.set(clientId, order);
          });
          newState.set(rootClientId, insertAt(subState, mappedBlocks.get(rootClientId), index));
          return newState;
        }
      case 'MOVE_BLOCKS_TO_POSITION':
        {
          var _state$get$filter;
          const {
            fromRootClientId = '',
            toRootClientId = '',
            clientIds
          } = action;
          const {
            index = state.get(toRootClientId).length
          } = action;

          // Moving inside the same parent block.
          if (fromRootClientId === toRootClientId) {
            const subState = state.get(toRootClientId);
            const fromIndex = subState.indexOf(clientIds[0]);
            const newState = new Map(state);
            newState.set(toRootClientId, moveTo(state.get(toRootClientId), fromIndex, index, clientIds.length));
            return newState;
          }

          // Moving from a parent block to another.
          const newState = new Map(state);
          newState.set(fromRootClientId, (_state$get$filter = state.get(fromRootClientId)?.filter(id => !clientIds.includes(id))) !== null && _state$get$filter !== void 0 ? _state$get$filter : []);
          newState.set(toRootClientId, insertAt(state.get(toRootClientId), clientIds, index));
          return newState;
        }
      case 'MOVE_BLOCKS_UP':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = clientIds[0];
          const subState = state.get(rootClientId);
          if (!subState.length || firstClientId === subState[0]) {
            return state;
          }
          const firstIndex = subState.indexOf(firstClientId);
          const newState = new Map(state);
          newState.set(rootClientId, moveTo(subState, firstIndex, firstIndex - 1, clientIds.length));
          return newState;
        }
      case 'MOVE_BLOCKS_DOWN':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = clientIds[0];
          const lastClientId = clientIds[clientIds.length - 1];
          const subState = state.get(rootClientId);
          if (!subState.length || lastClientId === subState[subState.length - 1]) {
            return state;
          }
          const firstIndex = subState.indexOf(firstClientId);
          const newState = new Map(state);
          newState.set(rootClientId, moveTo(subState, firstIndex, firstIndex + 1, clientIds.length));
          return newState;
        }
      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const {
            clientIds
          } = action;
          if (!action.blocks) {
            return state;
          }
          const mappedBlocks = mapBlockOrder(action.blocks);
          const newState = new Map(state);
          action.replacedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          mappedBlocks.forEach((order, clientId) => {
            if (clientId !== '') {
              newState.set(clientId, order);
            }
          });
          newState.forEach((order, clientId) => {
            const newSubOrder = Object.values(order).reduce((result, subClientId) => {
              if (subClientId === clientIds[0]) {
                return [...result, ...mappedBlocks.get('')];
              }
              if (clientIds.indexOf(subClientId) === -1) {
                result.push(subClientId);
              }
              return result;
            }, []);
            newState.set(clientId, newSubOrder);
          });
          return newState;
        }
      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state);
          // Remove inner block ordering for removed blocks.
          action.removedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          newState.forEach((order, clientId) => {
            var _order$filter;
            const newSubOrder = (_order$filter = order?.filter(id => !action.removedClientIds.includes(id))) !== null && _order$filter !== void 0 ? _order$filter : [];
            if (newSubOrder.length !== order.length) {
              newState.set(clientId, newSubOrder);
            }
          });
          return newState;
        }
    }
    return state;
  },
  // While technically redundant data as the inverse of `order`, it serves as
  // an optimization for the selectors which derive the ancestry of a block.
  parents(state = new Map(), action) {
    switch (action.type) {
      case 'RECEIVE_BLOCKS':
        {
          const newState = new Map(state);
          mapBlockParents(action.blocks).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }
      case 'INSERT_BLOCKS':
        {
          const newState = new Map(state);
          mapBlockParents(action.blocks, action.rootClientId || '').forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }
      case 'MOVE_BLOCKS_TO_POSITION':
        {
          const newState = new Map(state);
          action.clientIds.forEach(id => {
            newState.set(id, action.toRootClientId || '');
          });
          return newState;
        }
      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state);
          action.replacedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          mapBlockParents(action.blocks, state.get(action.clientIds[0])).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }
      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const newState = new Map(state);
          action.removedClientIds.forEach(clientId => {
            newState.delete(clientId);
          });
          return newState;
        }
    }
    return state;
  },
  controlledInnerBlocks(state = {}, {
    type,
    clientId,
    hasControlledInnerBlocks
  }) {
    if (type === 'SET_HAS_CONTROLLED_INNER_BLOCKS') {
      return {
        ...state,
        [clientId]: hasControlledInnerBlocks
      };
    }
    return state;
  }
});

/**
 * Reducer returning visibility status of block interface.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */
function isBlockInterfaceHidden(state = false, action) {
  switch (action.type) {
    case 'HIDE_BLOCK_INTERFACE':
      return true;
    case 'SHOW_BLOCK_INTERFACE':
      return false;
  }
  return state;
}

/**
 * Reducer returning typing state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */
function isTyping(state = false, action) {
  switch (action.type) {
    case 'START_TYPING':
      return true;
    case 'STOP_TYPING':
      return false;
  }
  return state;
}

/**
 * Reducer returning dragging state. It is possible for a user to be dragging
 * data from outside of the editor, so this state is separate from `draggedBlocks`.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */
function isDragging(state = false, action) {
  switch (action.type) {
    case 'START_DRAGGING':
      return true;
    case 'STOP_DRAGGING':
      return false;
  }
  return state;
}

/**
 * Reducer returning dragged block client id.
 *
 * @param {string[]} state  Current state.
 * @param {Object}   action Dispatched action.
 *
 * @return {string[]} Updated state.
 */
function draggedBlocks(state = [], action) {
  switch (action.type) {
    case 'START_DRAGGING_BLOCKS':
      return action.clientIds;
    case 'STOP_DRAGGING_BLOCKS':
      return [];
  }
  return state;
}

/**
 * Reducer tracking the visible blocks.
 *
 * @param {Record<string,boolean>} state  Current state.
 * @param {Object}                 action Dispatched action.
 *
 * @return {Record<string,boolean>} Block visibility.
 */
function blockVisibility(state = {}, action) {
  if (action.type === 'SET_BLOCK_VISIBILITY') {
    return {
      ...state,
      ...action.updates
    };
  }
  return state;
}

/**
 * Internal helper reducer for selectionStart and selectionEnd. Can hold a block
 * selection, represented by an object with property clientId.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function selectionHelper(state = {}, action) {
  switch (action.type) {
    case 'CLEAR_SELECTED_BLOCK':
      {
        if (state.clientId) {
          return {};
        }
        return state;
      }
    case 'SELECT_BLOCK':
      if (action.clientId === state.clientId) {
        return state;
      }
      return {
        clientId: action.clientId
      };
    case 'REPLACE_INNER_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        if (!action.updateSelection || !action.blocks.length) {
          return state;
        }
        return {
          clientId: action.blocks[0].clientId
        };
      }
    case 'REMOVE_BLOCKS':
      if (!action.clientIds || !action.clientIds.length || action.clientIds.indexOf(state.clientId) === -1) {
        return state;
      }
      return {};
    case 'REPLACE_BLOCKS':
      {
        if (action.clientIds.indexOf(state.clientId) === -1) {
          return state;
        }
        const blockToSelect = action.blocks[action.indexToSelect] || action.blocks[action.blocks.length - 1];
        if (!blockToSelect) {
          return {};
        }
        if (blockToSelect.clientId === state.clientId) {
          return state;
        }
        return {
          clientId: blockToSelect.clientId
        };
      }
  }
  return state;
}

/**
 * Reducer returning the selection state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */
function selection(state = {}, action) {
  switch (action.type) {
    case 'SELECTION_CHANGE':
      if (action.clientId) {
        return {
          selectionStart: {
            clientId: action.clientId,
            attributeKey: action.attributeKey,
            offset: action.startOffset
          },
          selectionEnd: {
            clientId: action.clientId,
            attributeKey: action.attributeKey,
            offset: action.endOffset
          }
        };
      }
      return {
        selectionStart: action.start || state.selectionStart,
        selectionEnd: action.end || state.selectionEnd
      };
    case 'RESET_SELECTION':
      const {
        selectionStart,
        selectionEnd
      } = action;
      return {
        selectionStart,
        selectionEnd
      };
    case 'MULTI_SELECT':
      const {
        start,
        end
      } = action;
      if (start === state.selectionStart?.clientId && end === state.selectionEnd?.clientId) {
        return state;
      }
      return {
        selectionStart: {
          clientId: start
        },
        selectionEnd: {
          clientId: end
        }
      };
    case 'RESET_BLOCKS':
      const startClientId = state?.selectionStart?.clientId;
      const endClientId = state?.selectionEnd?.clientId;

      // Do nothing if there's no selected block.
      if (!startClientId && !endClientId) {
        return state;
      }

      // If the start of the selection won't exist after reset, remove selection.
      if (!action.blocks.some(block => block.clientId === startClientId)) {
        return {
          selectionStart: {},
          selectionEnd: {}
        };
      }

      // If the end of the selection won't exist after reset, collapse selection.
      if (!action.blocks.some(block => block.clientId === endClientId)) {
        return {
          ...state,
          selectionEnd: state.selectionStart
        };
      }
  }
  const selectionStart = selectionHelper(state.selectionStart, action);
  const selectionEnd = selectionHelper(state.selectionEnd, action);
  if (selectionStart === state.selectionStart && selectionEnd === state.selectionEnd) {
    return state;
  }
  return {
    selectionStart,
    selectionEnd
  };
}

/**
 * Reducer returning whether the user is multi-selecting.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */
function isMultiSelecting(state = false, action) {
  switch (action.type) {
    case 'START_MULTI_SELECT':
      return true;
    case 'STOP_MULTI_SELECT':
      return false;
  }
  return state;
}

/**
 * Reducer returning whether selection is enabled.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */
function isSelectionEnabled(state = true, action) {
  switch (action.type) {
    case 'TOGGLE_SELECTION':
      return action.isSelectionEnabled;
  }
  return state;
}

/**
 * Reducer returning the data needed to display a prompt when certain blocks
 * are removed, or `false` if no such prompt is requested.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {Object|false} Data for removal prompt display, if any.
 */
function removalPromptData(state = false, action) {
  switch (action.type) {
    case 'DISPLAY_BLOCK_REMOVAL_PROMPT':
      const {
        clientIds,
        selectPrevious,
        message
      } = action;
      return {
        clientIds,
        selectPrevious,
        message
      };
    case 'CLEAR_BLOCK_REMOVAL_PROMPT':
      return false;
  }
  return state;
}

/**
 * Reducer returning any rules that a block editor may provide in order to
 * prevent a user from accidentally removing certain blocks. These rules are
 * then used to display a confirmation prompt to the user. For instance, in the
 * Site Editor, the Query Loop block is important enough to warrant such
 * confirmation.
 *
 * The data is a record whose keys are block types (e.g. 'core/query') and
 * whose values are the explanation to be shown to users (e.g. 'Query Loop
 * displays a list of posts or pages.').
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {Record<string,string>} Updated state.
 */
function blockRemovalRules(state = false, action) {
  switch (action.type) {
    case 'SET_BLOCK_REMOVAL_RULES':
      return action.rules;
  }
  return state;
}

/**
 * Reducer returning the initial block selection.
 *
 * Currently this in only used to restore the selection after block deletion and
 * pasting new content.This reducer should eventually be removed in favour of setting
 * selection directly.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {number|null} Initial position: 0, -1 or null.
 */
function initialPosition(state = null, action) {
  if (action.type === 'REPLACE_BLOCKS' && action.initialPosition !== undefined) {
    return action.initialPosition;
  } else if (['MULTI_SELECT', 'SELECT_BLOCK', 'RESET_SELECTION', 'INSERT_BLOCKS', 'REPLACE_INNER_BLOCKS'].includes(action.type)) {
    return action.initialPosition;
  }
  return state;
}
function blocksMode(state = {}, action) {
  if (action.type === 'TOGGLE_BLOCK_MODE') {
    const {
      clientId
    } = action;
    return {
      ...state,
      [clientId]: state[clientId] && state[clientId] === 'html' ? 'visual' : 'html'
    };
  }
  return state;
}

/**
 * Reducer returning the block insertion point visibility, either null if there
 * is not an explicit insertion point assigned, or an object of its `index` and
 * `rootClientId`.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function insertionPoint(state = null, action) {
  switch (action.type) {
    case 'SHOW_INSERTION_POINT':
      {
        const {
          rootClientId,
          index,
          __unstableWithInserter,
          operation,
          nearestSide
        } = action;
        const nextState = {
          rootClientId,
          index,
          __unstableWithInserter,
          operation,
          nearestSide
        };

        // Bail out updates if the states are the same.
        return es6_default()(state, nextState) ? state : nextState;
      }
    case 'HIDE_INSERTION_POINT':
      return null;
  }
  return state;
}

/**
 * Reducer returning whether the post blocks match the defined template or not.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {boolean} Updated state.
 */
function template(state = {
  isValid: true
}, action) {
  switch (action.type) {
    case 'SET_TEMPLATE_VALIDITY':
      return {
        ...state,
        isValid: action.isValid
      };
  }
  return state;
}

/**
 * Reducer returning the editor setting.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function settings(state = SETTINGS_DEFAULTS, action) {
  switch (action.type) {
    case 'UPDATE_SETTINGS':
      if (action.reset) {
        return {
          ...SETTINGS_DEFAULTS,
          ...action.settings
        };
      }
      return {
        ...state,
        ...action.settings
      };
  }
  return state;
}

/**
 * Reducer returning the user preferences.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string} Updated state.
 */
function preferences(state = PREFERENCES_DEFAULTS, action) {
  switch (action.type) {
    case 'INSERT_BLOCKS':
    case 'REPLACE_BLOCKS':
      {
        const nextInsertUsage = action.blocks.reduce((prevUsage, block) => {
          const {
            attributes,
            name: blockName
          } = block;
          let id = blockName;
          // If a block variation match is found change the name to be the same with the
          // one that is used for block variations in the Inserter (`getItemFromVariation`).
          const match = (0,build_module_select/* select */.L)(build_module/* store */.M_).getActiveBlockVariation(blockName, attributes);
          if (match?.name) {
            id += '/' + match.name;
          }
          if (blockName === 'core/block') {
            id += '/' + attributes.ref;
          }
          return {
            ...prevUsage,
            [id]: {
              time: action.time,
              count: prevUsage[id] ? prevUsage[id].count + 1 : 1
            }
          };
        }, state.insertUsage);
        return {
          ...state,
          insertUsage: nextInsertUsage
        };
      }
  }
  return state;
}

/**
 * Reducer returning an object where each key is a block client ID, its value
 * representing the settings for its nested blocks.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
const blockListSettings = (state = {}, action) => {
  switch (action.type) {
    // Even if the replaced blocks have the same client ID, our logic
    // should correct the state.
    case 'REPLACE_BLOCKS':
    case 'REMOVE_BLOCKS':
      {
        return Object.fromEntries(Object.entries(state).filter(([id]) => !action.clientIds.includes(id)));
      }
    case 'UPDATE_BLOCK_LIST_SETTINGS':
      {
        const updates = typeof action.clientId === 'string' ? {
          [action.clientId]: action.settings
        } : action.clientId;

        // Remove settings that are the same as the current state.
        for (const clientId in updates) {
          if (!updates[clientId]) {
            if (!state[clientId]) {
              delete updates[clientId];
            }
          } else if (es6_default()(state[clientId], updates[clientId])) {
            delete updates[clientId];
          }
        }
        if (Object.keys(updates).length === 0) {
          return state;
        }
        const merged = {
          ...state,
          ...updates
        };
        for (const clientId in updates) {
          if (!updates[clientId]) {
            delete merged[clientId];
          }
        }
        return merged;
      }
  }
  return state;
};

/**
 * Reducer returning which mode is enabled.
 *
 * @param {string} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string} Updated state.
 */
function editorMode(state = 'edit', action) {
  // Let inserting block in navigation mode always trigger Edit mode.
  if (action.type === 'INSERT_BLOCKS' && state === 'navigation') {
    return 'edit';
  }
  if (action.type === 'SET_EDITOR_MODE') {
    return action.mode;
  }
  return state;
}

/**
 * Reducer returning whether the block moving mode is enabled or not.
 *
 * @param {string|null} state  Current state.
 * @param {Object}      action Dispatched action.
 *
 * @return {string|null} Updated state.
 */
function hasBlockMovingClientId(state = null, action) {
  if (action.type === 'SET_BLOCK_MOVING_MODE') {
    return action.hasBlockMovingClientId;
  }
  if (action.type === 'SET_EDITOR_MODE') {
    return null;
  }
  return state;
}

/**
 * Reducer return an updated state representing the most recent block attribute
 * update. The state is structured as an object where the keys represent the
 * client IDs of blocks, the values a subset of attributes from the most recent
 * block update. The state is always reset to null if the last action is
 * anything other than an attributes update.
 *
 * @param {Object<string,Object>} state  Current state.
 * @param {Object}                action Action object.
 *
 * @return {[string,Object]} Updated state.
 */
function lastBlockAttributesChange(state = null, action) {
  switch (action.type) {
    case 'UPDATE_BLOCK':
      if (!action.updates.attributes) {
        break;
      }
      return {
        [action.clientId]: action.updates.attributes
      };
    case 'UPDATE_BLOCK_ATTRIBUTES':
      return action.clientIds.reduce((accumulator, id) => ({
        ...accumulator,
        [id]: action.uniqueByBlock ? action.attributes[id] : action.attributes
      }), {});
  }
  return state;
}

/**
 * Reducer returning current highlighted block.
 *
 * @param {boolean} state  Current highlighted block.
 * @param {Object}  action Dispatched action.
 *
 * @return {string} Updated state.
 */
function highlightedBlock(state, action) {
  switch (action.type) {
    case 'TOGGLE_BLOCK_HIGHLIGHT':
      const {
        clientId,
        isHighlighted
      } = action;
      if (isHighlighted) {
        return clientId;
      } else if (state === clientId) {
        return null;
      }
      return state;
    case 'SELECT_BLOCK':
      if (action.clientId !== state) {
        return null;
      }
  }
  return state;
}

/**
 * Reducer returning current expanded block in the list view.
 *
 * @param {string|null} state  Current expanded block.
 * @param {Object}      action Dispatched action.
 *
 * @return {string|null} Updated state.
 */
function expandedBlock(state = null, action) {
  switch (action.type) {
    case 'SET_BLOCK_EXPANDED_IN_LIST_VIEW':
      return action.clientId;
    case 'SELECT_BLOCK':
      if (action.clientId !== state) {
        return null;
      }
  }
  return state;
}

/**
 * Reducer returning the block insertion event list state.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function lastBlockInserted(state = {}, action) {
  switch (action.type) {
    case 'INSERT_BLOCKS':
    case 'REPLACE_BLOCKS':
      if (!action.blocks.length) {
        return state;
      }
      const clientIds = action.blocks.map(block => {
        return block.clientId;
      });
      const source = action.meta?.source;
      return {
        clientIds,
        source
      };
    case 'RESET_BLOCKS':
      return {};
  }
  return state;
}

/**
 * Reducer returning the block that is eding temporarily edited as blocks.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function temporarilyEditingAsBlocks(state = '', action) {
  if (action.type === 'SET_TEMPORARILY_EDITING_AS_BLOCKS') {
    return action.temporarilyEditingAsBlocks;
  }
  return state;
}

/**
 * Reducer returning the focus mode that should be used when temporarily edit as blocks finishes.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function temporarilyEditingFocusModeRevert(state = '', action) {
  if (action.type === 'SET_TEMPORARILY_EDITING_AS_BLOCKS') {
    return action.focusModeToRevert;
  }
  return state;
}

/**
 * Reducer returning a map of block client IDs to block editing modes.
 *
 * @param {Map}    state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Map} Updated state.
 */
function blockEditingModes(state = new Map(), action) {
  switch (action.type) {
    case 'SET_BLOCK_EDITING_MODE':
      return new Map(state).set(action.clientId, action.mode);
    case 'UNSET_BLOCK_EDITING_MODE':
      {
        const newState = new Map(state);
        newState.delete(action.clientId);
        return newState;
      }
    case 'RESET_BLOCKS':
      {
        return state.has('') ? new Map().set('', state.get('')) : state;
      }
  }
  return state;
}

/**
 * Reducer returning the clientId of the block settings menu that is currently open.
 *
 * @param {string|null} state  Current state.
 * @param {Object}      action Dispatched action.
 *
 * @return {string|null} Updated state.
 */
function openedBlockSettingsMenu(state = null, action) {
  if ('SET_OPENED_BLOCK_SETTINGS_MENU' === action.type) {
    var _action$clientId;
    return (_action$clientId = action?.clientId) !== null && _action$clientId !== void 0 ? _action$clientId : null;
  }
  return state;
}

/**
 * Reducer returning a map of style IDs to style overrides.
 *
 * @param {Map}    state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Map} Updated state.
 */
function styleOverrides(state = new Map(), action) {
  switch (action.type) {
    case 'SET_STYLE_OVERRIDE':
      return new Map(state).set(action.id, action.style);
    case 'DELETE_STYLE_OVERRIDE':
      {
        const newState = new Map(state);
        newState.delete(action.id);
        return newState;
      }
  }
  return state;
}

/**
 * Reducer returning a map of the registered inserter media categories.
 *
 * @param {Array}  state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Array} Updated state.
 */
function registeredInserterMediaCategories(state = [], action) {
  switch (action.type) {
    case 'REGISTER_INSERTER_MEDIA_CATEGORY':
      return [...state, action.category];
  }
  return state;
}

/**
 * Reducer setting last focused element
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */
function lastFocus(state = false, action) {
  switch (action.type) {
    case 'LAST_FOCUS':
      return action.lastFocus;
  }
  return state;
}
const combinedReducers = (0,data_build_module/* combineReducers */.HY)({
  blocks,
  isDragging,
  isTyping,
  isBlockInterfaceHidden,
  draggedBlocks,
  selection,
  isMultiSelecting,
  isSelectionEnabled,
  initialPosition,
  blocksMode,
  blockListSettings,
  insertionPoint,
  template,
  settings,
  preferences,
  lastBlockAttributesChange,
  lastFocus,
  editorMode,
  hasBlockMovingClientId,
  expandedBlock,
  highlightedBlock,
  lastBlockInserted,
  temporarilyEditingAsBlocks,
  temporarilyEditingFocusModeRevert,
  blockVisibility,
  blockEditingModes,
  styleOverrides,
  removalPromptData,
  blockRemovalRules,
  openedBlockSettingsMenu,
  registeredInserterMediaCategories
});
function withAutomaticChangeReset(reducer) {
  return (state, action) => {
    const nextState = reducer(state, action);
    if (!state) {
      return nextState;
    }

    // Take over the last value without creating a new reference.
    nextState.automaticChangeStatus = state.automaticChangeStatus;
    if (action.type === 'MARK_AUTOMATIC_CHANGE') {
      return {
        ...nextState,
        automaticChangeStatus: 'pending'
      };
    }
    if (action.type === 'MARK_AUTOMATIC_CHANGE_FINAL' && state.automaticChangeStatus === 'pending') {
      return {
        ...nextState,
        automaticChangeStatus: 'final'
      };
    }

    // If there's a change that doesn't affect blocks or selection, maintain
    // the current status.
    if (nextState.blocks === state.blocks && nextState.selection === state.selection) {
      return nextState;
    }

    // As long as the state is not final, ignore any selection changes.
    if (nextState.automaticChangeStatus !== 'final' && nextState.selection !== state.selection) {
      return nextState;
    }

    // Reset the status if blocks change or selection changes (when status is final).
    return {
      ...nextState,
      automaticChangeStatus: undefined
    };
  };
}
/* harmony default export */ const reducer = (withAutomaticChangeReset(combinedReducers));
//# sourceMappingURL=reducer.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/platform.js
var platform = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/platform.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js
var svg = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/symbol.js
/**
 * WordPress dependencies
 */


const symbol = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M21.3 10.8l-5.6-5.6c-.7-.7-1.8-.7-2.5 0l-5.6 5.6c-.7.7-.7 1.8 0 2.5l5.6 5.6c.3.3.8.5 1.2.5s.9-.2 1.2-.5l5.6-5.6c.8-.7.8-1.9.1-2.5zm-1 1.4l-5.6 5.6c-.1.1-.3.1-.4 0l-5.6-5.6c-.1-.1-.1-.3 0-.4l5.6-5.6s.1-.1.2-.1.1 0 .2.1l5.6 5.6c.1.1.1.3 0 .4zm-16.6-.4L10 5.5l-1-1-6.3 6.3c-.7.7-.7 1.8 0 2.5L9 19.5l1.1-1.1-6.3-6.3c-.2 0-.2-.2-.1-.3z"
  })
});
/* harmony default export */ const library_symbol = (symbol);
//# sourceMappingURL=symbol.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@7.0.2_react@18.3.1/node_modules/@wordpress/rich-text/build-module/index.js + 17 modules
var rich_text_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+rich-text@7.0.2_react@18.3.1/node_modules/@wordpress/rich-text/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+deprecated@4.0.1/node_modules/@wordpress/deprecated/build-module/index.js
var deprecated_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+deprecated@4.0.1/node_modules/@wordpress/deprecated/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js
var rememo = __webpack_require__("../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/factory.js
var factory = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/factory.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/private-keys.js
const globalStylesDataKey = Symbol('globalStylesDataKey');
const selectBlockPatternsKey = Symbol('selectBlockPatternsKey');
const reusableBlocksSelectKey = Symbol('reusableBlocksSelect');
//# sourceMappingURL=private-keys.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+private-apis@1.10.0/node_modules/@wordpress/private-apis/build-module/implementation.js
var implementation = __webpack_require__("../../node_modules/.pnpm/@wordpress+private-apis@1.10.0/node_modules/@wordpress/private-apis/build-module/implementation.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/lock-unlock.js
/**
 * WordPress dependencies
 */

const {
  lock,
  unlock: lock_unlock_unlock
} = (0,implementation/* __dangerousOptInToUnstableAPIsOnlyForCoreModules */.yf)('I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.', '@wordpress/block-editor');
//# sourceMappingURL=lock-unlock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/constants.js
const STORE_NAME = 'core/block-editor';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/utils.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const withRootClientIdOptionKey = Symbol('withRootClientId');
const parsedPatternCache = new WeakMap();
function parsePattern(pattern) {
  const blocks = (0,build_module/* parse */.qg)(pattern.content, {
    __unstableSkipMigrationLogs: true
  });
  if (blocks.length === 1) {
    blocks[0].attributes = {
      ...blocks[0].attributes,
      metadata: {
        ...(blocks[0].attributes.metadata || {}),
        categories: pattern.categories,
        patternName: pattern.name,
        name: blocks[0].attributes.metadata?.name || pattern.title
      }
    };
  }
  return {
    ...pattern,
    blocks
  };
}
function getParsedPattern(pattern) {
  let parsedPattern = parsedPatternCache.get(pattern);
  if (parsedPattern) {
    return parsedPattern;
  }
  parsedPattern = parsePattern(pattern);
  parsedPatternCache.set(pattern, parsedPattern);
  return parsedPattern;
}
const checkAllowList = (list, item, defaultResult = null) => {
  if (typeof list === 'boolean') {
    return list;
  }
  if (Array.isArray(list)) {
    // TODO: when there is a canonical way to detect that we are editing a post
    // the following check should be changed to something like:
    // if ( list.includes( 'core/post-content' ) && getEditorMode() === 'post-content' && item === null )
    if (list.includes('core/post-content') && item === null) {
      return true;
    }
    return list.includes(item);
  }
  return defaultResult;
};
const checkAllowListRecursive = (blocks, allowedBlockTypes) => {
  if (typeof allowedBlockTypes === 'boolean') {
    return allowedBlockTypes;
  }
  const blocksQueue = [...blocks];
  while (blocksQueue.length > 0) {
    const block = blocksQueue.shift();
    const isAllowed = checkAllowList(allowedBlockTypes, block.name || block.blockName, true);
    if (!isAllowed) {
      return false;
    }
    block.innerBlocks?.forEach(innerBlock => {
      blocksQueue.push(innerBlock);
    });
  }
  return true;
};
const getAllPatternsDependants = select => state => {
  return [state.settings.__experimentalBlockPatterns, state.settings.__experimentalUserPatternCategories, state.settings.__experimentalReusableBlocks, state.settings[selectBlockPatternsKey]?.(select), state.blockPatterns, lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks()];
};
function getInsertBlockTypeDependants(state, rootClientId) {
  return [state.blockListSettings[rootClientId], state.blocks.byClientId.get(rootClientId), state.settings.allowedBlockTypes, state.settings.templateLock, state.blockEditingModes];
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/utils/sorting.js
/**
 * Recursive stable sorting comparator function.
 *
 * @param {string|Function} field Field to sort by.
 * @param {Array}           items Items to sort.
 * @param {string}          order Order, 'asc' or 'desc'.
 * @return {Function} Comparison function to be used in a `.sort()`.
 */
const comparator = (field, items, order) => {
  return (a, b) => {
    let cmpA, cmpB;
    if (typeof field === 'function') {
      cmpA = field(a);
      cmpB = field(b);
    } else {
      cmpA = a[field];
      cmpB = b[field];
    }
    if (cmpA > cmpB) {
      return order === 'asc' ? 1 : -1;
    } else if (cmpB > cmpA) {
      return order === 'asc' ? -1 : 1;
    }
    const orderA = items.findIndex(item => item === a);
    const orderB = items.findIndex(item => item === b);

    // Stable sort: maintaining original array order
    if (orderA > orderB) {
      return 1;
    } else if (orderB > orderA) {
      return -1;
    }
    return 0;
  };
};

/**
 * Order items by a certain key.
 * Supports decorator functions that allow complex picking of a comparison field.
 * Sorts in ascending order by default, but supports descending as well.
 * Stable sort - maintains original order of equal items.
 *
 * @param {Array}           items Items to order.
 * @param {string|Function} field Field to order by.
 * @param {string}          order Sorting order, `asc` or `desc`.
 * @return {Array} Sorted items.
 */
function orderBy(items, field, order = 'asc') {
  return items.concat().sort(comparator(field, items, order));
}
//# sourceMappingURL=sorting.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/utils.js
/**
 * WordPress dependencies
 */


const INSERTER_PATTERN_TYPES = {
  user: 'user',
  theme: 'theme',
  directory: 'directory'
};
const INSERTER_SYNC_TYPES = {
  full: 'fully',
  unsynced: 'unsynced'
};
const allPatternsCategory = {
  name: 'allPatterns',
  label: (0,i18n_build_module._x)('All', 'patterns')
};
const myPatternsCategory = {
  name: 'myPatterns',
  label: (0,i18n_build_module.__)('My patterns')
};
function isPatternFiltered(pattern, sourceFilter, syncFilter) {
  const isUserPattern = pattern.name.startsWith('core/block');
  const isDirectoryPattern = pattern.source === 'core' || pattern.source?.startsWith('pattern-directory');

  // If theme source selected, filter out user created patterns and those from
  // the core patterns directory.
  if (sourceFilter === INSERTER_PATTERN_TYPES.theme && (isUserPattern || isDirectoryPattern)) {
    return true;
  }

  // If the directory source is selected, filter out user created patterns
  // and those bundled with the theme.
  if (sourceFilter === INSERTER_PATTERN_TYPES.directory && (isUserPattern || !isDirectoryPattern)) {
    return true;
  }

  // If user source selected, filter out theme patterns.
  if (sourceFilter === INSERTER_PATTERN_TYPES.user && pattern.type !== INSERTER_PATTERN_TYPES.user) {
    return true;
  }

  // Filter by sync status.
  if (syncFilter === INSERTER_SYNC_TYPES.full && pattern.syncStatus !== '') {
    return true;
  }
  if (syncFilter === INSERTER_SYNC_TYPES.unsynced && pattern.syncStatus !== 'unsynced' && isUserPattern) {
    return true;
  }
  return false;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/utils/object.js
/**
 * Immutably sets a value inside an object. Like `lodash#set`, but returning a
 * new object. Treats nullish initial values as empty objects. Clones any
 * nested objects. Supports arrays, too.
 *
 * @param {Object}              object Object to set a value in.
 * @param {number|string|Array} path   Path in the object to modify.
 * @param {*}                   value  New value to set.
 * @return {Object} Cloned object with the new value set.
 */
function object_setImmutably(object, path, value) {
  // Normalize path
  path = Array.isArray(path) ? [...path] : [path];

  // Shallowly clone the base of the object
  object = Array.isArray(object) ? [...object] : {
    ...object
  };
  const leaf = path.pop();

  // Traverse object from root to leaf, shallowly cloning at each level
  let prev = object;
  for (const key of path) {
    const lvl = prev[key];
    prev = prev[key] = Array.isArray(lvl) ? [...lvl] : {
      ...lvl
    };
  }
  prev[leaf] = value;
  return object;
}

/**
 * Helper util to return a value from a certain path of the object.
 * Path is specified as either:
 * - a string of properties, separated by dots, for example: "x.y".
 * - an array of properties, for example `[ 'x', 'y' ]`.
 * You can also specify a default value in case the result is nullish.
 *
 * @param {Object}       object       Input object.
 * @param {string|Array} path         Path to the object property.
 * @param {*}            defaultValue Default value if the value at the specified path is nullish.
 * @return {*} Value of the object property at the specified path.
 */
const object_getValueFromObjectPath = (object, path, defaultValue) => {
  var _value;
  const arrayPath = Array.isArray(path) ? path : path.split('.');
  let value = object;
  arrayPath.forEach(fieldName => {
    value = value?.[fieldName];
  });
  return (_value = value) !== null && _value !== void 0 ? _value : defaultValue;
};

/**
 * Helper util to filter out objects with duplicate values for a given property.
 *
 * @param {Object[]} array    Array of objects to filter.
 * @param {string}   property Property to filter unique values by.
 *
 * @return {Object[]} Array of objects with unique values for the specified property.
 */
function uniqByProperty(array, property) {
  const seen = new Set();
  return array.filter(item => {
    const value = item[property];
    return seen.has(value) ? false : seen.add(value);
  });
}
//# sourceMappingURL=object.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/get-block-settings.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const blockedPaths = ['color', 'border', 'dimensions', 'typography', 'spacing'];
const deprecatedFlags = {
  'color.palette': settings => settings.colors,
  'color.gradients': settings => settings.gradients,
  'color.custom': settings => settings.disableCustomColors === undefined ? undefined : !settings.disableCustomColors,
  'color.customGradient': settings => settings.disableCustomGradients === undefined ? undefined : !settings.disableCustomGradients,
  'typography.fontSizes': settings => settings.fontSizes,
  'typography.customFontSize': settings => settings.disableCustomFontSizes === undefined ? undefined : !settings.disableCustomFontSizes,
  'typography.lineHeight': settings => settings.enableCustomLineHeight,
  'spacing.units': settings => {
    if (settings.enableCustomUnits === undefined) {
      return;
    }
    if (settings.enableCustomUnits === true) {
      return ['px', 'em', 'rem', 'vh', 'vw', '%'];
    }
    return settings.enableCustomUnits;
  },
  'spacing.padding': settings => settings.enableCustomSpacing
};
const prefixedFlags = {
  /*
   * These were only available in the plugin
   * and can be removed when the minimum WordPress version
   * for the plugin is 5.9.
   */
  'border.customColor': 'border.color',
  'border.customStyle': 'border.style',
  'border.customWidth': 'border.width',
  'typography.customFontStyle': 'typography.fontStyle',
  'typography.customFontWeight': 'typography.fontWeight',
  'typography.customLetterSpacing': 'typography.letterSpacing',
  'typography.customTextDecorations': 'typography.textDecoration',
  'typography.customTextTransforms': 'typography.textTransform',
  /*
   * These were part of WordPress 5.8 and we need to keep them.
   */
  'border.customRadius': 'border.radius',
  'spacing.customMargin': 'spacing.margin',
  'spacing.customPadding': 'spacing.padding',
  'typography.customLineHeight': 'typography.lineHeight'
};

/**
 * Remove `custom` prefixes for flags that did not land in 5.8.
 *
 * This provides continued support for `custom` prefixed properties. It will
 * be removed once third party devs have had sufficient time to update themes,
 * plugins, etc.
 *
 * @see https://github.com/WordPress/gutenberg/pull/34485
 *
 * @param {string} path Path to desired value in settings.
 * @return {string}     The value for defined setting.
 */
const removeCustomPrefixes = path => {
  return prefixedFlags[path] || path;
};
function getBlockSettings(state, clientId, ...paths) {
  const blockName = getBlockName(state, clientId);
  const candidates = [];
  if (clientId) {
    let id = clientId;
    do {
      const name = getBlockName(state, id);
      if ((0,build_module/* hasBlockSupport */.pN)(name, '__experimentalSettings', false)) {
        candidates.push(id);
      }
    } while (id = state.blocks.parents.get(id));
  }
  return paths.map(path => {
    if (blockedPaths.includes(path)) {
      // eslint-disable-next-line no-console
      console.warn('Top level useSetting paths are disabled. Please use a subpath to query the information needed.');
      return undefined;
    }

    // 0. Allow third parties to filter the block's settings at runtime.
    let result = (0,hooks_build_module/* applyFilters */.W5)('blockEditor.useSetting.before', undefined, path, clientId, blockName);
    if (undefined !== result) {
      return result;
    }
    const normalizedPath = removeCustomPrefixes(path);

    // 1. Take settings from the block instance or its ancestors.
    // Start from the current block and work our way up the ancestors.
    for (const candidateClientId of candidates) {
      var _getValueFromObjectPa;
      const candidateAtts = getBlockAttributes(state, candidateClientId);
      result = (_getValueFromObjectPa = object_getValueFromObjectPath(candidateAtts.settings?.blocks?.[blockName], normalizedPath)) !== null && _getValueFromObjectPa !== void 0 ? _getValueFromObjectPa : object_getValueFromObjectPath(candidateAtts.settings, normalizedPath);
      if (result !== undefined) {
        // Stop the search for more distant ancestors and move on.
        break;
      }
    }

    // 2. Fall back to the settings from the block editor store (__experimentalFeatures).
    const settings = getSettings(state);
    if (result === undefined && blockName) {
      result = object_getValueFromObjectPath(settings.__experimentalFeatures?.blocks?.[blockName], normalizedPath);
    }
    if (result === undefined) {
      result = object_getValueFromObjectPath(settings.__experimentalFeatures, normalizedPath);
    }

    // Return if the setting was found in either the block instance or the store.
    if (result !== undefined) {
      if (build_module/* __EXPERIMENTAL_PATHS_WITH_OVERRIDE */.G8[normalizedPath]) {
        var _ref, _result$custom;
        return (_ref = (_result$custom = result.custom) !== null && _result$custom !== void 0 ? _result$custom : result.theme) !== null && _ref !== void 0 ? _ref : result.default;
      }
      return result;
    }

    // 3. Otherwise, use deprecated settings.
    const deprecatedSettingsValue = deprecatedFlags[normalizedPath]?.(settings);
    if (deprecatedSettingsValue !== undefined) {
      return deprecatedSettingsValue;
    }

    // 4. Fallback for typography.dropCap:
    // This is only necessary to support typography.dropCap.
    // when __experimentalFeatures are not present (core without plugin).
    // To remove when __experimentalFeatures are ported to core.
    return normalizedPath === 'typography.dropCap' ? true : undefined;
  });
}
//# sourceMappingURL=get-block-settings.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/private-selectors.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */








/**
 * Returns true if the block interface is hidden, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the block toolbar is hidden.
 */
function private_selectors_isBlockInterfaceHidden(state) {
  return state.isBlockInterfaceHidden;
}

/**
 * Gets the client ids of the last inserted blocks.
 *
 * @param {Object} state Global application state.
 * @return {Array|undefined} Client Ids of the last inserted block(s).
 */
function getLastInsertedBlocksClientIds(state) {
  return state?.lastBlockInserted?.clientIds;
}
function getBlockWithoutAttributes(state, clientId) {
  return state.blocks.byClientId.get(clientId);
}

/**
 * Returns true if all of the descendants of a block with the given client ID
 * have an editing mode of 'disabled', or false otherwise.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block client ID.
 *
 * @return {boolean} Whether the block descendants are disabled.
 */
const isBlockSubtreeDisabled = (state, clientId) => {
  const isChildSubtreeDisabled = childClientId => {
    return getBlockEditingMode(state, childClientId) === 'disabled' && getBlockOrder(state, childClientId).every(isChildSubtreeDisabled);
  };
  return getBlockOrder(state, clientId).every(isChildSubtreeDisabled);
};
function getEnabledClientIdsTreeUnmemoized(state, rootClientId) {
  const blockOrder = getBlockOrder(state, rootClientId);
  const result = [];
  for (const clientId of blockOrder) {
    const innerBlocks = getEnabledClientIdsTreeUnmemoized(state, clientId);
    if (getBlockEditingMode(state, clientId) !== 'disabled') {
      result.push({
        clientId,
        innerBlocks
      });
    } else {
      result.push(...innerBlocks);
    }
  }
  return result;
}

/**
 * Returns a tree of block objects with only clientID and innerBlocks set.
 * Blocks with a 'disabled' editing mode are not included.
 *
 * @param {Object}  state        Global application state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Tree of block objects with only clientID and innerBlocks set.
 */
const getEnabledClientIdsTree = (0,rememo/* default */.A)(getEnabledClientIdsTreeUnmemoized, state => [state.blocks.order, state.blockEditingModes, state.settings.templateLock, state.blockListSettings]);

/**
 * Returns a list of a given block's ancestors, from top to bottom. Blocks with
 * a 'disabled' editing mode are excluded.
 *
 * @see getBlockParents
 *
 * @param {Object}  state     Global application state.
 * @param {string}  clientId  The block client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top
 *                            to bottom (false).
 */
const getEnabledBlockParents = (0,rememo/* default */.A)((state, clientId, ascending = false) => {
  return getBlockParents(state, clientId, ascending).filter(parent => getBlockEditingMode(state, parent) !== 'disabled');
}, state => [state.blocks.parents, state.blockEditingModes, state.settings.templateLock, state.blockListSettings]);

/**
 * Selector that returns the data needed to display a prompt when certain
 * blocks are removed, or `false` if no such prompt is requested.
 *
 * @param {Object} state Global application state.
 *
 * @return {Object|false} Data for removal prompt display, if any.
 */
function getRemovalPromptData(state) {
  return state.removalPromptData;
}

/**
 * Returns true if removal prompt exists, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether removal prompt exists.
 */
function getBlockRemovalRules(state) {
  return state.blockRemovalRules;
}

/**
 * Returns the client ID of the block settings menu that is currently open.
 *
 * @param {Object} state Global application state.
 * @return {string|null} The client ID of the block menu that is currently open.
 */
function getOpenedBlockSettingsMenu(state) {
  return state.openedBlockSettingsMenu;
}

/**
 * Returns all style overrides, intended to be merged with global editor styles.
 *
 * Overrides are sorted to match the order of the blocks they relate to. This
 * is useful to maintain correct CSS cascade order.
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} An array of style ID to style override pairs.
 */
const getStyleOverrides = (0,rememo/* default */.A)(state => {
  const clientIds = getClientIdsWithDescendants(state);
  const clientIdMap = clientIds.reduce((acc, clientId, index) => {
    acc[clientId] = index;
    return acc;
  }, {});
  return [...state.styleOverrides].sort((overrideA, overrideB) => {
    var _clientIdMap$clientId, _clientIdMap$clientId2;
    // Once the overrides Map is spread to an array, the first element
    // is the key, while the second is the override itself including
    // the clientId to sort by.
    const [, {
      clientId: clientIdA
    }] = overrideA;
    const [, {
      clientId: clientIdB
    }] = overrideB;
    const aIndex = (_clientIdMap$clientId = clientIdMap[clientIdA]) !== null && _clientIdMap$clientId !== void 0 ? _clientIdMap$clientId : -1;
    const bIndex = (_clientIdMap$clientId2 = clientIdMap[clientIdB]) !== null && _clientIdMap$clientId2 !== void 0 ? _clientIdMap$clientId2 : -1;
    return aIndex - bIndex;
  });
}, state => [state.blocks.order, state.styleOverrides]);

/** @typedef {import('./actions').InserterMediaCategory} InserterMediaCategory */
/**
 * Returns the registered inserter media categories through the public API.
 *
 * @param {Object} state Editor state.
 *
 * @return {InserterMediaCategory[]} Inserter media categories.
 */
function getRegisteredInserterMediaCategories(state) {
  return state.registeredInserterMediaCategories;
}

/**
 * Returns an array containing the allowed inserter media categories.
 * It merges the registered media categories from extenders with the
 * core ones. It also takes into account the allowed `mime_types`, which
 * can be altered by `upload_mimes` filter and restrict some of them.
 *
 * @param {Object} state Global application state.
 *
 * @return {InserterMediaCategory[]} Client IDs of descendants.
 */
const getInserterMediaCategories = (0,rememo/* default */.A)(state => {
  const {
    settings: {
      inserterMediaCategories,
      allowedMimeTypes,
      enableOpenverseMediaCategory
    },
    registeredInserterMediaCategories
  } = state;
  // The allowed `mime_types` can be altered by `upload_mimes` filter and restrict
  // some of them. In this case we shouldn't add the category to the available media
  // categories list in the inserter.
  if (!inserterMediaCategories && !registeredInserterMediaCategories.length || !allowedMimeTypes) {
    return;
  }
  const coreInserterMediaCategoriesNames = inserterMediaCategories?.map(({
    name
  }) => name) || [];
  const mergedCategories = [...(inserterMediaCategories || []), ...(registeredInserterMediaCategories || []).filter(({
    name
  }) => !coreInserterMediaCategoriesNames.includes(name))];
  return mergedCategories.filter(category => {
    // Check if Openverse category is enabled.
    if (!enableOpenverseMediaCategory && category.name === 'openverse') {
      return false;
    }
    return Object.values(allowedMimeTypes).some(mimeType => mimeType.startsWith(`${category.mediaType}/`));
  });
}, state => [state.settings.inserterMediaCategories, state.settings.allowedMimeTypes, state.settings.enableOpenverseMediaCategory, state.registeredInserterMediaCategories]);

/**
 * Returns whether there is at least one allowed pattern for inner blocks children.
 * This is useful for deferring the parsing of all patterns until needed.
 *
 * @param {Object} state               Editor state.
 * @param {string} [rootClientId=null] Target root client ID.
 *
 * @return {boolean} If there is at least one allowed pattern.
 */
const hasAllowedPatterns = (0,factory/* createRegistrySelector */.N)(select => (0,rememo/* default */.A)((state, rootClientId = null) => {
  const {
    getAllPatterns
  } = lock_unlock_unlock(select(STORE_NAME));
  const patterns = getAllPatterns();
  const {
    allowedBlockTypes
  } = getSettings(state);
  return patterns.some(pattern => {
    const {
      inserter = true
    } = pattern;
    if (!inserter) {
      return false;
    }
    const {
      blocks
    } = getParsedPattern(pattern);
    return checkAllowListRecursive(blocks, allowedBlockTypes) && blocks.every(({
      name: blockName
    }) => canInsertBlockType(state, blockName, rootClientId));
  });
}, (state, rootClientId) => [...getAllPatternsDependants(select)(state), ...getInsertBlockTypeDependants(state, rootClientId)]));
function mapUserPattern(userPattern, __experimentalUserPatternCategories = []) {
  return {
    name: `core/block/${userPattern.id}`,
    id: userPattern.id,
    type: INSERTER_PATTERN_TYPES.user,
    title: userPattern.title.raw,
    categories: userPattern.wp_pattern_category.map(catId => {
      const category = __experimentalUserPatternCategories.find(({
        id
      }) => id === catId);
      return category ? category.slug : catId;
    }),
    content: userPattern.content.raw,
    syncStatus: userPattern.wp_pattern_sync_status
  };
}
const getPatternBySlug = (0,factory/* createRegistrySelector */.N)(select => (0,rememo/* default */.A)((state, patternName) => {
  var _state$settings$__exp, _state$settings$selec;
  // Only fetch reusable blocks if we know we need them. To do: maybe
  // use the entity record API to retrieve the block by slug.
  if (patternName?.startsWith('core/block/')) {
    const _id = parseInt(patternName.slice('core/block/'.length), 10);
    const block = lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks().find(({
      id
    }) => id === _id);
    if (!block) {
      return null;
    }
    return mapUserPattern(block, state.settings.__experimentalUserPatternCategories);
  }
  return [
  // This setting is left for back compat.
  ...((_state$settings$__exp = state.settings.__experimentalBlockPatterns) !== null && _state$settings$__exp !== void 0 ? _state$settings$__exp : []), ...((_state$settings$selec = state.settings[selectBlockPatternsKey]?.(select)) !== null && _state$settings$selec !== void 0 ? _state$settings$selec : [])].find(({
    name
  }) => name === patternName);
}, (state, patternName) => patternName?.startsWith('core/block/') ? [lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks(), state.settings.__experimentalReusableBlocks] : [state.settings.__experimentalBlockPatterns, state.settings[selectBlockPatternsKey]?.(select)]));
const getAllPatterns = (0,factory/* createRegistrySelector */.N)(select => (0,rememo/* default */.A)(state => {
  var _state$settings$__exp2, _state$settings$selec2;
  return [...lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks().map(userPattern => mapUserPattern(userPattern, state.settings.__experimentalUserPatternCategories)),
  // This setting is left for back compat.
  ...((_state$settings$__exp2 = state.settings.__experimentalBlockPatterns) !== null && _state$settings$__exp2 !== void 0 ? _state$settings$__exp2 : []), ...((_state$settings$selec2 = state.settings[selectBlockPatternsKey]?.(select)) !== null && _state$settings$selec2 !== void 0 ? _state$settings$selec2 : [])].filter((x, index, arr) => index === arr.findIndex(y => x.name === y.name));
}, getAllPatternsDependants(select)));
const isResolvingPatterns = (0,factory/* createRegistrySelector */.N)(select => (0,rememo/* default */.A)(state => {
  const blockPatternsSelect = state.settings[selectBlockPatternsKey];
  const reusableBlocksSelect = state.settings[reusableBlocksSelectKey];
  return (blockPatternsSelect ? blockPatternsSelect(select) === undefined : false) || (reusableBlocksSelect ? reusableBlocksSelect(select) === undefined : false);
}, getAllPatternsDependants(select)));
const EMPTY_ARRAY = [];
const getReusableBlocks = (0,factory/* createRegistrySelector */.N)(select => state => {
  var _state$settings$__exp3;
  const reusableBlocksSelect = state.settings[reusableBlocksSelectKey];
  return reusableBlocksSelect ? reusableBlocksSelect(select) : (_state$settings$__exp3 = state.settings.__experimentalReusableBlocks) !== null && _state$settings$__exp3 !== void 0 ? _state$settings$__exp3 : EMPTY_ARRAY;
});

/**
 * Returns the element of the last element that had focus when focus left the editor canvas.
 *
 * @param {Object} state Block editor state.
 *
 * @return {Object} Element.
 */
function getLastFocus(state) {
  return state.lastFocus;
}

/**
 * Returns true if the user is dragging anything, or false otherwise. It is possible for a
 * user to be dragging data from outside of the editor, so this selector is separate from
 * the `isDraggingBlocks` selector which only returns true if the user is dragging blocks.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is dragging.
 */
function private_selectors_isDragging(state) {
  return state.isDragging;
}

/**
 * Retrieves the expanded block from the state.
 *
 * @param {Object} state Block editor state.
 *
 * @return {string|null} The client ID of the expanded block, if set.
 */
function getExpandedBlock(state) {
  return state.expandedBlock;
}

/**
 * Retrieves the client ID of the ancestor block that is content locking the block
 * with the provided client ID.
 *
 * @param {Object} state    Global application state.
 * @param {Object} clientId Client Id of the block.
 *
 * @return {?string} Client ID of the ancestor block that is content locking the block.
 */
const getContentLockingParent = (0,rememo/* default */.A)((state, clientId) => {
  let current = clientId;
  let result;
  while (current = state.blocks.parents.get(current)) {
    if (getBlockName(state, current) === 'core/block' || getTemplateLock(state, current) === 'contentOnly') {
      result = current;
    }
  }
  return result;
}, state => [state.blocks.parents, state.blockListSettings]);

/**
 * Retrieves the client ID of the block that is content locked but is
 * currently being temporarily edited as a non-locked block.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} The client ID of the block being temporarily edited as a non-locked block.
 */
function getTemporarilyEditingAsBlocks(state) {
  return state.temporarilyEditingAsBlocks;
}

/**
 * Returns the focus mode that should be reapplied when the user stops editing
 * a content locked blocks as a block without locking.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} The focus mode that should be re-set when temporarily editing as blocks stops.
 */
function getTemporarilyEditingFocusModeToRevert(state) {
  return state.temporarilyEditingFocusModeRevert;
}
//# sourceMappingURL=private-selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/selectors.js
/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */






/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */

// Module constants.
const MILLISECONDS_PER_HOUR = 3600 * 1000;
const MILLISECONDS_PER_DAY = 24 * 3600 * 1000;
const MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;

/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation, as in a connected or
 * other pure component which performs `shouldComponentUpdate` check on props.
 * This should be used as a last resort, since the normalized data should be
 * maintained by the reducer result in state.
 *
 * @type {Array}
 */
const selectors_EMPTY_ARRAY = [];

/**
 * Shared reference to an empty Set for cases where it is important to avoid
 * returning a new Set reference on every invocation, as in a connected or
 * other pure component which performs `shouldComponentUpdate` check on props.
 * This should be used as a last resort, since the normalized data should be
 * maintained by the reducer result in state.
 *
 * @type {Set}
 */
const EMPTY_SET = new Set();
const EMPTY_OBJECT = {};

/**
 * Returns a block's name given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {string} Block name.
 */
function getBlockName(state, clientId) {
  const block = state.blocks.byClientId.get(clientId);
  const socialLinkName = 'core/social-link';
  if (platform/* default */.A.OS !== 'web' && block?.name === socialLinkName) {
    const attributes = state.blocks.attributes.get(clientId);
    const {
      service
    } = attributes !== null && attributes !== void 0 ? attributes : {};
    return service ? `${socialLinkName}-${service}` : socialLinkName;
  }
  return block ? block.name : null;
}

/**
 * Returns whether a block is valid or not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Is Valid.
 */
function isBlockValid(state, clientId) {
  const block = state.blocks.byClientId.get(clientId);
  return !!block && block.isValid;
}

/**
 * Returns a block's attributes given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object?} Block attributes.
 */
function getBlockAttributes(state, clientId) {
  const block = state.blocks.byClientId.get(clientId);
  if (!block) {
    return null;
  }
  return state.blocks.attributes.get(clientId);
}

/**
 * Returns a block given its client ID. This is a parsed copy of the block,
 * containing its `blockName`, `clientId`, and current `attributes` state. This
 * is not the block's registration settings, which must be retrieved from the
 * blocks module registration store.
 *
 * getBlock recurses through its inner blocks until all its children blocks have
 * been retrieved. Note that getBlock will not return the child inner blocks of
 * an inner block controller. This is because an inner block controller syncs
 * itself with its own entity, and should therefore not be included with the
 * blocks of a different entity. For example, say you call `getBlocks( TP )` to
 * get the blocks of a template part. If another template part is a child of TP,
 * then the nested template part's child blocks will not be returned. This way,
 * the template block itself is considered part of the parent, but the children
 * are not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Parsed block object.
 */
function getBlock(state, clientId) {
  if (!state.blocks.byClientId.has(clientId)) {
    return null;
  }
  return state.blocks.tree.get(clientId);
}
const __unstableGetBlockWithoutInnerBlocks = (0,rememo/* default */.A)((state, clientId) => {
  const block = state.blocks.byClientId.get(clientId);
  if (!block) {
    return null;
  }
  return {
    ...block,
    attributes: getBlockAttributes(state, clientId)
  };
}, (state, clientId) => [state.blocks.byClientId.get(clientId), state.blocks.attributes.get(clientId)]);

/**
 * Returns all block objects for the current post being edited as an array in
 * the order they appear in the post. Note that this will exclude child blocks
 * of nested inner block controllers.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Post blocks.
 */
function getBlocks(state, rootClientId) {
  const treeKey = !rootClientId || !areInnerBlocksControlled(state, rootClientId) ? rootClientId || '' : 'controlled||' + rootClientId;
  return state.blocks.tree.get(treeKey)?.innerBlocks || selectors_EMPTY_ARRAY;
}

/**
 * Returns a stripped down block object containing only its client ID,
 * and its inner blocks' client IDs.
 *
 * @deprecated
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Client ID of the block to get.
 *
 * @return {Object} Client IDs of the post blocks.
 */
const __unstableGetClientIdWithClientIdsTree = (0,rememo/* default */.A)((state, clientId) => {
  (0,deprecated_build_module/* default */.A)("wp.data.select( 'core/block-editor' ).__unstableGetClientIdWithClientIdsTree", {
    since: '6.3',
    version: '6.5'
  });
  return {
    clientId,
    innerBlocks: __unstableGetClientIdsTree(state, clientId)
  };
}, state => [state.blocks.order]);

/**
 * Returns the block tree represented in the block-editor store from the
 * given root, consisting of stripped down block objects containing only
 * their client IDs, and their inner blocks' client IDs.
 *
 * @deprecated
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Client IDs of the post blocks.
 */
const __unstableGetClientIdsTree = (0,rememo/* default */.A)((state, rootClientId = '') => {
  (0,deprecated_build_module/* default */.A)("wp.data.select( 'core/block-editor' ).__unstableGetClientIdsTree", {
    since: '6.3',
    version: '6.5'
  });
  return getBlockOrder(state, rootClientId).map(clientId => __unstableGetClientIdWithClientIdsTree(state, clientId));
}, state => [state.blocks.order]);

/**
 * Returns an array containing the clientIds of all descendants of the blocks
 * given. Returned ids are ordered first by the order of the ids given, then
 * by the order that they appear in the editor.
 *
 * @param {Object}          state   Global application state.
 * @param {string|string[]} rootIds Client ID(s) for which descendant blocks are to be returned.
 *
 * @return {Array} Client IDs of descendants.
 */
const getClientIdsOfDescendants = (0,rememo/* default */.A)((state, rootIds) => {
  rootIds = Array.isArray(rootIds) ? [...rootIds] : [rootIds];
  const ids = [];

  // Add the descendants of the root blocks first.
  for (const rootId of rootIds) {
    const order = state.blocks.order.get(rootId);
    if (order) {
      ids.push(...order);
    }
  }
  let index = 0;

  // Add the descendants of the descendants, recursively.
  while (index < ids.length) {
    const id = ids[index];
    const order = state.blocks.order.get(id);
    if (order) {
      ids.splice(index + 1, 0, ...order);
    }
    index++;
  }
  return ids;
}, state => [state.blocks.order]);

/**
 * Returns an array containing the clientIds of the top-level blocks and
 * their descendants of any depth (for nested blocks). Ids are returned
 * in the same order that they appear in the editor.
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} ids of top-level and descendant blocks.
 */
const getClientIdsWithDescendants = state => getClientIdsOfDescendants(state, '');

/**
 * Returns the total number of blocks, or the total number of blocks with a specific name in a post.
 * The number returned includes nested blocks.
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if specified only blocks of that type will be counted.
 *
 * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.
 */
const getGlobalBlockCount = (0,rememo/* default */.A)((state, blockName) => {
  const clientIds = getClientIdsWithDescendants(state);
  if (!blockName) {
    return clientIds.length;
  }
  let count = 0;
  for (const clientId of clientIds) {
    const block = state.blocks.byClientId.get(clientId);
    if (block.name === blockName) {
      count++;
    }
  }
  return count;
}, state => [state.blocks.order, state.blocks.byClientId]);

/**
 * Returns all blocks that match a blockName. Results include nested blocks.
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if not specified, returns an empty array.
 *
 * @return {Array} Array of clientIds of blocks with name equal to blockName.
 */
const getBlocksByName = (0,rememo/* default */.A)((state, blockName) => {
  if (!blockName) {
    return selectors_EMPTY_ARRAY;
  }
  const blockNames = Array.isArray(blockName) ? blockName : [blockName];
  const clientIds = getClientIdsWithDescendants(state);
  const foundBlocks = clientIds.filter(clientId => {
    const block = state.blocks.byClientId.get(clientId);
    return blockNames.includes(block.name);
  });
  return foundBlocks.length > 0 ? foundBlocks : selectors_EMPTY_ARRAY;
}, state => [state.blocks.order, state.blocks.byClientId]);

/**
 * Returns all global blocks that match a blockName. Results include nested blocks.
 *
 * @deprecated
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if not specified, returns an empty array.
 *
 * @return {Array} Array of clientIds of blocks with name equal to blockName.
 */
function __experimentalGetGlobalBlocksByName(state, blockName) {
  (0,deprecated_build_module/* default */.A)("wp.data.select( 'core/block-editor' ).__experimentalGetGlobalBlocksByName", {
    since: '6.5',
    alternative: `wp.data.select( 'core/block-editor' ).getBlocksByName`
  });
  return getBlocksByName(state, blockName);
}

/**
 * Given an array of block client IDs, returns the corresponding array of block
 * objects.
 *
 * @param {Object}   state     Editor state.
 * @param {string[]} clientIds Client IDs for which blocks are to be returned.
 *
 * @return {WPBlock[]} Block objects.
 */
const getBlocksByClientId = (0,rememo/* default */.A)((state, clientIds) => (Array.isArray(clientIds) ? clientIds : [clientIds]).map(clientId => getBlock(state, clientId)), (state, clientIds) => (Array.isArray(clientIds) ? clientIds : [clientIds]).map(clientId => state.blocks.tree.get(clientId)));

/**
 * Given an array of block client IDs, returns the corresponding array of block
 * names.
 *
 * @param {Object}   state     Editor state.
 * @param {string[]} clientIds Client IDs for which block names are to be returned.
 *
 * @return {string[]} Block names.
 */
const getBlockNamesByClientId = (0,rememo/* default */.A)((state, clientIds) => getBlocksByClientId(state, clientIds).filter(Boolean).map(block => block.name), (state, clientIds) => getBlocksByClientId(state, clientIds));

/**
 * Returns the number of blocks currently present in the post.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {number} Number of blocks in the post.
 */
function getBlockCount(state, rootClientId) {
  return getBlockOrder(state, rootClientId).length;
}

/**
 * Returns the current selection start block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection start information.
 */
function getSelectionStart(state) {
  return state.selection.selectionStart;
}

/**
 * Returns the current selection end block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection end information.
 */
function getSelectionEnd(state) {
  return state.selection.selectionEnd;
}

/**
 * Returns the current block selection start. This value may be null, and it
 * may represent either a singular block selection or multi-selection start.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection start.
 */
function getBlockSelectionStart(state) {
  return state.selection.selectionStart.clientId;
}

/**
 * Returns the current block selection end. This value may be null, and it
 * may represent either a singular block selection or multi-selection end.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection end.
 */
function getBlockSelectionEnd(state) {
  return state.selection.selectionEnd.clientId;
}

/**
 * Returns the number of blocks currently selected in the post.
 *
 * @param {Object} state Global application state.
 *
 * @return {number} Number of blocks selected in the post.
 */
function getSelectedBlockCount(state) {
  const multiSelectedBlockCount = getMultiSelectedBlockClientIds(state).length;
  if (multiSelectedBlockCount) {
    return multiSelectedBlockCount;
  }
  return state.selection.selectionStart.clientId ? 1 : 0;
}

/**
 * Returns true if there is a single selected block, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether a single block is selected.
 */
function hasSelectedBlock(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return !!selectionStart.clientId && selectionStart.clientId === selectionEnd.clientId;
}

/**
 * Returns the currently selected block client ID, or null if there is no
 * selected block.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Selected block client ID.
 */
function getSelectedBlockClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  const {
    clientId
  } = selectionStart;
  if (!clientId || clientId !== selectionEnd.clientId) {
    return null;
  }
  return clientId;
}

/**
 * Returns the currently selected block, or null if there is no selected block.
 *
 * @param {Object} state Global application state.
 *
 * @return {?Object} Selected block.
 */
function getSelectedBlock(state) {
  const clientId = getSelectedBlockClientId(state);
  return clientId ? getBlock(state, clientId) : null;
}

/**
 * Given a block client ID, returns the root block from which the block is
 * nested, an empty string for top-level blocks, or null if the block does not
 * exist.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {?string} Root client ID, if exists
 */
function getBlockRootClientId(state, clientId) {
  var _state$blocks$parents;
  return (_state$blocks$parents = state.blocks.parents.get(clientId)) !== null && _state$blocks$parents !== void 0 ? _state$blocks$parents : null;
}

/**
 * Given a block client ID, returns the list of all its parents from top to bottom.
 *
 * @param {Object}  state     Editor state.
 * @param {string}  clientId  Block from which to find root client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */
const getBlockParents = (0,rememo/* default */.A)((state, clientId, ascending = false) => {
  const parents = [];
  let current = clientId;
  while (current = state.blocks.parents.get(current)) {
    parents.push(current);
  }
  if (!parents.length) {
    return selectors_EMPTY_ARRAY;
  }
  return ascending ? parents : parents.reverse();
}, state => [state.blocks.parents]);

/**
 * Given a block client ID and a block name, returns the list of all its parents
 * from top to bottom, filtered by the given name(s). For example, if passed
 * 'core/group' as the blockName, it will only return parents which are group
 * blocks. If passed `[ 'core/group', 'core/cover']`, as the blockName, it will
 * return parents which are group blocks and parents which are cover blocks.
 *
 * @param {Object}          state     Editor state.
 * @param {string}          clientId  Block from which to find root client ID.
 * @param {string|string[]} blockName Block name(s) to filter.
 * @param {boolean}         ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */
const getBlockParentsByBlockName = (0,rememo/* default */.A)((state, clientId, blockName, ascending = false) => {
  const parents = getBlockParents(state, clientId, ascending);
  const hasName = Array.isArray(blockName) ? name => blockName.includes(name) : name => blockName === name;
  return parents.filter(id => hasName(getBlockName(state, id)));
}, state => [state.blocks.parents]);
/**
 * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {string} Root client ID
 */
function getBlockHierarchyRootClientId(state, clientId) {
  let current = clientId;
  let parent;
  do {
    parent = current;
    current = state.blocks.parents.get(current);
  } while (current);
  return parent;
}

/**
 * Given a block client ID, returns the lowest common ancestor with selected client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find common ancestor client ID.
 *
 * @return {string} Common ancestor client ID or undefined
 */
function getLowestCommonAncestorWithSelectedBlock(state, clientId) {
  const selectedId = getSelectedBlockClientId(state);
  const clientParents = [...getBlockParents(state, clientId), clientId];
  const selectedParents = [...getBlockParents(state, selectedId), selectedId];
  let lowestCommonAncestor;
  const maxDepth = Math.min(clientParents.length, selectedParents.length);
  for (let index = 0; index < maxDepth; index++) {
    if (clientParents[index] === selectedParents[index]) {
      lowestCommonAncestor = clientParents[index];
    } else {
      break;
    }
  }
  return lowestCommonAncestor;
}

/**
 * Returns the client ID of the block adjacent one at the given reference
 * startClientId and modifier directionality. Defaults start startClientId to
 * the selected block, and direction as next block. Returns null if there is no
 * adjacent block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 * @param {?number} modifier      Directionality multiplier (1 next, -1
 *                                previous).
 *
 * @return {?string} Return the client ID of the block, or null if none exists.
 */
function getAdjacentBlockClientId(state, startClientId, modifier = 1) {
  // Default to selected block.
  if (startClientId === undefined) {
    startClientId = getSelectedBlockClientId(state);
  }

  // Try multi-selection starting at extent based on modifier.
  if (startClientId === undefined) {
    if (modifier < 0) {
      startClientId = getFirstMultiSelectedBlockClientId(state);
    } else {
      startClientId = getLastMultiSelectedBlockClientId(state);
    }
  }

  // Validate working start client ID.
  if (!startClientId) {
    return null;
  }

  // Retrieve start block root client ID, being careful to allow the falsey
  // empty string top-level root by explicitly testing against null.
  const rootClientId = getBlockRootClientId(state, startClientId);
  if (rootClientId === null) {
    return null;
  }
  const {
    order
  } = state.blocks;
  const orderSet = order.get(rootClientId);
  const index = orderSet.indexOf(startClientId);
  const nextIndex = index + 1 * modifier;

  // Block was first in set and we're attempting to get previous.
  if (nextIndex < 0) {
    return null;
  }

  // Block was last in set and we're attempting to get next.
  if (nextIndex === orderSet.length) {
    return null;
  }

  // Assume incremented index is within the set.
  return orderSet[nextIndex];
}

/**
 * Returns the previous block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no previous
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */
function getPreviousBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, -1);
}

/**
 * Returns the next block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no next
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */
function getNextBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, 1);
}

/* eslint-disable jsdoc/valid-types */
/**
 * Returns the initial caret position for the selected block.
 * This position is to used to position the caret properly when the selected block changes.
 * If the current block is not a RichText, having initial position set to 0 means "focus block"
 *
 * @param {Object} state Global application state.
 *
 * @return {0|-1|null} Initial position.
 */
function getSelectedBlocksInitialCaretPosition(state) {
  /* eslint-enable jsdoc/valid-types */
  return state.initialPosition;
}

/**
 * Returns the current selection set of block client IDs (multiselection or single selection).
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */
const getSelectedBlockClientIds = (0,rememo/* default */.A)(state => {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  if (!selectionStart.clientId || !selectionEnd.clientId) {
    return selectors_EMPTY_ARRAY;
  }
  if (selectionStart.clientId === selectionEnd.clientId) {
    return [selectionStart.clientId];
  }

  // Retrieve root client ID to aid in retrieving relevant nested block
  // order, being careful to allow the falsey empty string top-level root
  // by explicitly testing against null.
  const rootClientId = getBlockRootClientId(state, selectionStart.clientId);
  if (rootClientId === null) {
    return selectors_EMPTY_ARRAY;
  }
  const blockOrder = getBlockOrder(state, rootClientId);
  const startIndex = blockOrder.indexOf(selectionStart.clientId);
  const endIndex = blockOrder.indexOf(selectionEnd.clientId);
  if (startIndex > endIndex) {
    return blockOrder.slice(endIndex, startIndex + 1);
  }
  return blockOrder.slice(startIndex, endIndex + 1);
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);

/**
 * Returns the current multi-selection set of block client IDs, or an empty
 * array if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */
function getMultiSelectedBlockClientIds(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  if (selectionStart.clientId === selectionEnd.clientId) {
    return selectors_EMPTY_ARRAY;
  }
  return getSelectedBlockClientIds(state);
}

/**
 * Returns the current multi-selection set of blocks, or an empty array if
 * there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block objects.
 */
const getMultiSelectedBlocks = (0,rememo/* default */.A)(state => {
  const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
  if (!multiSelectedBlockClientIds.length) {
    return selectors_EMPTY_ARRAY;
  }
  return multiSelectedBlockClientIds.map(clientId => getBlock(state, clientId));
}, state => [...getSelectedBlockClientIds.getDependants(state), state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);

/**
 * Returns the client ID of the first block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} First block client ID in the multi-selection set.
 */
function getFirstMultiSelectedBlockClientId(state) {
  return getMultiSelectedBlockClientIds(state)[0] || null;
}

/**
 * Returns the client ID of the last block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Last block client ID in the multi-selection set.
 */
function getLastMultiSelectedBlockClientId(state) {
  const selectedClientIds = getMultiSelectedBlockClientIds(state);
  return selectedClientIds[selectedClientIds.length - 1] || null;
}

/**
 * Returns true if a multi-selection exists, and the block corresponding to the
 * specified client ID is the first block of the multi-selection set, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is first in multi-selection.
 */
function isFirstMultiSelectedBlock(state, clientId) {
  return getFirstMultiSelectedBlockClientId(state) === clientId;
}

/**
 * Returns true if the client ID occurs within the block multi-selection, or
 * false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is in multi-selection set.
 */
function isBlockMultiSelected(state, clientId) {
  return getMultiSelectedBlockClientIds(state).indexOf(clientId) !== -1;
}

/**
 * Returns true if an ancestor of the block is multi-selected, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether an ancestor of the block is in multi-selection
 *                   set.
 */
const isAncestorMultiSelected = (0,rememo/* default */.A)((state, clientId) => {
  let ancestorClientId = clientId;
  let isMultiSelected = false;
  while (ancestorClientId && !isMultiSelected) {
    ancestorClientId = getBlockRootClientId(state, ancestorClientId);
    isMultiSelected = isBlockMultiSelected(state, ancestorClientId);
  }
  return isMultiSelected;
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);

/**
 * Returns the client ID of the block which begins the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the first client ID in the selection.
 *
 * @see getFirstMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block beginning multi-selection.
 */
function getMultiSelectedBlocksStartClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }
  return selectionStart.clientId || null;
}

/**
 * Returns the client ID of the block which ends the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the last client ID in the selection.
 *
 * @see getLastMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block ending multi-selection.
 */
function getMultiSelectedBlocksEndClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }
  return selectionEnd.clientId || null;
}

/**
 * Returns true if the selection is not partial.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether the selection is mergeable.
 */
function __unstableIsFullySelected(state) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  return !selectionAnchor.attributeKey && !selectionFocus.attributeKey && typeof selectionAnchor.offset === 'undefined' && typeof selectionFocus.offset === 'undefined';
}

/**
 * Returns true if the selection is collapsed.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether the selection is collapsed.
 */
function __unstableIsSelectionCollapsed(state) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  return !!selectionAnchor && !!selectionFocus && selectionAnchor.clientId === selectionFocus.clientId && selectionAnchor.attributeKey === selectionFocus.attributeKey && selectionAnchor.offset === selectionFocus.offset;
}
function __unstableSelectionHasUnmergeableBlock(state) {
  return getSelectedBlockClientIds(state).some(clientId => {
    const blockName = getBlockName(state, clientId);
    const blockType = (0,build_module/* getBlockType */.E7)(blockName);
    return !blockType.merge;
  });
}

/**
 * Check whether the selection is mergeable.
 *
 * @param {Object}  state     Editor state.
 * @param {boolean} isForward Whether to merge forwards.
 *
 * @return {boolean} Whether the selection is mergeable.
 */
function __unstableIsSelectionMergeable(state, isForward) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);

  // It's not mergeable if the start and end are within the same block.
  if (selectionAnchor.clientId === selectionFocus.clientId) {
    return false;
  }

  // It's not mergeable if there's no rich text selection.
  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') {
    return false;
  }
  const anchorRootClientId = getBlockRootClientId(state, selectionAnchor.clientId);
  const focusRootClientId = getBlockRootClientId(state, selectionFocus.clientId);

  // It's not mergeable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.
  if (anchorRootClientId !== focusRootClientId) {
    return false;
  }
  const blockOrder = getBlockOrder(state, anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId);

  // Reassign selection start and end based on order.
  let selectionStart, selectionEnd;
  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }
  const targetBlockClientId = isForward ? selectionEnd.clientId : selectionStart.clientId;
  const blockToMergeClientId = isForward ? selectionStart.clientId : selectionEnd.clientId;
  const targetBlockName = getBlockName(state, targetBlockClientId);
  const targetBlockType = (0,build_module/* getBlockType */.E7)(targetBlockName);
  if (!targetBlockType.merge) {
    return false;
  }
  const blockToMerge = getBlock(state, blockToMergeClientId);

  // It's mergeable if the blocks are of the same type.
  if (blockToMerge.name === targetBlockName) {
    return true;
  }

  // If the blocks are of a different type, try to transform the block being
  // merged into the same type of block.
  const blocksToMerge = (0,build_module/* switchToBlockType */.bh)(blockToMerge, targetBlockName);
  return blocksToMerge && blocksToMerge.length;
}

/**
 * Get partial selected blocks with their content updated
 * based on the selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object[]} Updated partial selected blocks.
 */
const __unstableGetSelectedBlocksWithPartialSelection = state => {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  if (selectionAnchor.clientId === selectionFocus.clientId) {
    return selectors_EMPTY_ARRAY;
  }

  // Can't split if the selection is not set.
  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') {
    return selectors_EMPTY_ARRAY;
  }
  const anchorRootClientId = getBlockRootClientId(state, selectionAnchor.clientId);
  const focusRootClientId = getBlockRootClientId(state, selectionFocus.clientId);

  // It's not splittable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.
  if (anchorRootClientId !== focusRootClientId) {
    return selectors_EMPTY_ARRAY;
  }
  const blockOrder = getBlockOrder(state, anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId);

  // Reassign selection start and end based on order.
  const [selectionStart, selectionEnd] = anchorIndex > focusIndex ? [selectionFocus, selectionAnchor] : [selectionAnchor, selectionFocus];
  const blockA = getBlock(state, selectionStart.clientId);
  const blockB = getBlock(state, selectionEnd.clientId);
  const htmlA = blockA.attributes[selectionStart.attributeKey];
  const htmlB = blockB.attributes[selectionEnd.attributeKey];
  let valueA = (0,rich_text_build_module/* create */.vt)({
    html: htmlA
  });
  let valueB = (0,rich_text_build_module/* create */.vt)({
    html: htmlB
  });
  valueA = (0,rich_text_build_module/* remove */.TF)(valueA, 0, selectionStart.offset);
  valueB = (0,rich_text_build_module/* remove */.TF)(valueB, selectionEnd.offset, valueB.text.length);
  return [{
    ...blockA,
    attributes: {
      ...blockA.attributes,
      [selectionStart.attributeKey]: (0,rich_text_build_module/* toHTMLString */.Ky)({
        value: valueA
      })
    }
  }, {
    ...blockB,
    attributes: {
      ...blockB.attributes,
      [selectionEnd.attributeKey]: (0,rich_text_build_module/* toHTMLString */.Ky)({
        value: valueB
      })
    }
  }];
};

/**
 * Returns an array containing all block client IDs in the editor in the order
 * they appear. Optionally accepts a root client ID of the block list for which
 * the order should be returned, defaulting to the top-level block order.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array} Ordered client IDs of editor blocks.
 */
function getBlockOrder(state, rootClientId) {
  return state.blocks.order.get(rootClientId || '') || selectors_EMPTY_ARRAY;
}

/**
 * Returns the index at which the block corresponding to the specified client
 * ID occurs within the block order, or `-1` if the block does not exist.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {number} Index at which block exists in order.
 */
function getBlockIndex(state, clientId) {
  const rootClientId = getBlockRootClientId(state, clientId);
  return getBlockOrder(state, rootClientId).indexOf(clientId);
}

/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected and no multi-selection exists, or false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and multi-selection exists.
 */
function isBlockSelected(state, clientId) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  if (selectionStart.clientId !== selectionEnd.clientId) {
    return false;
  }
  return selectionStart.clientId === clientId;
}

/**
 * Returns true if one of the block's inner blocks is selected.
 *
 * @param {Object}  state    Editor state.
 * @param {string}  clientId Block client ID.
 * @param {boolean} deep     Perform a deep check.
 *
 * @return {boolean} Whether the block has an inner block selected
 */
function hasSelectedInnerBlock(state, clientId, deep = false) {
  const selectedBlockClientIds = getSelectedBlockClientIds(state);
  if (!selectedBlockClientIds.length) {
    return false;
  }
  if (deep) {
    return selectedBlockClientIds.some(id =>
    // Pass true because we don't care about order and it's more
    // performant.
    getBlockParents(state, id, true).includes(clientId));
  }
  return selectedBlockClientIds.some(id => getBlockRootClientId(state, id) === clientId);
}

/**
 * Returns true if one of the block's inner blocks is dragged.
 *
 * @param {Object}  state    Editor state.
 * @param {string}  clientId Block client ID.
 * @param {boolean} deep     Perform a deep check.
 *
 * @return {boolean} Whether the block has an inner block dragged
 */
function hasDraggedInnerBlock(state, clientId, deep = false) {
  return getBlockOrder(state, clientId).some(innerClientId => isBlockBeingDragged(state, innerClientId) || deep && hasDraggedInnerBlock(state, innerClientId, deep));
}

/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected but isn't the last of the selected blocks. Here "last"
 * refers to the block sequence in the document, _not_ the sequence of
 * multi-selection, which is why `state.selectionEnd` isn't used.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and not the last in the
 *                   selection.
 */
function isBlockWithinSelection(state, clientId) {
  if (!clientId) {
    return false;
  }
  const clientIds = getMultiSelectedBlockClientIds(state);
  const index = clientIds.indexOf(clientId);
  return index > -1 && index < clientIds.length - 1;
}

/**
 * Returns true if a multi-selection has been made, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether multi-selection has been made.
 */
function hasMultiSelection(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return selectionStart.clientId !== selectionEnd.clientId;
}

/**
 * Whether in the process of multi-selecting or not. This flag is only true
 * while the multi-selection is being selected (by mouse move), and is false
 * once the multi-selection has been settled.
 *
 * @see hasMultiSelection
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if multi-selecting, false if not.
 */
function selectors_isMultiSelecting(state) {
  return state.isMultiSelecting;
}

/**
 * Selector that returns if multi-selection is enabled or not.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if it should be possible to multi-select blocks, false if multi-selection is disabled.
 */
function selectors_isSelectionEnabled(state) {
  return state.isSelectionEnabled;
}

/**
 * Returns the block's editing mode, defaulting to "visual" if not explicitly
 * assigned.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Block editing mode.
 */
function getBlockMode(state, clientId) {
  return state.blocksMode[clientId] || 'visual';
}

/**
 * Returns true if the user is typing, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is typing.
 */
function selectors_isTyping(state) {
  return state.isTyping;
}

/**
 * Returns true if the user is dragging blocks, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is dragging blocks.
 */
function isDraggingBlocks(state) {
  return !!state.draggedBlocks.length;
}

/**
 * Returns the client ids of any blocks being directly dragged.
 *
 * This does not include children of a parent being dragged.
 *
 * @param {Object} state Global application state.
 *
 * @return {string[]} Array of dragged block client ids.
 */
function getDraggedBlockClientIds(state) {
  return state.draggedBlocks;
}

/**
 * Returns whether the block is being dragged.
 *
 * Only returns true if the block is being directly dragged,
 * not if the block is a child of a parent being dragged.
 * See `isAncestorBeingDragged` for child blocks.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block is being dragged.
 */
function isBlockBeingDragged(state, clientId) {
  return state.draggedBlocks.includes(clientId);
}

/**
 * Returns whether a parent/ancestor of the block is being dragged.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block's ancestor is being dragged.
 */
function isAncestorBeingDragged(state, clientId) {
  // Return early if no blocks are being dragged rather than
  // the more expensive check for parents.
  if (!isDraggingBlocks(state)) {
    return false;
  }
  const parents = getBlockParents(state, clientId);
  return parents.some(parentClientId => isBlockBeingDragged(state, parentClientId));
}

/**
 * Returns true if the caret is within formatted text, or false otherwise.
 *
 * @deprecated
 *
 * @return {boolean} Whether the caret is within formatted text.
 */
function isCaretWithinFormattedText() {
  (0,deprecated_build_module/* default */.A)('wp.data.select( "core/block-editor" ).isCaretWithinFormattedText', {
    since: '6.1',
    version: '6.3'
  });
  return false;
}

/**
 * Returns the insertion point, the index at which the new inserted block would
 * be placed. Defaults to the last index.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} Insertion point object with `rootClientId`, `index`.
 */
const getBlockInsertionPoint = (0,rememo/* default */.A)(state => {
  let rootClientId, index;
  const {
    insertionPoint,
    selection: {
      selectionEnd
    }
  } = state;
  if (insertionPoint !== null) {
    return insertionPoint;
  }
  const {
    clientId
  } = selectionEnd;
  if (clientId) {
    rootClientId = getBlockRootClientId(state, clientId) || undefined;
    index = getBlockIndex(state, selectionEnd.clientId) + 1;
  } else {
    index = getBlockOrder(state).length;
  }
  return {
    rootClientId,
    index
  };
}, state => [state.insertionPoint, state.selection.selectionEnd.clientId, state.blocks.parents, state.blocks.order]);

/**
 * Returns true if we should show the block insertion point.
 *
 * @param {Object} state Global application state.
 *
 * @return {?boolean} Whether the insertion point is visible or not.
 */
function isBlockInsertionPointVisible(state) {
  return state.insertionPoint !== null;
}

/**
 * Returns whether the blocks matches the template or not.
 *
 * @param {boolean} state
 * @return {?boolean} Whether the template is valid or not.
 */
function isValidTemplate(state) {
  return state.template.isValid;
}

/**
 * Returns the defined block template
 *
 * @param {boolean} state
 *
 * @return {?Array} Block Template.
 */
function getTemplate(state) {
  return state.settings.template;
}

/**
 * Returns the defined block template lock. Optionally accepts a root block
 * client ID as context, otherwise defaulting to the global context.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional block root client ID.
 *
 * @return {string|false} Block Template Lock
 */
function getTemplateLock(state, rootClientId) {
  var _getBlockListSettings;
  if (!rootClientId) {
    var _state$settings$templ;
    return (_state$settings$templ = state.settings.templateLock) !== null && _state$settings$templ !== void 0 ? _state$settings$templ : false;
  }
  return (_getBlockListSettings = getBlockListSettings(state, rootClientId)?.templateLock) !== null && _getBlockListSettings !== void 0 ? _getBlockListSettings : false;
}

/**
 * Determines if the given block type is allowed to be inserted into the block list.
 * This function is not exported and not memoized because using a memoized selector
 * inside another memoized selector is just a waste of time.
 *
 * @param {Object}        state        Editor state.
 * @param {string|Object} blockName    The block type object, e.g., the response
 *                                     from the block directory; or a string name of
 *                                     an installed block type, e.g.' core/paragraph'.
 * @param {?string}       rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */
const canInsertBlockTypeUnmemoized = (state, blockName, rootClientId = null) => {
  let blockType;
  if (blockName && 'object' === typeof blockName) {
    blockType = blockName;
    blockName = blockType.name;
  } else {
    blockType = (0,build_module/* getBlockType */.E7)(blockName);
  }
  if (!blockType) {
    return false;
  }
  const {
    allowedBlockTypes
  } = getSettings(state);
  const isBlockAllowedInEditor = checkAllowList(allowedBlockTypes, blockName, true);
  if (!isBlockAllowedInEditor) {
    return false;
  }
  const isLocked = !!getTemplateLock(state, rootClientId);
  if (isLocked) {
    return false;
  }
  if (getBlockEditingMode(state, rootClientId !== null && rootClientId !== void 0 ? rootClientId : '') === 'disabled') {
    return false;
  }
  const parentBlockListSettings = getBlockListSettings(state, rootClientId);

  // The parent block doesn't have settings indicating it doesn't support
  // inner blocks, return false.
  if (rootClientId && parentBlockListSettings === undefined) {
    return false;
  }
  const parentName = getBlockName(state, rootClientId);
  const parentBlockType = (0,build_module/* getBlockType */.E7)(parentName);

  // Look at the `blockType.allowedBlocks` field to determine whether this is an allowed child block.
  const parentAllowedChildBlocks = parentBlockType?.allowedBlocks;
  let hasParentAllowedBlock = checkAllowList(parentAllowedChildBlocks, blockName);

  // The `allowedBlocks` block list setting can further limit which blocks are allowed children.
  if (hasParentAllowedBlock !== false) {
    const parentAllowedBlocks = parentBlockListSettings?.allowedBlocks;
    const hasParentListAllowedBlock = checkAllowList(parentAllowedBlocks, blockName);
    // Never downgrade the result from `true` to `null`
    if (hasParentListAllowedBlock !== null) {
      hasParentAllowedBlock = hasParentListAllowedBlock;
    }
  }
  const blockAllowedParentBlocks = blockType.parent;
  const hasBlockAllowedParent = checkAllowList(blockAllowedParentBlocks, parentName);
  let hasBlockAllowedAncestor = true;
  const blockAllowedAncestorBlocks = blockType.ancestor;
  if (blockAllowedAncestorBlocks) {
    const ancestors = [rootClientId, ...getBlockParents(state, rootClientId)];
    hasBlockAllowedAncestor = ancestors.some(ancestorClientId => checkAllowList(blockAllowedAncestorBlocks, getBlockName(state, ancestorClientId)));
  }
  const canInsert = hasBlockAllowedAncestor && (hasParentAllowedBlock === null && hasBlockAllowedParent === null || hasParentAllowedBlock === true || hasBlockAllowedParent === true);
  if (!canInsert) {
    return canInsert;
  }

  /**
   * This filter is an ad-hoc solution to prevent adding template parts inside post content.
   * Conceptually, having a filter inside a selector is bad pattern so this code will be
   * replaced by a declarative API that doesn't the following drawbacks:
   *
   * Filters are not reactive: Upon switching between "template mode" and non "template mode",
   * the filter and selector won't necessarily be executed again. For now, it doesn't matter much
   * because you can't switch between the two modes while the inserter stays open.
   *
   * Filters are global: Once they're defined, they will affect all editor instances and all registries.
   * An ideal API would only affect specific editor instances.
   */
  return (0,hooks_build_module/* applyFilters */.W5)('blockEditor.__unstableCanInsertBlockType', canInsert, blockType, rootClientId, {
    // Pass bound selectors of the current registry. If we're in a nested
    // context, the data will differ from the one selected from the root
    // registry.
    getBlock: getBlock.bind(null, state),
    getBlockParentsByBlockName: getBlockParentsByBlockName.bind(null, state)
  });
};

/**
 * Determines if the given block type is allowed to be inserted into the block list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */
const canInsertBlockType = (0,rememo/* default */.A)(canInsertBlockTypeUnmemoized, (state, blockName, rootClientId) => getInsertBlockTypeDependants(state, rootClientId));

/**
 * Determines if the given blocks are allowed to be inserted into the block
 * list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be inserted.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be inserted.
 */
function canInsertBlocks(state, clientIds, rootClientId = null) {
  return clientIds.every(id => canInsertBlockType(state, getBlockName(state, id), rootClientId));
}

/**
 * Determines if the given block is allowed to be deleted.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId The block client Id.
 *
 * @return {boolean} Whether the given block is allowed to be removed.
 */
function canRemoveBlock(state, clientId) {
  const attributes = getBlockAttributes(state, clientId);
  if (attributes === null) {
    return true;
  }
  if (attributes.lock?.remove !== undefined) {
    return !attributes.lock.remove;
  }
  const rootClientId = getBlockRootClientId(state, clientId);
  if (getTemplateLock(state, rootClientId)) {
    return false;
  }
  return getBlockEditingMode(state, rootClientId) !== 'disabled';
}

/**
 * Determines if the given blocks are allowed to be removed.
 *
 * @param {Object} state     Editor state.
 * @param {string} clientIds The block client IDs to be removed.
 *
 * @return {boolean} Whether the given blocks are allowed to be removed.
 */
function canRemoveBlocks(state, clientIds) {
  return clientIds.every(clientId => canRemoveBlock(state, clientId));
}

/**
 * Determines if the given block is allowed to be moved.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId The block client Id.
 *
 * @return {boolean | undefined} Whether the given block is allowed to be moved.
 */
function canMoveBlock(state, clientId) {
  const attributes = getBlockAttributes(state, clientId);
  if (attributes === null) {
    return true;
  }
  if (attributes.lock?.move !== undefined) {
    return !attributes.lock.move;
  }
  const rootClientId = getBlockRootClientId(state, clientId);
  if (getTemplateLock(state, rootClientId) === 'all') {
    return false;
  }
  return getBlockEditingMode(state, rootClientId) !== 'disabled';
}

/**
 * Determines if the given blocks are allowed to be moved.
 *
 * @param {Object} state     Editor state.
 * @param {string} clientIds The block client IDs to be moved.
 *
 * @return {boolean} Whether the given blocks are allowed to be moved.
 */
function canMoveBlocks(state, clientIds) {
  return clientIds.every(clientId => canMoveBlock(state, clientId));
}

/**
 * Determines if the given block is allowed to be edited.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId The block client Id.
 *
 * @return {boolean} Whether the given block is allowed to be edited.
 */
function canEditBlock(state, clientId) {
  const attributes = getBlockAttributes(state, clientId);
  if (attributes === null) {
    return true;
  }
  const {
    lock
  } = attributes;

  // When the edit is true, we cannot edit the block.
  return !lock?.edit;
}

/**
 * Determines if the given block type can be locked/unlocked by a user.
 *
 * @param {Object}          state      Editor state.
 * @param {(string|Object)} nameOrType Block name or type object.
 *
 * @return {boolean} Whether a given block type can be locked/unlocked.
 */
function canLockBlockType(state, nameOrType) {
  if (!(0,build_module/* hasBlockSupport */.pN)(nameOrType, 'lock', true)) {
    return false;
  }

  // Use block editor settings as the default value.
  return !!state.settings?.canLockBlocks;
}

/**
 * Returns information about how recently and frequently a block has been inserted.
 *
 * @param {Object} state Global application state.
 * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'
 *
 * @return {?{ time: number, count: number }} An object containing `time` which is when the last
 *                                            insert occurred as a UNIX epoch, and `count` which is
 *                                            the number of inserts that have occurred.
 */
function getInsertUsage(state, id) {
  var _state$preferences$in;
  return (_state$preferences$in = state.preferences.insertUsage?.[id]) !== null && _state$preferences$in !== void 0 ? _state$preferences$in : null;
}

/**
 * Returns whether we can show a block type in the inserter
 *
 * @param {Object}  state        Global State
 * @param {Object}  blockType    BlockType
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be shown in the inserter.
 */
const canIncludeBlockTypeInInserter = (state, blockType, rootClientId) => {
  if (!(0,build_module/* hasBlockSupport */.pN)(blockType, 'inserter', true)) {
    return false;
  }
  return canInsertBlockTypeUnmemoized(state, blockType.name, rootClientId);
};

/**
 * Return a function to be used to tranform a block variation to an inserter item
 *
 * @param {Object} state Global State
 * @param {Object} item  Denormalized inserter item
 * @return {Function} Function to transform a block variation to inserter item
 */
const getItemFromVariation = (state, item) => variation => {
  const variationId = `${item.id}/${variation.name}`;
  const {
    time,
    count = 0
  } = getInsertUsage(state, variationId) || {};
  return {
    ...item,
    id: variationId,
    icon: variation.icon || item.icon,
    title: variation.title || item.title,
    description: variation.description || item.description,
    category: variation.category || item.category,
    // If `example` is explicitly undefined for the variation, the preview will not be shown.
    example: variation.hasOwnProperty('example') ? variation.example : item.example,
    initialAttributes: {
      ...item.initialAttributes,
      ...variation.attributes
    },
    innerBlocks: variation.innerBlocks,
    keywords: variation.keywords || item.keywords,
    frecency: calculateFrecency(time, count)
  };
};

/**
 * Returns the calculated frecency.
 *
 * 'frecency' is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * @param {number} time  When the last insert occurred as a UNIX epoch
 * @param {number} count The number of inserts that have occurred.
 *
 * @return {number} The calculated frecency.
 */
const calculateFrecency = (time, count) => {
  if (!time) {
    return count;
  }
  // The selector is cached, which means Date.now() is the last time that the
  // relevant state changed. This suits our needs.
  const duration = Date.now() - time;
  switch (true) {
    case duration < MILLISECONDS_PER_HOUR:
      return count * 4;
    case duration < MILLISECONDS_PER_DAY:
      return count * 2;
    case duration < MILLISECONDS_PER_WEEK:
      return count / 2;
    default:
      return count / 4;
  }
};

/**
 * Returns a function that accepts a block type and builds an item to be shown
 * in a specific context. It's used for building items for Inserter and available
 * block Transfroms list.
 *
 * @param {Object} state              Editor state.
 * @param {Object} options            Options object for handling the building of a block type.
 * @param {string} options.buildScope The scope for which the item is going to be used.
 * @return {Function} Function returns an item to be shown in a specific context (Inserter|Transforms list).
 */
const buildBlockTypeItem = (state, {
  buildScope = 'inserter'
}) => blockType => {
  const id = blockType.name;
  let isDisabled = false;
  if (!(0,build_module/* hasBlockSupport */.pN)(blockType.name, 'multiple', true)) {
    isDisabled = getBlocksByClientId(state, getClientIdsWithDescendants(state)).some(({
      name
    }) => name === blockType.name);
  }
  const {
    time,
    count = 0
  } = getInsertUsage(state, id) || {};
  const blockItemBase = {
    id,
    name: blockType.name,
    title: blockType.title,
    icon: blockType.icon,
    isDisabled,
    frecency: calculateFrecency(time, count)
  };
  if (buildScope === 'transform') {
    return blockItemBase;
  }
  const inserterVariations = (0,build_module/* getBlockVariations */.oO)(blockType.name, 'inserter');
  return {
    ...blockItemBase,
    initialAttributes: {},
    description: blockType.description,
    category: blockType.category,
    keywords: blockType.keywords,
    variations: inserterVariations,
    example: blockType.example,
    utility: 1 // Deprecated.
  };
};

/**
 * Determines the items that appear in the inserter. Includes both static
 * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).
 *
 * Each item object contains what's necessary to display a button in the
 * inserter and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'utility' and 'frecency'.
 *
 * @param    {Object}   state             Editor state.
 * @param    {?string}  rootClientId      Optional root client ID of block list.
 *
 * @return {WPEditorInserterItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorInserterItem
 * @property {string}   id                Unique identifier for the item.
 * @property {string}   name              The type of block to create.
 * @property {Object}   initialAttributes Attributes to pass to the newly created block.
 * @property {string}   title             Title of the item, as it appears in the inserter.
 * @property {string}   icon              Dashicon for the item, as it appears in the inserter.
 * @property {string}   category          Block category that the item is associated with.
 * @property {string[]} keywords          Keywords that can be searched to find this item.
 * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting
 *                                        this item.
 * @property {number}   frecency          Heuristic that combines frequency and recency.
 */
const getInserterItems = (0,factory/* createRegistrySelector */.N)(select => (0,rememo/* default */.A)((state, rootClientId = null, options = EMPTY_OBJECT) => {
  const buildReusableBlockInserterItem = reusableBlock => {
    const icon = !reusableBlock.wp_pattern_sync_status ? {
      src: library_symbol,
      foreground: 'var(--wp-block-synced-color)'
    } : library_symbol;
    const id = `core/block/${reusableBlock.id}`;
    const {
      time,
      count = 0
    } = getInsertUsage(state, id) || {};
    const frecency = calculateFrecency(time, count);
    return {
      id,
      name: 'core/block',
      initialAttributes: {
        ref: reusableBlock.id
      },
      title: reusableBlock.title?.raw,
      icon,
      category: 'reusable',
      keywords: ['reusable'],
      isDisabled: false,
      utility: 1,
      // Deprecated.
      frecency,
      content: reusableBlock.content?.raw,
      syncStatus: reusableBlock.wp_pattern_sync_status
    };
  };
  const syncedPatternInserterItems = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) ? lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks().map(buildReusableBlockInserterItem) : [];
  const buildBlockTypeInserterItem = buildBlockTypeItem(state, {
    buildScope: 'inserter'
  });
  let blockTypeInserterItems = (0,build_module/* getBlockTypes */.li)().filter(blockType => (0,build_module/* hasBlockSupport */.pN)(blockType, 'inserter', true)).map(buildBlockTypeInserterItem);
  if (options[withRootClientIdOptionKey]) {
    blockTypeInserterItems = blockTypeInserterItems.reduce((accumulator, item) => {
      item.rootClientId = rootClientId !== null && rootClientId !== void 0 ? rootClientId : '';
      while (!canInsertBlockTypeUnmemoized(state, item.name, item.rootClientId)) {
        if (!item.rootClientId) {
          let sectionRootClientId;
          try {
            sectionRootClientId = lock_unlock_unlock(getSettings(state)).sectionRootClientId;
          } catch (e) {}
          if (sectionRootClientId && canInsertBlockTypeUnmemoized(state, item.name, sectionRootClientId)) {
            item.rootClientId = sectionRootClientId;
          } else {
            delete item.rootClientId;
          }
          break;
        } else {
          const parentClientId = getBlockRootClientId(state, item.rootClientId);
          item.rootClientId = parentClientId;
        }
      }

      // We could also add non insertable items and gray them out.
      if (item.hasOwnProperty('rootClientId')) {
        accumulator.push(item);
      }
      return accumulator;
    }, []);
  } else {
    blockTypeInserterItems = blockTypeInserterItems.filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));
  }
  const items = blockTypeInserterItems.reduce((accumulator, item) => {
    const {
      variations = []
    } = item;
    // Exclude any block type item that is to be replaced by a default variation.
    if (!variations.some(({
      isDefault
    }) => isDefault)) {
      accumulator.push(item);
    }
    if (variations.length) {
      const variationMapper = getItemFromVariation(state, item);
      accumulator.push(...variations.map(variationMapper));
    }
    return accumulator;
  }, []);

  // Ensure core blocks are prioritized in the returned results,
  // because third party blocks can be registered earlier than
  // the core blocks (usually by using the `init` action),
  // thus affecting the display order.
  // We don't sort reusable blocks as they are handled differently.
  const groupByType = (blocks, block) => {
    const {
      core,
      noncore
    } = blocks;
    const type = block.name.startsWith('core/') ? core : noncore;
    type.push(block);
    return blocks;
  };
  const {
    core: coreItems,
    noncore: nonCoreItems
  } = items.reduce(groupByType, {
    core: [],
    noncore: []
  });
  const sortedBlockTypes = [...coreItems, ...nonCoreItems];
  return [...sortedBlockTypes, ...syncedPatternInserterItems];
}, (state, rootClientId) => [(0,build_module/* getBlockTypes */.li)(), lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks(), state.blocks.order, state.preferences.insertUsage, ...getInsertBlockTypeDependants(state, rootClientId)]));

/**
 * Determines the items that appear in the available block transforms list.
 *
 * Each item object contains what's necessary to display a menu item in the
 * transform list and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'frecency'.
 *
 * @param    {Object}          state        Editor state.
 * @param    {Object|Object[]} blocks       Block object or array objects.
 * @param    {?string}         rootClientId Optional root client ID of block list.
 *
 * @return {WPEditorTransformItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorTransformItem
 * @property {string}          id           Unique identifier for the item.
 * @property {string}          name         The type of block to create.
 * @property {string}          title        Title of the item, as it appears in the inserter.
 * @property {string}          icon         Dashicon for the item, as it appears in the inserter.
 * @property {boolean}         isDisabled   Whether or not the user should be prevented from inserting
 *                                          this item.
 * @property {number}          frecency     Heuristic that combines frequency and recency.
 */
const getBlockTransformItems = (0,rememo/* default */.A)((state, blocks, rootClientId = null) => {
  const normalizedBlocks = Array.isArray(blocks) ? blocks : [blocks];
  const buildBlockTypeTransformItem = buildBlockTypeItem(state, {
    buildScope: 'transform'
  });
  const blockTypeTransformItems = (0,build_module/* getBlockTypes */.li)().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeTransformItem);
  const itemsByName = Object.fromEntries(Object.entries(blockTypeTransformItems).map(([, value]) => [value.name, value]));
  const possibleTransforms = (0,build_module/* getPossibleBlockTransformations */.Fk)(normalizedBlocks).reduce((accumulator, block) => {
    if (itemsByName[block?.name]) {
      accumulator.push(itemsByName[block.name]);
    }
    return accumulator;
  }, []);
  return orderBy(possibleTransforms, block => itemsByName[block.name].frecency, 'desc');
}, (state, blocks, rootClientId) => [(0,build_module/* getBlockTypes */.li)(), state.preferences.insertUsage, ...getInsertBlockTypeDependants(state, rootClientId)]);

/**
 * Determines whether there are items to show in the inserter.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Items that appear in inserter.
 */
const hasInserterItems = (0,factory/* createRegistrySelector */.N)(select => (state, rootClientId = null) => {
  const hasBlockType = (0,build_module/* getBlockTypes */.li)().some(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));
  if (hasBlockType) {
    return true;
  }
  const hasReusableBlock = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) && lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks().length > 0;
  return hasReusableBlock;
});

/**
 * Returns the list of allowed inserter blocks for inner blocks children.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array?} The list of allowed block types.
 */
const getAllowedBlocks = (0,factory/* createRegistrySelector */.N)(select => (0,rememo/* default */.A)((state, rootClientId = null) => {
  if (!rootClientId) {
    return;
  }
  const blockTypes = (0,build_module/* getBlockTypes */.li)().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));
  const hasReusableBlock = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) && lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks().length > 0;
  if (hasReusableBlock) {
    blockTypes.push('core/block');
  }
  return blockTypes;
}, (state, rootClientId) => [(0,build_module/* getBlockTypes */.li)(), lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks(), ...getInsertBlockTypeDependants(state, rootClientId)]));
const __experimentalGetAllowedBlocks = (0,rememo/* default */.A)((state, rootClientId = null) => {
  (0,deprecated_build_module/* default */.A)('wp.data.select( "core/block-editor" ).__experimentalGetAllowedBlocks', {
    alternative: 'wp.data.select( "core/block-editor" ).getAllowedBlocks',
    since: '6.2',
    version: '6.4'
  });
  return getAllowedBlocks(state, rootClientId);
}, (state, rootClientId) => getAllowedBlocks.getDependants(state, rootClientId));

/**
 * Returns the block to be directly inserted by the block appender.
 *
 * @param    {Object}         state            Editor state.
 * @param    {?string}        rootClientId     Optional root client ID of block list.
 *
 * @return {WPDirectInsertBlock|undefined}              The block type to be directly inserted.
 *
 * @typedef {Object} WPDirectInsertBlock
 * @property {string}         name             The type of block.
 * @property {?Object}        attributes       Attributes to pass to the newly created block.
 * @property {?Array<string>} attributesToCopy Attributes to be copied from adjecent blocks when inserted.
 */
function getDirectInsertBlock(state, rootClientId = null) {
  var _state$blockListSetti;
  if (!rootClientId) {
    return;
  }
  const {
    defaultBlock,
    directInsert
  } = (_state$blockListSetti = state.blockListSettings[rootClientId]) !== null && _state$blockListSetti !== void 0 ? _state$blockListSetti : {};
  if (!defaultBlock || !directInsert) {
    return;
  }
  return defaultBlock;
}
function __experimentalGetDirectInsertBlock(state, rootClientId = null) {
  (0,deprecated_build_module/* default */.A)('wp.data.select( "core/block-editor" ).__experimentalGetDirectInsertBlock', {
    alternative: 'wp.data.select( "core/block-editor" ).getDirectInsertBlock',
    since: '6.3',
    version: '6.4'
  });
  return getDirectInsertBlock(state, rootClientId);
}
const __experimentalGetParsedPattern = (0,factory/* createRegistrySelector */.N)(select => (state, patternName) => {
  const pattern = lock_unlock_unlock(select(STORE_NAME)).getPatternBySlug(patternName);
  return pattern ? getParsedPattern(pattern) : null;
});
const getAllowedPatternsDependants = select => (state, rootClientId) => [...getAllPatternsDependants(select)(state), ...getInsertBlockTypeDependants(state, rootClientId)];

/**
 * Returns the list of allowed patterns for inner blocks children.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional target root client ID.
 *
 * @return {Array?} The list of allowed patterns.
 */
const __experimentalGetAllowedPatterns = (0,factory/* createRegistrySelector */.N)(select => {
  return (0,rememo/* default */.A)((state, rootClientId = null) => {
    const {
      getAllPatterns
    } = lock_unlock_unlock(select(STORE_NAME));
    const patterns = getAllPatterns();
    const {
      allowedBlockTypes
    } = getSettings(state);
    const parsedPatterns = patterns.filter(({
      inserter = true
    }) => !!inserter).map(getParsedPattern);
    const availableParsedPatterns = parsedPatterns.filter(({
      blocks
    }) => checkAllowListRecursive(blocks, allowedBlockTypes));
    const patternsAllowed = availableParsedPatterns.filter(({
      blocks
    }) => blocks.every(({
      name
    }) => canInsertBlockType(state, name, rootClientId)));
    return patternsAllowed;
  }, getAllowedPatternsDependants(select));
});

/**
 * Returns the list of patterns based on their declared `blockTypes`
 * and a block's name.
 * Patterns can use `blockTypes` to integrate in work flows like
 * suggesting appropriate patterns in a Placeholder state(during insertion)
 * or blocks transformations.
 *
 * @param {Object}          state        Editor state.
 * @param {string|string[]} blockNames   Block's name or array of block names to find matching pattens.
 * @param {?string}         rootClientId Optional target root client ID.
 *
 * @return {Array} The list of matched block patterns based on declared `blockTypes` and block name.
 */
const getPatternsByBlockTypes = (0,factory/* createRegistrySelector */.N)(select => (0,rememo/* default */.A)((state, blockNames, rootClientId = null) => {
  if (!blockNames) {
    return selectors_EMPTY_ARRAY;
  }
  const patterns = select(STORE_NAME).__experimentalGetAllowedPatterns(rootClientId);
  const normalizedBlockNames = Array.isArray(blockNames) ? blockNames : [blockNames];
  const filteredPatterns = patterns.filter(pattern => pattern?.blockTypes?.some?.(blockName => normalizedBlockNames.includes(blockName)));
  if (filteredPatterns.length === 0) {
    return selectors_EMPTY_ARRAY;
  }
  return filteredPatterns;
}, (state, blockNames, rootClientId) => getAllowedPatternsDependants(select)(state, rootClientId)));
const __experimentalGetPatternsByBlockTypes = (0,factory/* createRegistrySelector */.N)(select => {
  (0,deprecated_build_module/* default */.A)('wp.data.select( "core/block-editor" ).__experimentalGetPatternsByBlockTypes', {
    alternative: 'wp.data.select( "core/block-editor" ).getPatternsByBlockTypes',
    since: '6.2',
    version: '6.4'
  });
  return select(STORE_NAME).getPatternsByBlockTypes;
});

/**
 * Determines the items that appear in the available pattern transforms list.
 *
 * For now we only handle blocks without InnerBlocks and take into account
 * the `__experimentalRole` property of blocks' attributes for the transformation.
 *
 * We return the first set of possible eligible block patterns,
 * by checking the `blockTypes` property. We still have to recurse through
 * block pattern's blocks and try to find matches from the selected blocks.
 * Now this happens in the consumer to avoid heavy operations in the selector.
 *
 * @param {Object}   state        Editor state.
 * @param {Object[]} blocks       The selected blocks.
 * @param {?string}  rootClientId Optional root client ID of block list.
 *
 * @return {WPBlockPattern[]} Items that are eligible for a pattern transformation.
 */
const __experimentalGetPatternTransformItems = (0,factory/* createRegistrySelector */.N)(select => (0,rememo/* default */.A)((state, blocks, rootClientId = null) => {
  if (!blocks) {
    return selectors_EMPTY_ARRAY;
  }
  /**
   * For now we only handle blocks without InnerBlocks and take into account
   * the `__experimentalRole` property of blocks' attributes for the transformation.
   * Note that the blocks have been retrieved through `getBlock`, which doesn't
   * return the inner blocks of an inner block controller, so we still need
   * to check for this case too.
   */
  if (blocks.some(({
    clientId,
    innerBlocks
  }) => innerBlocks.length || areInnerBlocksControlled(state, clientId))) {
    return selectors_EMPTY_ARRAY;
  }

  // Create a Set of the selected block names that is used in patterns filtering.
  const selectedBlockNames = Array.from(new Set(blocks.map(({
    name
  }) => name)));
  /**
   * Here we will return first set of possible eligible block patterns,
   * by checking the `blockTypes` property. We still have to recurse through
   * block pattern's blocks and try to find matches from the selected blocks.
   * Now this happens in the consumer to avoid heavy operations in the selector.
   */
  return select(STORE_NAME).getPatternsByBlockTypes(selectedBlockNames, rootClientId);
}, (state, blocks, rootClientId) => getAllowedPatternsDependants(select)(state, rootClientId)));

/**
 * Returns the Block List settings of a block, if any exist.
 *
 * @param {Object}  state    Editor state.
 * @param {?string} clientId Block client ID.
 *
 * @return {?Object} Block settings of the block if set.
 */
function getBlockListSettings(state, clientId) {
  return state.blockListSettings[clientId];
}

/**
 * Returns the editor settings.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} The editor settings object.
 */
function getSettings(state) {
  return state.settings;
}

/**
 * Returns true if the most recent block change is be considered persistent, or
 * false otherwise. A persistent change is one committed by BlockEditorProvider
 * via its `onChange` callback, in addition to `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was persistent.
 */
function isLastBlockChangePersistent(state) {
  return state.blocks.isPersistentChange;
}

/**
 * Returns the block list settings for an array of blocks, if any exist.
 *
 * @param {Object} state     Editor state.
 * @param {Array}  clientIds Block client IDs.
 *
 * @return {Object} An object where the keys are client ids and the values are
 *                  a block list setting object.
 */
const __experimentalGetBlockListSettingsForBlocks = (0,rememo/* default */.A)((state, clientIds = []) => {
  return clientIds.reduce((blockListSettingsForBlocks, clientId) => {
    if (!state.blockListSettings[clientId]) {
      return blockListSettingsForBlocks;
    }
    return {
      ...blockListSettingsForBlocks,
      [clientId]: state.blockListSettings[clientId]
    };
  }, {});
}, state => [state.blockListSettings]);

/**
 * Returns the title of a given reusable block
 *
 * @param {Object}        state Global application state.
 * @param {number|string} ref   The shared block's ID.
 *
 * @return {string} The reusable block saved title.
 */
const __experimentalGetReusableBlockTitle = (0,factory/* createRegistrySelector */.N)(select => (0,rememo/* default */.A)((state, ref) => {
  (0,deprecated_build_module/* default */.A)("wp.data.select( 'core/block-editor' ).__experimentalGetReusableBlockTitle", {
    since: '6.6',
    version: '6.8'
  });
  const reusableBlock = lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks().find(block => block.id === ref);
  if (!reusableBlock) {
    return null;
  }
  return reusableBlock.title?.raw;
}, () => [lock_unlock_unlock(select(STORE_NAME)).getReusableBlocks()]));

/**
 * Returns true if the most recent block change is be considered ignored, or
 * false otherwise. An ignored change is one not to be committed by
 * BlockEditorProvider, neither via `onChange` nor `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was ignored.
 */
function __unstableIsLastBlockChangeIgnored(state) {
  // TODO: Removal Plan: Changes incurred by RECEIVE_BLOCKS should not be
  // ignored if in-fact they result in a change in blocks state. The current
  // need to ignore changes not a result of user interaction should be
  // accounted for in the refactoring of reusable blocks as occurring within
  // their own separate block editor / state (#7119).
  return state.blocks.isIgnoredChange;
}

/**
 * Returns the block attributes changed as a result of the last dispatched
 * action.
 *
 * @param {Object} state Block editor state.
 *
 * @return {Object<string,Object>} Subsets of block attributes changed, keyed
 *                                 by block client ID.
 */
function __experimentalGetLastBlockAttributeChanges(state) {
  return state.lastBlockAttributesChange;
}

/**
 * Returns whether the navigation mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Is navigation mode enabled.
 */
function isNavigationMode(state) {
  return state.editorMode === 'navigation';
}

/**
 * Returns the current editor mode.
 *
 * @param {Object} state Editor state.
 *
 * @return {string} the editor mode.
 */
function __unstableGetEditorMode(state) {
  return state.editorMode;
}

/**
 * Returns whether block moving mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {string} Client Id of moving block.
 */
function selectors_hasBlockMovingClientId(state) {
  return state.hasBlockMovingClientId;
}

/**
 * Returns true if the last change was an automatic change, false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the last change was automatic.
 */
function didAutomaticChange(state) {
  return !!state.automaticChangeStatus;
}

/**
 * Returns true if the current highlighted block matches the block clientId.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} Whether the block is currently highlighted.
 */
function isBlockHighlighted(state, clientId) {
  return state.highlightedBlock === clientId;
}

/**
 * Checks if a given block has controlled inner blocks.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} True if the block has controlled inner blocks.
 */
function areInnerBlocksControlled(state, clientId) {
  return !!state.blocks.controlledInnerBlocks[clientId];
}

/**
 * Returns the clientId for the first 'active' block of a given array of block names.
 * A block is 'active' if it (or a child) is the selected block.
 * Returns the first match moving up the DOM from the selected block.
 *
 * @param {Object}   state            Global application state.
 * @param {string[]} validBlocksNames The names of block types to check for.
 *
 * @return {string} The matching block's clientId.
 */
const __experimentalGetActiveBlockIdByBlockNames = (0,rememo/* default */.A)((state, validBlockNames) => {
  if (!validBlockNames.length) {
    return null;
  }
  // Check if selected block is a valid entity area.
  const selectedBlockClientId = getSelectedBlockClientId(state);
  if (validBlockNames.includes(getBlockName(state, selectedBlockClientId))) {
    return selectedBlockClientId;
  }
  // Check if first selected block is a child of a valid entity area.
  const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
  const entityAreaParents = getBlockParentsByBlockName(state, selectedBlockClientId || multiSelectedBlockClientIds[0], validBlockNames);
  if (entityAreaParents) {
    // Last parent closest/most interior.
    return entityAreaParents[entityAreaParents.length - 1];
  }
  return null;
}, (state, validBlockNames) => [state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId, validBlockNames]);

/**
 * Tells if the block with the passed clientId was just inserted.
 *
 * @param {Object}  state    Global application state.
 * @param {Object}  clientId Client Id of the block.
 * @param {?string} source   Optional insertion source of the block.
 * @return {boolean} True if the block matches the last block inserted from the specified source.
 */
function wasBlockJustInserted(state, clientId, source) {
  const {
    lastBlockInserted
  } = state;
  return lastBlockInserted.clientIds?.includes(clientId) && lastBlockInserted.source === source;
}

/**
 * Tells if the block is visible on the canvas or not.
 *
 * @param {Object} state    Global application state.
 * @param {Object} clientId Client Id of the block.
 * @return {boolean} True if the block is visible.
 */
function isBlockVisible(state, clientId) {
  var _state$blockVisibilit;
  return (_state$blockVisibilit = state.blockVisibility?.[clientId]) !== null && _state$blockVisibilit !== void 0 ? _state$blockVisibilit : true;
}

/**
 * Returns the list of all hidden blocks.
 *
 * @param {Object} state Global application state.
 * @return {[string]} List of hidden blocks.
 */
const __unstableGetVisibleBlocks = (0,rememo/* default */.A)(state => {
  const visibleBlocks = new Set(Object.keys(state.blockVisibility).filter(key => state.blockVisibility[key]));
  if (visibleBlocks.size === 0) {
    return EMPTY_SET;
  }
  return visibleBlocks;
}, state => [state.blockVisibility]);
function __unstableHasActiveBlockOverlayActive(state, clientId) {
  // Prevent overlay on blocks with a non-default editing mode. If the mdoe is
  // 'disabled' then the overlay is redundant since the block can't be
  // selected. If the mode is 'contentOnly' then the overlay is redundant
  // since there will be no controls to interact with once selected.
  if (getBlockEditingMode(state, clientId) !== 'default') {
    return false;
  }

  // If the block editing is locked, the block overlay is always active.
  if (!canEditBlock(state, clientId)) {
    return true;
  }
  const editorMode = __unstableGetEditorMode(state);

  // In zoom-out mode, the block overlay is always active for section level blocks.
  if (editorMode === 'zoom-out') {
    const {
      sectionRootClientId
    } = lock_unlock_unlock(getSettings(state));
    if (sectionRootClientId) {
      const sectionClientIds = getBlockOrder(state, sectionRootClientId);
      if (sectionClientIds?.includes(clientId)) {
        return true;
      }
    } else if (clientId && !getBlockRootClientId(state, clientId)) {
      return true;
    }
  }

  // In navigation mode, the block overlay is active when the block is not
  // selected (and doesn't contain a selected child). The same behavior is
  // also enabled in all modes for blocks that have controlled children
  // (reusable block, template part, navigation), unless explicitly disabled
  // with `supports.__experimentalDisableBlockOverlay`.
  const blockSupportDisable = (0,build_module/* hasBlockSupport */.pN)(getBlockName(state, clientId), '__experimentalDisableBlockOverlay', false);
  const shouldEnableIfUnselected = editorMode === 'navigation' || (blockSupportDisable ? false : areInnerBlocksControlled(state, clientId));
  return shouldEnableIfUnselected && !isBlockSelected(state, clientId) && !hasSelectedInnerBlock(state, clientId, true);
}
function __unstableIsWithinBlockOverlay(state, clientId) {
  let parent = state.blocks.parents.get(clientId);
  while (!!parent) {
    if (__unstableHasActiveBlockOverlayActive(state, parent)) {
      return true;
    }
    parent = state.blocks.parents.get(parent);
  }
  return false;
}

/**
 * @typedef {import('../components/block-editing-mode').BlockEditingMode} BlockEditingMode
 */

/**
 * Returns the block editing mode for a given block.
 *
 * The mode can be one of three options:
 *
 * - `'disabled'`: Prevents editing the block entirely, i.e. it cannot be
 *   selected.
 * - `'contentOnly'`: Hides all non-content UI, e.g. auxiliary controls in the
 *   toolbar, the block movers, block settings.
 * - `'default'`: Allows editing the block as normal.
 *
 * Blocks can set a mode using the `useBlockEditingMode` hook.
 *
 * The mode is inherited by all of the block's inner blocks, unless they have
 * their own mode.
 *
 * A template lock can also set a mode. If the template lock is `'contentOnly'`,
 * the block's mode is overridden to `'contentOnly'` if the block has a content
 * role attribute, or `'disabled'` otherwise.
 *
 * @see useBlockEditingMode
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block client ID, or `''` for the root container.
 *
 * @return {BlockEditingMode} The block editing mode. One of `'disabled'`,
 *                            `'contentOnly'`, or `'default'`.
 */
const getBlockEditingMode = (0,factory/* createRegistrySelector */.N)(select => (state, clientId = '') => {
  // Some selectors that call this provide `null` as the default
  // rootClientId, but the default rootClientId is actually `''`.
  if (clientId === null) {
    clientId = '';
  }
  // In zoom-out mode, override the behavior set by
  // __unstableSetBlockEditingMode to only allow editing the top-level
  // sections.
  const editorMode = __unstableGetEditorMode(state);
  if (editorMode === 'zoom-out') {
    const {
      sectionRootClientId
    } = lock_unlock_unlock(getSettings(state));
    if (clientId === '' /* ROOT_CONTAINER_CLIENT_ID */) {
      return sectionRootClientId ? 'disabled' : 'contentOnly';
    }
    if (clientId === sectionRootClientId) {
      return 'contentOnly';
    }
    const sectionsClientIds = getBlockOrder(state, sectionRootClientId);
    if (!sectionsClientIds?.includes(clientId)) {
      return 'disabled';
    }
  }
  const blockEditingMode = state.blockEditingModes.get(clientId);
  if (blockEditingMode) {
    return blockEditingMode;
  }
  if (!clientId) {
    return 'default';
  }
  const rootClientId = getBlockRootClientId(state, clientId);
  const templateLock = getTemplateLock(state, rootClientId);
  if (templateLock === 'contentOnly') {
    const name = getBlockName(state, clientId);
    const isContent = select(build_module/* store */.M_).__experimentalHasContentRoleAttribute(name);
    return isContent ? 'contentOnly' : 'disabled';
  }
  const parentMode = getBlockEditingMode(state, rootClientId);
  return parentMode === 'contentOnly' ? 'default' : parentMode;
});

/**
 * Indicates if a block is ungroupable.
 * A block is ungroupable if it is a single grouping block with inner blocks.
 * If a block has an `ungroup` transform, it is also ungroupable, without the
 * requirement of being the default grouping block.
 * Additionally a block can only be ungrouped if it has inner blocks and can
 * be removed.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client Id of the block. If not passed the selected block's client id will be used.
 * @return {boolean} True if the block is ungroupable.
 */
const isUngroupable = (0,factory/* createRegistrySelector */.N)(select => (state, clientId = '') => {
  const _clientId = clientId || getSelectedBlockClientId(state);
  if (!_clientId) {
    return false;
  }
  const {
    getGroupingBlockName
  } = select(build_module/* store */.M_);
  const block = getBlock(state, _clientId);
  const groupingBlockName = getGroupingBlockName();
  const _isUngroupable = block && (block.name === groupingBlockName || (0,build_module/* getBlockType */.E7)(block.name)?.transforms?.ungroup) && !!block.innerBlocks.length;
  return _isUngroupable && canRemoveBlock(state, _clientId);
});

/**
 * Indicates if the provided blocks(by client ids) are groupable.
 * We need to have at least one block, have a grouping block name set and
 * be able to remove these blocks.
 *
 * @param {Object}   state     Global application state.
 * @param {string[]} clientIds Block client ids. If not passed the selected blocks client ids will be used.
 * @return {boolean} True if the blocks are groupable.
 */
const isGroupable = (0,factory/* createRegistrySelector */.N)(select => (state, clientIds = selectors_EMPTY_ARRAY) => {
  const {
    getGroupingBlockName
  } = select(build_module/* store */.M_);
  const groupingBlockName = getGroupingBlockName();
  const _clientIds = clientIds?.length ? clientIds : getSelectedBlockClientIds(state);
  const rootClientId = _clientIds?.length ? getBlockRootClientId(state, _clientIds[0]) : undefined;
  const groupingBlockAvailable = canInsertBlockType(state, groupingBlockName, rootClientId);
  const _isGroupable = groupingBlockAvailable && _clientIds.length;
  return _isGroupable && canRemoveBlocks(state, _clientIds);
});

/**
 * DO-NOT-USE in production.
 * This selector is created for internal/experimental only usage and may be
 * removed anytime without any warning, causing breakage on any plugin or theme invoking it.
 *
 * @deprecated
 *
 * @param {Object} state    Global application state.
 * @param {Object} clientId Client Id of the block.
 *
 * @return {?string} Client ID of the ancestor block that is content locking the block.
 */
const __unstableGetContentLockingParent = (state, clientId) => {
  (0,deprecated_build_module/* default */.A)("wp.data.select( 'core/block-editor' ).__unstableGetContentLockingParent", {
    since: '6.1',
    version: '6.7'
  });
  return getContentLockingParent(state, clientId);
};

/**
 * DO-NOT-USE in production.
 * This selector is created for internal/experimental only usage and may be
 * removed anytime without any warning, causing breakage on any plugin or theme invoking it.
 *
 * @deprecated
 *
 * @param {Object} state Global application state.
 */
function __unstableGetTemporarilyEditingAsBlocks(state) {
  (0,deprecated_build_module/* default */.A)("wp.data.select( 'core/block-editor' ).__unstableGetTemporarilyEditingAsBlocks", {
    since: '6.1',
    version: '6.7'
  });
  return getTemporarilyEditingAsBlocks(state);
}

/**
 * DO-NOT-USE in production.
 * This selector is created for internal/experimental only usage and may be
 * removed anytime without any warning, causing breakage on any plugin or theme invoking it.
 *
 * @deprecated
 *
 * @param {Object} state Global application state.
 */
function __unstableGetTemporarilyEditingFocusModeToRevert(state) {
  (0,deprecated_build_module/* default */.A)("wp.data.select( 'core/block-editor' ).__unstableGetTemporarilyEditingFocusModeToRevert", {
    since: '6.5',
    version: '6.7'
  });
  return getTemporarilyEditingFocusModeToRevert(state);
}
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/undo-ignore.js
// Keep track of the blocks that should not be pushing an additional
// undo stack when editing the entity.
// See the implementation of `syncDerivedUpdates` and `useBlockSync`.
const undoIgnoreBlocks = new WeakSet();
//# sourceMappingURL=undo-ignore.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/private-actions.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const castArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];

/**
 * A list of private/experimental block editor settings that
 * should not become a part of the WordPress public API.
 * BlockEditorProvider will remove these settings from the
 * settings object it receives.
 *
 * @see https://github.com/WordPress/gutenberg/pull/46131
 */
const privateSettings = ['inserterMediaCategories', 'blockInspectorAnimation'];

/**
 * Action that updates the block editor settings and
 * conditionally preserves the experimental ones.
 *
 * @param {Object}  settings                          Updated settings
 * @param {Object}  options                           Options object.
 * @param {boolean} options.stripExperimentalSettings Whether to strip experimental settings.
 * @param {boolean} options.reset                     Whether to reset the settings.
 * @return {Object} Action object
 */
function __experimentalUpdateSettings(settings, {
  stripExperimentalSettings = false,
  reset = false
} = {}) {
  let cleanSettings = settings;
  // There are no plugins in the mobile apps, so there is no
  // need to strip the experimental settings:
  if (stripExperimentalSettings && platform/* default */.A.OS === 'web') {
    cleanSettings = {};
    for (const key in settings) {
      if (!privateSettings.includes(key)) {
        cleanSettings[key] = settings[key];
      }
    }
  }
  return {
    type: 'UPDATE_SETTINGS',
    settings: cleanSettings,
    reset
  };
}

/**
 * Hides the block interface (eg. toolbar, outline, etc.)
 *
 * @return {Object} Action object.
 */
function hideBlockInterface() {
  return {
    type: 'HIDE_BLOCK_INTERFACE'
  };
}

/**
 * Shows the block interface (eg. toolbar, outline, etc.)
 *
 * @return {Object} Action object.
 */
function showBlockInterface() {
  return {
    type: 'SHOW_BLOCK_INTERFACE'
  };
}

/**
 * Yields action objects used in signalling that the blocks corresponding to
 * the set of specified client IDs are to be removed.
 *
 * Compared to `removeBlocks`, this private interface exposes an additional
 * parameter; see `forceRemove`.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block
 *                                         or the immediate parent
 *                                         (if no previous block exists)
 *                                         should be selected
 *                                         when a block is removed.
 * @param {boolean}         forceRemove    Whether to force the operation,
 *                                         bypassing any checks for certain
 *                                         block types.
 */
const privateRemoveBlocks = (clientIds, selectPrevious = true, forceRemove = false) => ({
  select,
  dispatch,
  registry
}) => {
  if (!clientIds || !clientIds.length) {
    return;
  }
  clientIds = castArray(clientIds);
  const canRemoveBlocks = select.canRemoveBlocks(clientIds);
  if (!canRemoveBlocks) {
    return;
  }

  // In certain editing contexts, we'd like to prevent accidental removal
  // of important blocks. For example, in the site editor, the Query Loop
  // block is deemed important. In such cases, we'll ask the user for
  // confirmation that they intended to remove such block(s). However,
  // the editor instance is responsible for presenting those confirmation
  // prompts to the user. Any instance opting into removal prompts must
  // register using `setBlockRemovalRules()`.
  //
  // @see https://github.com/WordPress/gutenberg/pull/51145
  const rules = !forceRemove && select.getBlockRemovalRules();
  if (rules) {
    function flattenBlocks(blocks) {
      const result = [];
      const stack = [...blocks];
      while (stack.length) {
        const {
          innerBlocks,
          ...block
        } = stack.shift();
        stack.push(...innerBlocks);
        result.push(block);
      }
      return result;
    }
    const blockList = clientIds.map(select.getBlock);
    const flattenedBlocks = flattenBlocks(blockList);

    // Find the first message and use it.
    let message;
    for (const rule of rules) {
      message = rule.callback(flattenedBlocks);
      if (message) {
        dispatch(displayBlockRemovalPrompt(clientIds, selectPrevious, message));
        return;
      }
    }
  }
  if (selectPrevious) {
    dispatch.selectPreviousBlock(clientIds[0], selectPrevious);
  }

  // We're batching these two actions because an extra `undo/redo` step can
  // be created, based on whether we insert a default block or not.
  registry.batch(() => {
    dispatch({
      type: 'REMOVE_BLOCKS',
      clientIds
    });
    // To avoid a focus loss when removing the last block, assure there is
    // always a default block if the last of the blocks have been removed.
    dispatch(ensureDefaultBlock());
  });
};

/**
 * Action which will insert a default block insert action if there
 * are no other blocks at the root of the editor. This action should be used
 * in actions which may result in no blocks remaining in the editor (removal,
 * replacement, etc).
 */
const ensureDefaultBlock = () => ({
  select,
  dispatch
}) => {
  // To avoid a focus loss when removing the last block, assure there is
  // always a default block if the last of the blocks have been removed.
  const count = select.getBlockCount();
  if (count > 0) {
    return;
  }

  // If there's an custom appender, don't insert default block.
  // We have to remember to manually move the focus elsewhere to
  // prevent it from being lost though.
  const {
    __unstableHasCustomAppender
  } = select.getSettings();
  if (__unstableHasCustomAppender) {
    return;
  }
  dispatch.insertDefaultBlock();
};

/**
 * Returns an action object used in signalling that a block removal prompt must
 * be displayed.
 *
 * Contrast with `setBlockRemovalRules`.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block or the
 *                                         immediate parent (if no previous
 *                                         block exists) should be selected
 *                                         when a block is removed.
 * @param {string}          message        Message to display in the prompt.
 *
 * @return {Object} Action object.
 */
function displayBlockRemovalPrompt(clientIds, selectPrevious, message) {
  return {
    type: 'DISPLAY_BLOCK_REMOVAL_PROMPT',
    clientIds,
    selectPrevious,
    message
  };
}

/**
 * Returns an action object used in signalling that a block removal prompt must
 * be cleared, either be cause the user has confirmed or canceled the request
 * for removal.
 *
 * @return {Object} Action object.
 */
function clearBlockRemovalPrompt() {
  return {
    type: 'CLEAR_BLOCK_REMOVAL_PROMPT'
  };
}

/**
 * Returns an action object used to set up any rules that a block editor may
 * provide in order to prevent a user from accidentally removing certain
 * blocks. These rules are then used to display a confirmation prompt to the
 * user. For instance, in the Site Editor, the Query Loop block is important
 * enough to warrant such confirmation.
 *
 * IMPORTANT: Registering rules implicitly signals to the `privateRemoveBlocks`
 * action that the editor will be responsible for displaying block removal
 * prompts and confirming deletions. This action is meant to be used by
 * component `BlockRemovalWarningModal` only.
 *
 * The data is a record whose keys are block types (e.g. 'core/query') and
 * whose values are the explanation to be shown to users (e.g. 'Query Loop
 * displays a list of posts or pages.').
 *
 * Contrast with `displayBlockRemovalPrompt`.
 *
 * @param {Record<string,string>|false} rules Block removal rules.
 * @return {Object} Action object.
 */
function setBlockRemovalRules(rules = false) {
  return {
    type: 'SET_BLOCK_REMOVAL_RULES',
    rules
  };
}

/**
 * Sets the client ID of the block settings menu that is currently open.
 *
 * @param {?string} clientId The block client ID.
 * @return {Object} Action object.
 */
function setOpenedBlockSettingsMenu(clientId) {
  return {
    type: 'SET_OPENED_BLOCK_SETTINGS_MENU',
    clientId
  };
}
function setStyleOverride(id, style) {
  return {
    type: 'SET_STYLE_OVERRIDE',
    id,
    style
  };
}
function deleteStyleOverride(id) {
  return {
    type: 'DELETE_STYLE_OVERRIDE',
    id
  };
}

/**
 * A higher-order action that mark every change inside a callback as "non-persistent"
 * and ignore pushing to the undo history stack. It's primarily used for synchronized
 * derived updates from the block editor without affecting the undo history.
 *
 * @param {() => void} callback The synchronous callback to derive updates.
 */
function syncDerivedUpdates(callback) {
  return ({
    dispatch,
    select,
    registry
  }) => {
    registry.batch(() => {
      // Mark every change in the `callback` as non-persistent.
      dispatch({
        type: 'SET_EXPLICIT_PERSISTENT',
        isPersistentChange: false
      });
      callback();
      dispatch({
        type: 'SET_EXPLICIT_PERSISTENT',
        isPersistentChange: undefined
      });

      // Ignore pushing undo stack for the updated blocks.
      const updatedBlocks = select.getBlocks();
      undoIgnoreBlocks.add(updatedBlocks);
    });
  };
}

/**
 * Action that sets the element that had focus when focus leaves the editor canvas.
 *
 * @param {Object} lastFocus The last focused element.
 *
 *
 * @return {Object} Action object.
 */
function setLastFocus(lastFocus = null) {
  return {
    type: 'LAST_FOCUS',
    lastFocus
  };
}

/**
 * Action that stops temporarily editing as blocks.
 *
 * @param {string} clientId The block's clientId.
 */
function stopEditingAsBlocks(clientId) {
  return ({
    select,
    dispatch,
    registry
  }) => {
    const focusModeToRevert = lock_unlock_unlock(registry.select(store_store)).getTemporarilyEditingFocusModeToRevert();
    dispatch.__unstableMarkNextChangeAsNotPersistent();
    dispatch.updateBlockAttributes(clientId, {
      templateLock: 'contentOnly'
    });
    dispatch.updateBlockListSettings(clientId, {
      ...select.getBlockListSettings(clientId),
      templateLock: 'contentOnly'
    });
    dispatch.updateSettings({
      focusMode: focusModeToRevert
    });
    dispatch.__unstableSetTemporarilyEditingAsBlocks();
  };
}

/**
 * Returns an action object used in signalling that the user has begun to drag.
 *
 * @return {Object} Action object.
 */
function startDragging() {
  return {
    type: 'START_DRAGGING'
  };
}

/**
 * Returns an action object used in signalling that the user has stopped dragging.
 *
 * @return {Object} Action object.
 */
function stopDragging() {
  return {
    type: 'STOP_DRAGGING'
  };
}

/**
 * @param {string|null} clientId The block's clientId, or `null` to clear.
 *
 * @return  {Object} Action object.
 */
function expandBlock(clientId) {
  return {
    type: 'SET_BLOCK_EXPANDED_IN_LIST_VIEW',
    clientId
  };
}

/**
 * Temporarily modify/unlock the content-only block for editions.
 *
 * @param {string} clientId The client id of the block.
 */
const modifyContentLockBlock = clientId => ({
  select,
  dispatch
}) => {
  dispatch.__unstableMarkNextChangeAsNotPersistent();
  dispatch.updateBlockAttributes(clientId, {
    templateLock: undefined
  });
  dispatch.updateBlockListSettings(clientId, {
    ...select.getBlockListSettings(clientId),
    templateLock: false
  });
  const focusModeToRevert = select.getSettings().focusMode;
  dispatch.updateSettings({
    focusMode: true
  });
  dispatch.__unstableSetTemporarilyEditingAsBlocks(clientId, focusModeToRevert);
};
//# sourceMappingURL=private-actions.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+a11y@4.0.1/node_modules/@wordpress/a11y/build-module/index.js + 5 modules
var a11y_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+a11y@4.0.1/node_modules/@wordpress/a11y/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@5.0.2_react@18.3.1/node_modules/@wordpress/notices/build-module/store/utils/on-sub-key.js
/**
 * Higher-order reducer creator which creates a combined reducer object, keyed
 * by a property on the action object.
 *
 * @param {string} actionProperty Action property by which to key object.
 *
 * @return {Function} Higher-order reducer.
 */
const onSubKey = actionProperty => reducer => (state = {}, action) => {
  // Retrieve subkey from action. Do not track if undefined; useful for cases
  // where reducer is scoped by action shape.
  const key = action[actionProperty];
  if (key === undefined) {
    return state;
  }

  // Avoid updating state if unchanged. Note that this also accounts for a
  // reducer which returns undefined on a key which is not yet tracked.
  const nextKeyState = reducer(state[key], action);
  if (nextKeyState === state[key]) {
    return state;
  }
  return {
    ...state,
    [key]: nextKeyState
  };
};
/* harmony default export */ const on_sub_key = (onSubKey);
//# sourceMappingURL=on-sub-key.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@5.0.2_react@18.3.1/node_modules/@wordpress/notices/build-module/store/reducer.js
/**
 * Internal dependencies
 */


/**
 * Reducer returning the next notices state. The notices state is an object
 * where each key is a context, its value an array of notice objects.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
const notices = on_sub_key('context')((state = [], action) => {
  switch (action.type) {
    case 'CREATE_NOTICE':
      // Avoid duplicates on ID.
      return [...state.filter(({
        id
      }) => id !== action.notice.id), action.notice];
    case 'REMOVE_NOTICE':
      return state.filter(({
        id
      }) => id !== action.id);
    case 'REMOVE_NOTICES':
      return state.filter(({
        id
      }) => !action.ids.includes(id));
    case 'REMOVE_ALL_NOTICES':
      return state.filter(({
        type
      }) => type !== action.noticeType);
  }
  return state;
});
/* harmony default export */ const store_reducer = (notices);
//# sourceMappingURL=reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@5.0.2_react@18.3.1/node_modules/@wordpress/notices/build-module/store/constants.js
/**
 * Default context to use for notice grouping when not otherwise specified. Its
 * specific value doesn't hold much meaning, but it must be reasonably unique
 * and, more importantly, referenced consistently in the store implementation.
 *
 * @type {string}
 */
const DEFAULT_CONTEXT = 'global';

/**
 * Default notice status.
 *
 * @type {string}
 */
const DEFAULT_STATUS = 'info';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@5.0.2_react@18.3.1/node_modules/@wordpress/notices/build-module/store/actions.js
/**
 * Internal dependencies
 */


/**
 * @typedef {Object} WPNoticeAction Object describing a user action option associated with a notice.
 *
 * @property {string}    label   Message to use as action label.
 * @property {?string}   url     Optional URL of resource if action incurs
 *                               browser navigation.
 * @property {?Function} onClick Optional function to invoke when action is
 *                               triggered by user.
 */

let uniqueId = 0;

/**
 * Returns an action object used in signalling that a notice is to be created.
 *
 * @param {string|undefined}      status                       Notice status ("info" if undefined is passed).
 * @param {string}                content                      Notice message.
 * @param {Object}                [options]                    Notice options.
 * @param {string}                [options.context='global']   Context under which to
 *                                                             group notice.
 * @param {string}                [options.id]                 Identifier for notice.
 *                                                             Automatically assigned
 *                                                             if not specified.
 * @param {boolean}               [options.isDismissible=true] Whether the notice can
 *                                                             be dismissed by user.
 * @param {string}                [options.type='default']     Type of notice, one of
 *                                                             `default`, or `snackbar`.
 * @param {boolean}               [options.speak=true]         Whether the notice
 *                                                             content should be
 *                                                             announced to screen
 *                                                             readers.
 * @param {Array<WPNoticeAction>} [options.actions]            User actions to be
 *                                                             presented with notice.
 * @param {string}                [options.icon]               An icon displayed with the notice.
 *                                                             Only used when type is set to `snackbar`.
 * @param {boolean}               [options.explicitDismiss]    Whether the notice includes
 *                                                             an explicit dismiss button and
 *                                                             can't be dismissed by clicking
 *                                                             the body of the notice. Only applies
 *                                                             when type is set to `snackbar`.
 * @param {Function}              [options.onDismiss]          Called when the notice is dismissed.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () => createNotice( 'success', __( 'Notice message' ) ) }
 *         >
 *             { __( 'Generate a success notice!' ) }
 *         </Button>
 *     );
 * };
 * ```
 *
 * @return {Object} Action object.
 */
function createNotice(status = DEFAULT_STATUS, content, options = {}) {
  const {
    speak = true,
    isDismissible = true,
    context = DEFAULT_CONTEXT,
    id = `${context}${++uniqueId}`,
    actions = [],
    type = 'default',
    __unstableHTML,
    icon = null,
    explicitDismiss = false,
    onDismiss
  } = options;

  // The supported value shape of content is currently limited to plain text
  // strings. To avoid setting expectation that e.g. a React Element could be
  // supported, cast to a string.
  content = String(content);
  return {
    type: 'CREATE_NOTICE',
    context,
    notice: {
      id,
      status,
      content,
      spokenMessage: speak ? content : null,
      __unstableHTML,
      isDismissible,
      actions,
      type,
      icon,
      explicitDismiss,
      onDismiss
    }
  };
}

/**
 * Returns an action object used in signalling that a success notice is to be
 * created. Refer to `createNotice` for options documentation.
 *
 * @see createNotice
 *
 * @param {string} content   Notice message.
 * @param {Object} [options] Optional notice options.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createSuccessNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () =>
 *                 createSuccessNotice( __( 'Success!' ), {
 *                     type: 'snackbar',
 *                     icon: '🔥',
 *                 } )
 *             }
 *         >
 *             { __( 'Generate a snackbar success notice!' ) }
 *        </Button>
 *     );
 * };
 * ```
 *
 * @return {Object} Action object.
 */
function createSuccessNotice(content, options) {
  return createNotice('success', content, options);
}

/**
 * Returns an action object used in signalling that an info notice is to be
 * created. Refer to `createNotice` for options documentation.
 *
 * @see createNotice
 *
 * @param {string} content   Notice message.
 * @param {Object} [options] Optional notice options.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createInfoNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () =>
 *                createInfoNotice( __( 'Something happened!' ), {
 *                   isDismissible: false,
 *                } )
 *             }
 *         >
 *         { __( 'Generate a notice that cannot be dismissed.' ) }
 *       </Button>
 *       );
 * };
 *```
 *
 * @return {Object} Action object.
 */
function createInfoNotice(content, options) {
  return createNotice('info', content, options);
}

/**
 * Returns an action object used in signalling that an error notice is to be
 * created. Refer to `createNotice` for options documentation.
 *
 * @see createNotice
 *
 * @param {string} content   Notice message.
 * @param {Object} [options] Optional notice options.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createErrorNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () =>
 *                 createErrorNotice( __( 'An error occurred!' ), {
 *                     type: 'snackbar',
 *                     explicitDismiss: true,
 *                 } )
 *             }
 *         >
 *             { __(
 *                 'Generate an snackbar error notice with explicit dismiss button.'
 *             ) }
 *         </Button>
 *     );
 * };
 * ```
 *
 * @return {Object} Action object.
 */
function createErrorNotice(content, options) {
  return createNotice('error', content, options);
}

/**
 * Returns an action object used in signalling that a warning notice is to be
 * created. Refer to `createNotice` for options documentation.
 *
 * @see createNotice
 *
 * @param {string} content   Notice message.
 * @param {Object} [options] Optional notice options.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createWarningNotice, createInfoNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () =>
 *                 createWarningNotice( __( 'Warning!' ), {
 *                     onDismiss: () => {
 *                         createInfoNotice(
 *                             __( 'The warning has been dismissed!' )
 *                         );
 *                     },
 *                 } )
 *             }
 *         >
 *             { __( 'Generates a warning notice with onDismiss callback' ) }
 *         </Button>
 *     );
 * };
 * ```
 *
 * @return {Object} Action object.
 */
function createWarningNotice(content, options) {
  return createNotice('warning', content, options);
}

/**
 * Returns an action object used in signalling that a notice is to be removed.
 *
 * @param {string} id                 Notice unique identifier.
 * @param {string} [context='global'] Optional context (grouping) in which the notice is
 *                                    intended to appear. Defaults to default context.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *    const notices = useSelect( ( select ) => select( noticesStore ).getNotices() );
 *    const { createWarningNotice, removeNotice } = useDispatch( noticesStore );
 *
 *    return (
 *         <>
 *             <Button
 *                 onClick={ () =>
 *                     createWarningNotice( __( 'Warning!' ), {
 *                         isDismissible: false,
 *                     } )
 *                 }
 *             >
 *                 { __( 'Generate a notice' ) }
 *             </Button>
 *             { notices.length > 0 && (
 *                 <Button onClick={ () => removeNotice( notices[ 0 ].id ) }>
 *                     { __( 'Remove the notice' ) }
 *                 </Button>
 *             ) }
 *         </>
 *     );
 *};
 * ```
 *
 * @return {Object} Action object.
 */
function removeNotice(id, context = DEFAULT_CONTEXT) {
  return {
    type: 'REMOVE_NOTICE',
    id,
    context
  };
}

/**
 * Removes all notices from a given context. Defaults to the default context.
 *
 * @param {string} noticeType The context to remove all notices from.
 * @param {string} context    The context to remove all notices from.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch, useSelect } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * export const ExampleComponent = () => {
 * 	const notices = useSelect( ( select ) =>
 * 		select( noticesStore ).getNotices()
 * 	);
 * 	const { removeAllNotices } = useDispatch( noticesStore );
 * 	return (
 * 		<>
 * 			<ul>
 * 				{ notices.map( ( notice ) => (
 * 					<li key={ notice.id }>{ notice.content }</li>
 * 				) ) }
 * 			</ul>
 * 			<Button
 * 				onClick={ () =>
 * 					removeAllNotices()
 * 				}
 * 			>
 * 				{ __( 'Clear all notices', 'woo-gutenberg-products-block' ) }
 * 			</Button>
 * 			<Button
 * 				onClick={ () =>
 * 					removeAllNotices( 'snackbar' )
 * 				}
 * 			>
 * 				{ __( 'Clear all snackbar notices', 'woo-gutenberg-products-block' ) }
 * 			</Button>
 * 		</>
 * 	);
 * };
 * ```
 *
 * @return {Object} 	   Action object.
 */
function removeAllNotices(noticeType = 'default', context = DEFAULT_CONTEXT) {
  return {
    type: 'REMOVE_ALL_NOTICES',
    noticeType,
    context
  };
}

/**
 * Returns an action object used in signalling that several notices are to be removed.
 *
 * @param {string[]} ids                List of unique notice identifiers.
 * @param {string}   [context='global'] Optional context (grouping) in which the notices are
 *                                      intended to appear. Defaults to default context.
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch, useSelect } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 * 	const notices = useSelect( ( select ) =>
 * 		select( noticesStore ).getNotices()
 * 	);
 * 	const { removeNotices } = useDispatch( noticesStore );
 * 	return (
 * 		<>
 * 			<ul>
 * 				{ notices.map( ( notice ) => (
 * 					<li key={ notice.id }>{ notice.content }</li>
 * 				) ) }
 * 			</ul>
 * 			<Button
 * 				onClick={ () =>
 * 					removeNotices( notices.map( ( { id } ) => id ) )
 * 				}
 * 			>
 * 				{ __( 'Clear all notices' ) }
 * 			</Button>
 * 		</>
 * 	);
 * };
 * ```
 * @return {Object} Action object.
 */
function removeNotices(ids, context = DEFAULT_CONTEXT) {
  return {
    type: 'REMOVE_NOTICES',
    ids,
    context
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@5.0.2_react@18.3.1/node_modules/@wordpress/notices/build-module/store/selectors.js
/**
 * Internal dependencies
 */


/** @typedef {import('./actions').WPNoticeAction} WPNoticeAction */

/**
 * The default empty set of notices to return when there are no notices
 * assigned for a given notices context. This can occur if the getNotices
 * selector is called without a notice ever having been created for the
 * context. A shared value is used to ensure referential equality between
 * sequential selector calls, since otherwise `[] !== []`.
 *
 * @type {Array}
 */
const DEFAULT_NOTICES = [];

/**
 * @typedef {Object} WPNotice Notice object.
 *
 * @property {string}           id             Unique identifier of notice.
 * @property {string}           status         Status of notice, one of `success`,
 *                                             `info`, `error`, or `warning`. Defaults
 *                                             to `info`.
 * @property {string}           content        Notice message.
 * @property {string}           spokenMessage  Audibly announced message text used by
 *                                             assistive technologies.
 * @property {string}           __unstableHTML Notice message as raw HTML. Intended to
 *                                             serve primarily for compatibility of
 *                                             server-rendered notices, and SHOULD NOT
 *                                             be used for notices. It is subject to
 *                                             removal without notice.
 * @property {boolean}          isDismissible  Whether the notice can be dismissed by
 *                                             user. Defaults to `true`.
 * @property {string}           type           Type of notice, one of `default`,
 *                                             or `snackbar`. Defaults to `default`.
 * @property {boolean}          speak          Whether the notice content should be
 *                                             announced to screen readers. Defaults to
 *                                             `true`.
 * @property {WPNoticeAction[]} actions        User actions to present with notice.
 */

/**
 * Returns all notices as an array, optionally for a given context. Defaults to
 * the global context.
 *
 * @param {Object}  state   Notices state.
 * @param {?string} context Optional grouping context.
 *
 * @example
 *
 *```js
 * import { useSelect } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 *
 * const ExampleComponent = () => {
 *     const notices = useSelect( ( select ) => select( noticesStore ).getNotices() );
 *     return (
 *         <ul>
 *         { notices.map( ( notice ) => (
 *             <li key={ notice.ID }>{ notice.content }</li>
 *         ) ) }
 *        </ul>
 *    )
 * };
 *```
 *
 * @return {WPNotice[]} Array of notices.
 */
function getNotices(state, context = DEFAULT_CONTEXT) {
  return state[context] || DEFAULT_NOTICES;
}
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@5.0.2_react@18.3.1/node_modules/@wordpress/notices/build-module/store/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




/**
 * Store definition for the notices namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 */
const store = (0,redux_store/* default */.A)('core/notices', {
  reducer: store_reducer,
  actions: actions_namespaceObject,
  selectors: store_selectors_namespaceObject
});
(0,data_build_module/* register */.kz)(store);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@5.0.2_react@18.3.1/node_modules/@wordpress/notices/build-module/index.js

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/utils/selection.js
/**
 * WordPress dependencies
 */


/**
 * A robust way to retain selection position through various
 * transforms is to insert a special character at the position and
 * then recover it.
 */
const START_OF_SELECTED_AREA = '\u0086';

/**
 * Retrieve the block attribute that contains the selection position.
 *
 * @param {Object} blockAttributes Block attributes.
 * @return {string|void} The name of the block attribute that was previously selected.
 */
function retrieveSelectedAttribute(blockAttributes) {
  if (!blockAttributes) {
    return;
  }
  return Object.keys(blockAttributes).find(name => {
    const value = blockAttributes[name];
    return (typeof value === 'string' || value instanceof rich_text_build_module/* RichTextData */.EF) &&
    // To do: refactor this to use rich text's selection instead, so we
    // no longer have to use on this hack inserting a special character.
    value.toString().indexOf(START_OF_SELECTED_AREA) !== -1;
  });
}
function findRichTextAttributeKey(blockType) {
  for (const [key, value] of Object.entries(blockType.attributes)) {
    if (value.source === 'rich-text' || value.source === 'html') {
      return key;
    }
  }
}
//# sourceMappingURL=selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/actions.js
/* eslint no-console: [ 'error', { allow: [ 'error', 'warn' ] } ] */
/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */





/** @typedef {import('../components/use-on-block-drop/types').WPDropOperation} WPDropOperation */

const actions_castArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];

/**
 * Action that resets blocks state to the specified array of blocks, taking precedence
 * over any other content reflected as an edit in state.
 *
 * @param {Array} blocks Array of blocks.
 */
const resetBlocks = blocks => ({
  dispatch
}) => {
  dispatch({
    type: 'RESET_BLOCKS',
    blocks
  });
  dispatch(validateBlocksToTemplate(blocks));
};

/**
 * Block validity is a function of blocks state (at the point of a
 * reset) and the template setting. As a compromise to its placement
 * across distinct parts of state, it is implemented here as a side
 * effect of the block reset action.
 *
 * @param {Array} blocks Array of blocks.
 */
const validateBlocksToTemplate = blocks => ({
  select,
  dispatch
}) => {
  const template = select.getTemplate();
  const templateLock = select.getTemplateLock();

  // Unlocked templates are considered always valid because they act
  // as default values only.
  const isBlocksValidToTemplate = !template || templateLock !== 'all' || (0,build_module/* doBlocksMatchTemplate */.V6)(blocks, template);

  // Update if validity has changed.
  const isValidTemplate = select.isValidTemplate();
  if (isBlocksValidToTemplate !== isValidTemplate) {
    dispatch.setTemplateValidity(isBlocksValidToTemplate);
    return isBlocksValidToTemplate;
  }
};

/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */

/**
 * A selection object.
 *
 * @typedef {Object} WPSelection
 *
 * @property {WPBlockSelection} start The selection start.
 * @property {WPBlockSelection} end   The selection end.
 */

/* eslint-disable jsdoc/valid-types */
/**
 * Returns an action object used in signalling that selection state should be
 * reset to the specified selection.
 *
 * @param {WPBlockSelection} selectionStart  The selection start.
 * @param {WPBlockSelection} selectionEnd    The selection end.
 * @param {0|-1|null}        initialPosition Initial block position.
 *
 * @return {Object} Action object.
 */
function resetSelection(selectionStart, selectionEnd, initialPosition) {
  /* eslint-enable jsdoc/valid-types */
  return {
    type: 'RESET_SELECTION',
    selectionStart,
    selectionEnd,
    initialPosition
  };
}

/**
 * Returns an action object used in signalling that blocks have been received.
 * Unlike resetBlocks, these should be appended to the existing known set, not
 * replacing.
 *
 * @deprecated
 *
 * @param {Object[]} blocks Array of block objects.
 *
 * @return {Object} Action object.
 */
function receiveBlocks(blocks) {
  (0,deprecated_build_module/* default */.A)('wp.data.dispatch( "core/block-editor" ).receiveBlocks', {
    since: '5.9',
    alternative: 'resetBlocks or insertBlocks'
  });
  return {
    type: 'RECEIVE_BLOCKS',
    blocks
  };
}

/**
 * Action that updates attributes of multiple blocks with the specified client IDs.
 *
 * @param {string|string[]} clientIds     Block client IDs.
 * @param {Object}          attributes    Block attributes to be merged. Should be keyed by clientIds if
 *                                        uniqueByBlock is true.
 * @param {boolean}         uniqueByBlock true if each block in clientIds array has a unique set of attributes
 * @return {Object} Action object.
 */
function updateBlockAttributes(clientIds, attributes, uniqueByBlock = false) {
  return {
    type: 'UPDATE_BLOCK_ATTRIBUTES',
    clientIds: actions_castArray(clientIds),
    attributes,
    uniqueByBlock
  };
}

/**
 * Action that updates the block with the specified client ID.
 *
 * @param {string} clientId Block client ID.
 * @param {Object} updates  Block attributes to be merged.
 *
 * @return {Object} Action object.
 */
function updateBlock(clientId, updates) {
  return {
    type: 'UPDATE_BLOCK',
    clientId,
    updates
  };
}

/* eslint-disable jsdoc/valid-types */
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been selected, optionally accepting a position
 * value reflecting its selection directionality. An initialPosition of -1
 * reflects a reverse selection.
 *
 * @param {string}    clientId        Block client ID.
 * @param {0|-1|null} initialPosition Optional initial position. Pass as -1 to
 *                                    reflect reverse selection.
 *
 * @return {Object} Action object.
 */
function selectBlock(clientId, initialPosition = 0) {
  /* eslint-enable jsdoc/valid-types */
  return {
    type: 'SELECT_BLOCK',
    initialPosition,
    clientId
  };
}

/**
 * Yields action objects used in signalling that the block preceding the given
 * clientId (or optionally, its first parent from bottom to top)
 * should be selected.
 *
 * @param {string}  clientId         Block client ID.
 * @param {boolean} fallbackToParent If true, select the first parent if there is no previous block.
 */
const selectPreviousBlock = (clientId, fallbackToParent = false) => ({
  select,
  dispatch
}) => {
  const previousBlockClientId = select.getPreviousBlockClientId(clientId);
  if (previousBlockClientId) {
    dispatch.selectBlock(previousBlockClientId, -1);
  } else if (fallbackToParent) {
    const firstParentClientId = select.getBlockRootClientId(clientId);
    if (firstParentClientId) {
      dispatch.selectBlock(firstParentClientId, -1);
    }
  }
};

/**
 * Yields action objects used in signalling that the block following the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */
const selectNextBlock = clientId => ({
  select,
  dispatch
}) => {
  const nextBlockClientId = select.getNextBlockClientId(clientId);
  if (nextBlockClientId) {
    dispatch.selectBlock(nextBlockClientId);
  }
};

/**
 * Action that starts block multi-selection.
 *
 * @return {Object} Action object.
 */
function startMultiSelect() {
  return {
    type: 'START_MULTI_SELECT'
  };
}

/**
 * Action that stops block multi-selection.
 *
 * @return {Object} Action object.
 */
function stopMultiSelect() {
  return {
    type: 'STOP_MULTI_SELECT'
  };
}

/**
 * Action that changes block multi-selection.
 *
 * @param {string}      start                         First block of the multi selection.
 * @param {string}      end                           Last block of the multiselection.
 * @param {number|null} __experimentalInitialPosition Optional initial position. Pass as null to skip focus within editor canvas.
 */
const multiSelect = (start, end, __experimentalInitialPosition = 0) => ({
  select,
  dispatch
}) => {
  const startBlockRootClientId = select.getBlockRootClientId(start);
  const endBlockRootClientId = select.getBlockRootClientId(end);

  // Only allow block multi-selections at the same level.
  if (startBlockRootClientId !== endBlockRootClientId) {
    return;
  }
  dispatch({
    type: 'MULTI_SELECT',
    start,
    end,
    initialPosition: __experimentalInitialPosition
  });
  const blockCount = select.getSelectedBlockCount();
  (0,a11y_build_module/* speak */.L)((0,i18n_build_module/* sprintf */.nv)( /* translators: %s: number of selected blocks */
  (0,i18n_build_module._n)('%s block selected.', '%s blocks selected.', blockCount), blockCount), 'assertive');
};

/**
 * Action that clears the block selection.
 *
 * @return {Object} Action object.
 */
function clearSelectedBlock() {
  return {
    type: 'CLEAR_SELECTED_BLOCK'
  };
}

/**
 * Action that enables or disables block selection.
 *
 * @param {boolean} [isSelectionEnabled=true] Whether block selection should
 *                                            be enabled.
 *
 * @return {Object} Action object.
 */
function toggleSelection(isSelectionEnabled = true) {
  return {
    type: 'TOGGLE_SELECTION',
    isSelectionEnabled
  };
}

/* eslint-disable jsdoc/valid-types */
/**
 * Action that replaces given blocks with one or more replacement blocks.
 *
 * @param {(string|string[])} clientIds       Block client ID(s) to replace.
 * @param {(Object|Object[])} blocks          Replacement block(s).
 * @param {number}            indexToSelect   Index of replacement block to select.
 * @param {0|-1|null}         initialPosition Index of caret after in the selected block after the operation.
 * @param {?Object}           meta            Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */
const replaceBlocks = (clientIds, blocks, indexToSelect, initialPosition = 0, meta) => ({
  select,
  dispatch,
  registry
}) => {
  /* eslint-enable jsdoc/valid-types */
  clientIds = actions_castArray(clientIds);
  blocks = actions_castArray(blocks);
  const rootClientId = select.getBlockRootClientId(clientIds[0]);
  // Replace is valid if the new blocks can be inserted in the root block.
  for (let index = 0; index < blocks.length; index++) {
    const block = blocks[index];
    const canInsertBlock = select.canInsertBlockType(block.name, rootClientId);
    if (!canInsertBlock) {
      return;
    }
  }
  // We're batching these two actions because an extra `undo/redo` step can
  // be created, based on whether we insert a default block or not.
  registry.batch(() => {
    dispatch({
      type: 'REPLACE_BLOCKS',
      clientIds,
      blocks,
      time: Date.now(),
      indexToSelect,
      initialPosition,
      meta
    });
    // To avoid a focus loss when removing the last block, assure there is
    // always a default block if the last of the blocks have been removed.
    dispatch.ensureDefaultBlock();
  });
};

/**
 * Action that replaces a single block with one or more replacement blocks.
 *
 * @param {(string|string[])} clientId Block client ID to replace.
 * @param {(Object|Object[])} block    Replacement block(s).
 *
 * @return {Object} Action object.
 */
function replaceBlock(clientId, block) {
  return replaceBlocks(clientId, block);
}

/**
 * Higher-order action creator which, given the action type to dispatch creates
 * an action creator for managing block movement.
 *
 * @param {string} type Action type to dispatch.
 *
 * @return {Function} Action creator.
 */
const createOnMove = type => (clientIds, rootClientId) => ({
  select,
  dispatch
}) => {
  // If one of the blocks is locked or the parent is locked, we cannot move any block.
  const canMoveBlocks = select.canMoveBlocks(clientIds);
  if (!canMoveBlocks) {
    return;
  }
  dispatch({
    type,
    clientIds: actions_castArray(clientIds),
    rootClientId
  });
};
const moveBlocksDown = createOnMove('MOVE_BLOCKS_DOWN');
const moveBlocksUp = createOnMove('MOVE_BLOCKS_UP');

/**
 * Action that moves given blocks to a new position.
 *
 * @param {?string} clientIds        The client IDs of the blocks.
 * @param {?string} fromRootClientId Root client ID source.
 * @param {?string} toRootClientId   Root client ID destination.
 * @param {number}  index            The index to move the blocks to.
 */
const moveBlocksToPosition = (clientIds, fromRootClientId = '', toRootClientId = '', index) => ({
  select,
  dispatch
}) => {
  const canMoveBlocks = select.canMoveBlocks(clientIds);

  // If one of the blocks is locked or the parent is locked, we cannot move any block.
  if (!canMoveBlocks) {
    return;
  }

  // If moving inside the same root block the move is always possible.
  if (fromRootClientId !== toRootClientId) {
    const canRemoveBlocks = select.canRemoveBlocks(clientIds);

    // If we're moving to another block, it means we're deleting blocks from
    // the original block, so we need to check if removing is possible.
    if (!canRemoveBlocks) {
      return;
    }
    const canInsertBlocks = select.canInsertBlocks(clientIds, toRootClientId);

    // If moving to other parent block, the move is possible if we can insert a block of the same type inside the new parent block.
    if (!canInsertBlocks) {
      return;
    }
  }
  dispatch({
    type: 'MOVE_BLOCKS_TO_POSITION',
    fromRootClientId,
    toRootClientId,
    clientIds,
    index
  });
};

/**
 * Action that moves given block to a new position.
 *
 * @param {?string} clientId         The client ID of the block.
 * @param {?string} fromRootClientId Root client ID source.
 * @param {?string} toRootClientId   Root client ID destination.
 * @param {number}  index            The index to move the block to.
 */
function moveBlockToPosition(clientId, fromRootClientId = '', toRootClientId = '', index) {
  return moveBlocksToPosition([clientId], fromRootClientId, toRootClientId, index);
}

/**
 * Action that inserts a single block, optionally at a specific index respective a root block list.
 *
 * Only allowed blocks are inserted. The action may fail silently for blocks that are not allowed or if
 * a templateLock is active on the block list.
 *
 * @param {Object}   block           Block object to insert.
 * @param {?number}  index           Index at which block should be inserted.
 * @param {?string}  rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean} updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to true.
 * @param {?Object}  meta            Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */
function insertBlock(block, index, rootClientId, updateSelection, meta) {
  return insertBlocks([block], index, rootClientId, updateSelection, 0, meta);
}

/* eslint-disable jsdoc/valid-types */
/**
 * Action that inserts an array of blocks, optionally at a specific index respective a root block list.
 *
 * Only allowed blocks are inserted. The action may fail silently for blocks that are not allowed or if
 * a templateLock is active on the block list.
 *
 * @param {Object[]}  blocks          Block objects to insert.
 * @param {?number}   index           Index at which block should be inserted.
 * @param {?string}   rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean}  updateSelection If true block selection will be updated.  If false, block selection will not change. Defaults to true.
 * @param {0|-1|null} initialPosition Initial focus position. Setting it to null prevent focusing the inserted block.
 * @param {?Object}   meta            Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */
const insertBlocks = (blocks, index, rootClientId, updateSelection = true, initialPosition = 0, meta) => ({
  select,
  dispatch
}) => {
  /* eslint-enable jsdoc/valid-types */
  if (initialPosition !== null && typeof initialPosition === 'object') {
    meta = initialPosition;
    initialPosition = 0;
    (0,deprecated_build_module/* default */.A)("meta argument in wp.data.dispatch('core/block-editor')", {
      since: '5.8',
      hint: 'The meta argument is now the 6th argument of the function'
    });
  }
  blocks = actions_castArray(blocks);
  const allowedBlocks = [];
  for (const block of blocks) {
    const isValid = select.canInsertBlockType(block.name, rootClientId);
    if (isValid) {
      allowedBlocks.push(block);
    }
  }
  if (allowedBlocks.length) {
    dispatch({
      type: 'INSERT_BLOCKS',
      blocks: allowedBlocks,
      index,
      rootClientId,
      time: Date.now(),
      updateSelection,
      initialPosition: updateSelection ? initialPosition : null,
      meta
    });
  }
};

/**
 * Action that shows the insertion point.
 *
 * @param    {?string}         rootClientId           Optional root client ID of block list on
 *                                                    which to insert.
 * @param    {?number}         index                  Index at which block should be inserted.
 * @param    {?Object}         __unstableOptions      Additional options.
 * @property {boolean}         __unstableWithInserter Whether or not to show an inserter button.
 * @property {WPDropOperation} operation              The operation to perform when applied,
 *                                                    either 'insert' or 'replace' for now.
 *
 * @return {Object} Action object.
 */
function showInsertionPoint(rootClientId, index, __unstableOptions = {}) {
  const {
    __unstableWithInserter,
    operation,
    nearestSide
  } = __unstableOptions;
  return {
    type: 'SHOW_INSERTION_POINT',
    rootClientId,
    index,
    __unstableWithInserter,
    operation,
    nearestSide
  };
}
/**
 * Action that hides the insertion point.
 */
const hideInsertionPoint = () => ({
  select,
  dispatch
}) => {
  if (!select.isBlockInsertionPointVisible()) {
    return;
  }
  dispatch({
    type: 'HIDE_INSERTION_POINT'
  });
};

/**
 * Action that resets the template validity.
 *
 * @param {boolean} isValid template validity flag.
 *
 * @return {Object} Action object.
 */
function setTemplateValidity(isValid) {
  return {
    type: 'SET_TEMPLATE_VALIDITY',
    isValid
  };
}

/**
 * Action that synchronizes the template with the list of blocks.
 *
 * @return {Object} Action object.
 */
const synchronizeTemplate = () => ({
  select,
  dispatch
}) => {
  dispatch({
    type: 'SYNCHRONIZE_TEMPLATE'
  });
  const blocks = select.getBlocks();
  const template = select.getTemplate();
  const updatedBlockList = (0,build_module/* synchronizeBlocksWithTemplate */.Nk)(blocks, template);
  dispatch.resetBlocks(updatedBlockList);
};

/**
 * Delete the current selection.
 *
 * @param {boolean} isForward
 */
const __unstableDeleteSelection = isForward => ({
  registry,
  select,
  dispatch
}) => {
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  if (selectionAnchor.clientId === selectionFocus.clientId) {
    return;
  }

  // It's not mergeable if there's no rich text selection.
  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') {
    return false;
  }
  const anchorRootClientId = select.getBlockRootClientId(selectionAnchor.clientId);
  const focusRootClientId = select.getBlockRootClientId(selectionFocus.clientId);

  // It's not mergeable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.
  if (anchorRootClientId !== focusRootClientId) {
    return;
  }
  const blockOrder = select.getBlockOrder(anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId);

  // Reassign selection start and end based on order.
  let selectionStart, selectionEnd;
  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }
  const targetSelection = isForward ? selectionEnd : selectionStart;
  const targetBlock = select.getBlock(targetSelection.clientId);
  const targetBlockType = (0,build_module/* getBlockType */.E7)(targetBlock.name);
  if (!targetBlockType.merge) {
    return;
  }
  const selectionA = selectionStart;
  const selectionB = selectionEnd;
  const blockA = select.getBlock(selectionA.clientId);
  const blockB = select.getBlock(selectionB.clientId);
  const htmlA = blockA.attributes[selectionA.attributeKey];
  const htmlB = blockB.attributes[selectionB.attributeKey];
  let valueA = (0,rich_text_build_module/* create */.vt)({
    html: htmlA
  });
  let valueB = (0,rich_text_build_module/* create */.vt)({
    html: htmlB
  });
  valueA = (0,rich_text_build_module/* remove */.TF)(valueA, selectionA.offset, valueA.text.length);
  valueB = (0,rich_text_build_module/* insert */.Yr)(valueB, START_OF_SELECTED_AREA, 0, selectionB.offset);

  // Clone the blocks so we don't manipulate the original.
  const cloneA = (0,build_module/* cloneBlock */.JB)(blockA, {
    [selectionA.attributeKey]: (0,rich_text_build_module/* toHTMLString */.Ky)({
      value: valueA
    })
  });
  const cloneB = (0,build_module/* cloneBlock */.JB)(blockB, {
    [selectionB.attributeKey]: (0,rich_text_build_module/* toHTMLString */.Ky)({
      value: valueB
    })
  });
  const followingBlock = isForward ? cloneA : cloneB;

  // We can only merge blocks with similar types
  // thus, we transform the block to merge first
  const blocksWithTheSameType = blockA.name === blockB.name ? [followingBlock] : (0,build_module/* switchToBlockType */.bh)(followingBlock, targetBlockType.name);

  // If the block types can not match, do nothing
  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  }
  let updatedAttributes;
  if (isForward) {
    const blockToMerge = blocksWithTheSameType.pop();
    updatedAttributes = targetBlockType.merge(blockToMerge.attributes, cloneB.attributes);
  } else {
    const blockToMerge = blocksWithTheSameType.shift();
    updatedAttributes = targetBlockType.merge(cloneA.attributes, blockToMerge.attributes);
  }
  const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
  const convertedHtml = updatedAttributes[newAttributeKey];
  const convertedValue = (0,rich_text_build_module/* create */.vt)({
    html: convertedHtml
  });
  const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
  const newValue = (0,rich_text_build_module/* remove */.TF)(convertedValue, newOffset, newOffset + 1);
  const newHtml = (0,rich_text_build_module/* toHTMLString */.Ky)({
    value: newValue
  });
  updatedAttributes[newAttributeKey] = newHtml;
  const selectedBlockClientIds = select.getSelectedBlockClientIds();
  const replacement = [...(isForward ? blocksWithTheSameType : []), {
    // Preserve the original client ID.
    ...targetBlock,
    attributes: {
      ...targetBlock.attributes,
      ...updatedAttributes
    }
  }, ...(isForward ? [] : blocksWithTheSameType)];
  registry.batch(() => {
    dispatch.selectionChange(targetBlock.clientId, newAttributeKey, newOffset, newOffset);
    dispatch.replaceBlocks(selectedBlockClientIds, replacement, 0,
    // If we don't pass the `indexToSelect` it will default to the last block.
    select.getSelectedBlocksInitialCaretPosition());
  });
};

/**
 * Split the current selection.
 * @param {?Array} blocks
 */
const __unstableSplitSelection = (blocks = []) => ({
  registry,
  select,
  dispatch
}) => {
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  const anchorRootClientId = select.getBlockRootClientId(selectionAnchor.clientId);
  const focusRootClientId = select.getBlockRootClientId(selectionFocus.clientId);

  // It's not splittable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.
  if (anchorRootClientId !== focusRootClientId) {
    return;
  }
  const blockOrder = select.getBlockOrder(anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId);

  // Reassign selection start and end based on order.
  let selectionStart, selectionEnd;
  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }
  const selectionA = selectionStart;
  const selectionB = selectionEnd;
  const blockA = select.getBlock(selectionA.clientId);
  const blockB = select.getBlock(selectionB.clientId);
  const blockAType = (0,build_module/* getBlockType */.E7)(blockA.name);
  const blockBType = (0,build_module/* getBlockType */.E7)(blockB.name);
  const attributeKeyA = typeof selectionA.attributeKey === 'string' ? selectionA.attributeKey : findRichTextAttributeKey(blockAType);
  const attributeKeyB = typeof selectionB.attributeKey === 'string' ? selectionB.attributeKey : findRichTextAttributeKey(blockBType);
  const blockAttributes = select.getBlockAttributes(selectionA.clientId);
  const bindings = blockAttributes?.metadata?.bindings;

  // If the attribute is bound, don't split the selection and insert a new block instead.
  if (bindings?.[attributeKeyA]) {
    // Show warning if user tries to insert a block into another block with bindings.
    if (blocks.length) {
      const {
        createWarningNotice
      } = registry.dispatch(store);
      createWarningNotice((0,i18n_build_module.__)("Blocks can't be inserted into other blocks with bindings"), {
        type: 'snackbar'
      });
      return;
    }
    dispatch.insertAfterBlock(selectionA.clientId);
    return;
  }

  // Can't split if the selection is not set.
  if (!attributeKeyA || !attributeKeyB || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') {
    return;
  }

  // We can do some short-circuiting if the selection is collapsed.
  if (selectionA.clientId === selectionB.clientId && attributeKeyA === attributeKeyB && selectionA.offset === selectionB.offset) {
    // If an unmodified default block is selected, replace it. We don't
    // want to be converting into a default block.
    if (blocks.length) {
      if ((0,build_module/* isUnmodifiedDefaultBlock */.Xw)(blockA)) {
        dispatch.replaceBlocks([selectionA.clientId], blocks, blocks.length - 1, -1);
        return;
      }
    }

    // If selection is at the start or end, we can simply insert an
    // empty block, provided this block has no inner blocks.
    else if (!select.getBlockOrder(selectionA.clientId).length) {
      function createEmpty() {
        const defaultBlockName = (0,build_module/* getDefaultBlockName */.K$)();
        return select.canInsertBlockType(defaultBlockName, anchorRootClientId) ? (0,build_module/* createBlock */.Wv)(defaultBlockName) : (0,build_module/* createBlock */.Wv)(select.getBlockName(selectionA.clientId));
      }
      const length = blockAttributes[attributeKeyA].length;
      if (selectionA.offset === 0 && length) {
        dispatch.insertBlocks([createEmpty()], select.getBlockIndex(selectionA.clientId), anchorRootClientId, false);
        return;
      }
      if (selectionA.offset === length) {
        dispatch.insertBlocks([createEmpty()], select.getBlockIndex(selectionA.clientId) + 1, anchorRootClientId);
        return;
      }
    }
  }
  const htmlA = blockA.attributes[attributeKeyA];
  const htmlB = blockB.attributes[attributeKeyB];
  let valueA = (0,rich_text_build_module/* create */.vt)({
    html: htmlA
  });
  let valueB = (0,rich_text_build_module/* create */.vt)({
    html: htmlB
  });
  valueA = (0,rich_text_build_module/* remove */.TF)(valueA, selectionA.offset, valueA.text.length);
  valueB = (0,rich_text_build_module/* remove */.TF)(valueB, 0, selectionB.offset);
  let head = {
    // Preserve the original client ID.
    ...blockA,
    // If both start and end are the same, should only copy innerBlocks
    // once.
    innerBlocks: blockA.clientId === blockB.clientId ? [] : blockA.innerBlocks,
    attributes: {
      ...blockA.attributes,
      [attributeKeyA]: (0,rich_text_build_module/* toHTMLString */.Ky)({
        value: valueA
      })
    }
  };
  let tail = {
    ...blockB,
    // Only preserve the original client ID if the end is different.
    clientId: blockA.clientId === blockB.clientId ? (0,build_module/* createBlock */.Wv)(blockB.name).clientId : blockB.clientId,
    attributes: {
      ...blockB.attributes,
      [attributeKeyB]: (0,rich_text_build_module/* toHTMLString */.Ky)({
        value: valueB
      })
    }
  };

  // When splitting a block, attempt to convert the tail block to the
  // default block type. For example, when splitting a heading block, the
  // tail block will be converted to a paragraph block. Note that for
  // blocks such as a list item and button, this will be skipped because
  // the default block type cannot be inserted.
  const defaultBlockName = (0,build_module/* getDefaultBlockName */.K$)();
  if (
  // A block is only split when the selection is within the same
  // block.
  blockA.clientId === blockB.clientId && defaultBlockName && tail.name !== defaultBlockName && select.canInsertBlockType(defaultBlockName, anchorRootClientId)) {
    const switched = (0,build_module/* switchToBlockType */.bh)(tail, defaultBlockName);
    if (switched?.length === 1) {
      tail = switched[0];
    }
  }
  if (!blocks.length) {
    dispatch.replaceBlocks(select.getSelectedBlockClientIds(), [head, tail]);
    return;
  }
  let selection;
  const output = [];
  const clonedBlocks = [...blocks];
  const firstBlock = clonedBlocks.shift();
  const headType = (0,build_module/* getBlockType */.E7)(head.name);
  const firstBlocks = headType.merge && firstBlock.name === headType.name ? [firstBlock] : (0,build_module/* switchToBlockType */.bh)(firstBlock, headType.name);
  if (firstBlocks?.length) {
    const first = firstBlocks.shift();
    head = {
      ...head,
      attributes: {
        ...head.attributes,
        ...headType.merge(head.attributes, first.attributes)
      }
    };
    output.push(head);
    selection = {
      clientId: head.clientId,
      attributeKey: attributeKeyA,
      offset: (0,rich_text_build_module/* create */.vt)({
        html: head.attributes[attributeKeyA]
      }).text.length
    };
    clonedBlocks.unshift(...firstBlocks);
  } else {
    if (!(0,build_module/* isUnmodifiedBlock */.C5)(head)) {
      output.push(head);
    }
    output.push(firstBlock);
  }
  const lastBlock = clonedBlocks.pop();
  const tailType = (0,build_module/* getBlockType */.E7)(tail.name);
  if (clonedBlocks.length) {
    output.push(...clonedBlocks);
  }
  if (lastBlock) {
    const lastBlocks = tailType.merge && tailType.name === lastBlock.name ? [lastBlock] : (0,build_module/* switchToBlockType */.bh)(lastBlock, tailType.name);
    if (lastBlocks?.length) {
      const last = lastBlocks.pop();
      output.push({
        ...tail,
        attributes: {
          ...tail.attributes,
          ...tailType.merge(last.attributes, tail.attributes)
        }
      });
      output.push(...lastBlocks);
      selection = {
        clientId: tail.clientId,
        attributeKey: attributeKeyB,
        offset: (0,rich_text_build_module/* create */.vt)({
          html: last.attributes[attributeKeyB]
        }).text.length
      };
    } else {
      output.push(lastBlock);
      if (!(0,build_module/* isUnmodifiedBlock */.C5)(tail)) {
        output.push(tail);
      }
    }
  } else if (!(0,build_module/* isUnmodifiedBlock */.C5)(tail)) {
    output.push(tail);
  }
  registry.batch(() => {
    dispatch.replaceBlocks(select.getSelectedBlockClientIds(), output, output.length - 1, 0);
    if (selection) {
      dispatch.selectionChange(selection.clientId, selection.attributeKey, selection.offset, selection.offset);
    }
  });
};

/**
 * Expand the selection to cover the entire blocks, removing partial selection.
 */
const __unstableExpandSelection = () => ({
  select,
  dispatch
}) => {
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  dispatch.selectionChange({
    start: {
      clientId: selectionAnchor.clientId
    },
    end: {
      clientId: selectionFocus.clientId
    }
  });
};

/**
 * Action that merges two blocks.
 *
 * @param {string} firstBlockClientId  Client ID of the first block to merge.
 * @param {string} secondBlockClientId Client ID of the second block to merge.
 */
const mergeBlocks = (firstBlockClientId, secondBlockClientId) => ({
  registry,
  select,
  dispatch
}) => {
  const clientIdA = firstBlockClientId;
  const clientIdB = secondBlockClientId;
  const blockA = select.getBlock(clientIdA);
  const blockAType = (0,build_module/* getBlockType */.E7)(blockA.name);
  if (!blockAType) {
    return;
  }
  const blockB = select.getBlock(clientIdB);
  if (!blockAType.merge && (0,build_module/* getBlockSupport */.bI)(blockA.name, '__experimentalOnMerge')) {
    // If there's no merge function defined, attempt merging inner
    // blocks.
    const blocksWithTheSameType = (0,build_module/* switchToBlockType */.bh)(blockB, blockAType.name);
    // Only focus the previous block if it's not mergeable.
    if (blocksWithTheSameType?.length !== 1) {
      dispatch.selectBlock(blockA.clientId);
      return;
    }
    const [blockWithSameType] = blocksWithTheSameType;
    if (blockWithSameType.innerBlocks.length < 1) {
      dispatch.selectBlock(blockA.clientId);
      return;
    }
    registry.batch(() => {
      dispatch.insertBlocks(blockWithSameType.innerBlocks, undefined, clientIdA);
      dispatch.removeBlock(clientIdB);
      dispatch.selectBlock(blockWithSameType.innerBlocks[0].clientId);

      // Attempt to merge the next block if it's the same type and
      // same attributes. This is useful when merging a paragraph into
      // a list, and the next block is also a list. If we don't merge,
      // it looks like one list, but it's actually two lists. The same
      // applies to other blocks such as a group with the same
      // attributes.
      const nextBlockClientId = select.getNextBlockClientId(clientIdA);
      if (nextBlockClientId && select.getBlockName(clientIdA) === select.getBlockName(nextBlockClientId)) {
        const rootAttributes = select.getBlockAttributes(clientIdA);
        const previousRootAttributes = select.getBlockAttributes(nextBlockClientId);
        if (Object.keys(rootAttributes).every(key => rootAttributes[key] === previousRootAttributes[key])) {
          dispatch.moveBlocksToPosition(select.getBlockOrder(nextBlockClientId), nextBlockClientId, clientIdA);
          dispatch.removeBlock(nextBlockClientId, false);
        }
      }
    });
    return;
  }
  if ((0,build_module/* isUnmodifiedDefaultBlock */.Xw)(blockA)) {
    dispatch.removeBlock(clientIdA, select.isBlockSelected(clientIdA));
    return;
  }
  if ((0,build_module/* isUnmodifiedDefaultBlock */.Xw)(blockB)) {
    dispatch.removeBlock(clientIdB, select.isBlockSelected(clientIdB));
    return;
  }
  if (!blockAType.merge) {
    dispatch.selectBlock(blockA.clientId);
    return;
  }
  const blockBType = (0,build_module/* getBlockType */.E7)(blockB.name);
  const {
    clientId,
    attributeKey,
    offset
  } = select.getSelectionStart();
  const selectedBlockType = clientId === clientIdA ? blockAType : blockBType;
  const attributeDefinition = selectedBlockType.attributes[attributeKey];
  const canRestoreTextSelection = (clientId === clientIdA || clientId === clientIdB) && attributeKey !== undefined && offset !== undefined &&
  // We cannot restore text selection if the RichText identifier
  // is not a defined block attribute key. This can be the case if the
  // fallback intance ID is used to store selection (and no RichText
  // identifier is set), or when the identifier is wrong.
  !!attributeDefinition;
  if (!attributeDefinition) {
    if (typeof attributeKey === 'number') {
      window.console.error(`RichText needs an identifier prop that is the block attribute key of the attribute it controls. Its type is expected to be a string, but was ${typeof attributeKey}`);
    } else {
      window.console.error('The RichText identifier prop does not match any attributes defined by the block.');
    }
  }

  // Clone the blocks so we don't insert the character in a "live" block.
  const cloneA = (0,build_module/* cloneBlock */.JB)(blockA);
  const cloneB = (0,build_module/* cloneBlock */.JB)(blockB);
  if (canRestoreTextSelection) {
    const selectedBlock = clientId === clientIdA ? cloneA : cloneB;
    const html = selectedBlock.attributes[attributeKey];
    const value = (0,rich_text_build_module/* insert */.Yr)((0,rich_text_build_module/* create */.vt)({
      html
    }), START_OF_SELECTED_AREA, offset, offset);
    selectedBlock.attributes[attributeKey] = (0,rich_text_build_module/* toHTMLString */.Ky)({
      value
    });
  }

  // We can only merge blocks with similar types
  // thus, we transform the block to merge first.
  const blocksWithTheSameType = blockA.name === blockB.name ? [cloneB] : (0,build_module/* switchToBlockType */.bh)(cloneB, blockA.name);

  // If the block types can not match, do nothing.
  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  }

  // Calling the merge to update the attributes and remove the block to be merged.
  const updatedAttributes = blockAType.merge(cloneA.attributes, blocksWithTheSameType[0].attributes);
  if (canRestoreTextSelection) {
    const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
    const convertedHtml = updatedAttributes[newAttributeKey];
    const convertedValue = (0,rich_text_build_module/* create */.vt)({
      html: convertedHtml
    });
    const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
    const newValue = (0,rich_text_build_module/* remove */.TF)(convertedValue, newOffset, newOffset + 1);
    const newHtml = (0,rich_text_build_module/* toHTMLString */.Ky)({
      value: newValue
    });
    updatedAttributes[newAttributeKey] = newHtml;
    dispatch.selectionChange(blockA.clientId, newAttributeKey, newOffset, newOffset);
  }
  dispatch.replaceBlocks([blockA.clientId, blockB.clientId], [{
    ...blockA,
    attributes: {
      ...blockA.attributes,
      ...updatedAttributes
    }
  }, ...blocksWithTheSameType.slice(1)], 0 // If we don't pass the `indexToSelect` it will default to the last block.
  );
};

/**
 * Yields action objects used in signalling that the blocks corresponding to
 * the set of specified client IDs are to be removed.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block
 *                                         or the immediate parent
 *                                         (if no previous block exists)
 *                                         should be selected
 *                                         when a block is removed.
 */
const removeBlocks = (clientIds, selectPrevious = true) => privateRemoveBlocks(clientIds, selectPrevious);

/**
 * Returns an action object used in signalling that the block with the
 * specified client ID is to be removed.
 *
 * @param {string}  clientId       Client ID of block to remove.
 * @param {boolean} selectPrevious True if the previous block should be
 *                                 selected when a block is removed.
 *
 * @return {Object} Action object.
 */
function removeBlock(clientId, selectPrevious) {
  return removeBlocks([clientId], selectPrevious);
}

/* eslint-disable jsdoc/valid-types */
/**
 * Returns an action object used in signalling that the inner blocks with the
 * specified client ID should be replaced.
 *
 * @param {string}    rootClientId    Client ID of the block whose InnerBlocks will re replaced.
 * @param {Object[]}  blocks          Block objects to insert as new InnerBlocks
 * @param {?boolean}  updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to false.
 * @param {0|-1|null} initialPosition Initial block position.
 * @return {Object} Action object.
 */
function replaceInnerBlocks(rootClientId, blocks, updateSelection = false, initialPosition = 0) {
  /* eslint-enable jsdoc/valid-types */
  return {
    type: 'REPLACE_INNER_BLOCKS',
    rootClientId,
    blocks,
    updateSelection,
    initialPosition: updateSelection ? initialPosition : null,
    time: Date.now()
  };
}

/**
 * Returns an action object used to toggle the block editing mode between
 * visual and HTML modes.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Action object.
 */
function toggleBlockMode(clientId) {
  return {
    type: 'TOGGLE_BLOCK_MODE',
    clientId
  };
}

/**
 * Returns an action object used in signalling that the user has begun to type.
 *
 * @return {Object} Action object.
 */
function startTyping() {
  return {
    type: 'START_TYPING'
  };
}

/**
 * Returns an action object used in signalling that the user has stopped typing.
 *
 * @return {Object} Action object.
 */
function stopTyping() {
  return {
    type: 'STOP_TYPING'
  };
}

/**
 * Returns an action object used in signalling that the user has begun to drag blocks.
 *
 * @param {string[]} clientIds An array of client ids being dragged
 *
 * @return {Object} Action object.
 */
function startDraggingBlocks(clientIds = []) {
  return {
    type: 'START_DRAGGING_BLOCKS',
    clientIds
  };
}

/**
 * Returns an action object used in signalling that the user has stopped dragging blocks.
 *
 * @return {Object} Action object.
 */
function stopDraggingBlocks() {
  return {
    type: 'STOP_DRAGGING_BLOCKS'
  };
}

/**
 * Returns an action object used in signalling that the caret has entered formatted text.
 *
 * @deprecated
 *
 * @return {Object} Action object.
 */
function enterFormattedText() {
  (0,deprecated_build_module/* default */.A)('wp.data.dispatch( "core/block-editor" ).enterFormattedText', {
    since: '6.1',
    version: '6.3'
  });
  return {
    type: 'DO_NOTHING'
  };
}

/**
 * Returns an action object used in signalling that the user caret has exited formatted text.
 *
 * @deprecated
 *
 * @return {Object} Action object.
 */
function exitFormattedText() {
  (0,deprecated_build_module/* default */.A)('wp.data.dispatch( "core/block-editor" ).exitFormattedText', {
    since: '6.1',
    version: '6.3'
  });
  return {
    type: 'DO_NOTHING'
  };
}

/**
 * Action that changes the position of the user caret.
 *
 * @param {string|WPSelection} clientId     The selected block client ID.
 * @param {string}             attributeKey The selected block attribute key.
 * @param {number}             startOffset  The start offset.
 * @param {number}             endOffset    The end offset.
 *
 * @return {Object} Action object.
 */
function selectionChange(clientId, attributeKey, startOffset, endOffset) {
  if (typeof clientId === 'string') {
    return {
      type: 'SELECTION_CHANGE',
      clientId,
      attributeKey,
      startOffset,
      endOffset
    };
  }
  return {
    type: 'SELECTION_CHANGE',
    ...clientId
  };
}

/**
 * Action that adds a new block of the default type to the block list.
 *
 * @param {?Object} attributes   Optional attributes of the block to assign.
 * @param {?string} rootClientId Optional root client ID of block list on which
 *                               to append.
 * @param {?number} index        Optional index where to insert the default block.
 */
const insertDefaultBlock = (attributes, rootClientId, index) => ({
  dispatch
}) => {
  // Abort if there is no default block type (if it has been unregistered).
  const defaultBlockName = (0,build_module/* getDefaultBlockName */.K$)();
  if (!defaultBlockName) {
    return;
  }
  const block = (0,build_module/* createBlock */.Wv)(defaultBlockName, attributes);
  return dispatch.insertBlock(block, index, rootClientId);
};

/**
 * @typedef {Object< string, Object >} SettingsByClientId
 */

/**
 * Action that changes the nested settings of the given block(s).
 *
 * @param {string | SettingsByClientId} clientId Client ID of the block whose
 *                                               nested setting are being
 *                                               received, or object of settings
 *                                               by client ID.
 * @param {Object}                      settings Object with the new settings
 *                                               for the nested block.
 *
 * @return {Object} Action object
 */
function updateBlockListSettings(clientId, settings) {
  return {
    type: 'UPDATE_BLOCK_LIST_SETTINGS',
    clientId,
    settings
  };
}

/**
 * Action that updates the block editor settings.
 *
 * @param {Object} settings Updated settings
 *
 * @return {Object} Action object
 */
function updateSettings(settings) {
  return __experimentalUpdateSettings(settings, {
    stripExperimentalSettings: true
  });
}

/**
 * Action that signals that a temporary reusable block has been saved
 * in order to switch its temporary id with the real id.
 *
 * @param {string} id        Reusable block's id.
 * @param {string} updatedId Updated block's id.
 *
 * @return {Object} Action object.
 */
function __unstableSaveReusableBlock(id, updatedId) {
  return {
    type: 'SAVE_REUSABLE_BLOCK_SUCCESS',
    id,
    updatedId
  };
}

/**
 * Action that marks the last block change explicitly as persistent.
 *
 * @return {Object} Action object.
 */
function __unstableMarkLastChangeAsPersistent() {
  return {
    type: 'MARK_LAST_CHANGE_AS_PERSISTENT'
  };
}

/**
 * Action that signals that the next block change should be marked explicitly as not persistent.
 *
 * @return {Object} Action object.
 */
function __unstableMarkNextChangeAsNotPersistent() {
  return {
    type: 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT'
  };
}

/**
 * Action that marks the last block change as an automatic change, meaning it was not
 * performed by the user, and can be undone using the `Escape` and `Backspace` keys.
 * This action must be called after the change was made, and any actions that are a
 * consequence of it, so it is recommended to be called at the next idle period to ensure all
 * selection changes have been recorded.
 */
const __unstableMarkAutomaticChange = () => ({
  dispatch
}) => {
  dispatch({
    type: 'MARK_AUTOMATIC_CHANGE'
  });
  const {
    requestIdleCallback = cb => setTimeout(cb, 100)
  } = window;
  requestIdleCallback(() => {
    dispatch({
      type: 'MARK_AUTOMATIC_CHANGE_FINAL'
    });
  });
};

/**
 * Action that enables or disables the navigation mode.
 *
 * @param {boolean} isNavigationMode Enable/Disable navigation mode.
 */
const setNavigationMode = (isNavigationMode = true) => ({
  dispatch
}) => {
  dispatch.__unstableSetEditorMode(isNavigationMode ? 'navigation' : 'edit');
};

/**
 * Action that sets the editor mode
 *
 * @param {string} mode Editor mode
 */
const __unstableSetEditorMode = mode => ({
  dispatch,
  select,
  registry
}) => {
  // When switching to zoom-out mode, we need to select the parent section
  if (mode === 'zoom-out') {
    const firstSelectedClientId = select.getBlockSelectionStart();
    const {
      sectionRootClientId
    } = lock_unlock_unlock(registry.select(STORE_NAME).getSettings());
    if (firstSelectedClientId) {
      let sectionClientId;
      if (sectionRootClientId) {
        const sectionClientIds = select.getBlockOrder(sectionRootClientId);
        sectionClientId = select.getBlockParents(firstSelectedClientId).find(parent => sectionClientIds.includes(parent));
      } else {
        sectionClientId = select.getBlockHierarchyRootClientId(firstSelectedClientId);
      }
      if (sectionClientId) {
        dispatch.selectBlock(sectionClientId);
      } else {
        dispatch.clearSelectedBlock();
      }
    }
  }
  dispatch({
    type: 'SET_EDITOR_MODE',
    mode
  });
  if (mode === 'navigation') {
    (0,a11y_build_module/* speak */.L)((0,i18n_build_module.__)('You are currently in navigation mode. Navigate blocks using the Tab key and Arrow keys. Use Left and Right Arrow keys to move between nesting levels. To exit navigation mode and edit the selected block, press Enter.'));
  } else if (mode === 'edit') {
    (0,a11y_build_module/* speak */.L)((0,i18n_build_module.__)('You are currently in edit mode. To return to the navigation mode, press Escape.'));
  } else if (mode === 'zoom-out') {
    (0,a11y_build_module/* speak */.L)((0,i18n_build_module.__)('You are currently in zoom-out mode.'));
  }
};

/**
 * Action that enables or disables the block moving mode.
 *
 * @param {string|null} hasBlockMovingClientId Enable/Disable block moving mode.
 */
const setBlockMovingClientId = (hasBlockMovingClientId = null) => ({
  dispatch
}) => {
  dispatch({
    type: 'SET_BLOCK_MOVING_MODE',
    hasBlockMovingClientId
  });
  if (hasBlockMovingClientId) {
    (0,a11y_build_module/* speak */.L)((0,i18n_build_module.__)('Use the Tab key and Arrow keys to choose new block location. Use Left and Right Arrow keys to move between nesting levels. Once location is selected press Enter or Space to move the block.'));
  }
};

/**
 * Action that duplicates a list of blocks.
 *
 * @param {string[]} clientIds
 * @param {boolean}  updateSelection
 */
const duplicateBlocks = (clientIds, updateSelection = true) => ({
  select,
  dispatch
}) => {
  if (!clientIds || !clientIds.length) {
    return;
  }

  // Return early if blocks don't exist.
  const blocks = select.getBlocksByClientId(clientIds);
  if (blocks.some(block => !block)) {
    return;
  }

  // Return early if blocks don't support multiple usage.
  const blockNames = blocks.map(block => block.name);
  if (blockNames.some(blockName => !(0,build_module/* hasBlockSupport */.pN)(blockName, 'multiple', true))) {
    return;
  }
  const rootClientId = select.getBlockRootClientId(clientIds[0]);
  const clientIdsArray = actions_castArray(clientIds);
  const lastSelectedIndex = select.getBlockIndex(clientIdsArray[clientIdsArray.length - 1]);
  const clonedBlocks = blocks.map(block => (0,build_module/* __experimentalCloneSanitizedBlock */.Eb)(block));
  dispatch.insertBlocks(clonedBlocks, lastSelectedIndex + 1, rootClientId, updateSelection);
  if (clonedBlocks.length > 1 && updateSelection) {
    dispatch.multiSelect(clonedBlocks[0].clientId, clonedBlocks[clonedBlocks.length - 1].clientId);
  }
  return clonedBlocks.map(block => block.clientId);
};

/**
 * Action that inserts a default block before a given block.
 *
 * @param {string} clientId
 */
const insertBeforeBlock = clientId => ({
  select,
  dispatch
}) => {
  if (!clientId) {
    return;
  }
  const rootClientId = select.getBlockRootClientId(clientId);
  const isLocked = select.getTemplateLock(rootClientId);
  if (isLocked) {
    return;
  }
  const blockIndex = select.getBlockIndex(clientId);
  const directInsertBlock = rootClientId ? select.getDirectInsertBlock(rootClientId) : null;
  if (!directInsertBlock) {
    return dispatch.insertDefaultBlock({}, rootClientId, blockIndex);
  }
  const copiedAttributes = {};
  if (directInsertBlock.attributesToCopy) {
    const attributes = select.getBlockAttributes(clientId);
    directInsertBlock.attributesToCopy.forEach(key => {
      if (attributes[key]) {
        copiedAttributes[key] = attributes[key];
      }
    });
  }
  const block = (0,build_module/* createBlock */.Wv)(directInsertBlock.name, {
    ...directInsertBlock.attributes,
    ...copiedAttributes
  });
  return dispatch.insertBlock(block, blockIndex, rootClientId);
};

/**
 * Action that inserts a default block after a given block.
 *
 * @param {string} clientId
 */
const insertAfterBlock = clientId => ({
  select,
  dispatch
}) => {
  if (!clientId) {
    return;
  }
  const rootClientId = select.getBlockRootClientId(clientId);
  const isLocked = select.getTemplateLock(rootClientId);
  if (isLocked) {
    return;
  }
  const blockIndex = select.getBlockIndex(clientId);
  const directInsertBlock = rootClientId ? select.getDirectInsertBlock(rootClientId) : null;
  if (!directInsertBlock) {
    return dispatch.insertDefaultBlock({}, rootClientId, blockIndex + 1);
  }
  const copiedAttributes = {};
  if (directInsertBlock.attributesToCopy) {
    const attributes = select.getBlockAttributes(clientId);
    directInsertBlock.attributesToCopy.forEach(key => {
      if (attributes[key]) {
        copiedAttributes[key] = attributes[key];
      }
    });
  }
  const block = (0,build_module/* createBlock */.Wv)(directInsertBlock.name, {
    ...directInsertBlock.attributes,
    ...copiedAttributes
  });
  return dispatch.insertBlock(block, blockIndex + 1, rootClientId);
};

/**
 * Action that toggles the highlighted block state.
 *
 * @param {string}  clientId      The block's clientId.
 * @param {boolean} isHighlighted The highlight state.
 */
function toggleBlockHighlight(clientId, isHighlighted) {
  return {
    type: 'TOGGLE_BLOCK_HIGHLIGHT',
    clientId,
    isHighlighted
  };
}

/**
 * Action that "flashes" the block with a given `clientId` by rhythmically highlighting it.
 *
 * @param {string} clientId Target block client ID.
 */
const flashBlock = clientId => async ({
  dispatch
}) => {
  dispatch(toggleBlockHighlight(clientId, true));
  await new Promise(resolve => setTimeout(resolve, 150));
  dispatch(toggleBlockHighlight(clientId, false));
};

/**
 * Action that sets whether a block has controlled inner blocks.
 *
 * @param {string}  clientId                 The block's clientId.
 * @param {boolean} hasControlledInnerBlocks True if the block's inner blocks are controlled.
 */
function setHasControlledInnerBlocks(clientId, hasControlledInnerBlocks) {
  return {
    type: 'SET_HAS_CONTROLLED_INNER_BLOCKS',
    hasControlledInnerBlocks,
    clientId
  };
}

/**
 * Action that sets whether given blocks are visible on the canvas.
 *
 * @param {Record<string,boolean>} updates For each block's clientId, its new visibility setting.
 */
function setBlockVisibility(updates) {
  return {
    type: 'SET_BLOCK_VISIBILITY',
    updates
  };
}

/**
 * Action that sets whether a block is being temporarily edited as blocks.
 *
 * DO-NOT-USE in production.
 * This action is created for internal/experimental only usage and may be
 * removed anytime without any warning, causing breakage on any plugin or theme invoking it.
 *
 * @param {?string} temporarilyEditingAsBlocks The block's clientId being temporarily edited as blocks.
 * @param {?string} focusModeToRevert          The focus mode to revert after temporarily edit as blocks finishes.
 */
function __unstableSetTemporarilyEditingAsBlocks(temporarilyEditingAsBlocks, focusModeToRevert) {
  return {
    type: 'SET_TEMPORARILY_EDITING_AS_BLOCKS',
    temporarilyEditingAsBlocks,
    focusModeToRevert
  };
}

/**
 * Interface for inserter media requests.
 *
 * @typedef {Object} InserterMediaRequest
 * @property {number} per_page How many items to fetch per page.
 * @property {string} search   The search term to use for filtering the results.
 */

/**
 * Interface for inserter media responses. Any media resource should
 * map their response to this interface, in order to create the core
 * WordPress media blocks (image, video, audio).
 *
 * @typedef {Object} InserterMediaItem
 * @property {string}        title        The title of the media item.
 * @property {string}        url          The source url of the media item.
 * @property {string}        [previewUrl] The preview source url of the media item to display in the media list.
 * @property {number}        [id]         The WordPress id of the media item.
 * @property {number|string} [sourceId]   The id of the media item from external source.
 * @property {string}        [alt]        The alt text of the media item.
 * @property {string}        [caption]    The caption of the media item.
 */

/**
 * Registers a new inserter media category. Once registered, the media category is
 * available in the inserter's media tab.
 *
 * The following interfaces are used:
 *
 * _Type Definition_
 *
 * - _InserterMediaRequest_ `Object`: Interface for inserter media requests.
 *
 * _Properties_
 *
 * - _per_page_ `number`: How many items to fetch per page.
 * - _search_ `string`: The search term to use for filtering the results.
 *
 * _Type Definition_
 *
 * - _InserterMediaItem_ `Object`: Interface for inserter media responses. Any media resource should
 * map their response to this interface, in order to create the core
 * WordPress media blocks (image, video, audio).
 *
 * _Properties_
 *
 * - _title_ `string`: The title of the media item.
 * - _url_ `string: The source url of the media item.
 * - _previewUrl_ `[string]`: The preview source url of the media item to display in the media list.
 * - _id_ `[number]`: The WordPress id of the media item.
 * - _sourceId_ `[number|string]`: The id of the media item from external source.
 * - _alt_ `[string]`: The alt text of the media item.
 * - _caption_ `[string]`: The caption of the media item.
 *
 * @param    {InserterMediaCategory}                                  category                       The inserter media category to register.
 *
 * @example
 * ```js
 *
 * wp.data.dispatch('core/block-editor').registerInserterMediaCategory( {
 * 	 name: 'openverse',
 * 	 labels: {
 * 	 	name: 'Openverse',
 * 	 	search_items: 'Search Openverse',
 * 	 },
 * 	 mediaType: 'image',
 * 	 async fetch( query = {} ) {
 * 	 	const defaultArgs = {
 * 	 		mature: false,
 * 	 		excluded_source: 'flickr,inaturalist,wikimedia',
 * 	 		license: 'pdm,cc0',
 * 	 	};
 * 	 	const finalQuery = { ...query, ...defaultArgs };
 * 	 	// Sometimes you might need to map the supported request params according to `InserterMediaRequest`.
 * 	 	// interface. In this example the `search` query param is named `q`.
 * 	 	const mapFromInserterMediaRequest = {
 * 	 		per_page: 'page_size',
 * 	 		search: 'q',
 * 	 	};
 * 	 	const url = new URL( 'https://api.openverse.org/v1/images/' );
 * 	 	Object.entries( finalQuery ).forEach( ( [ key, value ] ) => {
 * 	 		const queryKey = mapFromInserterMediaRequest[ key ] || key;
 * 	 		url.searchParams.set( queryKey, value );
 * 	 	} );
 * 	 	const response = await window.fetch( url, {
 * 	 		headers: {
 * 	 			'User-Agent': 'WordPress/inserter-media-fetch',
 * 	 		},
 * 	 	} );
 * 	 	const jsonResponse = await response.json();
 * 	 	const results = jsonResponse.results;
 * 	 	return results.map( ( result ) => ( {
 * 	 		...result,
 * 	 		// If your response result includes an `id` prop that you want to access later, it should
 * 	 		// be mapped to `InserterMediaItem`'s `sourceId` prop. This can be useful if you provide
 * 	 		// a report URL getter.
 * 	 		// Additionally you should always clear the `id` value of your response results because
 * 	 		// it is used to identify WordPress media items.
 * 	 		sourceId: result.id,
 * 	 		id: undefined,
 * 	 		caption: result.caption,
 * 	 		previewUrl: result.thumbnail,
 * 	 	} ) );
 * 	 },
 * 	 getReportUrl: ( { sourceId } ) =>
 * 	 	`https://wordpress.org/openverse/image/${ sourceId }/report/`,
 * 	 isExternalResource: true,
 * } );
 * ```
 *
 * @typedef {Object} InserterMediaCategory Interface for inserter media category.
 * @property {string}                                                 name                           The name of the media category, that should be unique among all media categories.
 * @property {Object}                                                 labels                         Labels for the media category.
 * @property {string}                                                 labels.name                    General name of the media category. It's used in the inserter media items list.
 * @property {string}                                                 [labels.search_items='Search'] Label for searching items. Default is ‘Search Posts’ / ‘Search Pages’.
 * @property {('image'|'audio'|'video')}                              mediaType                      The media type of the media category.
 * @property {(InserterMediaRequest) => Promise<InserterMediaItem[]>} fetch                          The function to fetch media items for the category.
 * @property {(InserterMediaItem) => string}                          [getReportUrl]                 If the media category supports reporting media items, this function should return
 *                                                                                                   the report url for the media item. It accepts the `InserterMediaItem` as an argument.
 * @property {boolean}                                                [isExternalResource]           If the media category is an external resource, this should be set to true.
 *                                                                                                   This is used to avoid making a request to the external resource when the user
 */
const registerInserterMediaCategory = category => ({
  select,
  dispatch
}) => {
  if (!category || typeof category !== 'object') {
    console.error('Category should be an `InserterMediaCategory` object.');
    return;
  }
  if (!category.name) {
    console.error('Category should have a `name` that should be unique among all media categories.');
    return;
  }
  if (!category.labels?.name) {
    console.error('Category should have a `labels.name`.');
    return;
  }
  if (!['image', 'audio', 'video'].includes(category.mediaType)) {
    console.error('Category should have `mediaType` property that is one of `image|audio|video`.');
    return;
  }
  if (!category.fetch || typeof category.fetch !== 'function') {
    console.error('Category should have a `fetch` function defined with the following signature `(InserterMediaRequest) => Promise<InserterMediaItem[]>`.');
    return;
  }
  const registeredInserterMediaCategories = select.getRegisteredInserterMediaCategories();
  if (registeredInserterMediaCategories.some(({
    name
  }) => name === category.name)) {
    console.error(`A category is already registered with the same name: "${category.name}".`);
    return;
  }
  if (registeredInserterMediaCategories.some(({
    labels: {
      name
    } = {}
  }) => name === category.labels?.name)) {
    console.error(`A category is already registered with the same labels.name: "${category.labels.name}".`);
    return;
  }
  // `inserterMediaCategories` is a private block editor setting, which means it cannot
  // be updated through the public `updateSettings` action. We preserve this setting as
  // private, so extenders can only add new inserter media categories and don't have any
  // control over the core media categories.
  dispatch({
    type: 'REGISTER_INSERTER_MEDIA_CATEGORY',
    category: {
      ...category,
      isExternalResource: true
    }
  });
};

/**
 * @typedef {import('../components/block-editing-mode').BlockEditingMode} BlockEditingMode
 */

/**
 * Sets the block editing mode for a given block.
 *
 * @see useBlockEditingMode
 *
 * @param {string}           clientId The block client ID, or `''` for the root container.
 * @param {BlockEditingMode} mode     The block editing mode. One of `'disabled'`,
 *                                    `'contentOnly'`, or `'default'`.
 *
 * @return {Object} Action object.
 */
function setBlockEditingMode(clientId = '', mode) {
  return {
    type: 'SET_BLOCK_EDITING_MODE',
    clientId,
    mode
  };
}

/**
 * Clears the block editing mode for a given block.
 *
 * @see useBlockEditingMode
 *
 * @param {string} clientId The block client ID, or `''` for the root container.
 *
 * @return {Object} Action object.
 */
function unsetBlockEditingMode(clientId = '') {
  return {
    type: 'UNSET_BLOCK_EDITING_MODE',
    clientId
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/store/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */








/**
 * Block editor data store configuration.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#registerStore
 */
const storeConfig = {
  reducer: reducer,
  selectors: selectors_namespaceObject,
  actions: store_actions_namespaceObject
};

/**
 * Store definition for the block editor namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 */
const store_store = (0,redux_store/* default */.A)(STORE_NAME, {
  ...storeConfig,
  persist: ['preferences']
});

// We will be able to use the `register` function once we switch
// the "preferences" persistence to use the new preferences package.
const registeredStore = (0,data_build_module/* registerStore */.ti)(STORE_NAME, {
  ...storeConfig,
  persist: ['preferences']
});
lock_unlock_unlock(registeredStore).registerPrivateActions(private_actions_namespaceObject);
lock_unlock_unlock(registeredStore).registerPrivateSelectors(private_selectors_namespaceObject);

// TODO: Remove once we switch to the `register` function (see above).
//
// Until then, private functions also need to be attached to the original
// `store` descriptor in order to avoid unit tests failing, which could happen
// when tests create new registries in which they register stores.
//
// @see https://github.com/WordPress/gutenberg/pull/51145#discussion_r1239999590
lock_unlock_unlock(store_store).registerPrivateActions(private_actions_namespaceObject);
lock_unlock_unlock(store_store).registerPrivateSelectors(private_selectors_namespaceObject);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/use-settings/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




/**
 * Hook that retrieves the given settings for the block instance in use.
 *
 * It looks up the settings first in the block instance hierarchy.
 * If none are found, it'll look them up in the block editor settings.
 *
 * @param {string[]} paths The paths to the settings.
 * @return {any[]} Returns the values defined for the settings.
 * @example
 * ```js
 * const [ fixed, sticky ] = useSettings( 'position.fixed', 'position.sticky' );
 * ```
 */
function use_settings_useSettings(...paths) {
  const {
    clientId = null
  } = context_useBlockEditContext();
  return (0,use_select/* default */.A)(select => lock_unlock_unlock(select(store_store)).getBlockSettings(clientId, ...paths),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [clientId, ...paths]);
}

/**
 * Hook that retrieves the given setting for the block instance in use.
 *
 * It looks up the setting first in the block instance hierarchy.
 * If none is found, it'll look it up in the block editor settings.
 *
 * @param {string} path The path to the setting.
 * @return {any} Returns the value defined for the setting.
 * @deprecated 6.5.0 Use useSettings instead.
 * @example
 * ```js
 * const isEnabled = useSetting( 'typography.dropCap' );
 * ```
 */
function useSetting(path) {
  deprecated('wp.blockEditor.useSetting', {
    since: '6.5',
    alternative: 'wp.blockEditor.useSettings',
    note: 'The new useSettings function can retrieve multiple settings at once, with better performance.'
  });
  const [value] = use_settings_useSettings(path);
  return value;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/hooks.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const EMPTY_CONFIG = {
  settings: {},
  styles: {}
};
const VALID_SETTINGS = (/* unused pure expression or super */ null && (['appearanceTools', 'useRootPaddingAwareAlignments', 'background.backgroundImage', 'background.backgroundRepeat', 'background.backgroundSize', 'background.backgroundPosition', 'border.color', 'border.radius', 'border.style', 'border.width', 'shadow.presets', 'shadow.defaultPresets', 'color.background', 'color.button', 'color.caption', 'color.custom', 'color.customDuotone', 'color.customGradient', 'color.defaultDuotone', 'color.defaultGradients', 'color.defaultPalette', 'color.duotone', 'color.gradients', 'color.heading', 'color.link', 'color.palette', 'color.text', 'custom', 'dimensions.aspectRatio', 'dimensions.minHeight', 'layout.contentSize', 'layout.definitions', 'layout.wideSize', 'lightbox.enabled', 'lightbox.allowEditing', 'position.fixed', 'position.sticky', 'spacing.customSpacingSize', 'spacing.defaultSpacingSizes', 'spacing.spacingSizes', 'spacing.spacingScale', 'spacing.blockGap', 'spacing.margin', 'spacing.padding', 'spacing.units', 'typography.fluid', 'typography.customFontSize', 'typography.defaultFontSizes', 'typography.dropCap', 'typography.fontFamilies', 'typography.fontSizes', 'typography.fontStyle', 'typography.fontWeight', 'typography.letterSpacing', 'typography.lineHeight', 'typography.textAlign', 'typography.textColumns', 'typography.textDecoration', 'typography.textTransform', 'typography.writingMode']));
const useGlobalStylesReset = () => {
  const {
    user,
    setUserConfig
  } = useContext(GlobalStylesContext);
  const config = {
    settings: user.settings,
    styles: user.styles
  };
  const canReset = !!config && !fastDeepEqual(config, EMPTY_CONFIG);
  return [canReset, useCallback(() => setUserConfig(EMPTY_CONFIG), [setUserConfig])];
};
function hooks_useGlobalSetting(propertyPath, blockName, source = 'all') {
  const {
    setUserConfig,
    ...configs
  } = useContext(GlobalStylesContext);
  const appendedBlockPath = blockName ? '.blocks.' + blockName : '';
  const appendedPropertyPath = propertyPath ? '.' + propertyPath : '';
  const contextualPath = `settings${appendedBlockPath}${appendedPropertyPath}`;
  const globalPath = `settings${appendedPropertyPath}`;
  const sourceKey = source === 'all' ? 'merged' : source;
  const settingValue = useMemo(() => {
    const configToUse = configs[sourceKey];
    if (!configToUse) {
      throw 'Unsupported source';
    }
    if (propertyPath) {
      var _getValueFromObjectPa;
      return (_getValueFromObjectPa = getValueFromObjectPath(configToUse, contextualPath)) !== null && _getValueFromObjectPa !== void 0 ? _getValueFromObjectPa : getValueFromObjectPath(configToUse, globalPath);
    }
    let result = {};
    VALID_SETTINGS.forEach(setting => {
      var _getValueFromObjectPa2;
      const value = (_getValueFromObjectPa2 = getValueFromObjectPath(configToUse, `settings${appendedBlockPath}.${setting}`)) !== null && _getValueFromObjectPa2 !== void 0 ? _getValueFromObjectPa2 : getValueFromObjectPath(configToUse, `settings.${setting}`);
      if (value !== undefined) {
        result = setImmutably(result, setting.split('.'), value);
      }
    });
    return result;
  }, [configs, sourceKey, propertyPath, contextualPath, globalPath, appendedBlockPath]);
  const setSetting = newValue => {
    setUserConfig(currentConfig => setImmutably(currentConfig, contextualPath.split('.'), newValue));
  };
  return [settingValue, setSetting];
}
function useGlobalStyle(path, blockName, source = 'all', {
  shouldDecodeEncode = true
} = {}) {
  const {
    merged: mergedConfig,
    base: baseConfig,
    user: userConfig,
    setUserConfig
  } = useContext(GlobalStylesContext);
  const appendedPath = path ? '.' + path : '';
  const finalPath = !blockName ? `styles${appendedPath}` : `styles.blocks.${blockName}${appendedPath}`;
  const setStyle = newValue => {
    setUserConfig(currentConfig => setImmutably(currentConfig, finalPath.split('.'), shouldDecodeEncode ? getPresetVariableFromValue(mergedConfig.settings, blockName, path, newValue) : newValue));
  };
  let rawResult, result;
  switch (source) {
    case 'all':
      rawResult = getValueFromObjectPath(mergedConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
      break;
    case 'user':
      rawResult = getValueFromObjectPath(userConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
      break;
    case 'base':
      rawResult = getValueFromObjectPath(baseConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(baseConfig, blockName, rawResult) : rawResult;
      break;
    default:
      throw 'Unsupported source';
  }
  return [result, setStyle];
}
function useGlobalStyleLinks() {
  const {
    merged: mergedConfig
  } = useContext(GlobalStylesContext);
  return mergedConfig?._links;
}

/**
 * React hook that overrides a global settings object with block and element specific settings.
 *
 * @param {Object}     parentSettings Settings object.
 * @param {blockName?} blockName      Block name.
 * @param {element?}   element        Element name.
 *
 * @return {Object} Merge of settings and supports.
 */
function useSettingsForBlockElement(parentSettings, blockName, element) {
  const {
    supportedStyles,
    supports
  } = (0,use_select/* default */.A)(select => {
    return {
      supportedStyles: lock_unlock_unlock(select(build_module/* store */.M_)).getSupportedStyles(blockName, element),
      supports: select(build_module/* store */.M_).getBlockType(blockName)?.supports
    };
  }, [blockName, element]);
  return (0,react.useMemo)(() => {
    const updatedSettings = {
      ...parentSettings
    };
    if (!supportedStyles.includes('fontSize')) {
      updatedSettings.typography = {
        ...updatedSettings.typography,
        fontSizes: {},
        customFontSize: false,
        defaultFontSizes: false
      };
    }
    if (!supportedStyles.includes('fontFamily')) {
      updatedSettings.typography = {
        ...updatedSettings.typography,
        fontFamilies: {}
      };
    }
    updatedSettings.color = {
      ...updatedSettings.color,
      text: updatedSettings.color?.text && supportedStyles.includes('color'),
      background: updatedSettings.color?.background && (supportedStyles.includes('background') || supportedStyles.includes('backgroundColor')),
      button: updatedSettings.color?.button && supportedStyles.includes('buttonColor'),
      heading: updatedSettings.color?.heading && supportedStyles.includes('headingColor'),
      link: updatedSettings.color?.link && supportedStyles.includes('linkColor'),
      caption: updatedSettings.color?.caption && supportedStyles.includes('captionColor')
    };

    // Some blocks can enable background colors but disable gradients.
    if (!supportedStyles.includes('background')) {
      updatedSettings.color.gradients = [];
      updatedSettings.color.customGradient = false;
    }

    // If filters are not supported by the block/element, disable duotone.
    if (!supportedStyles.includes('filter')) {
      updatedSettings.color.defaultDuotone = false;
      updatedSettings.color.customDuotone = false;
    }
    ['lineHeight', 'fontStyle', 'fontWeight', 'letterSpacing', 'textAlign', 'textTransform', 'textDecoration', 'writingMode'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.typography = {
          ...updatedSettings.typography,
          [key]: false
        };
      }
    });

    // The column-count style is named text column to reduce confusion with
    // the columns block and manage expectations from the support.
    // See: https://github.com/WordPress/gutenberg/pull/33587
    if (!supportedStyles.includes('columnCount')) {
      updatedSettings.typography = {
        ...updatedSettings.typography,
        textColumns: false
      };
    }
    ['contentSize', 'wideSize'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.layout = {
          ...updatedSettings.layout,
          [key]: false
        };
      }
    });
    ['padding', 'margin', 'blockGap'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.spacing = {
          ...updatedSettings.spacing,
          [key]: false
        };
      }
      const sides = Array.isArray(supports?.spacing?.[key]) ? supports?.spacing?.[key] : supports?.spacing?.[key]?.sides;
      // Check if spacing type is supported before adding sides.
      if (sides?.length && updatedSettings.spacing?.[key]) {
        updatedSettings.spacing = {
          ...updatedSettings.spacing,
          [key]: {
            ...updatedSettings.spacing?.[key],
            sides
          }
        };
      }
    });
    ['aspectRatio', 'minHeight'].forEach(key => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.dimensions = {
          ...updatedSettings.dimensions,
          [key]: false
        };
      }
    });
    ['radius', 'color', 'style', 'width'].forEach(key => {
      if (!supportedStyles.includes('border' + key.charAt(0).toUpperCase() + key.slice(1))) {
        updatedSettings.border = {
          ...updatedSettings.border,
          [key]: false
        };
      }
    });
    updatedSettings.shadow = supportedStyles.includes('shadow') ? updatedSettings.shadow : false;

    // Text alignment is only available for blocks.
    if (element) {
      updatedSettings.typography.textAlign = false;
    }
    return updatedSettings;
  }, [parentSettings, supportedStyles, supports, element]);
}
function useColorsPerOrigin(settings) {
  const customColors = settings?.color?.palette?.custom;
  const themeColors = settings?.color?.palette?.theme;
  const defaultColors = settings?.color?.palette?.default;
  const shouldDisplayDefaultColors = settings?.color?.defaultPalette;
  return (0,react.useMemo)(() => {
    const result = [];
    if (themeColors && themeColors.length) {
      result.push({
        name: (0,i18n_build_module._x)('Theme', 'Indicates this palette comes from the theme.'),
        colors: themeColors
      });
    }
    if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
      result.push({
        name: (0,i18n_build_module._x)('Default', 'Indicates this palette comes from WordPress.'),
        colors: defaultColors
      });
    }
    if (customColors && customColors.length) {
      result.push({
        name: (0,i18n_build_module._x)('Custom', 'Indicates this palette is created by the user.'),
        colors: customColors
      });
    }
    return result;
  }, [customColors, themeColors, defaultColors, shouldDisplayDefaultColors]);
}
function useGradientsPerOrigin(settings) {
  const customGradients = settings?.color?.gradients?.custom;
  const themeGradients = settings?.color?.gradients?.theme;
  const defaultGradients = settings?.color?.gradients?.default;
  const shouldDisplayDefaultGradients = settings?.color?.defaultGradients;
  return (0,react.useMemo)(() => {
    const result = [];
    if (themeGradients && themeGradients.length) {
      result.push({
        name: (0,i18n_build_module._x)('Theme', 'Indicates this palette comes from the theme.'),
        gradients: themeGradients
      });
    }
    if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
      result.push({
        name: (0,i18n_build_module._x)('Default', 'Indicates this palette comes from WordPress.'),
        gradients: defaultGradients
      });
    }
    if (customGradients && customGradients.length) {
      result.push({
        name: (0,i18n_build_module._x)('Custom', 'Indicates this palette is created by the user.'),
        gradients: customGradients
      });
    }
    return result;
  }, [customGradients, themeGradients, defaultGradients, shouldDisplayDefaultGradients]);
}
//# sourceMappingURL=hooks.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
var dist_clsx = __webpack_require__("../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/utils.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */






/**
 * External dependencies
 */


/**
 * Removed falsy values from nested object.
 *
 * @param {*} object
 * @return {*} Object cleaned from falsy values
 */

const utils_cleanEmptyObject = object => {
  if (object === null || typeof object !== 'object' || Array.isArray(object)) {
    return object;
  }
  const cleanedNestedObjects = Object.entries(object).map(([key, value]) => [key, utils_cleanEmptyObject(value)]).filter(([, value]) => value !== undefined);
  return !cleanedNestedObjects.length ? undefined : Object.fromEntries(cleanedNestedObjects);
};
function transformStyles(activeSupports, migrationPaths, result, source, index, results) {
  // If there are no active supports return early.
  if (Object.values(activeSupports !== null && activeSupports !== void 0 ? activeSupports : {}).every(isActive => !isActive)) {
    return result;
  }
  // If the condition verifies we are probably in the presence of a wrapping transform
  // e.g: nesting paragraphs in a group or columns and in that case the styles should not be transformed.
  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  }
  // For cases where we have a transform from one block to multiple blocks
  // or multiple blocks to one block we apply the styles of the first source block
  // to the result(s).
  let referenceBlockAttributes = source[0]?.attributes;
  // If we are in presence of transform between more than one block in the source
  // that has more than one block in the result
  // we apply the styles on source N to the result N,
  // if source N does not exists we do nothing.
  if (results.length > 1 && source.length > 1) {
    if (source[index]) {
      referenceBlockAttributes = source[index]?.attributes;
    } else {
      return result;
    }
  }
  let returnBlock = result;
  Object.entries(activeSupports).forEach(([support, isActive]) => {
    if (isActive) {
      migrationPaths[support].forEach(path => {
        const styleValue = object_getValueFromObjectPath(referenceBlockAttributes, path);
        if (styleValue) {
          returnBlock = {
            ...returnBlock,
            attributes: object_setImmutably(returnBlock.attributes, path, styleValue)
          };
        }
      });
    }
  });
  return returnBlock;
}

/**
 * Check whether serialization of specific block support feature or set should
 * be skipped.
 *
 * @param {string|Object} blockNameOrType Block name or block type object.
 * @param {string}        featureSet      Name of block support feature set.
 * @param {string}        feature         Name of the individual feature to check.
 *
 * @return {boolean} Whether serialization should occur.
 */
function shouldSkipSerialization(blockNameOrType, featureSet, feature) {
  const support = (0,build_module/* getBlockSupport */.bI)(blockNameOrType, featureSet);
  const skipSerialization = support?.__experimentalSkipSerialization;
  if (Array.isArray(skipSerialization)) {
    return skipSerialization.includes(feature);
  }
  return skipSerialization;
}
const pendingStyleOverrides = new WeakMap();
function utils_useStyleOverride({
  id,
  css,
  assets,
  __unstableType,
  variation,
  clientId
} = {}) {
  const {
    setStyleOverride,
    deleteStyleOverride
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  const registry = (0,use_registry/* default */.A)();
  const fallbackId = (0,react.useId)();
  (0,react.useEffect)(() => {
    // Unmount if there is CSS and assets are empty.
    if (!css && !assets) {
      return;
    }
    const _id = id || fallbackId;
    const override = {
      id,
      css,
      assets,
      __unstableType,
      variation,
      clientId
    };
    // Batch updates to style overrides to avoid triggering cascading renders
    // for each style override block included in a tree and optimize initial render.
    if (!pendingStyleOverrides.get(registry)) {
      pendingStyleOverrides.set(registry, []);
    }
    pendingStyleOverrides.get(registry).push([_id, override]);
    window.queueMicrotask(() => {
      if (pendingStyleOverrides.get(registry)?.length) {
        registry.batch(() => {
          pendingStyleOverrides.get(registry).forEach(args => {
            setStyleOverride(...args);
          });
          pendingStyleOverrides.set(registry, []);
        });
      }
    });
    return () => {
      const isPending = pendingStyleOverrides.get(registry)?.find(([currentId]) => currentId === _id);
      if (isPending) {
        pendingStyleOverrides.set(registry, pendingStyleOverrides.get(registry).filter(([currentId]) => currentId !== _id));
      } else {
        deleteStyleOverride(_id);
      }
    };
  }, [id, css, clientId, assets, __unstableType, fallbackId, setStyleOverride, deleteStyleOverride, registry]);
}

/**
 * Based on the block and its context, returns an object of all the block settings.
 * This object can be passed as a prop to all the Styles UI components
 * (TypographyPanel, DimensionsPanel...).
 *
 * @param {string} name         Block name.
 * @param {*}      parentLayout Parent layout.
 *
 * @return {Object} Settings object.
 */
function useBlockSettings(name, parentLayout) {
  const [backgroundImage, backgroundSize, customFontFamilies, defaultFontFamilies, themeFontFamilies, defaultFontSizesEnabled, customFontSizes, defaultFontSizes, themeFontSizes, customFontSize, fontStyle, fontWeight, lineHeight, textAlign, textColumns, textDecoration, writingMode, textTransform, letterSpacing, padding, margin, blockGap, defaultSpacingSizesEnabled, customSpacingSize, userSpacingSizes, defaultSpacingSizes, themeSpacingSizes, units, aspectRatio, minHeight, layout, borderColor, borderRadius, borderStyle, borderWidth, customColorsEnabled, customColors, customDuotone, themeColors, defaultColors, defaultPalette, defaultDuotone, userDuotonePalette, themeDuotonePalette, defaultDuotonePalette, userGradientPalette, themeGradientPalette, defaultGradientPalette, defaultGradients, areCustomGradientsEnabled, isBackgroundEnabled, isLinkEnabled, isTextEnabled, isHeadingEnabled, isButtonEnabled, shadow] = use_settings_useSettings('background.backgroundImage', 'background.backgroundSize', 'typography.fontFamilies.custom', 'typography.fontFamilies.default', 'typography.fontFamilies.theme', 'typography.defaultFontSizes', 'typography.fontSizes.custom', 'typography.fontSizes.default', 'typography.fontSizes.theme', 'typography.customFontSize', 'typography.fontStyle', 'typography.fontWeight', 'typography.lineHeight', 'typography.textAlign', 'typography.textColumns', 'typography.textDecoration', 'typography.writingMode', 'typography.textTransform', 'typography.letterSpacing', 'spacing.padding', 'spacing.margin', 'spacing.blockGap', 'spacing.defaultSpacingSizes', 'spacing.customSpacingSize', 'spacing.spacingSizes.custom', 'spacing.spacingSizes.default', 'spacing.spacingSizes.theme', 'spacing.units', 'dimensions.aspectRatio', 'dimensions.minHeight', 'layout', 'border.color', 'border.radius', 'border.style', 'border.width', 'color.custom', 'color.palette.custom', 'color.customDuotone', 'color.palette.theme', 'color.palette.default', 'color.defaultPalette', 'color.defaultDuotone', 'color.duotone.custom', 'color.duotone.theme', 'color.duotone.default', 'color.gradients.custom', 'color.gradients.theme', 'color.gradients.default', 'color.defaultGradients', 'color.customGradient', 'color.background', 'color.link', 'color.text', 'color.heading', 'color.button', 'shadow');
  const rawSettings = (0,react.useMemo)(() => {
    return {
      background: {
        backgroundImage,
        backgroundSize
      },
      color: {
        palette: {
          custom: customColors,
          theme: themeColors,
          default: defaultColors
        },
        gradients: {
          custom: userGradientPalette,
          theme: themeGradientPalette,
          default: defaultGradientPalette
        },
        duotone: {
          custom: userDuotonePalette,
          theme: themeDuotonePalette,
          default: defaultDuotonePalette
        },
        defaultGradients,
        defaultPalette,
        defaultDuotone,
        custom: customColorsEnabled,
        customGradient: areCustomGradientsEnabled,
        customDuotone,
        background: isBackgroundEnabled,
        link: isLinkEnabled,
        heading: isHeadingEnabled,
        button: isButtonEnabled,
        text: isTextEnabled
      },
      typography: {
        fontFamilies: {
          custom: customFontFamilies,
          default: defaultFontFamilies,
          theme: themeFontFamilies
        },
        fontSizes: {
          custom: customFontSizes,
          default: defaultFontSizes,
          theme: themeFontSizes
        },
        customFontSize,
        defaultFontSizes: defaultFontSizesEnabled,
        fontStyle,
        fontWeight,
        lineHeight,
        textAlign,
        textColumns,
        textDecoration,
        textTransform,
        letterSpacing,
        writingMode
      },
      spacing: {
        spacingSizes: {
          custom: userSpacingSizes,
          default: defaultSpacingSizes,
          theme: themeSpacingSizes
        },
        customSpacingSize,
        defaultSpacingSizes: defaultSpacingSizesEnabled,
        padding,
        margin,
        blockGap,
        units
      },
      border: {
        color: borderColor,
        radius: borderRadius,
        style: borderStyle,
        width: borderWidth
      },
      dimensions: {
        aspectRatio,
        minHeight
      },
      layout,
      parentLayout,
      shadow
    };
  }, [backgroundImage, backgroundSize, customFontFamilies, defaultFontFamilies, themeFontFamilies, defaultFontSizesEnabled, customFontSizes, defaultFontSizes, themeFontSizes, customFontSize, fontStyle, fontWeight, lineHeight, textAlign, textColumns, textDecoration, textTransform, letterSpacing, writingMode, padding, margin, blockGap, defaultSpacingSizesEnabled, customSpacingSize, userSpacingSizes, defaultSpacingSizes, themeSpacingSizes, units, aspectRatio, minHeight, layout, parentLayout, borderColor, borderRadius, borderStyle, borderWidth, customColorsEnabled, customColors, customDuotone, themeColors, defaultColors, defaultPalette, defaultDuotone, userDuotonePalette, themeDuotonePalette, defaultDuotonePalette, userGradientPalette, themeGradientPalette, defaultGradientPalette, defaultGradients, areCustomGradientsEnabled, isBackgroundEnabled, isLinkEnabled, isTextEnabled, isHeadingEnabled, isButtonEnabled, shadow]);
  return useSettingsForBlockElement(rawSettings, name);
}
function createBlockEditFilter(features) {
  // We don't want block controls to re-render when typing inside a block.
  // `memo` will prevent re-renders unless props change, so only pass the
  // needed props and not the whole attributes object.
  features = features.map(settings => {
    return {
      ...settings,
      Edit: (0,react.memo)(settings.edit)
    };
  });
  const withBlockEditHooks = (0,create_higher_order_component/* createHigherOrderComponent */.f)(OriginalBlockEdit => props => {
    const context = context_useBlockEditContext();
    // CAUTION: code added before this line will be executed for all
    // blocks, not just those that support the feature! Code added
    // above this line should be carefully evaluated for its impact on
    // performance.
    return [...features.map((feature, i) => {
      const {
        Edit,
        hasSupport,
        attributeKeys = [],
        shareWithChildBlocks
      } = feature;
      const shouldDisplayControls = context[mayDisplayControlsKey] || context[mayDisplayParentControlsKey] && shareWithChildBlocks;
      if (!shouldDisplayControls || !hasSupport(props.name)) {
        return null;
      }
      const neededProps = {};
      for (const key of attributeKeys) {
        if (props.attributes[key]) {
          neededProps[key] = props.attributes[key];
        }
      }
      return /*#__PURE__*/(0,jsx_runtime.jsx)(Edit
      // We can use the index because the array length
      // is fixed per page load right now.
      , {
        name: props.name,
        isSelected: props.isSelected,
        clientId: props.clientId,
        setAttributes: props.setAttributes,
        __unstableParentLayout: props.__unstableParentLayout
        // This component is pure, so only pass needed
        // props!!!
        ,
        ...neededProps
      }, i);
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(OriginalBlockEdit, {
      ...props
    }, "edit")];
  }, 'withBlockEditHooks');
  (0,hooks_build_module/* addFilter */.U2)('editor.BlockEdit', 'core/editor/hooks', withBlockEditHooks);
}
function BlockProps({
  index,
  useBlockProps,
  setAllWrapperProps,
  ...props
}) {
  const wrapperProps = useBlockProps(props);
  const setWrapperProps = next => setAllWrapperProps(prev => {
    const nextAll = [...prev];
    nextAll[index] = next;
    return nextAll;
  });
  // Setting state after every render is fine because this component is
  // pure and will only re-render when needed props change.
  (0,react.useEffect)(() => {
    // We could shallow compare the props, but since this component only
    // changes when needed attributes change, the benefit is probably small.
    setWrapperProps(wrapperProps);
    return () => {
      setWrapperProps(undefined);
    };
  });
  return null;
}
const BlockPropsPure = (0,react.memo)(BlockProps);
function createBlockListBlockFilter(features) {
  const withBlockListBlockHooks = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockListBlock => props => {
    const [allWrapperProps, setAllWrapperProps] = (0,react.useState)(Array(features.length).fill(undefined));
    return [...features.map((feature, i) => {
      const {
        hasSupport,
        attributeKeys = [],
        useBlockProps,
        isMatch
      } = feature;
      const neededProps = {};
      for (const key of attributeKeys) {
        if (props.attributes[key]) {
          neededProps[key] = props.attributes[key];
        }
      }
      if (
      // Skip rendering if none of the needed attributes are
      // set.
      !Object.keys(neededProps).length || !hasSupport(props.name) || isMatch && !isMatch(neededProps)) {
        return null;
      }
      return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockPropsPure
      // We can use the index because the array length
      // is fixed per page load right now.
      , {
        index: i,
        useBlockProps: useBlockProps
        // This component is pure, so we must pass a stable
        // function reference.
        ,
        setAllWrapperProps: setAllWrapperProps,
        name: props.name,
        clientId: props.clientId
        // This component is pure, so only pass needed
        // props!!!
        ,
        ...neededProps
      }, i);
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(BlockListBlock, {
      ...props,
      wrapperProps: allWrapperProps.filter(Boolean).reduce((acc, wrapperProps) => {
        return {
          ...acc,
          ...wrapperProps,
          className: (0,dist_clsx/* default */.A)(acc.className, wrapperProps.className),
          style: {
            ...acc.style,
            ...wrapperProps.style
          }
        };
      }, props.wrapperProps || {})
    }, "edit")];
  }, 'withBlockListBlockHooks');
  (0,hooks_build_module/* addFilter */.U2)('editor.BlockListBlock', 'core/editor/hooks', withBlockListBlockHooks);
}
function createBlockSaveFilter(features) {
  function extraPropsFromHooks(props, name, attributes) {
    return features.reduce((accu, feature) => {
      const {
        hasSupport,
        attributeKeys = [],
        addSaveProps
      } = feature;
      const neededAttributes = {};
      for (const key of attributeKeys) {
        if (attributes[key]) {
          neededAttributes[key] = attributes[key];
        }
      }
      if (
      // Skip rendering if none of the needed attributes are
      // set.
      !Object.keys(neededAttributes).length || !hasSupport(name)) {
        return accu;
      }
      return addSaveProps(accu, name, neededAttributes);
    }, props);
  }
  (0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/editor/hooks', extraPropsFromHooks, 0);
  (0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/editor/hooks', props => {
    // Previously we had a filter deleting the className if it was an empty
    // string. That filter is no longer running, so now we need to delete it
    // here.
    if (props.hasOwnProperty('className') && !props.className) {
      delete props.className;
    }
    return props;
  });
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/compat.js
/**
 * WordPress dependencies
 */


function migrateLightBlockWrapper(settings) {
  const {
    apiVersion = 1
  } = settings;
  if (apiVersion < 2 && (0,build_module/* hasBlockSupport */.pN)(settings, 'lightBlockWrapper', false)) {
    settings.apiVersion = 2;
  }
  return settings;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/compat/migrateLightBlockWrapper', migrateLightBlockWrapper);
//# sourceMappingURL=compat.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar-group/index.js + 2 modules
var toolbar_group = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar-group/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/style-provider/index.js
var style_provider = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/style-provider/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/slot-fill/index.js + 9 modules
var slot_fill = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/slot-fill/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-controls/groups.js
/**
 * WordPress dependencies
 */

const BlockControlsDefault = (0,slot_fill/* createSlotFill */.QJ)('BlockControls');
const BlockControlsBlock = (0,slot_fill/* createSlotFill */.QJ)('BlockControlsBlock');
const BlockControlsInline = (0,slot_fill/* createSlotFill */.QJ)('BlockFormatControls');
const BlockControlsOther = (0,slot_fill/* createSlotFill */.QJ)('BlockControlsOther');
const BlockControlsParent = (0,slot_fill/* createSlotFill */.QJ)('BlockControlsParent');
const groups = {
  default: BlockControlsDefault,
  block: BlockControlsBlock,
  inline: BlockControlsInline,
  other: BlockControlsOther,
  parent: BlockControlsParent
};
/* harmony default export */ const block_controls_groups = (groups);
//# sourceMappingURL=groups.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-controls/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function useBlockControlsFill(group, shareWithChildBlocks) {
  const context = context_useBlockEditContext();
  if (context[mayDisplayControlsKey]) {
    return block_controls_groups[group]?.Fill;
  }
  if (context[mayDisplayParentControlsKey] && shareWithChildBlocks) {
    return block_controls_groups.parent.Fill;
  }
  return null;
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-controls/fill.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function BlockControlsFill({
  group = 'default',
  controls,
  children,
  __experimentalShareWithChildBlocks = false
}) {
  const Fill = useBlockControlsFill(group, __experimentalShareWithChildBlocks);
  if (!Fill) {
    return null;
  }
  const innerMarkup = /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [group === 'default' && /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_group/* default */.A, {
      controls: controls
    }), children]
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(style_provider/* default */.A, {
    document: document,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Fill, {
      children: fillProps => {
        // `fillProps.forwardedContext` is an array of context provider entries, provided by slot,
        // that should wrap the fill markup.
        const {
          forwardedContext = []
        } = fillProps;
        return forwardedContext.reduce((inner, [Provider, props]) => /*#__PURE__*/(0,jsx_runtime.jsx)(Provider, {
          ...props,
          children: inner
        }), innerMarkup);
      }
    })
  });
}
//# sourceMappingURL=fill.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7QTPYGNZ.js
var _7QTPYGNZ = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7QTPYGNZ.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3X3MDQGM.js
"use client";

// src/group/group-label-context.ts

var GroupLabelContext = (0,react.createContext)(void 0);



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3ORBWXWF.js
var _3ORBWXWF = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3ORBWXWF.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/6O5OEQGF.js
var _6O5OEQGF = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/6O5OEQGF.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4R3V3JGP.js
var _4R3V3JGP = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4R3V3JGP.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/R2QZ3KXH.js
"use client";





// src/group/group.tsx


var useGroup = (0,_3ORBWXWF/* createHook */.ab)((props) => {
  const [labelId, setLabelId] = (0,react.useState)();
  props = (0,_6O5OEQGF/* useWrapElement */.w7)(
    props,
    (element) => /* @__PURE__ */ (0,jsx_runtime.jsx)(GroupLabelContext.Provider, { value: setLabelId, children: element }),
    []
  );
  props = (0,_4R3V3JGP/* __spreadValues */.IA)({
    role: "group",
    "aria-labelledby": labelId
  }, props);
  return props;
});
var Group = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useGroup(props);
  return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
});
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/636A7WVS.js
"use client";




// src/composite/composite-group.ts
var useCompositeGroup = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store"]);
    props = useGroup(props);
    return props;
  }
);
var CompositeGroup = (0,_3ORBWXWF/* createComponent */.a0)(
  (props) => {
    const htmlProps = useCompositeGroup(props);
    return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
  }
);
if (false) {}



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/QZLXIDNP.js
var QZLXIDNP = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/QZLXIDNP.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/IB7YUKH5.js
var IB7YUKH5 = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/IB7YUKH5.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/Y3OOHFCN.js
var Y3OOHFCN = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/Y3OOHFCN.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/BNUFNEVY.js
"use client";





// src/composite/composite-row.tsx



var useCompositeRow = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, {
      store,
      "aria-setsize": ariaSetSize,
      "aria-posinset": ariaPosInSet
    } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, [
      "store",
      "aria-setsize",
      "aria-posinset"
    ]);
    const context = (0,IB7YUKH5/* useCompositeContext */.k)();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const id = (0,_6O5OEQGF/* useId */.Bi)(props.id);
    const baseElement = store.useState(
      (state) => state.baseElement || void 0
    );
    const providerValue = (0,react.useMemo)(
      () => ({ id, baseElement, ariaSetSize, ariaPosInSet }),
      [id, baseElement, ariaSetSize, ariaPosInSet]
    );
    props = (0,_6O5OEQGF/* useWrapElement */.w7)(
      props,
      (element) => /* @__PURE__ */ (0,jsx_runtime.jsx)(IB7YUKH5/* CompositeRowContext */.$o.Provider, { value: providerValue, children: element }),
      [providerValue]
    );
    props = (0,_4R3V3JGP/* __spreadValues */.IA)({ id }, props);
    return props;
  }
);
var CompositeRow = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useCompositeRow(props);
  return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
});
if (false) {}



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7GBW5FLS.js + 1 modules
var _7GBW5FLS = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7GBW5FLS.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/downshift@6.1.12_react@18.3.1/node_modules/downshift/dist/downshift.esm.js + 1 modules
var downshift_esm = __webpack_require__("../../node_modules/.pnpm/downshift@6.1.12_react@18.3.1/node_modules/downshift/dist/downshift.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/icon/index.js
var build_module_icon = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/icon/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/check.js
var check = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/check.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/visually-hidden/component.js + 1 modules
var component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/visually-hidden/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/select-control/styles/select-control-styles.js + 1 modules
var select_control_styles = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/select-control/styles/select-control-styles.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/select-control/chevron-down.js
var chevron_down = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/select-control/chevron-down.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/base-control/styles/base-control-styles.js
var base_control_styles = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/base-control/styles/base-control-styles.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/use-deprecated-props.js
var use_deprecated_props = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/use-deprecated-props.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/input-base.js + 2 modules
var input_base = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/input-base.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-select-control/index.js
// @ts-nocheck
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */








const itemToString = item => item?.name;
// This is needed so that in Windows, where
// the menu does not necessarily open on
// key up/down, you can still switch between
// options with the menu closed.
const stateReducer = ({
  selectedItem
}, {
  type,
  changes,
  props: {
    items
  }
}) => {
  switch (type) {
    case downshift_esm/* useSelect */.WM.stateChangeTypes.ToggleButtonKeyDownArrowDown:
      // If we already have a selected item, try to select the next one,
      // without circular navigation. Otherwise, select the first item.
      return {
        selectedItem: items[selectedItem ? Math.min(items.indexOf(selectedItem) + 1, items.length - 1) : 0]
      };
    case downshift_esm/* useSelect */.WM.stateChangeTypes.ToggleButtonKeyDownArrowUp:
      // If we already have a selected item, try to select the previous one,
      // without circular navigation. Otherwise, select the last item.
      return {
        selectedItem: items[selectedItem ? Math.max(items.indexOf(selectedItem) - 1, 0) : items.length - 1]
      };
    default:
      return changes;
  }
};
function CustomSelectControl(props) {
  const {
    /** Start opting into the larger default height that will become the default size in a future version. */
    __next40pxDefaultSize = false,
    className,
    hideLabelFromVision,
    label,
    describedBy,
    options: items,
    onChange: onSelectedItemChange,
    /** @type {import('../select-control/types').SelectControlProps.size} */
    size = 'default',
    value: _selectedItem,
    onMouseOver,
    onMouseOut,
    onFocus,
    onBlur,
    __experimentalShowSelectedHint = false
  } = (0,use_deprecated_props/* useDeprecated36pxDefaultSizeProp */.R)(props);
  const {
    getLabelProps,
    getToggleButtonProps,
    getMenuProps,
    getItemProps,
    isOpen,
    highlightedIndex,
    selectedItem
  } = (0,downshift_esm/* useSelect */.WM)({
    initialSelectedItem: items[0],
    items,
    itemToString,
    onSelectedItemChange,
    ...(typeof _selectedItem !== 'undefined' && _selectedItem !== null ? {
      selectedItem: _selectedItem
    } : undefined),
    stateReducer
  });
  function getDescribedBy() {
    if (describedBy) {
      return describedBy;
    }
    if (!selectedItem) {
      return (0,i18n_build_module.__)('No selection');
    }

    // translators: %s: The selected option.
    return (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Currently selected: %s'), selectedItem.name);
  }
  let menuProps = getMenuProps({
    className: 'components-custom-select-control__menu',
    'aria-hidden': !isOpen
  });
  const onKeyDownHandler = (0,react.useCallback)(e => {
    e.stopPropagation();
    menuProps?.onKeyDown?.(e);
  }, [menuProps]);

  // We need this here, because the null active descendant is not fully ARIA compliant.
  if (menuProps['aria-activedescendant']?.startsWith('downshift-null')) {
    const {
      'aria-activedescendant': ariaActivedescendant,
      ...restMenuProps
    } = menuProps;
    menuProps = restMenuProps;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: (0,dist_clsx/* default */.A)('components-custom-select-control', className),
    children: [hideLabelFromVision ? /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
      as: "label",
      ...getLabelProps(),
      children: label
    }) :
    /*#__PURE__*/
    /* eslint-disable-next-line jsx-a11y/label-has-associated-control, jsx-a11y/label-has-for */
    (0,jsx_runtime.jsx)(base_control_styles/* StyledLabel */.Gw, {
      ...getLabelProps({
        className: 'components-custom-select-control__label'
      }),
      children: label
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(input_base/* default */.A, {
      __next40pxDefaultSize: __next40pxDefaultSize,
      size: size,
      suffix: /*#__PURE__*/(0,jsx_runtime.jsx)(chevron_down/* default */.A, {}),
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(select_control_styles/* Select */.l6, {
        onMouseOver: onMouseOver,
        onMouseOut: onMouseOut,
        as: "button",
        onFocus: onFocus,
        onBlur: onBlur,
        selectSize: size,
        __next40pxDefaultSize: __next40pxDefaultSize,
        ...getToggleButtonProps({
          // This is needed because some speech recognition software don't support `aria-labelledby`.
          'aria-label': label,
          'aria-labelledby': undefined,
          className: 'components-custom-select-control__button',
          describedBy: getDescribedBy()
        }),
        children: [itemToString(selectedItem), __experimentalShowSelectedHint && selectedItem.__experimentalHint && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          className: "components-custom-select-control__hint",
          children: selectedItem.__experimentalHint
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "components-custom-select-control__menu-wrapper",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("ul", {
          ...menuProps,
          onKeyDown: onKeyDownHandler,
          children: isOpen && items.map((item, index) => /*#__PURE__*/(0,jsx_runtime.jsxs)("li", {
            ...getItemProps({
              item,
              index,
              className: (0,dist_clsx/* default */.A)(item.className, 'components-custom-select-control__item', {
                'is-highlighted': index === highlightedIndex,
                'has-hint': !!item.__experimentalHint,
                'is-next-40px-default-size': __next40pxDefaultSize
              }),
              style: item.style
            }),
            children: [item.name, item.__experimentalHint && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
              className: "components-custom-select-control__item-hint",
              children: item.__experimentalHint
            }), item === selectedItem && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
              icon: check/* default */.A,
              className: "components-custom-select-control__item-icon"
            })]
          }, item.key))
        })
      })]
    })]
  });
}
function StableCustomSelectControl(props) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(CustomSelectControl, {
    ...props,
    __experimentalShowSelectedHint: false
  });
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/popover/utils.js
var utils = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/popover/utils.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/TI7CMBHW.js
var TI7CMBHW = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/TI7CMBHW.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/YGMEBI3A.js
"use client";





// src/menu/menu-context.ts

var menu = (0,_3ORBWXWF/* createStoreContext */.B0)(
  [IB7YUKH5/* CompositeContextProvider */.ws, TI7CMBHW/* HovercardContextProvider */.pR],
  [IB7YUKH5/* CompositeScopedContextProvider */.aN, TI7CMBHW/* HovercardScopedContextProvider */.n0]
);
var useMenuContext = menu.useContext;
var useMenuScopedContext = menu.useScopedContext;
var useMenuProviderContext = menu.useProviderContext;
var MenuContextProvider = menu.ContextProvider;
var MenuScopedContextProvider = menu.ScopedContextProvider;
var useMenuBarContext = (/* unused pure expression or super */ null && (useMenubarContext));
var useMenuBarScopedContext = (/* unused pure expression or super */ null && (useMenubarScopedContext));
var useMenuBarProviderContext = (/* unused pure expression or super */ null && (useMenubarProviderContext));
var MenuBarContextProvider = (/* unused pure expression or super */ null && (MenubarContextProvider));
var MenuBarScopedContextProvider = (/* unused pure expression or super */ null && (MenubarScopedContextProvider));
var MenuItemCheckedContext = (0,react.createContext)(
  void 0
);



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/6XBVQI3K.js
"use client";

// src/checkbox/checkbox-checked-context.ts

var CheckboxCheckedContext = (0,react.createContext)(false);



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/MW2F7SEA.js
"use client";




// src/checkbox/checkbox-check.tsx


var checkmark = /* @__PURE__ */ (0,jsx_runtime.jsx)(
  "svg",
  {
    display: "block",
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "1.5pt",
    viewBox: "0 0 16 16",
    height: "1em",
    width: "1em",
    children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "4,8 7,12 12,4" })
  }
);
function getChildren(props) {
  if (props.checked) {
    return props.children || checkmark;
  }
  if (typeof props.children === "function") {
    return props.children;
  }
  return null;
}
var useCheckboxCheck = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store, checked } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store", "checked"]);
    const context = (0,react.useContext)(CheckboxCheckedContext);
    checked = checked != null ? checked : context;
    const children = getChildren({ checked, children: props.children });
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
      "aria-hidden": true
    }, props), {
      children,
      style: (0,_4R3V3JGP/* __spreadValues */.IA)({
        width: "1em",
        height: "1em",
        pointerEvents: "none"
      }, props.style)
    });
    return props;
  }
);
var CheckboxCheck = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useCheckboxCheck(props);
  return (0,_3ORBWXWF/* createElement */.n)("span", htmlProps);
});
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/menu/menu-item-check.js
"use client";















// src/menu/menu-item-check.ts

var useMenuItemCheck = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store, checked } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store", "checked"]);
    const context = (0,react.useContext)(MenuItemCheckedContext);
    checked = checked != null ? checked : context;
    props = useCheckboxCheck((0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props), { checked }));
    return props;
  }
);
var MenuItemCheck = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useMenuItemCheck(props);
  return (0,_3ORBWXWF/* createElement */.n)("span", htmlProps);
});
if (false) {}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/KA4GX64Z.js
"use client";



// src/menubar/menubar-context.ts

var menubar = (0,_3ORBWXWF/* createStoreContext */.B0)(
  [IB7YUKH5/* CompositeContextProvider */.ws],
  [IB7YUKH5/* CompositeScopedContextProvider */.aN]
);
var KA4GX64Z_useMenubarContext = menubar.useContext;
var KA4GX64Z_useMenubarScopedContext = menubar.useScopedContext;
var KA4GX64Z_useMenubarProviderContext = menubar.useProviderContext;
var KA4GX64Z_MenubarContextProvider = menubar.ContextProvider;
var KA4GX64Z_MenubarScopedContextProvider = menubar.ScopedContextProvider;
var KA4GX64Z_MenuItemCheckedContext = (0,react.createContext)(
  void 0
);



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7H5KSHHF.js
var _7H5KSHHF = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7H5KSHHF.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/W76OTZCC.js
"use client";




// src/combobox/combobox-context.tsx

var ctx = (0,_3ORBWXWF/* createStoreContext */.B0)(
  [_7H5KSHHF/* PopoverContextProvider */.wf, IB7YUKH5/* CompositeContextProvider */.ws],
  [_7H5KSHHF/* PopoverScopedContextProvider */.s1, IB7YUKH5/* CompositeScopedContextProvider */.aN]
);
var useComboboxContext = ctx.useContext;
var useComboboxScopedContext = ctx.useScopedContext;
var useComboboxProviderContext = ctx.useProviderContext;
var ComboboxContextProvider = ctx.ContextProvider;
var ComboboxScopedContextProvider = ctx.ScopedContextProvider;
var ComboboxItemValueContext = (0,react.createContext)(
  void 0
);
var ComboboxItemCheckedContext = (0,react.createContext)(false);



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/ZU7LQC5V.js + 1 modules
var ZU7LQC5V = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/ZU7LQC5V.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/EKQEJRUF.js
var EKQEJRUF = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/EKQEJRUF.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/SOLWE6E5.js + 1 modules
var SOLWE6E5 = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/SOLWE6E5.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/IERTEJ3A.js
var IERTEJ3A = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/IERTEJ3A.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/EAHJFCU4.js
var EAHJFCU4 = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/EAHJFCU4.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/4R3V3JGP.js
var _chunks_4R3V3JGP = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/4R3V3JGP.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/menu/menu-store.js
"use client";












// src/menu/menu-store.ts
function createMenuStore(_a = {}) {
  var _b = _a, {
    combobox,
    parent,
    menubar
  } = _b, props = (0,_chunks_4R3V3JGP/* __objRest */.YG)(_b, [
    "combobox",
    "parent",
    "menubar"
  ]);
  const parentIsMenubar = !!menubar && !parent;
  const store = (0,EAHJFCU4/* mergeStore */.od)(
    props.store,
    (0,EAHJFCU4/* pick */.Up)(parent, ["values"]),
    (0,EAHJFCU4/* omit */.cJ)(combobox, [
      "arrowElement",
      "anchorElement",
      "contentElement",
      "popoverElement",
      "disclosureElement"
    ])
  );
  (0,EAHJFCU4/* throwOnConflictingProps */.UE)(props, store);
  const syncState = store.getState();
  const composite = (0,IERTEJ3A/* createCompositeStore */.z)((0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, props), {
    store,
    orientation: (0,Y3OOHFCN/* defaultValue */.Jh)(
      props.orientation,
      syncState.orientation,
      "vertical"
    )
  }));
  const hovercard = (0,SOLWE6E5/* createHovercardStore */.y)((0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, props), {
    store,
    placement: (0,Y3OOHFCN/* defaultValue */.Jh)(
      props.placement,
      syncState.placement,
      "bottom-start"
    ),
    timeout: (0,Y3OOHFCN/* defaultValue */.Jh)(
      props.timeout,
      syncState.timeout,
      parentIsMenubar ? 0 : 150
    ),
    hideTimeout: (0,Y3OOHFCN/* defaultValue */.Jh)(props.hideTimeout, syncState.hideTimeout, 0)
  }));
  const initialState = (0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, composite.getState()), hovercard.getState()), {
    initialFocus: (0,Y3OOHFCN/* defaultValue */.Jh)(syncState.initialFocus, "container"),
    values: (0,Y3OOHFCN/* defaultValue */.Jh)(
      props.values,
      syncState.values,
      props.defaultValues,
      {}
    )
  });
  const menu = (0,EAHJFCU4/* createStore */.y$)(initialState, composite, hovercard, store);
  (0,EAHJFCU4/* setup */.mj)(
    menu,
    () => (0,EAHJFCU4/* sync */.OH)(menu, ["mounted"], (state) => {
      if (state.mounted)
        return;
      menu.setState("activeId", null);
    })
  );
  (0,EAHJFCU4/* setup */.mj)(
    menu,
    () => (0,EAHJFCU4/* sync */.OH)(parent, ["orientation"], (state) => {
      menu.setState(
        "placement",
        state.orientation === "vertical" ? "right-start" : "bottom-start"
      );
    })
  );
  return (0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, composite), hovercard), menu), {
    combobox,
    parent,
    menubar,
    hideAll: () => {
      hovercard.hide();
      parent == null ? void 0 : parent.hideAll();
    },
    setInitialFocus: (value) => menu.setState("initialFocus", value),
    setValues: (values) => menu.setState("values", values),
    setValue: (name, value) => {
      if (name === "__proto__")
        return;
      if (name === "constructor")
        return;
      if (Array.isArray(name))
        return;
      menu.setState("values", (values) => {
        const prevValue = values[name];
        const nextValue = (0,Y3OOHFCN/* applyState */.Qh)(value, prevValue);
        if (nextValue === prevValue)
          return values;
        return (0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, values), {
          [name]: nextValue !== void 0 && nextValue
        });
      });
    }
  });
}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/XJXP7ZSQ.js
"use client";









// src/menu/menu-store.ts

function useMenuStoreProps(store, update, props) {
  (0,_6O5OEQGF/* useUpdateEffect */.w5)(update, [props.combobox, props.parent, props.menubar]);
  store = (0,_7GBW5FLS/* useCompositeStoreProps */.Y)(store, update, props);
  store = (0,ZU7LQC5V/* useHovercardStoreProps */.B)(store, update, props);
  (0,EKQEJRUF/* useStoreProps */.Tz)(store, props, "values", "setValues");
  return Object.assign(store, {
    combobox: props.combobox,
    parent: props.parent,
    menubar: props.menubar
  });
}
function useMenuStore(props = {}) {
  const parent = useMenuContext();
  const menubar = KA4GX64Z_useMenubarContext();
  const combobox = useComboboxProviderContext();
  props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props), {
    parent: props.parent !== void 0 ? props.parent : parent,
    menubar: props.menubar !== void 0 ? props.menubar : menubar,
    combobox: props.combobox !== void 0 ? props.combobox : combobox
  });
  const [store, update] = (0,EKQEJRUF/* useStore */.Pj)(createMenuStore, props);
  return useMenuStoreProps(store, update, props);
}



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/NWCBQ4CV.js
var NWCBQ4CV = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/NWCBQ4CV.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/DLOEKDPY.js
var DLOEKDPY = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/__chunks/DLOEKDPY.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/VDNZBO4W.js
"use client";





// src/button/button.ts


var useButton = (0,_3ORBWXWF/* createHook */.ab)((props) => {
  const ref = (0,react.useRef)(null);
  const tagName = (0,_6O5OEQGF/* useTagName */.vO)(ref, props.as || "button");
  const [isNativeButton, setIsNativeButton] = (0,react.useState)(
    () => !!tagName && (0,DLOEKDPY/* isButton */.Bm)({ tagName, type: props.type })
  );
  (0,react.useEffect)(() => {
    if (!ref.current)
      return;
    setIsNativeButton((0,DLOEKDPY/* isButton */.Bm)(ref.current));
  }, []);
  props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
    role: !isNativeButton && tagName !== "a" ? "button" : void 0
  }, props), {
    ref: (0,_6O5OEQGF/* useMergeRefs */.SV)(ref, props.ref)
  });
  props = (0,NWCBQ4CV/* useCommand */.D)(props);
  return props;
});
var Button = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useButton(props);
  return (0,_3ORBWXWF/* createElement */.n)("button", htmlProps);
});
if (false) {}



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/OAYFXAQ2.js
var OAYFXAQ2 = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/OAYFXAQ2.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/BHEJ6NUH.js
"use client";






// src/disclosure/disclosure.ts


var BHEJ6NUH_symbol = Symbol("disclosure");
var useDisclosure = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store, toggleOnClick = true } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store", "toggleOnClick"]);
    const context = (0,OAYFXAQ2/* useDisclosureProviderContext */.vO)();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const ref = (0,react.useRef)(null);
    const [expanded, setExpanded] = (0,react.useState)(false);
    const disclosureElement = store.useState("disclosureElement");
    const open = store.useState("open");
    (0,react.useEffect)(() => {
      let isCurrentDisclosure = disclosureElement === ref.current;
      if (!(disclosureElement == null ? void 0 : disclosureElement.isConnected)) {
        store == null ? void 0 : store.setDisclosureElement(ref.current);
        isCurrentDisclosure = true;
      }
      setExpanded(open && isCurrentDisclosure);
    }, [disclosureElement, store, open]);
    const onClickProp = props.onClick;
    const toggleOnClickProp = (0,_6O5OEQGF/* useBooleanEvent */.O4)(toggleOnClick);
    const [isDuplicate, metadataProps] = (0,_6O5OEQGF/* useMetadataProps */.P1)(props, BHEJ6NUH_symbol, true);
    const onClick = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (event.defaultPrevented)
        return;
      if (isDuplicate)
        return;
      if (!toggleOnClickProp(event))
        return;
      store == null ? void 0 : store.setDisclosureElement(event.currentTarget);
      store == null ? void 0 : store.toggle();
    });
    const contentElement = store.useState("contentElement");
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)((0,_4R3V3JGP/* __spreadValues */.IA)({
      "aria-expanded": expanded,
      "aria-controls": contentElement == null ? void 0 : contentElement.id
    }, metadataProps), props), {
      ref: (0,_6O5OEQGF/* useMergeRefs */.SV)(ref, props.ref),
      onClick
    });
    props = useButton(props);
    return props;
  }
);
var Disclosure = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useDisclosure(props);
  return (0,_3ORBWXWF/* createElement */.n)("button", htmlProps);
});
if (false) {}



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/G6BJYYBK.js
var G6BJYYBK = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/G6BJYYBK.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/H3TG2CZP.js
"use client";





// src/dialog/dialog-disclosure.ts


var useDialogDisclosure = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store"]);
    const context = (0,G6BJYYBK/* useDialogProviderContext */.cH)();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const contentElement = store.useState("contentElement");
    props = (0,_4R3V3JGP/* __spreadValues */.IA)({
      "aria-haspopup": (0,DLOEKDPY/* getPopupRole */.Tc)(contentElement, "dialog")
    }, props);
    props = useDisclosure((0,_4R3V3JGP/* __spreadValues */.IA)({ store }, props));
    return props;
  }
);
var DialogDisclosure = (0,_3ORBWXWF/* createComponent */.a0)(
  (props) => {
    const htmlProps = useDialogDisclosure(props);
    return (0,_3ORBWXWF/* createElement */.n)("button", htmlProps);
  }
);
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/JCH6MLL2.js
"use client";





// src/popover/popover-anchor.ts
var usePopoverAnchor = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store"]);
    const context = (0,_7H5KSHHF/* usePopoverProviderContext */.zG)();
    store = store || context;
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props), {
      ref: (0,_6O5OEQGF/* useMergeRefs */.SV)(store == null ? void 0 : store.setAnchorElement, props.ref)
    });
    return props;
  }
);
var PopoverAnchor = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = usePopoverAnchor(props);
  return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
});
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/4ZEZYKUR.js
"use client";







// src/popover/popover-disclosure.tsx


var usePopoverDisclosure = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store"]);
    const context = (0,_7H5KSHHF/* usePopoverProviderContext */.zG)();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const onClickProp = props.onClick;
    const onClick = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      store == null ? void 0 : store.setAnchorElement(event.currentTarget);
      onClickProp == null ? void 0 : onClickProp(event);
    });
    props = (0,_6O5OEQGF/* useWrapElement */.w7)(
      props,
      (element) => /* @__PURE__ */ (0,jsx_runtime.jsx)(_7H5KSHHF/* PopoverScopedContextProvider */.s1, { value: store, children: element }),
      [store]
    );
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props), {
      onClick
    });
    props = usePopoverAnchor((0,_4R3V3JGP/* __spreadValues */.IA)({ store }, props));
    props = useDialogDisclosure((0,_4R3V3JGP/* __spreadValues */.IA)({ store }, props));
    return props;
  }
);
var PopoverDisclosure = (0,_3ORBWXWF/* createComponent */.a0)(
  (props) => {
    const htmlProps = usePopoverDisclosure(props);
    return (0,_3ORBWXWF/* createElement */.n)("button", htmlProps);
  }
);
if (false) {}



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3IEDWLST.js
var _3IEDWLST = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3IEDWLST.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/utils/events.js
var events = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/utils/events.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/346FK57L.js
"use client";






// src/composite/composite-typeahead.ts




var chars = "";
function clearChars() {
  chars = "";
}
function isValidTypeaheadEvent(event) {
  const target = event.target;
  if (target && (0,DLOEKDPY/* isTextField */.mB)(target))
    return false;
  if (event.key === " " && chars.length)
    return true;
  return event.key.length === 1 && !event.ctrlKey && !event.altKey && !event.metaKey && /^[\p{Letter}\p{Number}]$/u.test(event.key);
}
function isSelfTargetOrItem(event, items) {
  if ((0,events/* isSelfTarget */.uh)(event))
    return true;
  const target = event.target;
  if (!target)
    return false;
  const isItem = items.some((item) => item.element === target);
  return isItem;
}
function getEnabledItems(items) {
  return items.filter((item) => !item.disabled);
}
function itemTextStartsWith(item, text) {
  var _a;
  const itemText = ((_a = item.element) == null ? void 0 : _a.textContent) || item.children;
  if (!itemText)
    return false;
  return (0,Y3OOHFCN/* normalizeString */.J2)(itemText).trim().toLowerCase().startsWith(text.toLowerCase());
}
function getSameInitialItems(items, char, activeId) {
  if (!activeId)
    return items;
  const activeItem = items.find((item) => item.id === activeId);
  if (!activeItem)
    return items;
  if (!itemTextStartsWith(activeItem, char))
    return items;
  if (chars !== char && itemTextStartsWith(activeItem, chars))
    return items;
  chars = char;
  return (0,_3IEDWLST/* flipItems */._d)(
    items.filter((item) => itemTextStartsWith(item, chars)),
    activeId
  ).filter((item) => item.id !== activeId);
}
var useCompositeTypeahead = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store, typeahead = true } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store", "typeahead"]);
    const context = (0,IB7YUKH5/* useCompositeContext */.k)();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const onKeyDownCaptureProp = props.onKeyDownCapture;
    const cleanupTimeoutRef = (0,react.useRef)(0);
    const onKeyDownCapture = (0,_6O5OEQGF/* useEvent */._q)(
      (event) => {
        onKeyDownCaptureProp == null ? void 0 : onKeyDownCaptureProp(event);
        if (event.defaultPrevented)
          return;
        if (!typeahead)
          return;
        if (!store)
          return;
        const { items, activeId } = store.getState();
        if (!isValidTypeaheadEvent(event))
          return clearChars();
        let enabledItems = getEnabledItems(items);
        if (!isSelfTargetOrItem(event, enabledItems))
          return clearChars();
        event.preventDefault();
        window.clearTimeout(cleanupTimeoutRef.current);
        cleanupTimeoutRef.current = window.setTimeout(() => {
          chars = "";
        }, 500);
        const char = event.key.toLowerCase();
        chars += char;
        enabledItems = getSameInitialItems(enabledItems, char, activeId);
        const item = enabledItems.find(
          (item2) => itemTextStartsWith(item2, chars)
        );
        if (item) {
          store.move(item.id);
        } else {
          clearChars();
        }
      }
    );
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props), {
      onKeyDownCapture
    });
    return props;
  }
);
var CompositeTypeahead = (0,_3ORBWXWF/* createComponent */.a0)(
  (props) => {
    const htmlProps = useCompositeTypeahead(props);
    return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
  }
);
if (false) {}



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7X4DYKYU.js
var _7X4DYKYU = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/7X4DYKYU.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/FSFPRQFR.js
var FSFPRQFR = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/FSFPRQFR.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/menu/menu-button.js
"use client";


























// src/menu/menu-button.tsx




function getInitialFocus(event, dir) {
  const keyMap = {
    ArrowDown: dir === "bottom" || dir === "top" ? "first" : false,
    ArrowUp: dir === "bottom" || dir === "top" ? "last" : false,
    ArrowRight: dir === "right" ? "first" : false,
    ArrowLeft: dir === "left" ? "first" : false
  };
  return keyMap[event.key];
}
function hasActiveItem(items, excludeElement) {
  return !!(items == null ? void 0 : items.some((item) => {
    if (!item.element)
      return false;
    if (item.element === excludeElement)
      return false;
    return item.element.getAttribute("aria-expanded") === "true";
  }));
}
var useMenuButton = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store, focusable, accessibleWhenDisabled, showOnHover } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store", "focusable", "accessibleWhenDisabled", "showOnHover"]);
    const context = useMenuProviderContext();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const ref = (0,react.useRef)(null);
    const parentMenu = store.parent;
    const parentMenubar = store.menubar;
    const hasParentMenu = !!parentMenu;
    const parentIsMenubar = !!parentMenubar && !hasParentMenu;
    const disabled = (0,Y3OOHFCN/* disabledFromProps */.$f)(props);
    const showMenu = () => {
      const trigger = ref.current;
      if (!trigger)
        return;
      store == null ? void 0 : store.setDisclosureElement(trigger);
      store == null ? void 0 : store.setAnchorElement(trigger);
      store == null ? void 0 : store.show();
    };
    const onFocusProp = props.onFocus;
    const onFocus = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      if (disabled)
        return;
      if (event.defaultPrevented)
        return;
      store == null ? void 0 : store.setAutoFocusOnShow(false);
      store == null ? void 0 : store.setActiveId(null);
      if (!parentMenubar)
        return;
      if (!parentIsMenubar)
        return;
      const { items } = parentMenubar.getState();
      if (hasActiveItem(items, event.currentTarget)) {
        showMenu();
      }
    });
    const dir = store.useState(
      (state) => state.placement.split("-")[0]
    );
    const onKeyDownProp = props.onKeyDown;
    const onKeyDown = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (disabled)
        return;
      if (event.defaultPrevented)
        return;
      const initialFocus = getInitialFocus(event, dir);
      if (initialFocus) {
        event.preventDefault();
        showMenu();
        store == null ? void 0 : store.setAutoFocusOnShow(true);
        store == null ? void 0 : store.setInitialFocus(initialFocus);
      }
    });
    const onClickProp = props.onClick;
    const onClick = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (event.defaultPrevented)
        return;
      if (!store)
        return;
      const isKeyboardClick = !event.detail;
      const { open } = store.getState();
      if (!open || isKeyboardClick) {
        if (!hasParentMenu || isKeyboardClick) {
          store.setAutoFocusOnShow(true);
        }
        store.setInitialFocus(isKeyboardClick ? "first" : "container");
      }
      if (hasParentMenu) {
        showMenu();
      }
    });
    props = (0,_6O5OEQGF/* useWrapElement */.w7)(
      props,
      (element) => /* @__PURE__ */ (0,jsx_runtime.jsx)(MenuContextProvider, { value: store, children: element }),
      [store]
    );
    if (hasParentMenu) {
      props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props), {
        render: /* @__PURE__ */ (0,jsx_runtime.jsx)(FSFPRQFR/* Role */.X.div, { render: props.render })
      });
    }
    const id = (0,_6O5OEQGF/* useId */.Bi)(props.id);
    const parentContentElement = (0,EKQEJRUF/* useStoreState */.O$)(
      (parentMenu == null ? void 0 : parentMenu.combobox) || parentMenu,
      "contentElement"
    );
    const role = hasParentMenu || parentIsMenubar ? (0,DLOEKDPY/* getPopupItemRole */.cn)(parentContentElement, "menuitem") : void 0;
    const contentElement = store.useState("contentElement");
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
      id,
      role,
      "aria-haspopup": (0,DLOEKDPY/* getPopupRole */.Tc)(contentElement, "menu")
    }, props), {
      ref: (0,_6O5OEQGF/* useMergeRefs */.SV)(ref, props.ref),
      onFocus,
      onKeyDown,
      onClick
    });
    props = (0,_7X4DYKYU/* useHovercardAnchor */.p)((0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
      store,
      focusable,
      accessibleWhenDisabled
    }, props), {
      showOnHover: (event) => {
        const getShowOnHover = () => {
          if (typeof showOnHover === "function")
            return showOnHover(event);
          if (showOnHover != null)
            return showOnHover;
          if (hasParentMenu)
            return true;
          if (!parentMenubar)
            return false;
          const { items } = parentMenubar.getState();
          return parentIsMenubar && hasActiveItem(items);
        };
        const canShowOnHover = getShowOnHover();
        if (!canShowOnHover)
          return false;
        const parent = parentIsMenubar ? parentMenubar : parentMenu;
        if (!parent)
          return true;
        parent.setActiveId(event.currentTarget.id);
        return true;
      }
    }));
    props = usePopoverDisclosure((0,_4R3V3JGP/* __spreadValues */.IA)({
      store,
      toggleOnClick: !hasParentMenu,
      focusable,
      accessibleWhenDisabled
    }, props));
    props = useCompositeTypeahead((0,_4R3V3JGP/* __spreadValues */.IA)({
      store,
      typeahead: parentIsMenubar
    }, props));
    return props;
  }
);
var MenuButton = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useMenuButton(props);
  return (0,_3ORBWXWF/* createElement */.n)("button", htmlProps);
});
if (false) {}


// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-right-small.js
var chevron_right_small = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-right-small.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+primitives@4.11.0_react@18.3.1/node_modules/@wordpress/primitives/build-module/svg/index.js
var build_module_svg = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@4.11.0_react@18.3.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/use-context-system.js + 1 modules
var use_context_system = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/use-context-system.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-connect.js
var context_connect = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-connect.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/icon/index.js + 1 modules
var components_build_module_icon = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/icon/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1__@types+react@18.3.16_react@18.3.1/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js + 1 modules
var emotion_styled_base_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1__@types+react@18.3.16_react@18.3.1/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/CLE7NTOY.js
var CLE7NTOY = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/CLE7NTOY.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/HHNFDKU2.js
"use client";









// src/menu/menu-list.tsx



function useAriaLabelledBy(_a) {
  var _b = _a, { store } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store"]);
  const [id, setId] = (0,react.useState)(void 0);
  const label = props["aria-label"];
  const disclosureElement = (0,EKQEJRUF/* useStoreState */.O$)(store, "disclosureElement");
  const contentElement = (0,EKQEJRUF/* useStoreState */.O$)(store, "contentElement");
  (0,react.useEffect)(() => {
    const disclosure = disclosureElement;
    if (!disclosure)
      return;
    const menu = contentElement;
    if (!menu)
      return;
    const menuLabel = label || menu.hasAttribute("aria-label");
    if (menuLabel) {
      setId(void 0);
    } else if (disclosure.id) {
      setId(disclosure.id);
    }
  }, [label, disclosureElement, contentElement]);
  return id;
}
var useMenuList = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store, alwaysVisible, composite } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store", "alwaysVisible", "composite"]);
    const context = useMenuProviderContext();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const parentMenu = store.parent;
    const parentMenubar = store.menubar;
    const hasParentMenu = !!parentMenu;
    const id = (0,_6O5OEQGF/* useId */.Bi)(props.id);
    const onKeyDownProp = props.onKeyDown;
    const dir = store.useState(
      (state) => state.placement.split("-")[0]
    );
    const orientation = store.useState(
      (state) => state.orientation === "both" ? void 0 : state.orientation
    );
    const isHorizontal = orientation !== "vertical";
    const isMenubarHorizontal = (0,EKQEJRUF/* useStoreState */.O$)(
      parentMenubar,
      (state) => !!state && state.orientation !== "vertical"
    );
    const onKeyDown = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (event.defaultPrevented)
        return;
      if (hasParentMenu || parentMenubar && !isHorizontal) {
        const hideMap = {
          ArrowRight: () => dir === "left" && !isHorizontal,
          ArrowLeft: () => dir === "right" && !isHorizontal,
          ArrowUp: () => dir === "bottom" && isHorizontal,
          ArrowDown: () => dir === "top" && isHorizontal
        };
        const action = hideMap[event.key];
        if (action == null ? void 0 : action()) {
          event.stopPropagation();
          event.preventDefault();
          return store == null ? void 0 : store.hide();
        }
      }
      if (parentMenubar) {
        const keyMap = {
          ArrowRight: () => {
            if (!isMenubarHorizontal)
              return;
            return parentMenubar.next();
          },
          ArrowLeft: () => {
            if (!isMenubarHorizontal)
              return;
            return parentMenubar.previous();
          },
          ArrowDown: () => {
            if (isMenubarHorizontal)
              return;
            return parentMenubar.next();
          },
          ArrowUp: () => {
            if (isMenubarHorizontal)
              return;
            return parentMenubar.previous();
          }
        };
        const action = keyMap[event.key];
        const id2 = action == null ? void 0 : action();
        if (id2 !== void 0) {
          event.stopPropagation();
          event.preventDefault();
          parentMenubar.move(id2);
        }
      }
    });
    props = (0,_6O5OEQGF/* useWrapElement */.w7)(
      props,
      (element) => /* @__PURE__ */ (0,jsx_runtime.jsx)(MenuScopedContextProvider, { value: store, children: element }),
      [store]
    );
    const ariaLabelledBy = useAriaLabelledBy((0,_4R3V3JGP/* __spreadValues */.IA)({ store }, props));
    const mounted = store.useState("mounted");
    const hidden = (0,CLE7NTOY/* isHidden */.dK)(mounted, props.hidden, alwaysVisible);
    const style = hidden ? (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props.style), { display: "none" }) : props.style;
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
      id,
      "aria-labelledby": ariaLabelledBy,
      hidden
    }, props), {
      ref: (0,_6O5OEQGF/* useMergeRefs */.SV)(id ? store.setContentElement : null, props.ref),
      style,
      onKeyDown
    });
    const hasCombobox = !!store.combobox;
    composite = composite != null ? composite : !hasCombobox;
    if (composite) {
      props = (0,_4R3V3JGP/* __spreadValues */.IA)({
        role: "menu",
        "aria-orientation": orientation
      }, props);
    }
    props = (0,_7QTPYGNZ/* useComposite */.T)((0,_4R3V3JGP/* __spreadValues */.IA)({ store, composite }, props));
    props = useCompositeTypeahead((0,_4R3V3JGP/* __spreadValues */.IA)({ store, typeahead: !hasCombobox }, props));
    return props;
  }
);
var MenuList = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useMenuList(props);
  return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
});
if (false) {}



// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/QWSZGSIG.js + 2 modules
var QWSZGSIG = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/QWSZGSIG.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/NERBASET.js + 21 modules
var NERBASET = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/NERBASET.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/utils/focus.js
var utils_focus = __webpack_require__("../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/utils/focus.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/menu/menu.js
"use client";

















































// src/menu/menu.tsx




var useMenu = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, {
      store,
      modal: modalProp = false,
      portal = !!modalProp,
      hideOnEscape = true,
      autoFocusOnShow = true,
      hideOnHoverOutside,
      alwaysVisible
    } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, [
      "store",
      "modal",
      "portal",
      "hideOnEscape",
      "autoFocusOnShow",
      "hideOnHoverOutside",
      "alwaysVisible"
    ]);
    const context = useMenuProviderContext();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const ref = (0,react.useRef)(null);
    const parentMenu = store.parent;
    const parentMenubar = store.menubar;
    const hasParentMenu = !!parentMenu;
    const parentIsMenubar = !!parentMenubar && !hasParentMenu;
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props), {
      ref: (0,_6O5OEQGF/* useMergeRefs */.SV)(ref, props.ref)
    });
    const _a2 = useMenuList(
      (0,_4R3V3JGP/* __spreadValues */.IA)({ store, alwaysVisible }, props)
    ), { "aria-labelledby": ariaLabelledBy } = _a2, menuListProps = (0,_4R3V3JGP/* __objRest */.YG)(_a2, ["aria-labelledby"]);
    props = menuListProps;
    const [initialFocusRef, setInitialFocusRef] = (0,react.useState)();
    const autoFocusOnShowState = store.useState("autoFocusOnShow");
    const initialFocus = store.useState("initialFocus");
    const baseElement = store.useState("baseElement");
    const items = store.useState("renderedItems");
    (0,react.useEffect)(() => {
      let cleaning = false;
      setInitialFocusRef((prevInitialFocusRef) => {
        var _a3, _b2, _c;
        if (cleaning)
          return;
        if (!autoFocusOnShowState)
          return;
        if ((_a3 = prevInitialFocusRef == null ? void 0 : prevInitialFocusRef.current) == null ? void 0 : _a3.isConnected)
          return prevInitialFocusRef;
        const ref2 = (0,react.createRef)();
        switch (initialFocus) {
          case "first":
            ref2.current = ((_b2 = items.find((item) => !item.disabled && item.element)) == null ? void 0 : _b2.element) || null;
            break;
          case "last":
            ref2.current = ((_c = [...items].reverse().find((item) => !item.disabled && item.element)) == null ? void 0 : _c.element) || null;
            break;
          default:
            ref2.current = baseElement;
        }
        return ref2;
      });
      return () => {
        cleaning = true;
      };
    }, [store, autoFocusOnShowState, initialFocus, items, baseElement]);
    const modal = hasParentMenu ? false : modalProp;
    const mayAutoFocusOnShow = !!autoFocusOnShow;
    const canAutoFocusOnShow = !!initialFocusRef || !!props.initialFocus || !!modal;
    const contentElement = (0,EKQEJRUF/* useStoreState */.O$)(
      store.combobox || store,
      "contentElement"
    );
    const parentContentElement = (0,EKQEJRUF/* useStoreState */.O$)(
      (parentMenu == null ? void 0 : parentMenu.combobox) || parentMenu,
      "contentElement"
    );
    const preserveTabOrderAnchor = (0,react.useMemo)(() => {
      if (!parentContentElement)
        return;
      if (!contentElement)
        return;
      const role = contentElement.getAttribute("role");
      const parentRole = parentContentElement.getAttribute("role");
      const parentIsMenuOrMenubar = parentRole === "menu" || parentRole === "menubar";
      if (parentIsMenuOrMenubar && role === "menu")
        return;
      return parentContentElement;
    }, [contentElement, parentContentElement]);
    if (preserveTabOrderAnchor !== void 0) {
      props = (0,_4R3V3JGP/* __spreadValues */.IA)({
        preserveTabOrderAnchor
      }, props);
    }
    props = (0,QWSZGSIG/* useHovercard */.a)((0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
      store,
      alwaysVisible,
      initialFocus: initialFocusRef,
      autoFocusOnShow: mayAutoFocusOnShow ? canAutoFocusOnShow && autoFocusOnShow : autoFocusOnShowState || !!modal
    }, props), {
      hideOnEscape: (event) => {
        if ((0,Y3OOHFCN/* isFalsyBooleanCallback */.zO)(hideOnEscape, event))
          return false;
        store == null ? void 0 : store.hideAll();
        return true;
      },
      hideOnHoverOutside: (event) => {
        const disclosureElement = store == null ? void 0 : store.getState().disclosureElement;
        const getHideOnHoverOutside = () => {
          if (typeof hideOnHoverOutside === "function") {
            return hideOnHoverOutside(event);
          }
          if (hideOnHoverOutside != null)
            return hideOnHoverOutside;
          if (hasParentMenu)
            return true;
          if (!parentIsMenubar)
            return false;
          if (!disclosureElement)
            return true;
          if ((0,utils_focus/* hasFocusWithin */.oW)(disclosureElement))
            return false;
          return true;
        };
        if (!getHideOnHoverOutside())
          return false;
        if (event.defaultPrevented)
          return true;
        if (!hasParentMenu)
          return true;
        if (!disclosureElement)
          return true;
        (0,events/* fireEvent */.rC)(disclosureElement, "mouseout", event);
        if (!(0,utils_focus/* hasFocusWithin */.oW)(disclosureElement))
          return true;
        requestAnimationFrame(() => {
          if ((0,utils_focus/* hasFocusWithin */.oW)(disclosureElement))
            return;
          store == null ? void 0 : store.hide();
        });
        return false;
      },
      modal,
      portal,
      backdrop: hasParentMenu ? false : props.backdrop
    }));
    props = (0,_4R3V3JGP/* __spreadValues */.IA)({
      "aria-labelledby": ariaLabelledBy
    }, props);
    return props;
  }
);
var Menu = (0,NERBASET/* createDialogComponent */.AV)(
  (0,_3ORBWXWF/* createComponent */.a0)((props) => {
    const htmlProps = useMenu(props);
    return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
  }),
  useMenuProviderContext
);
if (false) {}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/G6ONQ5EH.js
"use client";





// src/composite/composite-hover.ts




function getMouseDestination(event) {
  const relatedTarget = event.relatedTarget;
  if ((relatedTarget == null ? void 0 : relatedTarget.nodeType) === Node.ELEMENT_NODE) {
    return relatedTarget;
  }
  return null;
}
function hoveringInside(event) {
  const nextElement = getMouseDestination(event);
  if (!nextElement)
    return false;
  return (0,DLOEKDPY/* contains */.gR)(event.currentTarget, nextElement);
}
var G6ONQ5EH_symbol = Symbol("composite-hover");
function movingToAnotherItem(event) {
  let dest = getMouseDestination(event);
  if (!dest)
    return false;
  do {
    if ((0,Y3OOHFCN/* hasOwnProperty */.mQ)(dest, G6ONQ5EH_symbol) && dest[G6ONQ5EH_symbol])
      return true;
    dest = dest.parentElement;
  } while (dest);
  return false;
}
var useCompositeHover = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, {
      store,
      focusOnHover = true,
      blurOnHoverEnd = !!focusOnHover
    } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, [
      "store",
      "focusOnHover",
      "blurOnHoverEnd"
    ]);
    const context = (0,IB7YUKH5/* useCompositeContext */.k)();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const isMouseMoving = (0,_6O5OEQGF/* useIsMouseMoving */.P$)();
    const onMouseMoveProp = props.onMouseMove;
    const focusOnHoverProp = (0,_6O5OEQGF/* useBooleanEvent */.O4)(focusOnHover);
    const onMouseMove = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
      if (event.defaultPrevented)
        return;
      if (!isMouseMoving())
        return;
      if (!focusOnHoverProp(event))
        return;
      if (!(0,utils_focus/* hasFocusWithin */.oW)(event.currentTarget)) {
        const baseElement = store == null ? void 0 : store.getState().baseElement;
        if (baseElement && !(0,utils_focus/* hasFocus */.AJ)(baseElement)) {
          baseElement.focus();
        }
      }
      store == null ? void 0 : store.setActiveId(event.currentTarget.id);
    });
    const onMouseLeaveProp = props.onMouseLeave;
    const blurOnHoverEndProp = (0,_6O5OEQGF/* useBooleanEvent */.O4)(blurOnHoverEnd);
    const onMouseLeave = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      var _a2;
      onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);
      if (event.defaultPrevented)
        return;
      if (!isMouseMoving())
        return;
      if (hoveringInside(event))
        return;
      if (movingToAnotherItem(event))
        return;
      if (!focusOnHoverProp(event))
        return;
      if (!blurOnHoverEndProp(event))
        return;
      store == null ? void 0 : store.setActiveId(null);
      (_a2 = store == null ? void 0 : store.getState().baseElement) == null ? void 0 : _a2.focus();
    });
    const ref = (0,react.useCallback)((element) => {
      if (!element)
        return;
      element[G6ONQ5EH_symbol] = true;
    }, []);
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props), {
      ref: (0,_6O5OEQGF/* useMergeRefs */.SV)(ref, props.ref),
      onMouseMove,
      onMouseLeave
    });
    return props;
  }
);
var CompositeHover = (0,_3ORBWXWF/* createMemoComponent */.MA)(
  (props) => {
    const htmlProps = useCompositeHover(props);
    return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
  }
);
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/Y6467XPW.js
"use client";









// src/menu/menu-item.ts




function menuHasFocus(baseElement, items, currentTarget) {
  var _a;
  if (!baseElement)
    return false;
  if ((0,utils_focus/* hasFocusWithin */.oW)(baseElement))
    return true;
  const expandedItem = items == null ? void 0 : items.find((item) => {
    var _a2;
    if (item.element === currentTarget)
      return false;
    return ((_a2 = item.element) == null ? void 0 : _a2.getAttribute("aria-expanded")) === "true";
  });
  const expandedMenuId = (_a = expandedItem == null ? void 0 : expandedItem.element) == null ? void 0 : _a.getAttribute("aria-controls");
  if (!expandedMenuId)
    return false;
  const doc = (0,DLOEKDPY/* getDocument */.YE)(baseElement);
  const expandedMenu = doc.getElementById(expandedMenuId);
  if (!expandedMenu)
    return false;
  if ((0,utils_focus/* hasFocusWithin */.oW)(expandedMenu))
    return true;
  return !!expandedMenu.querySelector("[role=menuitem][aria-expanded=true]");
}
var useMenuItem = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, {
      store,
      hideOnClick = true,
      preventScrollOnKeyDown = true,
      focusOnHover,
      blurOnHoverEnd
    } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, [
      "store",
      "hideOnClick",
      "preventScrollOnKeyDown",
      "focusOnHover",
      "blurOnHoverEnd"
    ]);
    const menuContext = useMenuScopedContext(true);
    const menubarContext = KA4GX64Z_useMenubarScopedContext();
    store = store || menuContext || menubarContext;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const onClickProp = props.onClick;
    const hideOnClickProp = (0,_6O5OEQGF/* useBooleanEvent */.O4)(hideOnClick);
    const hideMenu = "hideAll" in store ? store.hideAll : void 0;
    const isWithinMenu = !!hideMenu;
    const onClick = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (event.defaultPrevented)
        return;
      if ((0,events/* isDownloading */.RN)(event))
        return;
      if ((0,events/* isOpeningInNewTab */.$b)(event))
        return;
      if (!hideMenu)
        return;
      const popupType = event.currentTarget.getAttribute("aria-haspopup");
      if (popupType === "menu")
        return;
      if (!hideOnClickProp(event))
        return;
      hideMenu();
    });
    const contentElement = (0,EKQEJRUF/* useStoreState */.O$)(
      store,
      (state) => "contentElement" in state ? state.contentElement : null
    );
    const role = (0,DLOEKDPY/* getPopupItemRole */.cn)(contentElement, "menuitem");
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
      role
    }, props), {
      onClick
    });
    props = (0,QZLXIDNP/* useCompositeItem */.k)((0,_4R3V3JGP/* __spreadValues */.IA)({ store, preventScrollOnKeyDown }, props));
    props = useCompositeHover((0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
      store
    }, props), {
      focusOnHover(event) {
        const getFocusOnHover = () => {
          if (typeof focusOnHover === "function")
            return focusOnHover(event);
          if (focusOnHover != null)
            return focusOnHover;
          return true;
        };
        if (!store)
          return false;
        if (!getFocusOnHover())
          return false;
        const { baseElement, items } = store.getState();
        if (isWithinMenu) {
          if (event.currentTarget.hasAttribute("aria-expanded")) {
            event.currentTarget.focus();
          }
          return true;
        }
        if (menuHasFocus(baseElement, items, event.currentTarget)) {
          event.currentTarget.focus();
          return true;
        }
        return false;
      },
      blurOnHoverEnd(event) {
        if (typeof blurOnHoverEnd === "function")
          return blurOnHoverEnd(event);
        if (blurOnHoverEnd != null)
          return blurOnHoverEnd;
        return isWithinMenu;
      }
    }));
    return props;
  }
);
var MenuItem = (0,_3ORBWXWF/* createMemoComponent */.MA)((props) => {
  const htmlProps = useMenuItem(props);
  return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
});
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/checkbox/checkbox-store.js
"use client";




// src/checkbox/checkbox-store.ts
function createCheckboxStore(props = {}) {
  var _a;
  (0,EAHJFCU4/* throwOnConflictingProps */.UE)(props, props.store);
  const syncState = (_a = props.store) == null ? void 0 : _a.getState();
  const initialState = {
    value: (0,Y3OOHFCN/* defaultValue */.Jh)(
      props.value,
      syncState == null ? void 0 : syncState.value,
      props.defaultValue,
      false
    )
  };
  const checkbox = (0,EAHJFCU4/* createStore */.y$)(initialState, props.store);
  return (0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, checkbox), {
    setValue: (value) => checkbox.setState("value", value)
  });
}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/JIZ5C2JK.js
"use client";



// src/checkbox/checkbox-store.ts

function useCheckboxStoreProps(store, update, props) {
  (0,_6O5OEQGF/* useUpdateEffect */.w5)(update, [props.store]);
  (0,EKQEJRUF/* useStoreProps */.Tz)(store, props, "value", "setValue");
  return store;
}
function useCheckboxStore(props = {}) {
  const [store, update] = (0,EKQEJRUF/* useStore */.Pj)(createCheckboxStore, props);
  return useCheckboxStoreProps(store, update, props);
}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/VPR2WHQV.js
"use client";


// src/checkbox/checkbox-context.tsx
var VPR2WHQV_ctx = (0,_3ORBWXWF/* createStoreContext */.B0)();
var useCheckboxContext = VPR2WHQV_ctx.useContext;
var useCheckboxScopedContext = VPR2WHQV_ctx.useScopedContext;
var useCheckboxProviderContext = VPR2WHQV_ctx.useProviderContext;
var CheckboxContextProvider = VPR2WHQV_ctx.ContextProvider;
var CheckboxScopedContextProvider = VPR2WHQV_ctx.ScopedContextProvider;



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/3AHQ6JCP.js
"use client";








// src/checkbox/checkbox.tsx



function setMixed(element, mixed) {
  if (mixed) {
    element.indeterminate = true;
  } else if (element.indeterminate) {
    element.indeterminate = false;
  }
}
function isNativeCheckbox(tagName, type) {
  return tagName === "input" && (!type || type === "checkbox");
}
function getPrimitiveValue(value) {
  if (Array.isArray(value)) {
    return value.toString();
  }
  return value;
}
var useCheckbox = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, {
      store,
      name,
      value: valueProp,
      checked: checkedProp,
      defaultChecked
    } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, [
      "store",
      "name",
      "value",
      "checked",
      "defaultChecked"
    ]);
    const context = useCheckboxContext();
    store = store || context;
    const [_checked, setChecked] = (0,react.useState)(defaultChecked != null ? defaultChecked : false);
    const checked = (0,EKQEJRUF/* useStoreState */.O$)(store, (state) => {
      if (checkedProp !== void 0)
        return checkedProp;
      if ((state == null ? void 0 : state.value) === void 0)
        return _checked;
      if (valueProp != null) {
        if (Array.isArray(state.value)) {
          const primitiveValue = getPrimitiveValue(valueProp);
          return state.value.includes(primitiveValue);
        }
        return state.value === valueProp;
      }
      if (Array.isArray(state.value))
        return false;
      if (typeof state.value === "boolean")
        return state.value;
      return false;
    });
    const ref = (0,react.useRef)(null);
    const tagName = (0,_6O5OEQGF/* useTagName */.vO)(ref, props.as || "input");
    const nativeCheckbox = isNativeCheckbox(tagName, props.type);
    const mixed = checked ? checked === "mixed" : void 0;
    const isChecked = checked === "mixed" ? false : checked;
    const disabled = (0,Y3OOHFCN/* disabledFromProps */.$f)(props);
    const [propertyUpdated, schedulePropertyUpdate] = (0,_6O5OEQGF/* useForceUpdate */.CH)();
    (0,react.useEffect)(() => {
      const element = ref.current;
      if (!element)
        return;
      setMixed(element, mixed);
      if (nativeCheckbox)
        return;
      element.checked = isChecked;
      if (name !== void 0) {
        element.name = name;
      }
      if (valueProp !== void 0) {
        element.value = `${valueProp}`;
      }
    }, [propertyUpdated, mixed, nativeCheckbox, isChecked, name, valueProp]);
    const onChangeProp = props.onChange;
    const onChange = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      if (disabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      setMixed(event.currentTarget, mixed);
      if (!nativeCheckbox) {
        event.currentTarget.checked = !event.currentTarget.checked;
        schedulePropertyUpdate();
      }
      onChangeProp == null ? void 0 : onChangeProp(event);
      if (event.defaultPrevented)
        return;
      const elementChecked = event.currentTarget.checked;
      setChecked(elementChecked);
      store == null ? void 0 : store.setValue((prevValue) => {
        if (valueProp == null)
          return elementChecked;
        const primitiveValue = getPrimitiveValue(valueProp);
        if (!Array.isArray(prevValue)) {
          return prevValue === primitiveValue ? false : primitiveValue;
        }
        if (elementChecked) {
          if (prevValue.includes(primitiveValue)) {
            return prevValue;
          }
          return [...prevValue, primitiveValue];
        }
        return prevValue.filter((v) => v !== primitiveValue);
      });
    });
    const onClickProp = props.onClick;
    const onClick = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (event.defaultPrevented)
        return;
      if (nativeCheckbox)
        return;
      onChange(event);
    });
    props = (0,_6O5OEQGF/* useWrapElement */.w7)(
      props,
      (element) => /* @__PURE__ */ (0,jsx_runtime.jsx)(CheckboxCheckedContext.Provider, { value: isChecked, children: element }),
      [isChecked]
    );
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
      role: !nativeCheckbox ? "checkbox" : void 0,
      type: nativeCheckbox ? "checkbox" : void 0,
      "aria-checked": checked
    }, props), {
      ref: (0,_6O5OEQGF/* useMergeRefs */.SV)(ref, props.ref),
      onChange,
      onClick
    });
    props = (0,NWCBQ4CV/* useCommand */.D)((0,_4R3V3JGP/* __spreadValues */.IA)({ clickOnEnter: !nativeCheckbox }, props));
    return (0,_4R3V3JGP/* __spreadValues */.IA)({
      name: nativeCheckbox ? name : void 0,
      value: nativeCheckbox ? valueProp : void 0,
      checked: isChecked
    }, props);
  }
);
var Checkbox = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useCheckbox(props);
  return (0,_3ORBWXWF/* createElement */.n)("input", htmlProps);
});
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/menu/menu-item-checkbox.js
"use client";


























// src/menu/menu-item-checkbox.ts


function menu_item_checkbox_getPrimitiveValue(value) {
  if (Array.isArray(value)) {
    return value.toString();
  }
  return value;
}
function getValue(storeValue, value, checked) {
  if (value === void 0) {
    if (Array.isArray(storeValue))
      return storeValue;
    return !!checked;
  }
  const primitiveValue = menu_item_checkbox_getPrimitiveValue(value);
  if (!Array.isArray(storeValue)) {
    if (checked) {
      return primitiveValue;
    }
    return storeValue === primitiveValue ? false : storeValue;
  }
  if (checked) {
    if (storeValue.includes(primitiveValue)) {
      return storeValue;
    }
    return [...storeValue, primitiveValue];
  }
  return storeValue.filter((v) => v !== primitiveValue);
}
var useMenuItemCheckbox = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, {
      store,
      name,
      value,
      checked,
      defaultChecked: defaultCheckedProp,
      hideOnClick = false
    } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, [
      "store",
      "name",
      "value",
      "checked",
      "defaultChecked",
      "hideOnClick"
    ]);
    const context = useMenuScopedContext();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const defaultChecked = (0,_6O5OEQGF/* useInitialValue */.nf)(defaultCheckedProp);
    (0,react.useEffect)(() => {
      store == null ? void 0 : store.setValue(name, (prevValue = []) => {
        if (!defaultChecked)
          return prevValue;
        return getValue(prevValue, value, true);
      });
    }, [store, name, value, defaultChecked]);
    (0,react.useEffect)(() => {
      if (checked === void 0)
        return;
      store == null ? void 0 : store.setValue(name, (prevValue) => {
        return getValue(prevValue, value, checked);
      });
    }, [store, name, value, checked]);
    const checkboxStore = useCheckboxStore({
      value: store.useState((state) => state.values[name]),
      setValue(internalValue) {
        store == null ? void 0 : store.setValue(name, () => {
          if (checked === void 0)
            return internalValue;
          const nextValue = getValue(internalValue, value, checked);
          if (!Array.isArray(nextValue))
            return nextValue;
          if (!Array.isArray(internalValue))
            return nextValue;
          if ((0,Y3OOHFCN/* shallowEqual */.bN)(internalValue, nextValue))
            return internalValue;
          return nextValue;
        });
      }
    });
    props = (0,_4R3V3JGP/* __spreadValues */.IA)({
      role: "menuitemcheckbox"
    }, props);
    props = useCheckbox((0,_4R3V3JGP/* __spreadValues */.IA)({
      store: checkboxStore,
      name,
      value,
      checked
    }, props));
    props = useMenuItem((0,_4R3V3JGP/* __spreadValues */.IA)({ store, hideOnClick }, props));
    return props;
  }
);
var MenuItemCheckbox = (0,_3ORBWXWF/* createMemoComponent */.MA)(
  (props) => {
    const htmlProps = useMenuItemCheckbox(props);
    return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
  }
);
if (false) {}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/XEV62JUQ.js
"use client";



// src/radio/radio-context.tsx
var XEV62JUQ_ctx = (0,_3ORBWXWF/* createStoreContext */.B0)(
  [IB7YUKH5/* CompositeContextProvider */.ws],
  [IB7YUKH5/* CompositeScopedContextProvider */.aN]
);
var useRadioContext = XEV62JUQ_ctx.useContext;
var useRadioScopedContext = XEV62JUQ_ctx.useScopedContext;
var useRadioProviderContext = XEV62JUQ_ctx.useProviderContext;
var RadioContextProvider = XEV62JUQ_ctx.ContextProvider;
var RadioScopedContextProvider = XEV62JUQ_ctx.ScopedContextProvider;



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/JL6IRDFK.js
"use client";







// src/radio/radio.ts


function getIsChecked(value, storeValue) {
  if (storeValue === void 0)
    return;
  if (value != null && storeValue != null) {
    return storeValue === value;
  }
  return !!storeValue;
}
function isNativeRadio(tagName, type) {
  return tagName === "input" && (!type || type === "radio");
}
var useRadio = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store, name, value, checked } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store", "name", "value", "checked"]);
    const context = useRadioContext();
    store = store || context;
    const id = (0,_6O5OEQGF/* useId */.Bi)(props.id);
    const ref = (0,react.useRef)(null);
    const isChecked = (0,EKQEJRUF/* useStoreState */.O$)(
      store,
      (state) => checked != null ? checked : getIsChecked(value, state == null ? void 0 : state.value)
    );
    (0,react.useEffect)(() => {
      if (!id)
        return;
      if (!isChecked)
        return;
      const isActiveItem = (store == null ? void 0 : store.getState().activeId) === id;
      if (isActiveItem)
        return;
      store == null ? void 0 : store.setActiveId(id);
    }, [store, isChecked, id]);
    const onChangeProp = props.onChange;
    const tagName = (0,_6O5OEQGF/* useTagName */.vO)(ref, props.as || "input");
    const nativeRadio = isNativeRadio(tagName, props.type);
    const disabled = (0,Y3OOHFCN/* disabledFromProps */.$f)(props);
    const [propertyUpdated, schedulePropertyUpdate] = (0,_6O5OEQGF/* useForceUpdate */.CH)();
    (0,react.useEffect)(() => {
      const element = ref.current;
      if (!element)
        return;
      if (nativeRadio)
        return;
      if (isChecked !== void 0) {
        element.checked = isChecked;
      }
      if (name !== void 0) {
        element.name = name;
      }
      if (value !== void 0) {
        element.value = `${value}`;
      }
    }, [propertyUpdated, nativeRadio, isChecked, name, value]);
    const onChange = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      if (disabled) {
        event.preventDefault();
        event.stopPropagation();
        return;
      }
      if (!nativeRadio) {
        event.currentTarget.checked = true;
        schedulePropertyUpdate();
      }
      onChangeProp == null ? void 0 : onChangeProp(event);
      if (event.defaultPrevented)
        return;
      store == null ? void 0 : store.setValue(value);
    });
    const onClickProp = props.onClick;
    const onClick = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (event.defaultPrevented)
        return;
      if (nativeRadio)
        return;
      onChange(event);
    });
    const onFocusProp = props.onFocus;
    const onFocus = (0,_6O5OEQGF/* useEvent */._q)((event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      if (event.defaultPrevented)
        return;
      if (!nativeRadio)
        return;
      if (!store)
        return;
      const { moves, activeId } = store.getState();
      if (!moves)
        return;
      if (id && activeId !== id)
        return;
      onChange(event);
    });
    props = (0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({
      id,
      role: !nativeRadio ? "radio" : void 0,
      type: nativeRadio ? "radio" : void 0,
      "aria-checked": isChecked
    }, props), {
      ref: (0,_6O5OEQGF/* useMergeRefs */.SV)(ref, props.ref),
      onChange,
      onClick,
      onFocus
    });
    props = (0,QZLXIDNP/* useCompositeItem */.k)((0,_4R3V3JGP/* __spreadValues */.IA)({ store, clickOnEnter: !nativeRadio }, props));
    return (0,_4R3V3JGP/* __spreadValues */.IA)({
      name: nativeRadio ? name : void 0,
      value: nativeRadio ? value : void 0,
      checked: isChecked
    }, props);
  }
);
var Radio = (0,_3ORBWXWF/* createMemoComponent */.MA)((props) => {
  const htmlProps = useRadio(props);
  return (0,_3ORBWXWF/* createElement */.n)("input", htmlProps);
});
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/menu/menu-item-radio.js
"use client";
























// src/menu/menu-item-radio.tsx



function menu_item_radio_getValue(prevValue, value, checked) {
  if (checked === void 0)
    return prevValue;
  if (checked)
    return value;
  return prevValue;
}
var useMenuItemRadio = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, {
      store,
      name,
      value,
      checked,
      onChange: onChangeProp,
      hideOnClick = false
    } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, [
      "store",
      "name",
      "value",
      "checked",
      "onChange",
      "hideOnClick"
    ]);
    const context = useMenuScopedContext();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const defaultChecked = (0,_6O5OEQGF/* useInitialValue */.nf)(props.defaultChecked);
    (0,react.useEffect)(() => {
      store == null ? void 0 : store.setValue(name, (prevValue = false) => {
        return menu_item_radio_getValue(prevValue, value, defaultChecked);
      });
    }, [store, name, value, defaultChecked]);
    (0,react.useEffect)(() => {
      if (checked === void 0)
        return;
      store == null ? void 0 : store.setValue(name, (prevValue) => {
        return menu_item_radio_getValue(prevValue, value, checked);
      });
    }, [store, name, value, checked]);
    const isChecked = store.useState((state) => state.values[name] === value);
    props = (0,_6O5OEQGF/* useWrapElement */.w7)(
      props,
      (element) => /* @__PURE__ */ (0,jsx_runtime.jsx)(MenuItemCheckedContext.Provider, { value: !!isChecked, children: element }),
      [isChecked]
    );
    props = (0,_4R3V3JGP/* __spreadValues */.IA)({
      role: "menuitemradio"
    }, props);
    props = useRadio((0,_4R3V3JGP/* __spreadValues */.IA)({
      name,
      value,
      checked: isChecked,
      onChange: (event) => {
        onChangeProp == null ? void 0 : onChangeProp(event);
        if (event.defaultPrevented)
          return;
        const element = event.currentTarget;
        store == null ? void 0 : store.setValue(name, (prevValue) => {
          return menu_item_radio_getValue(prevValue, value, checked != null ? checked : element.checked);
        });
      }
    }, props));
    props = useMenuItem((0,_4R3V3JGP/* __spreadValues */.IA)({ store, hideOnClick }, props));
    return props;
  }
);
var MenuItemRadio = (0,_3ORBWXWF/* createMemoComponent */.MA)(
  (props) => {
    const htmlProps = useMenuItemRadio(props);
    return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
  }
);
if (false) {}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/menu/menu-group.js
"use client";








// src/menu/menu-group.ts
var useMenuGroup = (0,_3ORBWXWF/* createHook */.ab)((props) => {
  props = useCompositeGroup(props);
  return props;
});
var MenuGroup = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useMenuGroup(props);
  return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
});
if (false) {}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/YZEJGRDQ.js
"use client";



// src/separator/separator.ts
var useSeparator = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { orientation = "horizontal" } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["orientation"]);
    props = (0,_4R3V3JGP/* __spreadValues */.IA)({
      role: "separator",
      "aria-orientation": orientation
    }, props);
    return props;
  }
);
var Separator = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useSeparator(props);
  return (0,_3ORBWXWF/* createElement */.n)("hr", htmlProps);
});
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/ENRQQ6LK.js
"use client";





// src/composite/composite-separator.ts

var useCompositeSeparator = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store"]);
    const context = (0,IB7YUKH5/* useCompositeContext */.k)();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    const orientation = store.useState(
      (state) => state.orientation === "horizontal" ? "vertical" : "horizontal"
    );
    props = useSeparator((0,_4R3V3JGP/* __spreadProps */.ko)((0,_4R3V3JGP/* __spreadValues */.IA)({}, props), { orientation }));
    return props;
  }
);
var CompositeSeparator = (0,_3ORBWXWF/* createComponent */.a0)(
  (props) => {
    const htmlProps = useCompositeSeparator(props);
    return (0,_3ORBWXWF/* createElement */.n)("hr", htmlProps);
  }
);
if (false) {}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/menu/menu-separator.js
"use client";















// src/menu/menu-separator.ts
var useMenuSeparator = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store"]);
    const context = useMenuContext();
    store = store || context;
    props = useCompositeSeparator((0,_4R3V3JGP/* __spreadValues */.IA)({ store }, props));
    return props;
  }
);
var MenuSeparator = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useMenuSeparator(props);
  return (0,_3ORBWXWF/* createElement */.n)("hr", htmlProps);
});
if (false) {}


// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1/node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var emotion_react_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1/node_modules/@emotion/react/dist/emotion-react.browser.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/colors-values.js
var colors_values = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/colors-values.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/config-values.js
var config_values = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/config-values.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/font.js + 1 modules
var font = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/font.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/rtl.js
var rtl = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/rtl.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/space.js
var space = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/space.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/view/component.js
var view_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/view/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/truncate/hook.js + 2 modules
var hook = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/truncate/hook.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/truncate/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function UnconnectedTruncate(props, forwardedRef) {
  const truncateProps = (0,hook/* default */.A)(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
    as: "span",
    ...truncateProps,
    ref: forwardedRef
  });
}

/**
 * `Truncate` is a typography primitive that trims text content.
 * For almost all cases, it is recommended that `Text`, `Heading`, or
 * `Subheading` is used to render text content. However,`Truncate` is
 * available for custom implementations.
 *
 * ```jsx
 * import { __experimentalTruncate as Truncate } from `@wordpress/components`;
 *
 * function Example() {
 * 	return (
 * 		<Truncate>
 * 			Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc ex
 * 			neque, vulputate a diam et, luctus convallis lacus. Vestibulum ac
 * 			mollis mi. Morbi id elementum massa.
 * 		</Truncate>
 * 	);
 * }
 * ```
 */
const Truncate = (0,context_connect/* contextConnect */.KZ)(UnconnectedTruncate, 'Truncate');
/* harmony default export */ const truncate_component = (Truncate);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/dropdown-menu-v2/styles.js

function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports


/**
 * Internal dependencies
 */




const ANIMATION_PARAMS = {
  SLIDE_AMOUNT: '2px',
  DURATION: '400ms',
  EASING: 'cubic-bezier( 0.16, 1, 0.3, 1 )'
};
const CONTENT_WRAPPER_PADDING = (0,space/* space */.x)(1);
const ITEM_PADDING_BLOCK = (0,space/* space */.x)(2);
const ITEM_PADDING_INLINE = (0,space/* space */.x)(3);

// TODO:
// - those values are different from saved variables?
// - should bring this into the config, and make themeable
// - border color and divider color are different?
const DEFAULT_BORDER_COLOR = colors_values/* COLORS */.l.gray[300];
const DIVIDER_COLOR = colors_values/* COLORS */.l.gray[200];
const TOOLBAR_VARIANT_BORDER_COLOR = colors_values/* COLORS */.l.gray['900'];
const DEFAULT_BOX_SHADOW = `0 0 0 ${config_values/* default */.A.borderWidth} ${DEFAULT_BORDER_COLOR}, ${config_values/* default */.A.popoverShadow}`;
const TOOLBAR_VARIANT_BOX_SHADOW = `0 0 0 ${config_values/* default */.A.borderWidth} ${TOOLBAR_VARIANT_BORDER_COLOR}`;
const GRID_TEMPLATE_COLS = 'minmax( 0, max-content ) 1fr';
const slideUpAndFade = (0,emotion_react_browser_esm/* keyframes */.i7)({
  '0%': {
    opacity: 0,
    transform: `translateY(${ANIMATION_PARAMS.SLIDE_AMOUNT})`
  },
  '100%': {
    opacity: 1,
    transform: 'translateY(0)'
  }
});
const slideRightAndFade = (0,emotion_react_browser_esm/* keyframes */.i7)({
  '0%': {
    opacity: 0,
    transform: `translateX(-${ANIMATION_PARAMS.SLIDE_AMOUNT})`
  },
  '100%': {
    opacity: 1,
    transform: 'translateX(0)'
  }
});
const slideDownAndFade = (0,emotion_react_browser_esm/* keyframes */.i7)({
  '0%': {
    opacity: 0,
    transform: `translateY(-${ANIMATION_PARAMS.SLIDE_AMOUNT})`
  },
  '100%': {
    opacity: 1,
    transform: 'translateY(0)'
  }
});
const slideLeftAndFade = (0,emotion_react_browser_esm/* keyframes */.i7)({
  '0%': {
    opacity: 0,
    transform: `translateX(${ANIMATION_PARAMS.SLIDE_AMOUNT})`
  },
  '100%': {
    opacity: 1,
    transform: 'translateX(0)'
  }
});
const DropdownMenu = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(Menu,  true ? {
  target: "e1kdzosf12"
} : 0)("position:relative;z-index:1000000;display:grid;grid-template-columns:", GRID_TEMPLATE_COLS, ";grid-template-rows:auto;box-sizing:border-box;min-width:160px;max-width:320px;max-height:var( --popover-available-height );padding:", CONTENT_WRAPPER_PADDING, ";background-color:", colors_values/* COLORS */.l.ui.background, ";border-radius:4px;", props => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("box-shadow:", props.variant === 'toolbar' ? TOOLBAR_VARIANT_BOX_SHADOW : DEFAULT_BOX_SHADOW, ";" + ( true ? "" : 0),  true ? "" : 0), " overscroll-behavior:contain;overflow:auto;outline:2px solid transparent!important;animation-duration:", ANIMATION_PARAMS.DURATION, ";animation-timing-function:", ANIMATION_PARAMS.EASING, ";will-change:transform,opacity;animation-name:", slideDownAndFade, ";&[data-side='right']{animation-name:", slideLeftAndFade, ";}&[data-side='bottom']{animation-name:", slideUpAndFade, ";}&[data-side='left']{animation-name:", slideRightAndFade, ";}@media ( prefers-reduced-motion ){animation-duration:0s;}" + ( true ? "" : 0));
const baseItem = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("all:unset;position:relative;min-height:", (0,space/* space */.x)(10), ";box-sizing:border-box;grid-column:1/-1;display:grid;grid-template-columns:", GRID_TEMPLATE_COLS, ";align-items:center;@supports ( grid-template-columns: subgrid ){grid-template-columns:subgrid;}font-size:", (0,font/* font */.g)('default.fontSize'), ";font-family:inherit;font-weight:normal;line-height:20px;color:", colors_values/* COLORS */.l.gray[900], ";border-radius:", config_values/* default */.A.radiusBlockUi, ";padding-block:", ITEM_PADDING_BLOCK, ";padding-inline:", ITEM_PADDING_INLINE, ";scroll-margin:", CONTENT_WRAPPER_PADDING, ";user-select:none;outline:none;&[aria-disabled='true']{color:", colors_values/* COLORS */.l.ui.textDisabled, ";cursor:not-allowed;}&[data-active-item]:not( [data-focus-visible] ):not(\n\t\t\t[aria-disabled='true']\n\t\t){background-color:", colors_values/* COLORS */.l.theme.accent, ";color:", colors_values/* COLORS */.l.white, ";}&[data-focus-visible]{box-shadow:0 0 0 1.5px ", colors_values/* COLORS */.l.theme.accent, ";outline:2px solid transparent;}&:active,&[data-active]{}", DropdownMenu, ":not(:focus) &:not(:focus)[aria-expanded=\"true\"]{background-color:", colors_values/* COLORS */.l.gray[100], ";color:", colors_values/* COLORS */.l.gray[900], ";}svg{fill:currentColor;}" + ( true ? "" : 0),  true ? "" : 0);
const styles_DropdownMenuItem = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(MenuItem,  true ? {
  target: "e1kdzosf11"
} : 0)(baseItem, ";" + ( true ? "" : 0));
const styles_DropdownMenuCheckboxItem = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(MenuItemCheckbox,  true ? {
  target: "e1kdzosf10"
} : 0)(baseItem, ";" + ( true ? "" : 0));
const styles_DropdownMenuRadioItem = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(MenuItemRadio,  true ? {
  target: "e1kdzosf9"
} : 0)(baseItem, ";" + ( true ? "" : 0));
const ItemPrefixWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1kdzosf8"
} : 0)("grid-column:1;", styles_DropdownMenuCheckboxItem, ">&,", styles_DropdownMenuRadioItem, ">&{min-width:", (0,space/* space */.x)(6), ";}", styles_DropdownMenuCheckboxItem, ">&,", styles_DropdownMenuRadioItem, ">&,&:not( :empty ){margin-inline-end:", (0,space/* space */.x)(2), ";}display:flex;align-items:center;justify-content:center;color:", colors_values/* COLORS */.l.gray['700'], ";[data-active-item]:not( [data-focus-visible] )>&,[aria-disabled='true']>&{color:inherit;}" + ( true ? "" : 0));
const DropdownMenuItemContentWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1kdzosf7"
} : 0)("grid-column:2;display:flex;align-items:center;justify-content:space-between;gap:", (0,space/* space */.x)(3), ";pointer-events:none;" + ( true ? "" : 0));
const DropdownMenuItemChildrenWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1kdzosf6"
} : 0)("flex:1;display:inline-flex;flex-direction:column;gap:", (0,space/* space */.x)(1), ";" + ( true ? "" : 0));
const ItemSuffixWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1kdzosf5"
} : 0)("flex:0 1 fit-content;min-width:0;width:fit-content;display:flex;align-items:center;justify-content:center;gap:", (0,space/* space */.x)(3), ";color:", colors_values/* COLORS */.l.gray['700'], ";[data-active-item]:not( [data-focus-visible] ) *:not(", DropdownMenu, ") &,[aria-disabled='true'] *:not(", DropdownMenu, ") &{color:inherit;}" + ( true ? "" : 0));
const styles_DropdownMenuGroup = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(MenuGroup,  true ? {
  target: "e1kdzosf4"
} : 0)( true ? {
  name: "49aokf",
  styles: "display:contents"
} : 0);
const styles_DropdownMenuSeparator = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(MenuSeparator,  true ? {
  target: "e1kdzosf3"
} : 0)("grid-column:1/-1;border:none;height:", config_values/* default */.A.borderWidth, ";background-color:", props => props.variant === 'toolbar' ? TOOLBAR_VARIANT_BORDER_COLOR : DIVIDER_COLOR, ";margin-block:", (0,space/* space */.x)(2), ";margin-inline:", ITEM_PADDING_INLINE, ";outline:2px solid transparent;" + ( true ? "" : 0));
const SubmenuChevronIcon = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(components_build_module_icon/* default */.A,  true ? {
  target: "e1kdzosf2"
} : 0)("width:", (0,space/* space */.x)(1.5), ";", (0,rtl/* rtl */.h)({
  transform: `scaleX(1)`
}, {
  transform: `scaleX(-1)`
}), ";" + ( true ? "" : 0));
const styles_DropdownMenuItemLabel = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(truncate_component,  true ? {
  target: "e1kdzosf1"
} : 0)("font-size:", (0,font/* font */.g)('default.fontSize'), ";line-height:20px;color:inherit;" + ( true ? "" : 0));
const styles_DropdownMenuItemHelpText = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(truncate_component,  true ? {
  target: "e1kdzosf0"
} : 0)("font-size:", (0,font/* font */.g)('helpText.fontSize'), ";line-height:16px;color:", colors_values/* COLORS */.l.gray['700'], ";[data-active-item]:not( [data-focus-visible] ) *:not( ", DropdownMenu, " ) &,[aria-disabled='true'] *:not( ", DropdownMenu, " ) &{color:inherit;}" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/dropdown-menu-v2/index.js
/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






const DropdownMenuContext = (0,react.createContext)(undefined);
const DropdownMenuItem = (0,react.forwardRef)(function DropdownMenuItem({
  prefix,
  suffix,
  children,
  hideOnClick = true,
  ...props
}, ref) {
  const dropdownMenuContext = (0,react.useContext)(DropdownMenuContext);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(styles_DropdownMenuItem, {
    ref: ref,
    ...props,
    accessibleWhenDisabled: true,
    hideOnClick: hideOnClick,
    store: dropdownMenuContext?.store,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(ItemPrefixWrapper, {
      children: prefix
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(DropdownMenuItemContentWrapper, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(DropdownMenuItemChildrenWrapper, {
        children: children
      }), suffix && /*#__PURE__*/(0,jsx_runtime.jsx)(ItemSuffixWrapper, {
        children: suffix
      })]
    })]
  });
});
const DropdownMenuCheckboxItem = (0,react.forwardRef)(function DropdownMenuCheckboxItem({
  suffix,
  children,
  hideOnClick = false,
  ...props
}, ref) {
  const dropdownMenuContext = (0,react.useContext)(DropdownMenuContext);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(styles_DropdownMenuCheckboxItem, {
    ref: ref,
    ...props,
    accessibleWhenDisabled: true,
    hideOnClick: hideOnClick,
    store: dropdownMenuContext?.store,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(MenuItemCheck, {
      store: dropdownMenuContext?.store,
      render: /*#__PURE__*/(0,jsx_runtime.jsx)(ItemPrefixWrapper, {})
      // Override some ariakit inline styles
      ,
      style: {
        width: 'auto',
        height: 'auto'
      },
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
        icon: check/* default */.A,
        size: 24
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(DropdownMenuItemContentWrapper, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(DropdownMenuItemChildrenWrapper, {
        children: children
      }), suffix && /*#__PURE__*/(0,jsx_runtime.jsx)(ItemSuffixWrapper, {
        children: suffix
      })]
    })]
  });
});
const radioCheck = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* Circle */.jl, {
    cx: 12,
    cy: 12,
    r: 3
  })
});
const DropdownMenuRadioItem = (0,react.forwardRef)(function DropdownMenuRadioItem({
  suffix,
  children,
  hideOnClick = false,
  ...props
}, ref) {
  const dropdownMenuContext = (0,react.useContext)(DropdownMenuContext);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(styles_DropdownMenuRadioItem, {
    ref: ref,
    ...props,
    accessibleWhenDisabled: true,
    hideOnClick: hideOnClick,
    store: dropdownMenuContext?.store,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(MenuItemCheck, {
      store: dropdownMenuContext?.store,
      render: /*#__PURE__*/(0,jsx_runtime.jsx)(ItemPrefixWrapper, {})
      // Override some ariakit inline styles
      ,
      style: {
        width: 'auto',
        height: 'auto'
      },
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
        icon: radioCheck,
        size: 24
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(DropdownMenuItemContentWrapper, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(DropdownMenuItemChildrenWrapper, {
        children: children
      }), suffix && /*#__PURE__*/(0,jsx_runtime.jsx)(ItemSuffixWrapper, {
        children: suffix
      })]
    })]
  });
});
const DropdownMenuGroup = (0,react.forwardRef)(function DropdownMenuGroup(props, ref) {
  const dropdownMenuContext = (0,react.useContext)(DropdownMenuContext);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(styles_DropdownMenuGroup, {
    ref: ref,
    ...props,
    store: dropdownMenuContext?.store
  });
});
const UnconnectedDropdownMenu = (props, ref) => {
  var _props$placement;
  const {
    // Store props
    open,
    defaultOpen = false,
    onOpenChange,
    placement,
    // Menu trigger props
    trigger,
    // Menu props
    gutter,
    children,
    shift,
    modal = true,
    // From internal components context
    variant,
    // Rest
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'DropdownMenu');
  const parentContext = (0,react.useContext)(DropdownMenuContext);
  const computedDirection = (0,i18n_build_module/* isRTL */.V8)() ? 'rtl' : 'ltr';

  // If an explicit value for the `placement` prop is not passed,
  // apply a default placement of `bottom-start` for the root dropdown,
  // and of `right-start` for nested dropdowns.
  let computedPlacement = (_props$placement = props.placement) !== null && _props$placement !== void 0 ? _props$placement : parentContext?.store ? 'right-start' : 'bottom-start';
  // Swap left/right in case of RTL direction
  if (computedDirection === 'rtl') {
    if (/right/.test(computedPlacement)) {
      computedPlacement = computedPlacement.replace('right', 'left');
    } else if (/left/.test(computedPlacement)) {
      computedPlacement = computedPlacement.replace('left', 'right');
    }
  }
  const dropdownMenuStore = useMenuStore({
    parent: parentContext?.store,
    open,
    defaultOpen,
    placement: computedPlacement,
    focusLoop: true,
    setOpen(willBeOpen) {
      onOpenChange?.(willBeOpen);
    },
    rtl: computedDirection === 'rtl'
  });
  const contextValue = (0,react.useMemo)(() => ({
    store: dropdownMenuStore,
    variant
  }), [dropdownMenuStore, variant]);

  // Extract the side from the applied placement — useful for animations.
  const appliedPlacementSide = dropdownMenuStore.useState('placement').split('-')[0];
  if (dropdownMenuStore.parent && !((0,react.isValidElement)(trigger) && DropdownMenuItem === trigger.type)) {
    // eslint-disable-next-line no-console
    console.warn('For nested DropdownMenus, the `trigger` should always be a `DropdownMenuItem`.');
  }
  const hideOnEscape = (0,react.useCallback)(event => {
    // Pressing Escape can cause unexpected consequences (ie. exiting
    // full screen mode on MacOs, close parent modals...).
    event.preventDefault();
    // Returning `true` causes the menu to hide.
    return true;
  }, []);
  const wrapperProps = (0,react.useMemo)(() => ({
    dir: computedDirection,
    style: {
      direction: computedDirection
    }
  }), [computedDirection]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(MenuButton, {
      ref: ref,
      store: dropdownMenuStore,
      render: dropdownMenuStore.parent ? (0,react.cloneElement)(trigger, {
        // Add submenu arrow, unless a `suffix` is explicitly specified
        suffix: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
          children: [trigger.props.suffix, /*#__PURE__*/(0,jsx_runtime.jsx)(SubmenuChevronIcon, {
            "aria-hidden": "true",
            icon: chevron_right_small/* default */.A,
            size: 24,
            preserveAspectRatio: "xMidYMid slice"
          })]
        })
      }) : trigger
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(DropdownMenu, {
      ...otherProps,
      modal: modal,
      store: dropdownMenuStore
      // Root menu has an 8px distance from its trigger,
      // otherwise 0 (which causes the submenu to slightly overlap)
      ,
      gutter: gutter !== null && gutter !== void 0 ? gutter : dropdownMenuStore.parent ? 0 : 8
      // Align nested menu by the same (but opposite) amount
      // as the menu container's padding.
      ,
      shift: shift !== null && shift !== void 0 ? shift : dropdownMenuStore.parent ? -4 : 0,
      hideOnHoverOutside: false,
      "data-side": appliedPlacementSide,
      variant: variant,
      wrapperProps: wrapperProps,
      hideOnEscape: hideOnEscape,
      unmountOnHide: true,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(DropdownMenuContext.Provider, {
        value: contextValue,
        children: children
      })
    })]
  });
};
const dropdown_menu_v2_DropdownMenu = (0,context_connect/* contextConnect */.KZ)(UnconnectedDropdownMenu, 'DropdownMenu');
const DropdownMenuSeparator = (0,react.forwardRef)(function DropdownMenuSeparator(props, ref) {
  const dropdownMenuContext = (0,react.useContext)(DropdownMenuContext);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(styles_DropdownMenuSeparator, {
    ref: ref,
    ...props,
    store: dropdownMenuContext?.store,
    variant: dropdownMenuContext?.variant
  });
});
const DropdownMenuItemLabel = (0,react.forwardRef)(function DropdownMenuItemLabel(props, ref) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(styles_DropdownMenuItemLabel, {
    numberOfLines: 1,
    ref: ref,
    ...props
  });
});
const DropdownMenuItemHelpText = (0,react.forwardRef)(function DropdownMenuItemHelpText(props, ref) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(styles_DropdownMenuItemHelpText, {
    numberOfLines: 2,
    ref: ref,
    ...props
  });
});
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-system-provider.js
var context_system_provider = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-system-provider.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/theme/styles.js

function styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */



/**
 * Internal dependencies
 */

const colorVariables = ({
  colors
}) => {
  const shades = Object.entries(colors.gray || {}).map(([k, v]) => `--wp-components-color-gray-${k}: ${v};`).join('');
  return [/*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("--wp-components-color-accent:", colors.accent, ";--wp-components-color-accent-darker-10:", colors.accentDarker10, ";--wp-components-color-accent-darker-20:", colors.accentDarker20, ";--wp-components-color-accent-inverted:", colors.accentInverted, ";--wp-components-color-background:", colors.background, ";--wp-components-color-foreground:", colors.foreground, ";--wp-components-color-foreground-inverted:", colors.foregroundInverted, ";", shades, ";" + ( true ? "" : 0),  true ? "" : 0)];
};
const Wrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1krjpvb0"
} : 0)( true ? {
  name: "1a3idx0",
  styles: "color:var( --wp-components-color-foreground, currentColor )"
} : 0);
//# sourceMappingURL=styles.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/index.mjs
var node_modules_colord = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/index.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs
var a11y = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/names.mjs
var names = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/names.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+warning@3.0.1/node_modules/@wordpress/warning/build-module/index.js + 1 modules
var warning_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+warning@3.0.1/node_modules/@wordpress/warning/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/theme/color-algorithms.js
/**
 * External dependencies
 */




/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);
function generateThemeVariables(inputs) {
  validateInputs(inputs);
  const generatedColors = {
    ...generateAccentDependentColors(inputs.accent),
    ...generateBackgroundDependentColors(inputs.background)
  };
  warnContrastIssues(checkContrasts(inputs, generatedColors));
  return {
    colors: generatedColors
  };
}
function validateInputs(inputs) {
  for (const [key, value] of Object.entries(inputs)) {
    if (typeof value !== 'undefined' && !(0,node_modules_colord/* colord */.Mj)(value).isValid()) {
      globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)(`wp.components.Theme: "${value}" is not a valid color value for the '${key}' prop.`) : void 0;
    }
  }
}
function checkContrasts(inputs, outputs) {
  const background = inputs.background || colors_values/* COLORS */.l.white;
  const accent = inputs.accent || '#3858e9';
  const foreground = outputs.foreground || colors_values/* COLORS */.l.gray[900];
  const gray = outputs.gray || colors_values/* COLORS */.l.gray;
  return {
    accent: (0,node_modules_colord/* colord */.Mj)(background).isReadable(accent) ? undefined : `The background color ("${background}") does not have sufficient contrast against the accent color ("${accent}").`,
    foreground: (0,node_modules_colord/* colord */.Mj)(background).isReadable(foreground) ? undefined : `The background color provided ("${background}") does not have sufficient contrast against the standard foreground colors.`,
    grays: (0,node_modules_colord/* colord */.Mj)(background).contrast(gray[600]) >= 3 && (0,node_modules_colord/* colord */.Mj)(background).contrast(gray[700]) >= 4.5 ? undefined : `The background color provided ("${background}") cannot generate a set of grayscale foreground colors with sufficient contrast. Try adjusting the color to be lighter or darker.`
  };
}
function warnContrastIssues(issues) {
  for (const error of Object.values(issues)) {
    if (error) {
      globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)('wp.components.Theme: ' + error) : void 0;
    }
  }
}
function generateAccentDependentColors(accent) {
  if (!accent) {
    return {};
  }
  return {
    accent,
    accentDarker10: (0,node_modules_colord/* colord */.Mj)(accent).darken(0.1).toHex(),
    accentDarker20: (0,node_modules_colord/* colord */.Mj)(accent).darken(0.2).toHex(),
    accentInverted: getForegroundForColor(accent)
  };
}
function generateBackgroundDependentColors(background) {
  if (!background) {
    return {};
  }
  const foreground = getForegroundForColor(background);
  return {
    background,
    foreground,
    foregroundInverted: getForegroundForColor(foreground),
    gray: generateShades(background, foreground)
  };
}
function getForegroundForColor(color) {
  return (0,node_modules_colord/* colord */.Mj)(color).isDark() ? colors_values/* COLORS */.l.white : colors_values/* COLORS */.l.gray[900];
}
function generateShades(background, foreground) {
  // How much darkness you need to add to #fff to get the COLORS.gray[n] color
  const SHADES = {
    100: 0.06,
    200: 0.121,
    300: 0.132,
    400: 0.2,
    600: 0.42,
    700: 0.543,
    800: 0.821
  };

  // Darkness of COLORS.gray[ 900 ], relative to #fff
  const limit = 0.884;
  const direction = (0,node_modules_colord/* colord */.Mj)(background).isDark() ? 'lighten' : 'darken';

  // Lightness delta between the background and foreground colors
  const range = Math.abs((0,node_modules_colord/* colord */.Mj)(background).toHsl().l - (0,node_modules_colord/* colord */.Mj)(foreground).toHsl().l) / 100;
  const result = {};
  Object.entries(SHADES).forEach(([key, value]) => {
    result[parseInt(key)] = (0,node_modules_colord/* colord */.Mj)(background)[direction](value / limit * range).toHex();
  });
  return result;
}
//# sourceMappingURL=color-algorithms.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-cx.js
var use_cx = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-cx.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/theme/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





/**
 * `Theme` allows defining theme variables for components in the `@wordpress/components` package.
 *
 * Multiple `Theme` components can be nested in order to override specific theme variables.
 *
 *
 * ```jsx
 * const Example = () => {
 *   return (
 *     <Theme accent="red">
 *       <Button variant="primary">I'm red</Button>
 *       <Theme accent="blue">
 *         <Button variant="primary">I'm blue</Button>
 *       </Theme>
 *     </Theme>
 *   );
 * };
 * ```
 */

function Theme({
  accent,
  background,
  className,
  ...props
}) {
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => cx(...colorVariables(generateThemeVariables({
    accent,
    background
  })), className), [accent, background, className, cx]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Wrapper, {
    className: classes,
    ...props
  });
}
/* harmony default export */ const theme = (Theme);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/CQMDBRG5.js + 1 modules
var CQMDBRG5 = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/CQMDBRG5.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js
var use_instance_id = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tabs/context.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

const TabsContext = (0,react.createContext)(undefined);
const useTabsContext = () => (0,react.useContext)(TabsContext);
//# sourceMappingURL=context.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/tab/tab.js
var tab = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/tab/tab.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/tab/tab-panel.js
var tab_panel = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/tab/tab-panel.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tabs/styles.js

/**
 * External dependencies
 */

// eslint-disable-next-line no-restricted-imports


/**
 * Internal dependencies
 */


const TabListWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "enfox0g2"
} : 0)("position:relative;display:flex;align-items:stretch;flex-direction:row;&[aria-orientation='vertical']{flex-direction:column;}@media not ( prefers-reduced-motion: reduce ){&.is-animation-enabled::after{transition-property:left,top,width,height;transition-duration:0.2s;transition-timing-function:ease-out;}}&::after{content:'';position:absolute;pointer-events:none;outline:2px solid transparent;outline-offset:-1px;}&:not( [aria-orientation='vertical'] )::after{left:var( --indicator-left );bottom:0;width:var( --indicator-width );height:0;border-bottom:var( --wp-admin-border-width-focus ) solid ", colors_values/* COLORS */.l.theme.accent, ";}&[aria-orientation='vertical']::after{opacity:0;right:0;top:var( --indicator-top );height:var( --indicator-height );border-right:var( --wp-admin-border-width-focus ) solid ", colors_values/* COLORS */.l.theme.accent, ";}" + ( true ? "" : 0));
const styles_Tab = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(tab/* Tab */.o,  true ? {
  target: "enfox0g1"
} : 0)("&{display:inline-flex;align-items:center;position:relative;border-radius:0;height:", (0,space/* space */.x)(12), ";background:transparent;border:none;box-shadow:none;cursor:pointer;padding:3px ", (0,space/* space */.x)(4), ";margin-left:0;font-weight:500;&[aria-disabled='true']{cursor:default;opacity:0.3;}&:hover{color:", colors_values/* COLORS */.l.theme.accent, ";}&:focus:not( :disabled ){position:relative;box-shadow:none;outline:none;}&::before{content:'';position:absolute;top:", (0,space/* space */.x)(3), ";right:", (0,space/* space */.x)(3), ";bottom:", (0,space/* space */.x)(3), ";left:", (0,space/* space */.x)(3), ";pointer-events:none;box-shadow:0 0 0 var( --wp-admin-border-width-focus ) ", colors_values/* COLORS */.l.theme.accent, ";border-radius:2px;opacity:0;@media not ( prefers-reduced-motion ){transition:opacity 0.1s linear;}}&:focus-visible::before{opacity:1;outline:2px solid transparent;}}" + ( true ? "" : 0));
const styles_TabPanel = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(tab_panel/* TabPanel */.K,  true ? {
  target: "enfox0g0"
} : 0)("&:focus{box-shadow:none;outline:none;}&:focus-visible{border-radius:2px;box-shadow:0 0 0 var( --wp-admin-border-width-focus ) ", colors_values/* COLORS */.l.theme.accent, ";outline:2px solid transparent;outline-offset:0;}" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tabs/tab.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





const Tab = (0,react.forwardRef)(function Tab({
  children,
  tabId,
  disabled,
  render,
  ...otherProps
}, ref) {
  const context = useTabsContext();
  if (!context) {
    globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)('`Tabs.Tab` must be wrapped in a `Tabs` component.') : void 0;
    return null;
  }
  const {
    store,
    instanceId
  } = context;
  const instancedTabId = `${instanceId}-${tabId}`;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(styles_Tab, {
    ref: ref,
    store: store,
    id: instancedTabId,
    disabled: disabled,
    render: render,
    ...otherProps,
    children: children
  });
});
//# sourceMappingURL=tab.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/tab/tab-list.js
var tab_list = __webpack_require__("../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/tab/tab-list.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tabs/tablist.js
/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





function useTrackElementOffset(targetElement, onUpdate) {
  const [indicatorPosition, setIndicatorPosition] = (0,react.useState)({
    left: 0,
    top: 0,
    width: 0,
    height: 0
  });

  // TODO: replace with useEventCallback or similar when officially available.
  const updateCallbackRef = (0,react.useRef)(onUpdate);
  (0,react.useLayoutEffect)(() => {
    updateCallbackRef.current = onUpdate;
  });
  const observedElementRef = (0,react.useRef)();
  const resizeObserverRef = (0,react.useRef)();
  (0,react.useEffect)(() => {
    if (targetElement === observedElementRef.current) {
      return;
    }
    observedElementRef.current = targetElement !== null && targetElement !== void 0 ? targetElement : undefined;
    function updateIndicator(element) {
      setIndicatorPosition({
        // Workaround to prevent unwanted scrollbars, see:
        // https://github.com/WordPress/gutenberg/pull/61979
        left: Math.max(element.offsetLeft - 1, 0),
        top: Math.max(element.offsetTop - 1, 0),
        width: parseFloat(getComputedStyle(element).width),
        height: parseFloat(getComputedStyle(element).height)
      });
      updateCallbackRef.current?.();
    }

    // Set up a ResizeObserver.
    if (!resizeObserverRef.current) {
      resizeObserverRef.current = new ResizeObserver(() => {
        if (observedElementRef.current) {
          updateIndicator(observedElementRef.current);
        }
      });
    }
    const {
      current: resizeObserver
    } = resizeObserverRef;

    // Observe new element.
    if (targetElement) {
      updateIndicator(targetElement);
      resizeObserver.observe(targetElement);
    }
    return () => {
      // Unobserve previous element.
      if (observedElementRef.current) {
        resizeObserver.unobserve(observedElementRef.current);
      }
    };
  }, [targetElement]);
  return indicatorPosition;
}
function useOnValueUpdate(value, onUpdate) {
  const previousValueRef = (0,react.useRef)(value);

  // TODO: replace with useEventCallback or similar when officially available.
  const updateCallbackRef = (0,react.useRef)(onUpdate);
  (0,react.useLayoutEffect)(() => {
    updateCallbackRef.current = onUpdate;
  });
  (0,react.useEffect)(() => {
    if (previousValueRef.current !== value) {
      updateCallbackRef.current({
        previousValue: previousValueRef.current
      });
      previousValueRef.current = value;
    }
  }, [value]);
}
const TabList = (0,react.forwardRef)(function TabList({
  children,
  ...otherProps
}, ref) {
  const context = useTabsContext();
  const selectedId = context?.store.useState('selectedId');
  const indicatorPosition = useTrackElementOffset(context?.store.item(selectedId)?.element);
  const [animationEnabled, setAnimationEnabled] = (0,react.useState)(false);
  useOnValueUpdate(selectedId, ({
    previousValue
  }) => previousValue && setAnimationEnabled(true));
  if (!context) {
    globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)('`Tabs.TabList` must be wrapped in a `Tabs` component.') : void 0;
    return null;
  }
  const {
    store
  } = context;
  const {
    activeId,
    selectOnMove
  } = store.useState();
  const {
    setActiveId
  } = store;
  const onBlur = () => {
    if (!selectOnMove) {
      return;
    }

    // When automatic tab selection is on, make sure that the active tab is up
    // to date with the selected tab when leaving the tablist. This makes sure
    // that the selected tab will receive keyboard focus when tabbing back into
    // the tablist.
    if (selectedId !== activeId) {
      setActiveId(selectedId);
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tab_list/* TabList */.w, {
    ref: ref,
    store: store,
    render: /*#__PURE__*/(0,jsx_runtime.jsx)(TabListWrapper, {
      onTransitionEnd: event => {
        if (event.pseudoElement === '::after') {
          setAnimationEnabled(false);
        }
      }
    }),
    onBlur: onBlur,
    ...otherProps,
    style: {
      '--indicator-left': `${indicatorPosition.left}px`,
      '--indicator-top': `${indicatorPosition.top}px`,
      '--indicator-width': `${indicatorPosition.width}px`,
      '--indicator-height': `${indicatorPosition.height}px`,
      ...otherProps.style
    },
    className: (0,dist_clsx/* default */.A)(animationEnabled ? 'is-animation-enabled' : '', otherProps.className),
    children: children
  });
});
//# sourceMappingURL=tablist.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tabs/tabpanel.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





const TabPanel = (0,react.forwardRef)(function TabPanel({
  children,
  tabId,
  focusable = true,
  ...otherProps
}, ref) {
  const context = useTabsContext();
  if (!context) {
    globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)('`Tabs.TabPanel` must be wrapped in a `Tabs` component.') : void 0;
    return null;
  }
  const {
    store,
    instanceId
  } = context;
  const instancedTabId = `${instanceId}-${tabId}`;
  const selectedId = store.useState(state => state.selectedId);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(styles_TabPanel, {
    ref: ref,
    store: store
    // For TabPanel, the id passed here is the id attribute of the DOM
    // element.
    // `tabId` is the id of the tab that controls this panel.
    ,
    id: `${instancedTabId}-view`,
    tabId: instancedTabId,
    focusable: focusable,
    ...otherProps,
    children: selectedId === instancedTabId && children
  });
});
//# sourceMappingURL=tabpanel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tabs/index.js
/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






function Tabs({
  selectOnMove = true,
  defaultTabId,
  orientation = 'horizontal',
  onSelect,
  children,
  selectedTabId
}) {
  const instanceId = (0,use_instance_id/* default */.A)(Tabs, 'tabs');
  const store = CQMDBRG5/* useTabStore */.W({
    selectOnMove,
    orientation,
    defaultSelectedId: defaultTabId && `${instanceId}-${defaultTabId}`,
    setSelectedId: selectedId => {
      const strippedDownId = typeof selectedId === 'string' ? selectedId.replace(`${instanceId}-`, '') : selectedId;
      onSelect?.(strippedDownId);
    },
    selectedId: selectedTabId && `${instanceId}-${selectedTabId}`
  });
  const isControlled = selectedTabId !== undefined;
  const {
    items,
    selectedId,
    activeId
  } = store.useState();
  const {
    setSelectedId,
    setActiveId
  } = store;

  // Keep track of whether tabs have been populated. This is used to prevent
  // certain effects from firing too early while tab data and relevant
  // variables are undefined during the initial render.
  const tabsHavePopulated = (0,react.useRef)(false);
  if (items.length > 0) {
    tabsHavePopulated.current = true;
  }
  const selectedTab = items.find(item => item.id === selectedId);
  const firstEnabledTab = items.find(item => {
    // Ariakit internally refers to disabled tabs as `dimmed`.
    return !item.dimmed;
  });
  const initialTab = items.find(item => item.id === `${instanceId}-${defaultTabId}`);

  // Handle selecting the initial tab.
  (0,react.useLayoutEffect)(() => {
    if (isControlled) {
      return;
    }

    // Wait for the denoted initial tab to be declared before making a
    // selection. This ensures that if a tab is declared lazily it can
    // still receive initial selection, as well as ensuring no tab is
    // selected if an invalid `defaultTabId` is provided.
    if (defaultTabId && !initialTab) {
      return;
    }

    // If the currently selected tab is missing (i.e. removed from the DOM),
    // fall back to the initial tab or the first enabled tab if there is
    // one. Otherwise, no tab should be selected.
    if (!items.find(item => item.id === selectedId)) {
      if (initialTab && !initialTab.dimmed) {
        setSelectedId(initialTab?.id);
        return;
      }
      if (firstEnabledTab) {
        setSelectedId(firstEnabledTab.id);
      } else if (tabsHavePopulated.current) {
        setSelectedId(null);
      }
    }
  }, [firstEnabledTab, initialTab, defaultTabId, isControlled, items, selectedId, setSelectedId]);

  // Handle the currently selected tab becoming disabled.
  (0,react.useLayoutEffect)(() => {
    if (!selectedTab?.dimmed) {
      return;
    }

    // In controlled mode, we trust that disabling tabs is done
    // intentionally, and don't select a new tab automatically.
    if (isControlled) {
      setSelectedId(null);
      return;
    }

    // If the currently selected tab becomes disabled, fall back to the
    // `defaultTabId` if possible. Otherwise select the first
    // enabled tab (if there is one).
    if (initialTab && !initialTab.dimmed) {
      setSelectedId(initialTab.id);
      return;
    }
    if (firstEnabledTab) {
      setSelectedId(firstEnabledTab.id);
    }
  }, [firstEnabledTab, initialTab, isControlled, selectedTab?.dimmed, setSelectedId]);

  // Clear `selectedId` if the active tab is removed from the DOM in controlled mode.
  (0,react.useLayoutEffect)(() => {
    if (!isControlled) {
      return;
    }

    // Once the tabs have populated, if the `selectedTabId` still can't be
    // found, clear the selection.
    if (tabsHavePopulated.current && !!selectedTabId && !selectedTab) {
      setSelectedId(null);
    }
  }, [isControlled, selectedTab, selectedTabId, setSelectedId]);
  (0,react.useEffect)(() => {
    // If there is no active tab, fallback to place focus on the first enabled tab
    // so there is always an active element
    if (selectedTabId === null && !activeId && firstEnabledTab?.id) {
      setActiveId(firstEnabledTab.id);
    }
  }, [selectedTabId, activeId, firstEnabledTab?.id, setActiveId]);
  (0,react.useEffect)(() => {
    if (!isControlled) {
      return;
    }
    requestAnimationFrame(() => {
      const focusedElement = items?.[0]?.element?.ownerDocument.activeElement;
      if (!focusedElement || !items.some(item => focusedElement === item.element)) {
        return; // Return early if no tabs are focused.
      }

      // If, after ariakit re-computes the active tab, that tab doesn't match
      // the currently focused tab, then we force an update to ariakit to avoid
      // any mismatches, especially when navigating to previous/next tab with
      // arrow keys.
      if (activeId !== focusedElement.id) {
        setActiveId(focusedElement.id);
      }
    });
  }, [activeId, isControlled, items, setActiveId]);
  const contextValue = (0,react.useMemo)(() => ({
    store,
    instanceId
  }), [store, instanceId]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(TabsContext.Provider, {
    value: contextValue,
    children: children
  });
}
Tabs.TabList = TabList;
Tabs.Tab = Tab;
Tabs.TabPanel = TabPanel;
Tabs.Context = TabsContext;
/* harmony default export */ const tabs = (Tabs);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/strings.js
var strings = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/strings.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/lock-unlock.js
/**
 * WordPress dependencies
 */

const {
  lock: lock_unlock_lock,
  unlock: build_module_lock_unlock_unlock
} = (0,implementation/* __dangerousOptInToUnstableAPIsOnlyForCoreModules */.yf)('I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.', '@wordpress/components');
//# sourceMappingURL=lock-unlock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/private-apis.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */










const privateApis = {};
lock_unlock_lock(privateApis, {
  CompositeV2: _7QTPYGNZ/* Composite */.e,
  CompositeGroupV2: CompositeGroup,
  CompositeItemV2: QZLXIDNP/* CompositeItem */.l,
  CompositeRowV2: CompositeRow,
  useCompositeStoreV2: _7GBW5FLS/* useCompositeStore */.q,
  CustomSelectControl: CustomSelectControl,
  __experimentalPopoverLegacyPositionToPlacement: utils/* positionToPlacement */.YK,
  createPrivateSlotFill: slot_fill/* createPrivateSlotFill */.VI,
  ComponentsContext: context_system_provider/* ComponentsContext */.aG,
  Tabs: tabs,
  Theme: theme,
  DropdownMenuV2: dropdown_menu_v2_DropdownMenu,
  DropdownMenuGroupV2: DropdownMenuGroup,
  DropdownMenuItemV2: DropdownMenuItem,
  DropdownMenuCheckboxItemV2: DropdownMenuCheckboxItem,
  DropdownMenuRadioItemV2: DropdownMenuRadioItem,
  DropdownMenuSeparatorV2: DropdownMenuSeparator,
  DropdownMenuItemLabelV2: DropdownMenuItemLabel,
  DropdownMenuItemHelpTextV2: DropdownMenuItemHelpText,
  kebabCase: strings/* kebabCase */.kW
});
//# sourceMappingURL=private-apis.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar-context/index.js
var toolbar_context = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar-context/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-observable-value/index.js
var use_observable_value = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-observable-value/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/slot-fill-context.js
var slot_fill_context = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/slot-fill-context.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/use-slot-fills.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */

function useSlotFills(name) {
  const registry = (0,react.useContext)(slot_fill_context/* default */.A);
  return (0,use_observable_value/* default */.A)(registry.fills, name);
}
//# sourceMappingURL=use-slot-fills.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-controls/slot.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const {
  ComponentsContext
} = lock_unlock_unlock(privateApis);
function BlockControlsSlot({
  group = 'default',
  ...props
}) {
  const toolbarState = (0,react.useContext)(toolbar_context/* default */.A);
  const contextState = (0,react.useContext)(ComponentsContext);
  const fillProps = (0,react.useMemo)(() => ({
    forwardedContext: [[toolbar_context/* default */.A.Provider, {
      value: toolbarState
    }], [ComponentsContext.Provider, {
      value: contextState
    }]]
  }), [toolbarState, contextState]);
  const Slot = block_controls_groups[group]?.Slot;
  const fills = useSlotFills(Slot?.__unstableName);
  if (!Slot) {
    globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)(`Unknown BlockControls group "${group}" provided.`) : void 0;
    return null;
  }
  if (!fills?.length) {
    return null;
  }
  const slot = /*#__PURE__*/(0,jsx_runtime.jsx)(Slot, {
    ...props,
    bubblesVirtually: true,
    fillProps: fillProps
  });
  if (group === 'default') {
    return slot;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_group/* default */.A, {
    children: slot
  });
}
//# sourceMappingURL=slot.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-controls/index.js
/**
 * Internal dependencies
 */



const BlockControls = BlockControlsFill;
BlockControls.Slot = BlockControlsSlot;

// This is just here for backward compatibility.
const BlockFormatControls = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockControlsFill, {
    group: "inline",
    ...props
  });
};
BlockFormatControls.Slot = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockControlsSlot, {
    group: "inline",
    ...props
  });
};
/* harmony default export */ const block_controls = (BlockControls);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar-item/index.js + 1 modules
var toolbar_item = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar-item/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/dropdown-menu/index.js + 1 modules
var dropdown_menu = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/dropdown-menu/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar-dropdown-menu/index.js
/**
 * WordPress dependencies
 */


/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function ToolbarDropdownMenu(props, ref) {
  const accessibleToolbarState = (0,react.useContext)(toolbar_context/* default */.A);
  if (!accessibleToolbarState) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_menu/* default */.A, {
      ...props
    });
  }

  // ToolbarItem will pass all props to the render prop child, which will pass
  // all props to the toggle of DropdownMenu. This means that ToolbarDropdownMenu
  // has the same API as DropdownMenu.
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_item/* default */.A, {
    ref: ref,
    ...props.toggleProps,
    children: toolbarItemProps => /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_menu/* default */.A, {
      ...props,
      popoverProps: {
        ...props.popoverProps
      },
      toggleProps: toolbarItemProps
    })
  });
}
/* harmony default export */ const toolbar_dropdown_menu = ((0,react.forwardRef)(ToolbarDropdownMenu));
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/menu-group/index.js
var menu_group = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/menu-group/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/menu-item/index.js
var menu_item = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/menu-item/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/layout.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const defaultLayout = {
  type: 'default'
};
const Layout = (0,react.createContext)(defaultLayout);

/**
 * Allows to define the layout.
 */
const LayoutProvider = Layout.Provider;

/**
 * React hook used to retrieve the layout config.
 */
function useLayout() {
  return (0,react.useContext)(Layout);
}
function LayoutStyle({
  layout = {},
  css,
  ...props
}) {
  const layoutType = getLayoutType(layout.type);
  const [blockGapSupport] = useSettings('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null;
  if (layoutType) {
    if (css) {
      return /*#__PURE__*/_jsx("style", {
        children: css
      });
    }
    const layoutStyle = layoutType.getLayoutStyle?.({
      hasBlockGapSupport,
      layout,
      ...props
    });
    if (layoutStyle) {
      return /*#__PURE__*/_jsx("style", {
        children: layoutStyle
      });
    }
  }
  return null;
}
//# sourceMappingURL=layout.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/justify-left.js
/**
 * WordPress dependencies
 */


const justifyLeft = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M9 9v6h11V9H9zM4 20h1.5V4H4v16z"
  })
});
/* harmony default export */ const justify_left = (justifyLeft);
//# sourceMappingURL=justify-left.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/justify-center.js
/**
 * WordPress dependencies
 */


const justifyCenter = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M12.5 15v5H11v-5H4V9h7V4h1.5v5h7v6h-7Z"
  })
});
/* harmony default export */ const justify_center = (justifyCenter);
//# sourceMappingURL=justify-center.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/justify-right.js
/**
 * WordPress dependencies
 */


const justifyRight = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M4 15h11V9H4v6zM18.5 4v16H20V4h-1.5z"
  })
});
/* harmony default export */ const justify_right = (justifyRight);
//# sourceMappingURL=justify-right.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/justify-space-between.js
/**
 * WordPress dependencies
 */


const justifySpaceBetween = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M9 15h6V9H9v6zm-5 5h1.5V4H4v16zM18.5 4v16H20V4h-1.5z"
  })
});
/* harmony default export */ const justify_space_between = (justifySpaceBetween);
//# sourceMappingURL=justify-space-between.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/justify-stretch.js
/**
 * WordPress dependencies
 */


const justifyStretch = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M4 4H5.5V20H4V4ZM7 10L17 10V14L7 14V10ZM20 4H18.5V20H20V4Z"
  })
});
/* harmony default export */ const justify_stretch = (justifyStretch);
//# sourceMappingURL=justify-stretch.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/arrow-right.js
var arrow_right = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/arrow-right.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/arrow-down.js
var arrow_down = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/arrow-down.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex/component.js
var flex_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-item/component.js
var flex_item_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-item/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/button/index.js
var build_module_button = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/button/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
var LayoutGroupContext = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/DeprecatedLayoutGroupContext.mjs


/**
 * Note: Still used by components generated by old versions of Framer
 *
 * @deprecated
 */
const DeprecatedLayoutGroupContext = (0,react.createContext)(null);



// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var use_isomorphic_effect = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs



function useIsMounted() {
    const isMounted = (0,react.useRef)(false);
    (0,use_isomorphic_effect/* useIsomorphicLayoutEffect */.E)(() => {
        isMounted.current = true;
        return () => {
            isMounted.current = false;
        };
    }, []);
    return isMounted;
}



// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/frameloop/frame.mjs
var frameloop_frame = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/frameloop/frame.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/use-force-update.mjs




function use_force_update_useForceUpdate() {
    const isMounted = useIsMounted();
    const [forcedRenderCount, setForcedRenderCount] = (0,react.useState)(0);
    const forceRender = (0,react.useCallback)(() => {
        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
    }, [forcedRenderCount]);
    /**
     * Defer this to the end of the next animation frame in case there are multiple
     * synchronous calls.
     */
    const deferredForceRender = (0,react.useCallback)(() => frameloop_frame/* frame */.Gt.postRender(forceRender), [forceRender]);
    return [deferredForceRender, forcedRenderCount];
}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/projection/node/group.mjs
const notify = (node) => !node.isLayoutDirty && node.willUpdate(false);
function nodeGroup() {
    const nodes = new Set();
    const subscriptions = new WeakMap();
    const dirtyAll = () => nodes.forEach(notify);
    return {
        add: (node) => {
            nodes.add(node);
            subscriptions.set(node, node.addEventListener("willUpdate", dirtyAll));
        },
        remove: (node) => {
            nodes.delete(node);
            const unsubscribe = subscriptions.get(node);
            if (unsubscribe) {
                unsubscribe();
                subscriptions.delete(node);
            }
            dirtyAll();
        },
        dirty: dirtyAll,
    };
}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/components/LayoutGroup/index.mjs







const shouldInheritGroup = (inherit) => inherit === true;
const shouldInheritId = (inherit) => shouldInheritGroup(inherit === true) || inherit === "id";
const LayoutGroup = ({ children, id, inherit = true }) => {
    const layoutGroupContext = (0,react.useContext)(LayoutGroupContext/* LayoutGroupContext */.L);
    const deprecatedLayoutGroupContext = (0,react.useContext)(DeprecatedLayoutGroupContext);
    const [forceRender, key] = use_force_update_useForceUpdate();
    const context = (0,react.useRef)(null);
    const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
    if (context.current === null) {
        if (shouldInheritId(inherit) && upstreamId) {
            id = id ? upstreamId + "-" + id : upstreamId;
        }
        context.current = {
            id,
            group: shouldInheritGroup(inherit)
                ? layoutGroupContext.group || nodeGroup()
                : nodeGroup(),
        };
    }
    const memoizedContext = (0,react.useMemo)(() => ({ ...context.current, forceRender }), [key]);
    return ((0,jsx_runtime.jsx)(LayoutGroupContext/* LayoutGroupContext */.L.Provider, { value: memoizedContext, children: children }));
};



// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/base-control/index.js
var base_control = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/base-control/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/styles.js

function toggle_group_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const toggleGroupControl = ({
  isBlock,
  isDeselectable,
  size
}) => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("background:", colors_values/* COLORS */.l.ui.background, ";border:1px solid transparent;border-radius:", config_values/* default */.A.controlBorderRadius, ";display:inline-flex;min-width:0;position:relative;", toggleGroupControlSize(size), " ", !isDeselectable && enclosingBorders(isBlock), ";" + ( true ? "" : 0),  true ? "" : 0);
const enclosingBorders = isBlock => {
  const enclosingBorder = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border-color:", colors_values/* COLORS */.l.ui.border, ";" + ( true ? "" : 0),  true ? "" : 0);
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(isBlock && enclosingBorder, " &:hover{border-color:", colors_values/* COLORS */.l.ui.borderHover, ";}&:focus-within{border-color:", colors_values/* COLORS */.l.ui.borderFocus, ";box-shadow:", config_values/* default */.A.controlBoxShadowFocus, ";z-index:1;outline:2px solid transparent;outline-offset:-2px;}" + ( true ? "" : 0),  true ? "" : 0);
};
var _ref =  true ? {
  name: "1aqh2c7",
  styles: "min-height:40px;padding:3px"
} : 0;
var _ref2 =  true ? {
  name: "1ndywgm",
  styles: "min-height:36px;padding:2px"
} : 0;
const toggleGroupControlSize = size => {
  const styles = {
    default: _ref2,
    '__unstable-large': _ref
  };
  return styles[size];
};
const block =  true ? {
  name: "7whenc",
  styles: "display:flex;width:100%"
} : 0;
const VisualLabelWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eakva830"
} : 0)( true ? {
  name: "zjik7",
  styles: "display:flex"
} : 0);
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+core@0.3.11/node_modules/@ariakit/core/esm/radio/radio-store.js
"use client";








// src/radio/radio-store.ts
function createRadioStore(_a = {}) {
  var props = (0,_chunks_4R3V3JGP/* __objRest */.YG)(_a, []);
  var _a2;
  const syncState = (_a2 = props.store) == null ? void 0 : _a2.getState();
  const composite = (0,IERTEJ3A/* createCompositeStore */.z)((0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, props), {
    focusLoop: (0,Y3OOHFCN/* defaultValue */.Jh)(props.focusLoop, syncState == null ? void 0 : syncState.focusLoop, true)
  }));
  const initialState = (0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, composite.getState()), {
    value: (0,Y3OOHFCN/* defaultValue */.Jh)(
      props.value,
      syncState == null ? void 0 : syncState.value,
      props.defaultValue,
      null
    )
  });
  const radio = (0,EAHJFCU4/* createStore */.y$)(initialState, composite, props.store);
  return (0,_chunks_4R3V3JGP/* __spreadProps */.ko)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)((0,_chunks_4R3V3JGP/* __spreadValues */.IA)({}, composite), radio), {
    setValue: (value) => radio.setState("value", value)
  });
}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/__chunks/LEIRFLRL.js
"use client";



// src/radio/radio-store.ts

function useRadioStoreProps(store, update, props) {
  store = (0,_7GBW5FLS/* useCompositeStoreProps */.Y)(store, update, props);
  (0,EKQEJRUF/* useStoreProps */.Tz)(store, props, "value", "setValue");
  return store;
}
function useRadioStore(props = {}) {
  const [store, update] = (0,EKQEJRUF/* useStore */.Pj)(createRadioStore, props);
  return useRadioStoreProps(store, update, props);
}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@ariakit+react-core@0.3.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ariakit/react-core/esm/radio/radio-group.js
"use client";












// src/radio/radio-group.tsx


var useRadioGroup = (0,_3ORBWXWF/* createHook */.ab)(
  (_a) => {
    var _b = _a, { store } = _b, props = (0,_4R3V3JGP/* __objRest */.YG)(_b, ["store"]);
    const context = useRadioProviderContext();
    store = store || context;
    (0,Y3OOHFCN/* invariant */.V1)(
      store,
       false && 0
    );
    props = (0,_6O5OEQGF/* useWrapElement */.w7)(
      props,
      (element) => /* @__PURE__ */ (0,jsx_runtime.jsx)(RadioScopedContextProvider, { value: store, children: element }),
      [store]
    );
    props = (0,_4R3V3JGP/* __spreadValues */.IA)({
      role: "radiogroup"
    }, props);
    props = (0,_7QTPYGNZ/* useComposite */.T)((0,_4R3V3JGP/* __spreadValues */.IA)({ store }, props));
    return props;
  }
);
var RadioGroup = (0,_3ORBWXWF/* createComponent */.a0)((props) => {
  const htmlProps = useRadioGroup(props);
  return (0,_3ORBWXWF/* createElement */.n)("div", htmlProps);
});
if (false) {}


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/context.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

const ToggleGroupControlContext = (0,react.createContext)({});
const useToggleGroupControlContext = () => (0,react.useContext)(ToggleGroupControlContext);
/* harmony default export */ const context = (ToggleGroupControlContext);
//# sourceMappingURL=context.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-previous/index.js
var use_previous = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-previous/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/utils.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */

/**
 * Used to determine, via an internal heuristics, whether an `undefined` value
 * received for the `value` prop should be interpreted as the component being
 * used in uncontrolled mode, or as an "empty" value for controlled mode.
 *
 * @param valueProp The received `value`
 */
function useComputeControlledOrUncontrolledValue(valueProp) {
  const isInitialRender = (0,react.useRef)(true);
  const prevValueProp = (0,use_previous/* default */.A)(valueProp);
  const prevIsControlled = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    if (isInitialRender.current) {
      isInitialRender.current = false;
    }
  }, []);

  // Assume the component is being used in controlled mode on the first re-render
  // that has a different `valueProp` from the previous render.
  const isControlled = prevIsControlled.current || !isInitialRender.current && prevValueProp !== valueProp;
  (0,react.useEffect)(() => {
    prevIsControlled.current = isControlled;
  }, [isControlled]);
  if (isControlled) {
    // When in controlled mode, use `''` instead of `undefined`
    return {
      value: valueProp !== null && valueProp !== void 0 ? valueProp : '',
      defaultValue: undefined
    };
  }

  // When in uncontrolled mode, the `value` should be intended as the initial value
  return {
    value: undefined,
    defaultValue: valueProp
  };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/as-radio-group.js
/**
 * External dependencies
 */

// eslint-disable-next-line no-restricted-imports


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function UnforwardedToggleGroupControlAsRadioGroup({
  children,
  isAdaptiveWidth,
  label,
  onChange: onChangeProp,
  size,
  value: valueProp,
  id: idProp,
  ...otherProps
}, forwardedRef) {
  const generatedId = (0,use_instance_id/* default */.A)(ToggleGroupControlAsRadioGroup, 'toggle-group-control-as-radio-group');
  const baseId = idProp || generatedId;

  // Use a heuristic to understand if the component is being used in controlled
  // or uncontrolled mode, and consequently:
  // - when controlled, convert `undefined` values to `''` (ie. "no value")
  // - use the `value` prop as the `defaultValue` when uncontrolled
  const {
    value,
    defaultValue
  } = useComputeControlledOrUncontrolledValue(valueProp);

  // `useRadioStore`'s `setValue` prop can be called with `null`, while
  // the component's `onChange` prop only expects `undefined`
  const wrappedOnChangeProp = onChangeProp ? v => {
    onChangeProp(v !== null && v !== void 0 ? v : undefined);
  } : undefined;
  const radio = useRadioStore({
    defaultValue,
    value,
    setValue: wrappedOnChangeProp
  });
  const selectedValue = radio.useState('value');
  const setValue = radio.setValue;
  const groupContextValue = (0,react.useMemo)(() => ({
    baseId,
    isBlock: !isAdaptiveWidth,
    size,
    value: selectedValue,
    setValue
  }), [baseId, isAdaptiveWidth, size, selectedValue, setValue]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(context.Provider, {
    value: groupContextValue,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(RadioGroup, {
      store: radio,
      "aria-label": label,
      render: /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {}),
      ...otherProps,
      id: baseId,
      ref: forwardedRef,
      children: children
    })
  });
}
const ToggleGroupControlAsRadioGroup = (0,react.forwardRef)(UnforwardedToggleGroupControlAsRadioGroup);
//# sourceMappingURL=as-radio-group.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-controlled-value.js
var use_controlled_value = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-controlled-value.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/as-button-group.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





function UnforwardedToggleGroupControlAsButtonGroup({
  children,
  isAdaptiveWidth,
  label,
  onChange,
  size,
  value: valueProp,
  id: idProp,
  ...otherProps
}, forwardedRef) {
  const generatedId = (0,use_instance_id/* default */.A)(ToggleGroupControlAsButtonGroup, 'toggle-group-control-as-button-group');
  const baseId = idProp || generatedId;

  // Use a heuristic to understand if the component is being used in controlled
  // or uncontrolled mode, and consequently:
  // - when controlled, convert `undefined` values to `''` (ie. "no value")
  // - use the `value` prop as the `defaultValue` when uncontrolled
  const {
    value,
    defaultValue
  } = useComputeControlledOrUncontrolledValue(valueProp);
  const [selectedValue, setSelectedValue] = (0,use_controlled_value/* useControlledValue */.j)({
    defaultValue,
    value,
    onChange
  });
  const groupContextValue = (0,react.useMemo)(() => ({
    baseId,
    value: selectedValue,
    setValue: setSelectedValue,
    isBlock: !isAdaptiveWidth,
    isDeselectable: true,
    size
  }), [baseId, selectedValue, setSelectedValue, isAdaptiveWidth, size]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(context.Provider, {
    value: groupContextValue,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
      "aria-label": label,
      ...otherProps,
      ref: forwardedRef,
      role: "group",
      children: children
    })
  });
}
const ToggleGroupControlAsButtonGroup = (0,react.forwardRef)(UnforwardedToggleGroupControlAsButtonGroup);
//# sourceMappingURL=as-button-group.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/component.js
/**
 * External dependencies
 */

// eslint-disable-next-line no-restricted-imports


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */










function UnconnectedToggleGroupControl(props, forwardedRef) {
  const {
    __nextHasNoMarginBottom = false,
    __next40pxDefaultSize = false,
    className,
    isAdaptiveWidth = false,
    isBlock = false,
    isDeselectable = false,
    label,
    hideLabelFromVision = false,
    help,
    onChange,
    size = 'default',
    value,
    children,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'ToggleGroupControl');
  const baseId = (0,use_instance_id/* default */.A)(ToggleGroupControl, 'toggle-group-control');
  const normalizedSize = __next40pxDefaultSize && size === 'default' ? '__unstable-large' : size;
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => cx(toggleGroupControl({
    isBlock,
    isDeselectable,
    size: normalizedSize
  }), isBlock && block, className), [className, cx, isBlock, isDeselectable, normalizedSize]);
  const MainControl = isDeselectable ? ToggleGroupControlAsButtonGroup : ToggleGroupControlAsRadioGroup;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(base_control/* default */.Ay, {
    help: help,
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    children: [!hideLabelFromVision && /*#__PURE__*/(0,jsx_runtime.jsx)(VisualLabelWrapper, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
        children: label
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(MainControl, {
      ...otherProps,
      className: classes,
      isAdaptiveWidth: isAdaptiveWidth,
      label: label,
      onChange: onChange,
      ref: forwardedRef,
      size: normalizedSize,
      value: value,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(LayoutGroup, {
        id: baseId,
        children: children
      })
    })]
  });
}

/**
 * `ToggleGroupControl` is a form component that lets users choose options
 * represented in horizontal segments. To render options for this control use
 * `ToggleGroupControlOption` component.
 *
 * This component is intended for selecting a single persistent value from a set of options,
 * similar to a how a radio button group would work. If you simply want a toggle to switch between views,
 * use a `TabPanel` instead.
 *
 * Only use this control when you know for sure the labels of items inside won't
 * wrap. For items with longer labels, you can consider a `SelectControl` or a
 * `CustomSelectControl` component instead.
 *
 * ```jsx
 * import {
 *   __experimentalToggleGroupControl as ToggleGroupControl,
 *   __experimentalToggleGroupControlOption as ToggleGroupControlOption,
 * } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ToggleGroupControl label="my label" value="vertical" isBlock>
 *       <ToggleGroupControlOption value="horizontal" label="Horizontal" />
 *       <ToggleGroupControlOption value="vertical" label="Vertical" />
 *     </ToggleGroupControl>
 *   );
 * }
 * ```
 */
const ToggleGroupControl = (0,context_connect/* contextConnect */.KZ)(UnconnectedToggleGroupControl, 'ToggleGroupControl');
/* harmony default export */ const toggle_group_control_component = (ToggleGroupControl);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/render/dom/motion.mjs + 205 modules
var motion = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/render/dom/motion.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-reduced-motion/index.js
var use_reduced_motion = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-reduced-motion/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-base/styles.js

function toggle_group_control_option_base_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const LabelView = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "et6ln9s1"
} : 0)( true ? {
  name: "sln1fl",
  styles: "display:inline-flex;max-width:100%;min-width:0;position:relative"
} : 0);
const labelBlock =  true ? {
  name: "82a6rk",
  styles: "flex:1"
} : 0;
const buttonView = ({
  isDeselectable,
  isIcon,
  isPressed,
  size
}) => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("align-items:center;appearance:none;background:transparent;border:none;border-radius:", config_values/* default */.A.controlBorderRadius, ";color:", colors_values/* COLORS */.l.gray[700], ";fill:currentColor;cursor:pointer;display:flex;font-family:inherit;height:100%;justify-content:center;line-height:100%;outline:none;padding:0 12px;position:relative;text-align:center;@media not ( prefers-reduced-motion ){transition:background ", config_values/* default */.A.transitionDurationFast, " linear,color ", config_values/* default */.A.transitionDurationFast, " linear,font-weight 60ms linear;}user-select:none;width:100%;z-index:2;&::-moz-focus-inner{border:0;}&:active{background:", config_values/* default */.A.toggleGroupControlBackgroundColor, ";}", isDeselectable && deselectable, " ", isIcon && isIconStyles({
  size
}), " ", isPressed && pressed, ";" + ( true ? "" : 0),  true ? "" : 0);
const pressed = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("color:", colors_values/* COLORS */.l.white, ";&:active{background:transparent;}" + ( true ? "" : 0),  true ? "" : 0);
const deselectable = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("color:", colors_values/* COLORS */.l.gray[900], ";&:focus{box-shadow:inset 0 0 0 1px ", colors_values/* COLORS */.l.white, ",0 0 0 ", config_values/* default */.A.borderWidthFocus, " ", colors_values/* COLORS */.l.theme.accent, ";outline:2px solid transparent;}" + ( true ? "" : 0),  true ? "" : 0);
const ButtonContentView = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "et6ln9s0"
} : 0)("display:flex;font-size:", config_values/* default */.A.fontSize, ";line-height:1;" + ( true ? "" : 0));
const isIconStyles = ({
  size = 'default'
}) => {
  const iconButtonSizes = {
    default: '30px',
    '__unstable-large': '32px'
  };
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("color:", colors_values/* COLORS */.l.gray[900], ";height:", iconButtonSizes[size], ";aspect-ratio:1;padding-left:0;padding-right:0;" + ( true ? "" : 0),  true ? "" : 0);
};
const backdropView = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("background:", colors_values/* COLORS */.l.gray[900], ";border-radius:", config_values/* default */.A.controlBorderRadius, ";position:absolute;inset:0;z-index:1;outline:2px solid transparent;outline-offset:-3px;" + ( true ? "" : 0),  true ? "" : 0);
//# sourceMappingURL=styles.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tooltip/index.js + 5 modules
var tooltip = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tooltip/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-base/component.js
/**
 * External dependencies
 */

// eslint-disable-next-line no-restricted-imports

// eslint-disable-next-line no-restricted-imports


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */









const {
  ButtonContentView: component_ButtonContentView,
  LabelView: component_LabelView
} = toggle_group_control_option_base_styles_namespaceObject;
const REDUCED_MOTION_TRANSITION_CONFIG = {
  duration: 0
};
const LAYOUT_ID = 'toggle-group-backdrop-shared-layout-id';
const WithToolTip = ({
  showTooltip,
  text,
  children
}) => {
  if (showTooltip && text) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
      text: text,
      placement: "top",
      children: children
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: children
  });
};
function ToggleGroupControlOptionBase(props, forwardedRef) {
  const shouldReduceMotion = (0,use_reduced_motion/* default */.A)();
  const toggleGroupControlContext = useToggleGroupControlContext();
  const id = (0,use_instance_id/* default */.A)(ToggleGroupControlOptionBase, toggleGroupControlContext.baseId || 'toggle-group-control-option-base');
  const buttonProps = (0,use_context_system/* useContextSystem */.A)({
    ...props,
    id
  }, 'ToggleGroupControlOptionBase');
  const {
    isBlock = false,
    isDeselectable = false,
    size = 'default'
  } = toggleGroupControlContext;
  const {
    className,
    isIcon = false,
    value,
    children,
    showTooltip = false,
    onFocus: onFocusProp,
    ...otherButtonProps
  } = buttonProps;
  const isPressed = toggleGroupControlContext.value === value;
  const cx = (0,use_cx/* useCx */.l)();
  const labelViewClasses = (0,react.useMemo)(() => cx(isBlock && labelBlock), [cx, isBlock]);
  const itemClasses = (0,react.useMemo)(() => cx(buttonView({
    isDeselectable,
    isIcon,
    isPressed,
    size
  }), className), [cx, isDeselectable, isIcon, isPressed, size, className]);
  const backdropClasses = (0,react.useMemo)(() => cx(backdropView), [cx]);
  const buttonOnClick = () => {
    if (isDeselectable && isPressed) {
      toggleGroupControlContext.setValue(undefined);
    } else {
      toggleGroupControlContext.setValue(value);
    }
  };
  const commonProps = {
    ...otherButtonProps,
    className: itemClasses,
    'data-value': value,
    ref: forwardedRef
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(component_LabelView, {
    className: labelViewClasses,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(WithToolTip, {
      showTooltip: showTooltip,
      text: otherButtonProps['aria-label'],
      children: isDeselectable ? /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
        ...commonProps,
        onFocus: onFocusProp,
        "aria-pressed": isPressed,
        type: "button",
        onClick: buttonOnClick,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(component_ButtonContentView, {
          children: children
        })
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)(Radio, {
        render: /*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          type: "button",
          ...commonProps,
          onFocus: event => {
            onFocusProp?.(event);
            if (event.defaultPrevented) {
              return;
            }
            toggleGroupControlContext.setValue(value);
          }
        }),
        value: value,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(component_ButtonContentView, {
          children: children
        })
      })
    }), isPressed ? /*#__PURE__*/(0,jsx_runtime.jsx)(motion/* motion */.P.div, {
      layout: true,
      layoutRoot: true,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(motion/* motion */.P.div, {
        className: backdropClasses,
        transition: shouldReduceMotion ? REDUCED_MOTION_TRANSITION_CONFIG : undefined,
        role: "presentation",
        layoutId: LAYOUT_ID
      })
    }) : null]
  });
}

/**
 * `ToggleGroupControlOptionBase` is a form component and is meant to be used as an internal,
 * generic component for any children of `ToggleGroupControl`.
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalToggleGroupControl as ToggleGroupControl,
 *   __experimentalToggleGroupControlOptionBase as ToggleGroupControlOptionBase,
 * } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ToggleGroupControl label="my label" value="vertical" isBlock>
 *       <ToggleGroupControlOption value="horizontal" label="Horizontal" />
 *       <ToggleGroupControlOption value="vertical" label="Vertical" />
 *     </ToggleGroupControl>
 *   );
 * }
 * ```
 */
const ConnectedToggleGroupControlOptionBase = (0,context_connect/* contextConnect */.KZ)(ToggleGroupControlOptionBase, 'ToggleGroupControlOptionBase');
/* harmony default export */ const toggle_group_control_option_base_component = (ConnectedToggleGroupControlOptionBase);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-icon/component.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function UnforwardedToggleGroupControlOptionIcon(props, ref) {
  const {
    icon,
    label,
    ...restProps
  } = props;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_base_component, {
    ...restProps,
    isIcon: true,
    "aria-label": label,
    showTooltip: true,
    ref: ref,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
      icon: icon
    })
  });
}

/**
 * `ToggleGroupControlOptionIcon` is a form component which is meant to be used as a
 * child of `ToggleGroupControl` and displays an icon.
 *
 * ```jsx
 *
 * import {
 *	__experimentalToggleGroupControl as ToggleGroupControl,
 *	__experimentalToggleGroupControlOptionIcon as ToggleGroupControlOptionIcon,
 * from '@wordpress/components';
 * import { formatLowercase, formatUppercase } from '@wordpress/icons';
 *
 * function Example() {
 *	return (
 *		<ToggleGroupControl>
 *			<ToggleGroupControlOptionIcon
 *				value="uppercase"
 *				label="Uppercase"
 *				icon={ formatUppercase }
 *			/>
 *			<ToggleGroupControlOptionIcon
 *				value="lowercase"
 *				label="Lowercase"
 *				icon={ formatLowercase }
 *			/>
 *		</ToggleGroupControl>
 *	);
 * }
 * ```
 */
const ToggleGroupControlOptionIcon = (0,react.forwardRef)(UnforwardedToggleGroupControlOptionIcon);
/* harmony default export */ const toggle_group_control_option_icon_component = (ToggleGroupControlOptionIcon);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-control/index.js
var toggle_control = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-control/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/layouts/definitions.js
// Layout definitions keyed by layout type.
// Provides a common definition of slugs, classnames, base styles, and spacing styles for each layout type.
// If making changes or additions to layout definitions, be sure to update the corresponding PHP definitions in
// `block-supports/layout.php` so that the server-side and client-side definitions match.
const LAYOUT_DEFINITIONS = {
  default: {
    name: 'default',
    slug: 'flow',
    className: 'is-layout-flow',
    baseStyles: [{
      selector: ' > .alignleft',
      rules: {
        float: 'left',
        'margin-inline-start': '0',
        'margin-inline-end': '2em'
      }
    }, {
      selector: ' > .alignright',
      rules: {
        float: 'right',
        'margin-inline-start': '2em',
        'margin-inline-end': '0'
      }
    }, {
      selector: ' > .aligncenter',
      rules: {
        'margin-left': 'auto !important',
        'margin-right': 'auto !important'
      }
    }],
    spacingStyles: [{
      selector: ' > :first-child',
      rules: {
        'margin-block-start': '0'
      }
    }, {
      selector: ' > :last-child',
      rules: {
        'margin-block-end': '0'
      }
    }, {
      selector: ' > *',
      rules: {
        'margin-block-start': null,
        'margin-block-end': '0'
      }
    }]
  },
  constrained: {
    name: 'constrained',
    slug: 'constrained',
    className: 'is-layout-constrained',
    baseStyles: [{
      selector: ' > .alignleft',
      rules: {
        float: 'left',
        'margin-inline-start': '0',
        'margin-inline-end': '2em'
      }
    }, {
      selector: ' > .alignright',
      rules: {
        float: 'right',
        'margin-inline-start': '2em',
        'margin-inline-end': '0'
      }
    }, {
      selector: ' > .aligncenter',
      rules: {
        'margin-left': 'auto !important',
        'margin-right': 'auto !important'
      }
    }, {
      selector: ' > :where(:not(.alignleft):not(.alignright):not(.alignfull))',
      rules: {
        'max-width': 'var(--wp--style--global--content-size)',
        'margin-left': 'auto !important',
        'margin-right': 'auto !important'
      }
    }, {
      selector: ' > .alignwide',
      rules: {
        'max-width': 'var(--wp--style--global--wide-size)'
      }
    }],
    spacingStyles: [{
      selector: ' > :first-child',
      rules: {
        'margin-block-start': '0'
      }
    }, {
      selector: ' > :last-child',
      rules: {
        'margin-block-end': '0'
      }
    }, {
      selector: ' > *',
      rules: {
        'margin-block-start': null,
        'margin-block-end': '0'
      }
    }]
  },
  flex: {
    name: 'flex',
    slug: 'flex',
    className: 'is-layout-flex',
    displayMode: 'flex',
    baseStyles: [{
      selector: '',
      rules: {
        'flex-wrap': 'wrap',
        'align-items': 'center'
      }
    }, {
      selector: ' > :is(*, div)',
      // :is(*, div) instead of just * increases the specificity by 001.
      rules: {
        margin: '0'
      }
    }],
    spacingStyles: [{
      selector: '',
      rules: {
        gap: null
      }
    }]
  },
  grid: {
    name: 'grid',
    slug: 'grid',
    className: 'is-layout-grid',
    displayMode: 'grid',
    baseStyles: [{
      selector: ' > :is(*, div)',
      // :is(*, div) instead of just * increases the specificity by 001.
      rules: {
        margin: '0'
      }
    }],
    spacingStyles: [{
      selector: '',
      rules: {
        gap: null
      }
    }]
  }
};
//# sourceMappingURL=definitions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/layouts/utils.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Utility to generate the proper CSS selector for layout styles.
 *
 * @param {string} selectors CSS selector, also supports multiple comma-separated selectors.
 * @param {string} append    The string to append.
 *
 * @return {string} - CSS selector.
 */
function appendSelectors(selectors, append = '') {
  // Ideally we shouldn't need the `.editor-styles-wrapper` increased specificity here
  // The problem though is that we have a `.editor-styles-wrapper p { margin: reset; }` style
  // it's used to reset the default margin added by wp-admin to paragraphs
  // so we need this to be higher speficity otherwise, it won't be applied to paragraphs inside containers
  // When the post editor is fully iframed, this extra classname could be removed.

  return selectors.split(',').map(subselector => `.editor-styles-wrapper ${subselector}${append ? ` ${append}` : ''}`).join(',');
}

/**
 * Get generated blockGap CSS rules based on layout definitions provided in theme.json
 * Falsy values in the layout definition's spacingStyles rules will be swapped out
 * with the provided `blockGapValue`.
 *
 * @param {string} selector          The CSS selector to target for the generated rules.
 * @param {Object} layoutDefinitions Layout definitions object.
 * @param {string} layoutType        The layout type (e.g. `default` or `flex`).
 * @param {string} blockGapValue     The current blockGap value to be applied.
 * @return {string} The generated CSS rules.
 */
function getBlockGapCSS(selector, layoutDefinitions = LAYOUT_DEFINITIONS, layoutType, blockGapValue) {
  let output = '';
  if (layoutDefinitions?.[layoutType]?.spacingStyles?.length && blockGapValue) {
    layoutDefinitions[layoutType].spacingStyles.forEach(gapStyle => {
      output += `${appendSelectors(selector, gapStyle.selector.trim())} { `;
      output += Object.entries(gapStyle.rules).map(([cssProperty, value]) => `${cssProperty}: ${value ? value : blockGapValue}`).join('; ');
      output += '; }';
    });
  }
  return output;
}

/**
 * Helper method to assign contextual info to clarify
 * alignment settings.
 *
 * Besides checking if `contentSize` and `wideSize` have a
 * value, we now show this information only if their values
 * are not a `css var`. This needs to change when parsing
 * css variables land.
 *
 * @see https://github.com/WordPress/gutenberg/pull/34710#issuecomment-918000752
 *
 * @param {Object} layout The layout object.
 * @return {Object} An object with contextual info per alignment.
 */
function getAlignmentsInfo(layout) {
  const {
    contentSize,
    wideSize,
    type = 'default'
  } = layout;
  const alignmentInfo = {};
  const sizeRegex = /^(?!0)\d+(px|em|rem|vw|vh|%|svw|lvw|dvw|svh|lvh|dvh|vi|svi|lvi|dvi|vb|svb|lvb|dvb|vmin|svmin|lvmin|dvmin|vmax|svmax|lvmax|dvmax)?$/i;
  if (sizeRegex.test(contentSize) && type === 'constrained') {
    // translators: %s: container size (i.e. 600px etc)
    alignmentInfo.none = (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Max %s wide'), contentSize);
  }
  if (sizeRegex.test(wideSize)) {
    // translators: %s: container size (i.e. 600px etc)
    alignmentInfo.wide = (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Max %s wide'), wideSize);
  }
  return alignmentInfo;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/sides-all.js
/**
 * WordPress dependencies
 */


const sidesAll = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z"
  })
});
/* harmony default export */ const sides_all = (sidesAll);
//# sourceMappingURL=sides-all.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/sides-horizontal.js
/**
 * WordPress dependencies
 */


const sidesHorizontal = /*#__PURE__*/(0,jsx_runtime.jsxs)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
    style: {
      opacity: 0.25
    }
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m4.5 7.5v9h1.5v-9z"
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m18 7.5v9h1.5v-9z"
  })]
});
/* harmony default export */ const sides_horizontal = (sidesHorizontal);
//# sourceMappingURL=sides-horizontal.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/sides-vertical.js
/**
 * WordPress dependencies
 */


const sidesVertical = /*#__PURE__*/(0,jsx_runtime.jsxs)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
    style: {
      opacity: 0.25
    }
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7.5 6h9v-1.5h-9z"
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7.5 19.5h9v-1.5h-9z"
  })]
});
/* harmony default export */ const sides_vertical = (sidesVertical);
//# sourceMappingURL=sides-vertical.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/sides-top.js
/**
 * WordPress dependencies
 */


const sidesTop = /*#__PURE__*/(0,jsx_runtime.jsxs)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
    style: {
      opacity: 0.25
    }
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m16.5 6h-9v-1.5h9z"
  })]
});
/* harmony default export */ const sides_top = (sidesTop);
//# sourceMappingURL=sides-top.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/sides-right.js
/**
 * WordPress dependencies
 */


const sidesRight = /*#__PURE__*/(0,jsx_runtime.jsxs)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
    style: {
      opacity: 0.25
    }
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m18 16.5v-9h1.5v9z"
  })]
});
/* harmony default export */ const sides_right = (sidesRight);
//# sourceMappingURL=sides-right.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/sides-bottom.js
/**
 * WordPress dependencies
 */


const sidesBottom = /*#__PURE__*/(0,jsx_runtime.jsxs)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
    style: {
      opacity: 0.25
    }
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m16.5 19.5h-9v-1.5h9z"
  })]
});
/* harmony default export */ const sides_bottom = (sidesBottom);
//# sourceMappingURL=sides-bottom.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/sides-left.js
/**
 * WordPress dependencies
 */


const sidesLeft = /*#__PURE__*/(0,jsx_runtime.jsxs)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
    style: {
      opacity: 0.25
    }
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m4.5 16.5v-9h1.5v9z"
  })]
});
/* harmony default export */ const sides_left = (sidesLeft);
//# sourceMappingURL=sides-left.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/utils.js
/**
 * WordPress dependencies
 */


const RANGE_CONTROL_MAX_SIZE = 8;
const ALL_SIDES = ['top', 'right', 'bottom', 'left'];
const DEFAULT_VALUES = {
  top: undefined,
  right: undefined,
  bottom: undefined,
  left: undefined
};
const ICONS = {
  custom: sides_all,
  axial: sides_all,
  horizontal: sides_horizontal,
  vertical: sides_vertical,
  top: sides_top,
  right: sides_right,
  bottom: sides_bottom,
  left: sides_left
};
const LABELS = {
  default: (0,i18n_build_module.__)('Spacing control'),
  top: (0,i18n_build_module.__)('Top'),
  bottom: (0,i18n_build_module.__)('Bottom'),
  left: (0,i18n_build_module.__)('Left'),
  right: (0,i18n_build_module.__)('Right'),
  mixed: (0,i18n_build_module.__)('Mixed'),
  vertical: (0,i18n_build_module.__)('Vertical'),
  horizontal: (0,i18n_build_module.__)('Horizontal'),
  axial: (0,i18n_build_module.__)('Horizontal & vertical'),
  custom: (0,i18n_build_module.__)('Custom')
};
const VIEWS = {
  axial: 'axial',
  top: 'top',
  right: 'right',
  bottom: 'bottom',
  left: 'left',
  custom: 'custom'
};

/**
 * Checks is given value is a spacing preset.
 *
 * @param {string} value Value to check
 *
 * @return {boolean} Return true if value is string in format var:preset|spacing|.
 */
function isValueSpacingPreset(value) {
  if (!value?.includes) {
    return false;
  }
  return value === '0' || value.includes('var:preset|spacing|');
}

/**
 * Converts a spacing preset into a custom value.
 *
 * @param {string} value        Value to convert
 * @param {Array}  spacingSizes Array of the current spacing preset objects
 *
 * @return {string} Mapping of the spacing preset to its equivalent custom value.
 */
function getCustomValueFromPreset(value, spacingSizes) {
  if (!isValueSpacingPreset(value)) {
    return value;
  }
  const slug = getSpacingPresetSlug(value);
  const spacingSize = spacingSizes.find(size => String(size.slug) === slug);
  return spacingSize?.size;
}

/**
 * Converts a custom value to preset value if one can be found.
 *
 * Returns value as-is if no match is found.
 *
 * @param {string} value        Value to convert
 * @param {Array}  spacingSizes Array of the current spacing preset objects
 *
 * @return {string} The preset value if it can be found.
 */
function getPresetValueFromCustomValue(value, spacingSizes) {
  // Return value as-is if it is undefined or is already a preset, or '0';
  if (!value || isValueSpacingPreset(value) || value === '0') {
    return value;
  }
  const spacingMatch = spacingSizes.find(size => String(size.size) === String(value));
  if (spacingMatch?.slug) {
    return `var:preset|spacing|${spacingMatch.slug}`;
  }
  return value;
}

/**
 * Converts a spacing preset into a custom value.
 *
 * @param {string} value Value to convert.
 *
 * @return {string | undefined} CSS var string for given spacing preset value.
 */
function getSpacingPresetCssVar(value) {
  if (!value) {
    return;
  }
  const slug = value.match(/var:preset\|spacing\|(.+)/);
  if (!slug) {
    return value;
  }
  return `var(--wp--preset--spacing--${slug[1]})`;
}

/**
 * Returns the slug section of the given spacing preset string.
 *
 * @param {string} value Value to extract slug from.
 *
 * @return {string|undefined} The int value of the slug from given spacing preset.
 */
function getSpacingPresetSlug(value) {
  if (!value) {
    return;
  }
  if (value === '0' || value === 'default') {
    return value;
  }
  const slug = value.match(/var:preset\|spacing\|(.+)/);
  return slug ? slug[1] : undefined;
}

/**
 * Converts spacing preset value into a Range component value .
 *
 * @param {string} presetValue  Value to convert to Range value.
 * @param {Array}  spacingSizes Array of current spacing preset value objects.
 *
 * @return {number} The int value for use in Range control.
 */
function getSliderValueFromPreset(presetValue, spacingSizes) {
  if (presetValue === undefined) {
    return 0;
  }
  const slug = parseFloat(presetValue, 10) === 0 ? '0' : getSpacingPresetSlug(presetValue);
  const sliderValue = spacingSizes.findIndex(spacingSize => {
    return String(spacingSize.slug) === slug;
  });

  // Returning NaN rather than undefined as undefined makes range control thumb sit in center
  return sliderValue !== -1 ? sliderValue : NaN;
}

/**
 * Gets an items with the most occurrence within an array
 * https://stackoverflow.com/a/20762713
 *
 * @param {Array<any>} arr Array of items to check.
 * @return {any} The item with the most occurrences.
 */
function mode(arr) {
  return arr.sort((a, b) => arr.filter(v => v === a).length - arr.filter(v => v === b).length).pop();
}

/**
 * Gets the 'all' input value from values data.
 *
 * @param {Object} values Box spacing values
 *
 * @return {string} The most common value from all sides of box.
 */
function getAllRawValue(values = {}) {
  return mode(Object.values(values));
}

/**
 * Checks to determine if values are mixed.
 *
 * @param {Object} values Box values.
 * @param {Array}  sides  Sides that values relate to.
 *
 * @return {boolean} Whether values are mixed.
 */
function isValuesMixed(values = {}, sides = ALL_SIDES) {
  return Object.values(values).length >= 1 && Object.values(values).length < sides.length || new Set(Object.values(values)).size > 1;
}

/**
 * Checks to determine if values are defined.
 *
 * @param {Object} values Box values.
 *
 * @return {boolean} Whether values are defined.
 */
function isValuesDefined(values) {
  if (values === undefined || values === null) {
    return false;
  }
  return Object.values(values).filter(value => !!value).length > 0;
}

/**
 * Determines whether a particular axis has support. If no axis is
 * specified, this function checks if either axis is supported.
 *
 * @param {Array}  sides Supported sides.
 * @param {string} axis  Which axis to check.
 *
 * @return {boolean} Whether there is support for the specified axis or both axes.
 */
function hasAxisSupport(sides, axis) {
  if (!sides || !sides.length) {
    return false;
  }
  const hasHorizontalSupport = sides.includes('horizontal') || sides.includes('left') && sides.includes('right');
  const hasVerticalSupport = sides.includes('vertical') || sides.includes('top') && sides.includes('bottom');
  if (axis === 'horizontal') {
    return hasHorizontalSupport;
  }
  if (axis === 'vertical') {
    return hasVerticalSupport;
  }
  return hasHorizontalSupport || hasVerticalSupport;
}

/**
 * Determines which menu options should be included in the SidePicker.
 *
 * @param {Array} sides Supported sides.
 *
 * @return {Object} Menu options with each option containing label & icon.
 */
function getSupportedMenuItems(sides) {
  if (!sides || !sides.length) {
    return {};
  }
  const menuItems = {};

  // Determine the primary "side" menu options.
  const hasHorizontalSupport = hasAxisSupport(sides, 'horizontal');
  const hasVerticalSupport = hasAxisSupport(sides, 'vertical');
  if (hasHorizontalSupport && hasVerticalSupport) {
    menuItems.axial = {
      label: LABELS.axial,
      icon: ICONS.axial
    };
  } else if (hasHorizontalSupport) {
    menuItems.axial = {
      label: LABELS.horizontal,
      icon: ICONS.horizontal
    };
  } else if (hasVerticalSupport) {
    menuItems.axial = {
      label: LABELS.vertical,
      icon: ICONS.vertical
    };
  }

  // Track whether we have any individual sides so we can omit the custom
  // option if required.
  let numberOfIndividualSides = 0;
  ALL_SIDES.forEach(side => {
    if (sides.includes(side)) {
      numberOfIndividualSides += 1;
      menuItems[side] = {
        label: LABELS[side],
        icon: ICONS[side]
      };
    }
  });

  // Add custom item if there are enough sides to warrant a separated view.
  if (numberOfIndividualSides > 1) {
    menuItems.custom = {
      label: LABELS.custom,
      icon: ICONS.custom
    };
  }
  return menuItems;
}

/**
 * Checks if the supported sides are balanced for each axis.
 * - Horizontal - both left and right sides are supported.
 * - Vertical - both top and bottom are supported.
 *
 * @param {Array} sides The supported sides which may be axes as well.
 *
 * @return {boolean} Whether or not the supported sides are balanced.
 */
function hasBalancedSidesSupport(sides = []) {
  const counts = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  sides.forEach(side => counts[side] += 1);
  return (counts.top + counts.bottom) % 2 === 0 && (counts.left + counts.right) % 2 === 0;
}

/**
 * Determines which view the SpacingSizesControl should default to on its
 * first render; Axial, Custom, or Single side.
 *
 * @param {Object} values Current side values.
 * @param {Array}  sides  Supported sides.
 *
 * @return {string} View to display.
 */
function getInitialView(values = {}, sides) {
  const {
    top,
    right,
    bottom,
    left
  } = values;
  const sideValues = [top, right, bottom, left].filter(Boolean);

  // Axial ( Horizontal & vertical ).
  // - Has axial side support
  // - Has axial side values which match
  // - Has no values and the supported sides are balanced
  const hasMatchingAxialValues = top === bottom && left === right && (!!top || !!left);
  const hasNoValuesAndBalancedSides = !sideValues.length && hasBalancedSidesSupport(sides);
  if (hasAxisSupport(sides) && (hasMatchingAxialValues || hasNoValuesAndBalancedSides)) {
    return VIEWS.axial;
  }

  // Single side.
  // - Ensure the side returned is the first side that has a value.
  if (sideValues.length === 1) {
    let side;
    Object.entries(values).some(([key, value]) => {
      side = key;
      return value !== undefined;
    });
    return side;
  }

  // Only single side supported and no value defined.
  if (sides?.length === 1 && !sideValues.length) {
    return sides[0];
  }

  // Default to the Custom (separated sides) view.
  return VIEWS.custom;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/gap.js
/**
 * Internal dependencies
 */


/**
 * Returns a BoxControl object value from a given blockGap style value.
 * The string check is for backwards compatibility before Gutenberg supported
 * split gap values (row and column) and the value was a string n + unit.
 *
 * @param {string? | Object?} blockGapValue A block gap string or axial object value, e.g., '10px' or { top: '10px', left: '10px'}.
 * @return {Object|null}                    A value to pass to the BoxControl component.
 */
function getGapBoxControlValueFromStyle(blockGapValue) {
  if (!blockGapValue) {
    return null;
  }
  const isValueString = typeof blockGapValue === 'string';
  return {
    top: isValueString ? blockGapValue : blockGapValue?.top,
    left: isValueString ? blockGapValue : blockGapValue?.left
  };
}

/**
 * Returns a CSS value for the `gap` property from a given blockGap style.
 *
 * @param {string? | Object?} blockGapValue A block gap string or axial object value, e.g., '10px' or { top: '10px', left: '10px'}.
 * @param {string?}           defaultValue  A default gap value.
 * @return {string|null}                    The concatenated gap value (row and column).
 */
function getGapCSSValue(blockGapValue, defaultValue = '0') {
  const blockGapBoxControlValue = getGapBoxControlValueFromStyle(blockGapValue);
  if (!blockGapBoxControlValue) {
    return null;
  }
  const row = getSpacingPresetCssVar(blockGapBoxControlValue?.top) || defaultValue;
  const column = getSpacingPresetCssVar(blockGapBoxControlValue?.left) || defaultValue;
  return row === column ? row : `${row} ${column}`;
}
//# sourceMappingURL=gap.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/icons.js
/**
 * WordPress dependencies
 */


const alignBottom = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* Path */.wA, {
    d: "M15 4H9v11h6V4zM4 18.5V20h16v-1.5H4z"
  })
});
const alignCenter = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* Path */.wA, {
    d: "M20 11h-5V4H9v7H4v1.5h5V20h6v-7.5h5z"
  })
});
const alignTop = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* Path */.wA, {
    d: "M9 20h6V9H9v11zM4 4v1.5h16V4H4z"
  })
});
const alignStretch = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* Path */.wA, {
    d: "M4 4L20 4L20 5.5L4 5.5L4 4ZM10 7L14 7L14 17L10 17L10 7ZM20 18.5L4 18.5L4 20L20 20L20 18.5Z"
  })
});
const spaceBetween = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* Path */.wA, {
    d: "M7 4H17V8L7 8V4ZM7 16L17 16V20L7 20V16ZM20 11.25H4V12.75H20V11.25Z"
  })
});
//# sourceMappingURL=icons.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/ui.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const BLOCK_ALIGNMENTS_CONTROLS = {
  top: {
    icon: alignTop,
    title: (0,i18n_build_module._x)('Align top', 'Block vertical alignment setting')
  },
  center: {
    icon: alignCenter,
    title: (0,i18n_build_module._x)('Align middle', 'Block vertical alignment setting')
  },
  bottom: {
    icon: alignBottom,
    title: (0,i18n_build_module._x)('Align bottom', 'Block vertical alignment setting')
  },
  stretch: {
    icon: alignStretch,
    title: (0,i18n_build_module._x)('Stretch to fill', 'Block vertical alignment setting')
  },
  'space-between': {
    icon: spaceBetween,
    title: (0,i18n_build_module._x)('Space between', 'Block vertical alignment setting')
  }
};
const DEFAULT_CONTROLS = ['top', 'center', 'bottom'];
const DEFAULT_CONTROL = 'top';
function ui_BlockVerticalAlignmentUI({
  value,
  onChange,
  controls = DEFAULT_CONTROLS,
  isCollapsed = true,
  isToolbar
}) {
  function applyOrUnset(align) {
    return () => onChange(value === align ? undefined : align);
  }
  const activeAlignment = BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS[DEFAULT_CONTROL];
  const UIComponent = isToolbar ? toolbar_group/* default */.A : toolbar_dropdown_menu;
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return /*#__PURE__*/(0,jsx_runtime.jsx)(UIComponent, {
    icon: activeAlignment ? activeAlignment.icon : defaultAlignmentControl.icon,
    label: (0,i18n_build_module._x)('Change vertical alignment', 'Block vertical alignment setting label'),
    controls: controls.map(control => {
      return {
        ...BLOCK_ALIGNMENTS_CONTROLS[control],
        isActive: value === control,
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: applyOrUnset(control)
      };
    }),
    ...extraProps
  });
}

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-vertical-alignment-toolbar/README.md
 */
/* harmony default export */ const ui = (ui_BlockVerticalAlignmentUI);
//# sourceMappingURL=ui.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/index.js
/**
 * Internal dependencies
 */


const BlockVerticalAlignmentControl = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(ui, {
    ...props,
    isToolbar: false
  });
};
const BlockVerticalAlignmentToolbar = props => {
  return /*#__PURE__*/_jsx(BlockVerticalAlignmentUI, {
    ...props,
    isToolbar: true
  });
};

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-vertical-alignment-control/README.md
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/justify-content-control/ui.js
/**
 * WordPress dependencies
 */




const icons = {
  left: justify_left,
  center: justify_center,
  right: justify_right,
  'space-between': justify_space_between,
  stretch: justify_stretch
};
function ui_JustifyContentUI({
  allowedControls = ['left', 'center', 'right', 'space-between'],
  isCollapsed = true,
  onChange,
  value,
  popoverProps,
  isToolbar
}) {
  // If the control is already selected we want a click
  // again on the control to deselect the item, so we
  // call onChange( undefined )
  const handleClick = next => {
    if (next === value) {
      onChange(undefined);
    } else {
      onChange(next);
    }
  };
  const icon = value ? icons[value] : icons.left;
  const allControls = [{
    name: 'left',
    icon: justify_left,
    title: (0,i18n_build_module.__)('Justify items left'),
    isActive: 'left' === value,
    onClick: () => handleClick('left')
  }, {
    name: 'center',
    icon: justify_center,
    title: (0,i18n_build_module.__)('Justify items center'),
    isActive: 'center' === value,
    onClick: () => handleClick('center')
  }, {
    name: 'right',
    icon: justify_right,
    title: (0,i18n_build_module.__)('Justify items right'),
    isActive: 'right' === value,
    onClick: () => handleClick('right')
  }, {
    name: 'space-between',
    icon: justify_space_between,
    title: (0,i18n_build_module.__)('Space between items'),
    isActive: 'space-between' === value,
    onClick: () => handleClick('space-between')
  }, {
    name: 'stretch',
    icon: justify_stretch,
    title: (0,i18n_build_module.__)('Stretch items'),
    isActive: 'stretch' === value,
    onClick: () => handleClick('stretch')
  }];
  const UIComponent = isToolbar ? toolbar_group/* default */.A : toolbar_dropdown_menu;
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return /*#__PURE__*/(0,jsx_runtime.jsx)(UIComponent, {
    icon: icon,
    popoverProps: popoverProps,
    label: (0,i18n_build_module.__)('Change items justification'),
    controls: allControls.filter(elem => allowedControls.includes(elem.name)),
    ...extraProps
  });
}
/* harmony default export */ const justify_content_control_ui = (ui_JustifyContentUI);
//# sourceMappingURL=ui.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/justify-content-control/index.js
/**
 * Internal dependencies
 */


const JustifyContentControl = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(justify_content_control_ui, {
    ...props,
    isToolbar: false
  });
};
const JustifyToolbar = props => {
  return /*#__PURE__*/_jsx(JustifyContentUI, {
    ...props,
    isToolbar: true
  });
};

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/justify-content-control/README.md
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/layouts/flex.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






// Used with the default, horizontal flex orientation.



const justifyContentMap = {
  left: 'flex-start',
  right: 'flex-end',
  center: 'center',
  'space-between': 'space-between'
};

// Used with the vertical (column) flex orientation.
const alignItemsMap = {
  left: 'flex-start',
  right: 'flex-end',
  center: 'center',
  stretch: 'stretch'
};
const verticalAlignmentMap = {
  top: 'flex-start',
  center: 'center',
  bottom: 'flex-end',
  stretch: 'stretch',
  'space-between': 'space-between'
};
const flexWrapOptions = ['wrap', 'nowrap'];
/* harmony default export */ const flex = ({
  name: 'flex',
  label: (0,i18n_build_module.__)('Flex'),
  inspectorControls: function FlexLayoutInspectorControls({
    layout = {},
    onChange,
    layoutBlockSupport = {}
  }) {
    const {
      allowOrientation = true
    } = layoutBlockSupport;
    return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(FlexLayoutJustifyContentControl, {
            layout: layout,
            onChange: onChange
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          children: allowOrientation && /*#__PURE__*/(0,jsx_runtime.jsx)(OrientationControl, {
            layout: layout,
            onChange: onChange
          })
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(FlexWrapControl, {
        layout: layout,
        onChange: onChange
      })]
    });
  },
  toolBarControls: function FlexLayoutToolbarControls({
    layout = {},
    onChange,
    layoutBlockSupport
  }) {
    if (layoutBlockSupport?.allowSwitching) {
      return null;
    }
    const {
      allowVerticalAlignment = true
    } = layoutBlockSupport;
    return /*#__PURE__*/(0,jsx_runtime.jsxs)(block_controls, {
      group: "block",
      __experimentalShareWithChildBlocks: true,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(FlexLayoutJustifyContentControl, {
        layout: layout,
        onChange: onChange,
        isToolbar: true
      }), allowVerticalAlignment && /*#__PURE__*/(0,jsx_runtime.jsx)(FlexLayoutVerticalAlignmentControl, {
        layout: layout,
        onChange: onChange,
        isToolbar: true
      })]
    });
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    layout,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const {
      orientation = 'horizontal'
    } = layout;

    // If a block's block.json skips serialization for spacing or spacing.blockGap,
    // don't apply the user-defined value to the styles.
    const blockGapValue = style?.spacing?.blockGap && !shouldSkipSerialization(blockName, 'spacing', 'blockGap') ? getGapCSSValue(style?.spacing?.blockGap, '0.5em') : undefined;
    const justifyContent = justifyContentMap[layout.justifyContent];
    const flexWrap = flexWrapOptions.includes(layout.flexWrap) ? layout.flexWrap : 'wrap';
    const verticalAlignment = verticalAlignmentMap[layout.verticalAlignment];
    const alignItems = alignItemsMap[layout.justifyContent] || alignItemsMap.left;
    let output = '';
    const rules = [];
    if (flexWrap && flexWrap !== 'wrap') {
      rules.push(`flex-wrap: ${flexWrap}`);
    }
    if (orientation === 'horizontal') {
      if (verticalAlignment) {
        rules.push(`align-items: ${verticalAlignment}`);
      }
      if (justifyContent) {
        rules.push(`justify-content: ${justifyContent}`);
      }
    } else {
      if (verticalAlignment) {
        rules.push(`justify-content: ${verticalAlignment}`);
      }
      rules.push('flex-direction: column');
      rules.push(`align-items: ${alignItems}`);
    }
    if (rules.length) {
      output = `${appendSelectors(selector)} {
				${rules.join('; ')};
			}`;
    }

    // Output blockGap styles based on rules contained in layout definitions in theme.json.
    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'flex', blockGapValue);
    }
    return output;
  },
  getOrientation(layout) {
    const {
      orientation = 'horizontal'
    } = layout;
    return orientation;
  },
  getAlignments() {
    return [];
  }
});
function FlexLayoutVerticalAlignmentControl({
  layout,
  onChange,
  isToolbar = false
}) {
  const {
    orientation = 'horizontal'
  } = layout;
  const defaultVerticalAlignment = orientation === 'horizontal' ? verticalAlignmentMap.center : verticalAlignmentMap.top;
  const {
    verticalAlignment = defaultVerticalAlignment
  } = layout;
  const onVerticalAlignmentChange = value => {
    onChange({
      ...layout,
      verticalAlignment: value
    });
  };
  if (isToolbar) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockVerticalAlignmentControl, {
      onChange: onVerticalAlignmentChange,
      value: verticalAlignment,
      controls: orientation === 'horizontal' ? ['top', 'center', 'bottom', 'stretch'] : ['top', 'center', 'bottom', 'space-between']
    });
  }
  const verticalAlignmentOptions = [{
    value: 'flex-start',
    label: (0,i18n_build_module.__)('Align items top')
  }, {
    value: 'center',
    label: (0,i18n_build_module.__)('Align items center')
  }, {
    value: 'flex-end',
    label: (0,i18n_build_module.__)('Align items bottom')
  }];
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {
    className: "block-editor-hooks__flex-layout-vertical-alignment-control",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("legend", {
      children: (0,i18n_build_module.__)('Vertical alignment')
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      children: verticalAlignmentOptions.map((value, icon, label) => {
        return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          label: label,
          icon: icon,
          isPressed: verticalAlignment === value,
          onClick: () => onVerticalAlignmentChange(value)
        }, value);
      })
    })]
  });
}
const POPOVER_PROPS = {
  placement: 'bottom-start'
};
function FlexLayoutJustifyContentControl({
  layout,
  onChange,
  isToolbar = false
}) {
  const {
    justifyContent = 'left',
    orientation = 'horizontal'
  } = layout;
  const onJustificationChange = value => {
    onChange({
      ...layout,
      justifyContent: value
    });
  };
  const allowedControls = ['left', 'center', 'right'];
  if (orientation === 'horizontal') {
    allowedControls.push('space-between');
  } else {
    allowedControls.push('stretch');
  }
  if (isToolbar) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(JustifyContentControl, {
      allowedControls: allowedControls,
      value: justifyContent,
      onChange: onJustificationChange,
      popoverProps: POPOVER_PROPS
    });
  }
  const justificationOptions = [{
    value: 'left',
    icon: justify_left,
    label: (0,i18n_build_module.__)('Justify items left')
  }, {
    value: 'center',
    icon: justify_center,
    label: (0,i18n_build_module.__)('Justify items center')
  }, {
    value: 'right',
    icon: justify_right,
    label: (0,i18n_build_module.__)('Justify items right')
  }];
  if (orientation === 'horizontal') {
    justificationOptions.push({
      value: 'space-between',
      icon: justify_space_between,
      label: (0,i18n_build_module.__)('Space between items')
    });
  } else {
    justificationOptions.push({
      value: 'stretch',
      icon: justify_stretch,
      label: (0,i18n_build_module.__)('Stretch items')
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_component, {
    __nextHasNoMarginBottom: true,
    label: (0,i18n_build_module.__)('Justification'),
    value: justifyContent,
    onChange: onJustificationChange,
    className: "block-editor-hooks__flex-layout-justification-controls",
    children: justificationOptions.map(({
      value,
      icon,
      label
    }) => {
      return /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_icon_component, {
        value: value,
        icon: icon,
        label: label
      }, value);
    })
  });
}
function FlexWrapControl({
  layout,
  onChange
}) {
  const {
    flexWrap = 'wrap'
  } = layout;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_control/* default */.A, {
    __nextHasNoMarginBottom: true,
    label: (0,i18n_build_module.__)('Allow to wrap to multiple lines'),
    onChange: value => {
      onChange({
        ...layout,
        flexWrap: value ? 'wrap' : 'nowrap'
      });
    },
    checked: flexWrap === 'wrap'
  });
}
function OrientationControl({
  layout,
  onChange
}) {
  const {
    orientation = 'horizontal',
    verticalAlignment,
    justifyContent
  } = layout;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(toggle_group_control_component, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-hooks__flex-layout-orientation-controls",
    label: (0,i18n_build_module.__)('Orientation'),
    value: orientation,
    onChange: value => {
      // Make sure the vertical alignment and justification are compatible with the new orientation.
      let newVerticalAlignment = verticalAlignment;
      let newJustification = justifyContent;
      if (value === 'horizontal') {
        if (verticalAlignment === 'space-between') {
          newVerticalAlignment = 'center';
        }
        if (justifyContent === 'stretch') {
          newJustification = 'left';
        }
      } else {
        if (verticalAlignment === 'stretch') {
          newVerticalAlignment = 'top';
        }
        if (justifyContent === 'space-between') {
          newJustification = 'left';
        }
      }
      return onChange({
        ...layout,
        orientation: value,
        verticalAlignment: newVerticalAlignment,
        justifyContent: newJustification
      });
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_icon_component, {
      icon: arrow_right/* default */.A,
      value: "horizontal",
      label: (0,i18n_build_module.__)('Horizontal')
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_icon_component, {
      icon: arrow_down/* default */.A,
      value: "vertical",
      label: (0,i18n_build_module.__)('Vertical')
    })]
  });
}
//# sourceMappingURL=flex.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/layouts/flow.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




/* harmony default export */ const flow = ({
  name: 'default',
  label: (0,i18n_build_module.__)('Flow'),
  inspectorControls: function DefaultLayoutInspectorControls() {
    return null;
  },
  toolBarControls: function DefaultLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const blockGapStyleValue = getGapCSSValue(style?.spacing?.blockGap);

    // If a block's block.json skips serialization for spacing or
    // spacing.blockGap, don't apply the user-defined value to the styles.
    let blockGapValue = '';
    if (!shouldSkipSerialization(blockName, 'spacing', 'blockGap')) {
      // If an object is provided only use the 'top' value for this kind of gap.
      if (blockGapStyleValue?.top) {
        blockGapValue = getGapCSSValue(blockGapStyleValue?.top);
      } else if (typeof blockGapStyleValue === 'string') {
        blockGapValue = getGapCSSValue(blockGapStyleValue);
      }
    }
    let output = '';

    // Output blockGap styles based on rules contained in layout definitions in theme.json.
    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'default', blockGapValue);
    }
    return output;
  },
  getOrientation() {
    return 'vertical';
  },
  getAlignments(layout, isBlockBasedTheme) {
    const alignmentInfo = getAlignmentsInfo(layout);
    if (layout.alignments !== undefined) {
      if (!layout.alignments.includes('none')) {
        layout.alignments.unshift('none');
      }
      return layout.alignments.map(alignment => ({
        name: alignment,
        info: alignmentInfo[alignment]
      }));
    }
    const alignments = [{
      name: 'left'
    }, {
      name: 'center'
    }, {
      name: 'right'
    }];

    // This is for backwards compatibility with hybrid themes.
    if (!isBlockBasedTheme) {
      const {
        contentSize,
        wideSize
      } = layout;
      if (contentSize) {
        alignments.unshift({
          name: 'full'
        });
      }
      if (wideSize) {
        alignments.unshift({
          name: 'wide',
          info: alignmentInfo.wide
        });
      }
    }
    alignments.unshift({
      name: 'none',
      info: alignmentInfo.none
    });
    return alignments;
  }
});
//# sourceMappingURL=flow.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/unit-control/utils.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */

const isWeb = platform/* default */.A.OS === 'web';
const allUnits = {
  px: {
    value: 'px',
    label: isWeb ? 'px' : (0,i18n_build_module.__)('Pixels (px)'),
    a11yLabel: (0,i18n_build_module.__)('Pixels (px)'),
    step: 1
  },
  '%': {
    value: '%',
    label: isWeb ? '%' : (0,i18n_build_module.__)('Percentage (%)'),
    a11yLabel: (0,i18n_build_module.__)('Percent (%)'),
    step: 0.1
  },
  em: {
    value: 'em',
    label: isWeb ? 'em' : (0,i18n_build_module.__)('Relative to parent font size (em)'),
    a11yLabel: (0,i18n_build_module._x)('ems', 'Relative to parent font size (em)'),
    step: 0.01
  },
  rem: {
    value: 'rem',
    label: isWeb ? 'rem' : (0,i18n_build_module.__)('Relative to root font size (rem)'),
    a11yLabel: (0,i18n_build_module._x)('rems', 'Relative to root font size (rem)'),
    step: 0.01
  },
  vw: {
    value: 'vw',
    label: isWeb ? 'vw' : (0,i18n_build_module.__)('Viewport width (vw)'),
    a11yLabel: (0,i18n_build_module.__)('Viewport width (vw)'),
    step: 0.1
  },
  vh: {
    value: 'vh',
    label: isWeb ? 'vh' : (0,i18n_build_module.__)('Viewport height (vh)'),
    a11yLabel: (0,i18n_build_module.__)('Viewport height (vh)'),
    step: 0.1
  },
  vmin: {
    value: 'vmin',
    label: isWeb ? 'vmin' : (0,i18n_build_module.__)('Viewport smallest dimension (vmin)'),
    a11yLabel: (0,i18n_build_module.__)('Viewport smallest dimension (vmin)'),
    step: 0.1
  },
  vmax: {
    value: 'vmax',
    label: isWeb ? 'vmax' : (0,i18n_build_module.__)('Viewport largest dimension (vmax)'),
    a11yLabel: (0,i18n_build_module.__)('Viewport largest dimension (vmax)'),
    step: 0.1
  },
  ch: {
    value: 'ch',
    label: isWeb ? 'ch' : (0,i18n_build_module.__)('Width of the zero (0) character (ch)'),
    a11yLabel: (0,i18n_build_module.__)('Width of the zero (0) character (ch)'),
    step: 0.01
  },
  ex: {
    value: 'ex',
    label: isWeb ? 'ex' : (0,i18n_build_module.__)('x-height of the font (ex)'),
    a11yLabel: (0,i18n_build_module.__)('x-height of the font (ex)'),
    step: 0.01
  },
  cm: {
    value: 'cm',
    label: isWeb ? 'cm' : (0,i18n_build_module.__)('Centimeters (cm)'),
    a11yLabel: (0,i18n_build_module.__)('Centimeters (cm)'),
    step: 0.001
  },
  mm: {
    value: 'mm',
    label: isWeb ? 'mm' : (0,i18n_build_module.__)('Millimeters (mm)'),
    a11yLabel: (0,i18n_build_module.__)('Millimeters (mm)'),
    step: 0.1
  },
  in: {
    value: 'in',
    label: isWeb ? 'in' : (0,i18n_build_module.__)('Inches (in)'),
    a11yLabel: (0,i18n_build_module.__)('Inches (in)'),
    step: 0.001
  },
  pc: {
    value: 'pc',
    label: isWeb ? 'pc' : (0,i18n_build_module.__)('Picas (pc)'),
    a11yLabel: (0,i18n_build_module.__)('Picas (pc)'),
    step: 1
  },
  pt: {
    value: 'pt',
    label: isWeb ? 'pt' : (0,i18n_build_module.__)('Points (pt)'),
    a11yLabel: (0,i18n_build_module.__)('Points (pt)'),
    step: 1
  },
  svw: {
    value: 'svw',
    label: isWeb ? 'svw' : (0,i18n_build_module.__)('Small viewport width (svw)'),
    a11yLabel: (0,i18n_build_module.__)('Small viewport width (svw)'),
    step: 0.1
  },
  svh: {
    value: 'svh',
    label: isWeb ? 'svh' : (0,i18n_build_module.__)('Small viewport height (svh)'),
    a11yLabel: (0,i18n_build_module.__)('Small viewport height (svh)'),
    step: 0.1
  },
  svi: {
    value: 'svi',
    label: isWeb ? 'svi' : (0,i18n_build_module.__)('Viewport smallest size in the inline direction (svi)'),
    a11yLabel: (0,i18n_build_module.__)('Small viewport width or height (svi)'),
    step: 0.1
  },
  svb: {
    value: 'svb',
    label: isWeb ? 'svb' : (0,i18n_build_module.__)('Viewport smallest size in the block direction (svb)'),
    a11yLabel: (0,i18n_build_module.__)('Small viewport width or height (svb)'),
    step: 0.1
  },
  svmin: {
    value: 'svmin',
    label: isWeb ? 'svmin' : (0,i18n_build_module.__)('Small viewport smallest dimension (svmin)'),
    a11yLabel: (0,i18n_build_module.__)('Small viewport smallest dimension (svmin)'),
    step: 0.1
  },
  lvw: {
    value: 'lvw',
    label: isWeb ? 'lvw' : (0,i18n_build_module.__)('Large viewport width (lvw)'),
    a11yLabel: (0,i18n_build_module.__)('Large viewport width (lvw)'),
    step: 0.1
  },
  lvh: {
    value: 'lvh',
    label: isWeb ? 'lvh' : (0,i18n_build_module.__)('Large viewport height (lvh)'),
    a11yLabel: (0,i18n_build_module.__)('Large viewport height (lvh)'),
    step: 0.1
  },
  lvi: {
    value: 'lvi',
    label: isWeb ? 'lvi' : (0,i18n_build_module.__)('Large viewport width or height (lvi)'),
    a11yLabel: (0,i18n_build_module.__)('Large viewport width or height (lvi)'),
    step: 0.1
  },
  lvb: {
    value: 'lvb',
    label: isWeb ? 'lvb' : (0,i18n_build_module.__)('Large viewport width or height (lvb)'),
    a11yLabel: (0,i18n_build_module.__)('Large viewport width or height (lvb)'),
    step: 0.1
  },
  lvmin: {
    value: 'lvmin',
    label: isWeb ? 'lvmin' : (0,i18n_build_module.__)('Large viewport smallest dimension (lvmin)'),
    a11yLabel: (0,i18n_build_module.__)('Large viewport smallest dimension (lvmin)'),
    step: 0.1
  },
  dvw: {
    value: 'dvw',
    label: isWeb ? 'dvw' : (0,i18n_build_module.__)('Dynamic viewport width (dvw)'),
    a11yLabel: (0,i18n_build_module.__)('Dynamic viewport width (dvw)'),
    step: 0.1
  },
  dvh: {
    value: 'dvh',
    label: isWeb ? 'dvh' : (0,i18n_build_module.__)('Dynamic viewport height (dvh)'),
    a11yLabel: (0,i18n_build_module.__)('Dynamic viewport height (dvh)'),
    step: 0.1
  },
  dvi: {
    value: 'dvi',
    label: isWeb ? 'dvi' : (0,i18n_build_module.__)('Dynamic viewport width or height (dvi)'),
    a11yLabel: (0,i18n_build_module.__)('Dynamic viewport width or height (dvi)'),
    step: 0.1
  },
  dvb: {
    value: 'dvb',
    label: isWeb ? 'dvb' : (0,i18n_build_module.__)('Dynamic viewport width or height (dvb)'),
    a11yLabel: (0,i18n_build_module.__)('Dynamic viewport width or height (dvb)'),
    step: 0.1
  },
  dvmin: {
    value: 'dvmin',
    label: isWeb ? 'dvmin' : (0,i18n_build_module.__)('Dynamic viewport smallest dimension (dvmin)'),
    a11yLabel: (0,i18n_build_module.__)('Dynamic viewport smallest dimension (dvmin)'),
    step: 0.1
  },
  dvmax: {
    value: 'dvmax',
    label: isWeb ? 'dvmax' : (0,i18n_build_module.__)('Dynamic viewport largest dimension (dvmax)'),
    a11yLabel: (0,i18n_build_module.__)('Dynamic viewport largest dimension (dvmax)'),
    step: 0.1
  },
  svmax: {
    value: 'svmax',
    label: isWeb ? 'svmax' : (0,i18n_build_module.__)('Small viewport largest dimension (svmax)'),
    a11yLabel: (0,i18n_build_module.__)('Small viewport largest dimension (svmax)'),
    step: 0.1
  },
  lvmax: {
    value: 'lvmax',
    label: isWeb ? 'lvmax' : (0,i18n_build_module.__)('Large viewport largest dimension (lvmax)'),
    a11yLabel: (0,i18n_build_module.__)('Large viewport largest dimension (lvmax)'),
    step: 0.1
  }
};

/**
 * An array of all available CSS length units.
 */
const ALL_CSS_UNITS = Object.values(allUnits);

/**
 * Units of measurements. `a11yLabel` is used by screenreaders.
 */
const CSS_UNITS = [allUnits.px, allUnits['%'], allUnits.em, allUnits.rem, allUnits.vw, allUnits.vh];
const DEFAULT_UNIT = allUnits.px;

/**
 * Handles legacy value + unit handling.
 * This component use to manage both incoming value and units separately.
 *
 * Moving forward, ideally the value should be a string that contains both
 * the value and unit, example: '10px'
 *
 * @param rawValue     The raw value as a string (may or may not contain the unit)
 * @param fallbackUnit The unit used as a fallback, if not unit is detected in the `value`
 * @param allowedUnits Units to derive from.
 * @return The extracted quantity and unit. The quantity can be `undefined` in case the raw value
 * could not be parsed to a number correctly. The unit can be `undefined` in case the unit parse
 * from the raw value could not be matched against the list of allowed units.
 */
function getParsedQuantityAndUnit(rawValue, fallbackUnit, allowedUnits) {
  const initialValue = fallbackUnit ? `${rawValue !== null && rawValue !== void 0 ? rawValue : ''}${fallbackUnit}` : rawValue;
  return parseQuantityAndUnitFromRawValue(initialValue, allowedUnits);
}

/**
 * Checks if units are defined.
 *
 * @param units List of units.
 * @return Whether the list actually contains any units.
 */
function hasUnits(units) {
  // Although the `isArray` check shouldn't be necessary (given the signature of
  // this typed function), it's better to stay on the side of caution, since
  // this function may be called from un-typed environments.
  return Array.isArray(units) && !!units.length;
}

/**
 * Parses a quantity and unit from a raw string value, given a list of allowed
 * units and otherwise falling back to the default unit.
 *
 * @param rawValue     The raw value as a string (may or may not contain the unit)
 * @param allowedUnits Units to derive from.
 * @return The extracted quantity and unit. The quantity can be `undefined` in case the raw value
 * could not be parsed to a number correctly. The unit can be `undefined` in case the unit parsed
 * from the raw value could not be matched against the list of allowed units.
 */
function parseQuantityAndUnitFromRawValue(rawValue, allowedUnits = ALL_CSS_UNITS) {
  let trimmedValue;
  let quantityToReturn;
  if (typeof rawValue !== 'undefined' || rawValue === null) {
    trimmedValue = `${rawValue}`.trim();
    const parsedQuantity = parseFloat(trimmedValue);
    quantityToReturn = !isFinite(parsedQuantity) ? undefined : parsedQuantity;
  }
  const unitMatch = trimmedValue?.match(/[\d.\-\+]*\s*(.*)/);
  const matchedUnit = unitMatch?.[1]?.toLowerCase();
  let unitToReturn;
  if (hasUnits(allowedUnits)) {
    const match = allowedUnits.find(item => item.value === matchedUnit);
    unitToReturn = match?.value;
  } else {
    unitToReturn = DEFAULT_UNIT.value;
  }
  return [quantityToReturn, unitToReturn];
}

/**
 * Parses quantity and unit from a raw value. Validates parsed value, using fallback
 * value if invalid.
 *
 * @param rawValue         The next value.
 * @param allowedUnits     Units to derive from.
 * @param fallbackQuantity The fallback quantity, used in case it's not possible to parse a valid quantity from the raw value.
 * @param fallbackUnit     The fallback unit, used in case it's not possible to parse a valid unit from the raw value.
 * @return The extracted quantity and unit. The quantity can be `undefined` in case the raw value
 * could not be parsed to a number correctly, and the `fallbackQuantity` was also `undefined`. The
 * unit can be `undefined` only if the unit parsed from the raw value could not be matched against
 * the list of allowed units, the `fallbackQuantity` is also `undefined` and the list of
 * `allowedUnits` is passed empty.
 */
function getValidParsedQuantityAndUnit(rawValue, allowedUnits, fallbackQuantity, fallbackUnit) {
  const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(rawValue, allowedUnits);

  // The parsed value from `parseQuantityAndUnitFromRawValue` should now be
  // either a real number or undefined. If undefined, use the fallback value.
  const quantityToReturn = parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : fallbackQuantity;

  // If no unit is parsed from the raw value, or if the fallback unit is not
  // defined, use the first value from the list of allowed units as fallback.
  let unitToReturn = parsedUnit || fallbackUnit;
  if (!unitToReturn && hasUnits(allowedUnits)) {
    unitToReturn = allowedUnits[0].value;
  }
  return [quantityToReturn, unitToReturn];
}

/**
 * Takes a unit value and finds the matching accessibility label for the
 * unit abbreviation.
 *
 * @param unit Unit value (example: `px`)
 * @return a11y label for the unit abbreviation
 */
function getAccessibleLabelForUnit(unit) {
  const match = ALL_CSS_UNITS.find(item => item.value === unit);
  return match?.a11yLabel ? match?.a11yLabel : match?.value;
}

/**
 * Filters available units based on values defined a list of allowed unit values.
 *
 * @param allowedUnitValues Collection of allowed unit value strings.
 * @param availableUnits    Collection of available unit objects.
 * @return Filtered units.
 */
function filterUnitsWithSettings(allowedUnitValues = [], availableUnits) {
  // Although the `isArray` check shouldn't be necessary (given the signature of
  // this typed function), it's better to stay on the side of caution, since
  // this function may be called from un-typed environments.
  return Array.isArray(availableUnits) ? availableUnits.filter(unit => allowedUnitValues.includes(unit.value)) : [];
}

/**
 * Custom hook to retrieve and consolidate units setting from add_theme_support().
 * TODO: ideally this hook shouldn't be needed
 * https://github.com/WordPress/gutenberg/pull/31822#discussion_r633280823
 *
 * @param args                An object containing units, settingPath & defaultUnits.
 * @param args.units          Collection of all potentially available units.
 * @param args.availableUnits Collection of unit value strings for filtering available units.
 * @param args.defaultValues  Collection of default values for defined units. Example: `{ px: 350, em: 15 }`.
 *
 * @return Filtered list of units, with their default values updated following the `defaultValues`
 * argument's property.
 */
const useCustomUnits = ({
  units = ALL_CSS_UNITS,
  availableUnits = [],
  defaultValues
}) => {
  const customUnitsToReturn = filterUnitsWithSettings(availableUnits, units);
  if (defaultValues) {
    customUnitsToReturn.forEach((unit, i) => {
      if (defaultValues[unit.value]) {
        const [parsedDefaultValue] = parseQuantityAndUnitFromRawValue(defaultValues[unit.value]);
        customUnitsToReturn[i].default = parsedDefaultValue;
      }
    });
  }
  return customUnitsToReturn;
};

/**
 * Get available units with the unit for the currently selected value
 * prepended if it is not available in the list of units.
 *
 * This is useful to ensure that the current value's unit is always
 * accurately displayed in the UI, even if the intention is to hide
 * the availability of that unit.
 *
 * @param rawValue   Selected value to parse.
 * @param legacyUnit Legacy unit value, if rawValue needs it appended.
 * @param units      List of available units.
 *
 * @return A collection of units containing the unit for the current value.
 */
function getUnitsWithCurrentUnit(rawValue, legacyUnit, units = ALL_CSS_UNITS) {
  const unitsToReturn = Array.isArray(units) ? [...units] : [];
  const [, currentUnit] = getParsedQuantityAndUnit(rawValue, legacyUnit, ALL_CSS_UNITS);
  if (currentUnit && !unitsToReturn.some(unit => unit.value === currentUnit)) {
    if (allUnits[currentUnit]) {
      unitsToReturn.unshift(allUnits[currentUnit]);
    }
  }
  return unitsToReturn;
}
//# sourceMappingURL=utils.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/number-control/index.js + 1 modules
var number_control = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/number-control/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/styles/input-control-styles.js
var input_control_styles = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/styles/input-control-styles.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/unit-control/styles/unit-control-styles.js

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





// Using `selectSize` instead of `size` to avoid a type conflict with the
// `size` HTML attribute of the `select` element.

// TODO: Resolve need to use &&& to increase specificity
// https://github.com/WordPress/gutenberg/issues/18483

const ValueInput = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(number_control/* default */.A,  true ? {
  target: "e1bagdl32"
} : 0)("&&&{input{display:block;width:100%;}", input_control_styles/* BackdropUI */.Hr, "{transition:box-shadow 0.1s linear;}}" + ( true ? "" : 0));
const baseUnitLabelStyles = ({
  selectSize
}) => {
  const sizes = {
    small: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("box-sizing:border-box;padding:2px 1px;width:20px;color:", colors_values/* COLORS */.l.gray[800], ";font-size:8px;line-height:1;letter-spacing:-0.5px;text-transform:uppercase;text-align-last:center;" + ( true ? "" : 0),  true ? "" : 0),
    default: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("box-sizing:border-box;min-width:24px;max-width:48px;height:24px;margin-inline-end:", (0,space/* space */.x)(2), ";padding:", (0,space/* space */.x)(1), ";color:", colors_values/* COLORS */.l.theme.accent, ";font-size:13px;line-height:1;text-align-last:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;" + ( true ? "" : 0),  true ? "" : 0)
  };
  return sizes[selectSize];
};
const UnitLabel = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1bagdl31"
} : 0)("&&&{pointer-events:none;", baseUnitLabelStyles, ";color:", colors_values/* COLORS */.l.gray[900], ";}" + ( true ? "" : 0));
const unitSelectSizes = ({
  selectSize = 'default'
}) => {
  const sizes = {
    small: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("height:100%;border:1px solid transparent;transition:box-shadow 0.1s linear,border 0.1s linear;", (0,rtl/* rtl */.h)({
      borderTopLeftRadius: 0,
      borderBottomLeftRadius: 0
    })(), " &:not(:disabled):hover{background-color:", colors_values/* COLORS */.l.gray[100], ";}&:focus{border:1px solid ", colors_values/* COLORS */.l.ui.borderFocus, ";box-shadow:inset 0 0 0 ", config_values/* default */.A.borderWidth + ' ' + colors_values/* COLORS */.l.ui.borderFocus, ";outline-offset:0;outline:2px solid transparent;z-index:1;}" + ( true ? "" : 0),  true ? "" : 0),
    default: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("display:flex;justify-content:center;align-items:center;&:hover{color:", colors_values/* COLORS */.l.ui.borderFocus, ";box-shadow:inset 0 0 0 ", config_values/* default */.A.borderWidth + ' ' + colors_values/* COLORS */.l.ui.borderFocus, ";outline:", config_values/* default */.A.borderWidth, " solid transparent;}&:focus{box-shadow:0 0 0 ", config_values/* default */.A.borderWidthFocus + ' ' + colors_values/* COLORS */.l.ui.borderFocus, ";outline:", config_values/* default */.A.borderWidthFocus, " solid transparent;}" + ( true ? "" : 0),  true ? "" : 0)
  };
  return sizes[selectSize];
};
const UnitSelect = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("select",  true ? {
  target: "e1bagdl30"
} : 0)("&&&{appearance:none;background:transparent;border-radius:2px;border:none;display:block;outline:none;margin:0;min-height:auto;font-family:inherit;", baseUnitLabelStyles, ";", unitSelectSizes, ";&:not( :disabled ){cursor:pointer;}}" + ( true ? "" : 0));
//# sourceMappingURL=unit-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/unit-control/unit-select-control.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function UnitSelectControl({
  className,
  isUnitSelectTabbable: isTabbable = true,
  onChange,
  size = 'default',
  unit = 'px',
  units = CSS_UNITS,
  ...props
}, ref) {
  if (!hasUnits(units) || units?.length === 1) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(UnitLabel, {
      className: "components-unit-control__unit-label",
      selectSize: size,
      children: unit
    });
  }
  const handleOnChange = event => {
    const {
      value: unitValue
    } = event.target;
    const data = units.find(option => option.value === unitValue);
    onChange?.(unitValue, {
      event,
      data
    });
  };
  const classes = (0,dist_clsx/* default */.A)('components-unit-control__select', className);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(UnitSelect, {
    ref: ref,
    className: classes,
    onChange: handleOnChange,
    selectSize: size,
    tabIndex: isTabbable ? undefined : -1,
    value: unit,
    ...props,
    children: units.map(option => /*#__PURE__*/(0,jsx_runtime.jsx)("option", {
      value: option.value,
      children: option.label
    }, option.value))
  });
}
/* harmony default export */ const unit_select_control = ((0,react.forwardRef)(UnitSelectControl));
//# sourceMappingURL=unit-select-control.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/values.js
var values = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/values.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-controlled-state.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * @template T
 * @typedef Options
 * @property {T}      [initial] Initial value
 * @property {T | ""} fallback  Fallback value
 */

/** @type {Readonly<{ initial: undefined, fallback: '' }>} */
const defaultOptions = {
  initial: undefined,
  /**
   * Defaults to empty string, as that is preferred for usage with
   * <input />, <textarea />, and <select /> form elements.
   */
  fallback: ''
};

/**
 * Custom hooks for "controlled" components to track and consolidate internal
 * state and incoming values. This is useful for components that render
 * `input`, `textarea`, or `select` HTML elements.
 *
 * https://reactjs.org/docs/forms.html#controlled-components
 *
 * At first, a component using useControlledState receives an initial prop
 * value, which is used as initial internal state.
 *
 * This internal state can be maintained and updated without
 * relying on new incoming prop values.
 *
 * Unlike the basic useState hook, useControlledState's state can
 * be updated if a new incoming prop value is changed.
 *
 * @template T
 *
 * @param {T | undefined} currentState             The current value.
 * @param {Options<T>}    [options=defaultOptions] Additional options for the hook.
 *
 * @return {[T | "", (nextState: T) => void]} The controlled value and the value setter.
 */
function useControlledState(currentState, options = defaultOptions) {
  const {
    initial,
    fallback
  } = {
    ...defaultOptions,
    ...options
  };
  const [internalState, setInternalState] = (0,react.useState)(currentState);
  const hasCurrentState = (0,values/* isValueDefined */.J5)(currentState);

  /*
   * Resets internal state if value every changes from uncontrolled <-> controlled.
   */
  (0,react.useEffect)(() => {
    if (hasCurrentState && internalState) {
      setInternalState(undefined);
    }
  }, [hasCurrentState, internalState]);
  const state = (0,values/* getDefinedValue */.vD)([currentState, internalState, initial], fallback);

  /* eslint-disable jsdoc/no-undefined-types */
  /** @type {(nextState: T) => void} */
  const setState = (0,react.useCallback)(nextState => {
    if (!hasCurrentState) {
      setInternalState(nextState);
    }
  }, [hasCurrentState]);
  /* eslint-enable jsdoc/no-undefined-types */

  return [state, setState];
}
/* harmony default export */ const use_controlled_state = (useControlledState);
//# sourceMappingURL=use-controlled-state.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/unit-control/index.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */








function UnforwardedUnitControl(unitControlProps, forwardedRef) {
  const {
    __unstableStateReducer,
    autoComplete = 'off',
    // @ts-expect-error Ensure that children is omitted from restProps
    children,
    className,
    disabled = false,
    disableUnits = false,
    isPressEnterToChange = false,
    isResetValueOnUnitChange = false,
    isUnitSelectTabbable = true,
    label,
    onChange: onChangeProp,
    onUnitChange,
    size = 'default',
    unit: unitProp,
    units: unitsProp = CSS_UNITS,
    value: valueProp,
    onFocus: onFocusProp,
    ...props
  } = (0,use_deprecated_props/* useDeprecated36pxDefaultSizeProp */.R)(unitControlProps);
  if ('unit' in unitControlProps) {
    (0,deprecated_build_module/* default */.A)('UnitControl unit prop', {
      since: '5.6',
      hint: 'The unit should be provided within the `value` prop.',
      version: '6.2'
    });
  }

  // The `value` prop, in theory, should not be `null`, but the following line
  // ensures it fallback to `undefined` in case a consumer of `UnitControl`
  // still passes `null` as a `value`.
  const nonNullValueProp = valueProp !== null && valueProp !== void 0 ? valueProp : undefined;
  const [units, reFirstCharacterOfUnits] = (0,react.useMemo)(() => {
    const list = getUnitsWithCurrentUnit(nonNullValueProp, unitProp, unitsProp);
    const [{
      value: firstUnitValue = ''
    } = {}, ...rest] = list;
    const firstCharacters = rest.reduce((carry, {
      value
    }) => {
      const first = (0,strings/* escapeRegExp */.Nt)(value?.substring(0, 1) || '');
      return carry.includes(first) ? carry : `${carry}|${first}`;
    }, (0,strings/* escapeRegExp */.Nt)(firstUnitValue.substring(0, 1)));
    return [list, new RegExp(`^(?:${firstCharacters})$`, 'i')];
  }, [nonNullValueProp, unitProp, unitsProp]);
  const [parsedQuantity, parsedUnit] = getParsedQuantityAndUnit(nonNullValueProp, unitProp, units);
  const [unit, setUnit] = use_controlled_state(units.length === 1 ? units[0].value : unitProp, {
    initial: parsedUnit,
    fallback: ''
  });
  (0,react.useEffect)(() => {
    if (parsedUnit !== undefined) {
      setUnit(parsedUnit);
    }
  }, [parsedUnit, setUnit]);
  const classes = (0,dist_clsx/* default */.A)('components-unit-control',
  // This class is added for legacy purposes to maintain it on the outer
  // wrapper. See: https://github.com/WordPress/gutenberg/pull/45139
  'components-unit-control-wrapper', className);
  const handleOnQuantityChange = (nextQuantityValue, changeProps) => {
    if (nextQuantityValue === '' || typeof nextQuantityValue === 'undefined' || nextQuantityValue === null) {
      onChangeProp?.('', changeProps);
      return;
    }

    /*
     * Customizing the onChange callback.
     * This allows as to broadcast a combined value+unit to onChange.
     */
    const onChangeValue = getValidParsedQuantityAndUnit(nextQuantityValue, units, parsedQuantity, unit).join('');
    onChangeProp?.(onChangeValue, changeProps);
  };
  const handleOnUnitChange = (nextUnitValue, changeProps) => {
    const {
      data
    } = changeProps;
    let nextValue = `${parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : ''}${nextUnitValue}`;
    if (isResetValueOnUnitChange && data?.default !== undefined) {
      nextValue = `${data.default}${nextUnitValue}`;
    }
    onChangeProp?.(nextValue, changeProps);
    onUnitChange?.(nextUnitValue, changeProps);
    setUnit(nextUnitValue);
  };
  let handleOnKeyDown;
  if (!disableUnits && isUnitSelectTabbable && units.length) {
    handleOnKeyDown = event => {
      props.onKeyDown?.(event);
      // Unless the meta key was pressed (to avoid interfering with
      // shortcuts, e.g. pastes), moves focus to the unit select if a key
      // matches the first character of a unit.
      if (!event.metaKey && reFirstCharacterOfUnits.test(event.key)) {
        refInputSuffix.current?.focus();
      }
    };
  }
  const refInputSuffix = (0,react.useRef)(null);
  const inputSuffix = !disableUnits ? /*#__PURE__*/(0,jsx_runtime.jsx)(unit_select_control, {
    ref: refInputSuffix,
    "aria-label": (0,i18n_build_module.__)('Select unit'),
    disabled: disabled,
    isUnitSelectTabbable: isUnitSelectTabbable,
    onChange: handleOnUnitChange,
    size: ['small', 'compact'].includes(size) || size === 'default' && !props.__next40pxDefaultSize ? 'small' : 'default',
    unit: unit,
    units: units,
    onFocus: onFocusProp,
    onBlur: unitControlProps.onBlur
  }) : null;
  let step = props.step;

  /*
   * If no step prop has been passed, lookup the active unit and
   * try to get step from `units`, or default to a value of `1`
   */
  if (!step && units) {
    var _activeUnit$step;
    const activeUnit = units.find(option => option.value === unit);
    step = (_activeUnit$step = activeUnit?.step) !== null && _activeUnit$step !== void 0 ? _activeUnit$step : 1;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(ValueInput, {
    ...props,
    autoComplete: autoComplete,
    className: classes,
    disabled: disabled,
    spinControls: "none",
    isPressEnterToChange: isPressEnterToChange,
    label: label,
    onKeyDown: handleOnKeyDown,
    onChange: handleOnQuantityChange,
    ref: forwardedRef,
    size: size,
    suffix: inputSuffix,
    type: isPressEnterToChange ? 'text' : 'number',
    value: parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : '',
    step: step,
    onFocus: onFocusProp,
    __unstableStateReducer: __unstableStateReducer
  });
}

/**
 * `UnitControl` allows the user to set a numeric quantity as well as a unit (e.g. `px`).
 *
 *
 * ```jsx
 * import { __experimentalUnitControl as UnitControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const Example = () => {
 *   const [ value, setValue ] = useState( '10px' );
 *
 *   return <UnitControl onChange={ setValue } value={ value } />;
 * };
 * ```
 */
const UnitControl = (0,react.forwardRef)(UnforwardedUnitControl);

/* harmony default export */ const unit_control = (UnitControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/position-center.js
/**
 * WordPress dependencies
 */


const positionCenter = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM7 9h10v6H7V9Z"
  })
});
/* harmony default export */ const position_center = (positionCenter);
//# sourceMappingURL=position-center.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/stretch-wide.js
/**
 * WordPress dependencies
 */


const stretchWide = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M16 5.5H8V4h8v1.5ZM16 20H8v-1.5h8V20ZM5 9h14v6H5V9Z"
  })
});
/* harmony default export */ const stretch_wide = (stretchWide);
//# sourceMappingURL=stretch-wide.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/param-case@3.0.4/node_modules/param-case/dist.es2015/index.js + 1 modules
var dist_es2015 = __webpack_require__("../../node_modules/.pnpm/param-case@3.0.4/node_modules/param-case/dist.es2015/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/constants.js
const VARIABLE_REFERENCE_PREFIX = 'var:';
const VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE = '|';
const VARIABLE_PATH_SEPARATOR_TOKEN_STYLE = '--';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/utils.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Helper util to return a value from a certain path of the object.
 * Path is specified as an array of properties, like `[ 'x', 'y' ]`.
 *
 * @param object Input object.
 * @param path   Path to the object property.
 * @return Value of the object property at the specified path.
 */
const getStyleValueByPath = (object, path) => {
  let value = object;
  path.forEach(fieldName => {
    value = value?.[fieldName];
  });
  return value;
};

/**
 * Returns a JSON representation of the generated CSS rules.
 *
 * @param style   Style object.
 * @param options Options object with settings to adjust how the styles are generated.
 * @param path    An array of strings representing the path to the style value in the style object.
 * @param ruleKey A CSS property key.
 *
 * @return GeneratedCSSRule[] CSS rules.
 */
function generateRule(style, options, path, ruleKey) {
  const styleValue = getStyleValueByPath(style, path);
  return styleValue ? [{
    selector: options?.selector,
    key: ruleKey,
    value: getCSSValueFromRawStyle(styleValue)
  }] : [];
}

/**
 * Returns a JSON representation of the generated CSS rules taking into account box model properties, top, right, bottom, left.
 *
 * @param style                Style object.
 * @param options              Options object with settings to adjust how the styles are generated.
 * @param path                 An array of strings representing the path to the style value in the style object.
 * @param ruleKeys             An array of CSS property keys and patterns.
 * @param individualProperties The "sides" or individual properties for which to generate rules.
 *
 * @return GeneratedCSSRule[]  CSS rules.
 */
function generateBoxRules(style, options, path, ruleKeys, individualProperties = ['top', 'right', 'bottom', 'left']) {
  const boxStyle = getStyleValueByPath(style, path);
  if (!boxStyle) {
    return [];
  }
  const rules = [];
  if (typeof boxStyle === 'string') {
    rules.push({
      selector: options?.selector,
      key: ruleKeys.default,
      value: boxStyle
    });
  } else {
    const sideRules = individualProperties.reduce((acc, side) => {
      const value = getCSSValueFromRawStyle(getStyleValueByPath(boxStyle, [side]));
      if (value) {
        acc.push({
          selector: options?.selector,
          key: ruleKeys?.individual.replace('%s', upperFirst(side)),
          value
        });
      }
      return acc;
    }, []);
    rules.push(...sideRules);
  }
  return rules;
}

/**
 * Returns a WordPress CSS custom var value from incoming style preset value,
 * if one is detected.
 *
 * The preset value is a string and follows the pattern `var:description|context|slug`.
 *
 * Example:
 *
 * `getCSSValueFromRawStyle( 'var:preset|color|heavenlyBlue' )` // returns 'var(--wp--preset--color--heavenly-blue)'
 *
 * @param styleValue A string representing a raw CSS value. Non-strings won't be processed.
 *
 * @return A CSS custom var value if the incoming style value is a preset value.
 */

function getCSSValueFromRawStyle(styleValue) {
  if (typeof styleValue === 'string' && styleValue.startsWith(VARIABLE_REFERENCE_PREFIX)) {
    const variable = styleValue.slice(VARIABLE_REFERENCE_PREFIX.length).split(VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE).map(presetVariable => (0,dist_es2015/* paramCase */.c)(presetVariable, {
      splitRegexp: [/([a-z0-9])([A-Z])/g,
      // fooBar => foo-bar, 3Bar => 3-bar
      /([0-9])([a-z])/g,
      // 3bar => 3-bar
      /([A-Za-z])([0-9])/g,
      // Foo3 => foo-3, foo3 => foo-3
      /([A-Z])([A-Z][a-z])/g // FOOBar => foo-bar
      ]
    })).join(VARIABLE_PATH_SEPARATOR_TOKEN_STYLE);
    return `var(--wp--${variable})`;
  }
  return styleValue;
}

/**
 * Capitalizes the first letter in a string.
 *
 * @param string The string whose first letter the function will capitalize.
 *
 * @return String with the first letter capitalized.
 */
function upperFirst(string) {
  const [firstLetter, ...rest] = string;
  return firstLetter.toUpperCase() + rest.join('');
}

/**
 * Converts an array of strings into a camelCase string.
 *
 * @param strings The strings to join into a camelCase string.
 *
 * @return camelCase string.
 */
function camelCaseJoin(strings) {
  const [firstItem, ...rest] = strings;
  return firstItem.toLowerCase() + rest.map(upperFirst).join('');
}

/**
 * Safely decodes a URI with `decodeURI`. Returns the URI unmodified if
 * `decodeURI` throws an error.
 *
 * @param {string} uri URI to decode.
 *
 * @example
 * ```js
 * const badUri = safeDecodeURI( '%z' ); // does not throw an Error, simply returns '%z'
 * ```
 *
 * @return {string} Decoded URI if possible.
 */
function safeDecodeURI(uri) {
  try {
    return decodeURI(uri);
  } catch (uriError) {
    return uri;
  }
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/border/index.js
/**
 * Internal dependencies
 */



/**
 * Creates a function for generating CSS rules when the style path is the same as the camelCase CSS property used in React.
 *
 * @param path An array of strings representing the path to the style value in the style object.
 *
 * @return A function that generates CSS rules.
 */
function createBorderGenerateFunction(path) {
  return (style, options) => generateRule(style, options, path, camelCaseJoin(path));
}

/**
 * Creates a function for generating border-{top,bottom,left,right}-{color,style,width} CSS rules.
 *
 * @param edge The edge to create CSS rules for.
 *
 * @return A function that generates CSS rules.
 */
function createBorderEdgeGenerateFunction(edge) {
  return (style, options) => {
    return ['color', 'style', 'width'].flatMap(key => {
      const path = ['border', edge, key];
      return createBorderGenerateFunction(path)(style, options);
    });
  };
}
const color = {
  name: 'color',
  generate: createBorderGenerateFunction(['border', 'color'])
};
const radius = {
  name: 'radius',
  generate: (style, options) => {
    return generateBoxRules(style, options, ['border', 'radius'], {
      default: 'borderRadius',
      individual: 'border%sRadius'
    }, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);
  }
};
const borderStyle = {
  name: 'style',
  generate: createBorderGenerateFunction(['border', 'style'])
};
const width = {
  name: 'width',
  generate: createBorderGenerateFunction(['border', 'width'])
};
const borderTop = {
  name: 'borderTop',
  generate: createBorderEdgeGenerateFunction('top')
};
const borderRight = {
  name: 'borderRight',
  generate: createBorderEdgeGenerateFunction('right')
};
const borderBottom = {
  name: 'borderBottom',
  generate: createBorderEdgeGenerateFunction('bottom')
};
const borderLeft = {
  name: 'borderLeft',
  generate: createBorderEdgeGenerateFunction('left')
};
/* harmony default export */ const border = ([color, borderStyle, width, radius, borderTop, borderRight, borderBottom, borderLeft]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/color/background.js
/**
 * Internal dependencies
 */


const background = {
  name: 'background',
  generate: (style, options) => {
    return generateRule(style, options, ['color', 'background'], 'backgroundColor');
  }
};
/* harmony default export */ const color_background = (background);
//# sourceMappingURL=background.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/color/gradient.js
/**
 * Internal dependencies
 */


const gradient = {
  name: 'gradient',
  generate: (style, options) => {
    return generateRule(style, options, ['color', 'gradient'], 'background');
  }
};
/* harmony default export */ const color_gradient = (gradient);
//# sourceMappingURL=gradient.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/color/text.js
/**
 * Internal dependencies
 */


const text_text = {
  name: 'text',
  generate: (style, options) => {
    return generateRule(style, options, ['color', 'text'], 'color');
  }
};
/* harmony default export */ const color_text = (text_text);
//# sourceMappingURL=text.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/color/index.js
/**
 * Internal dependencies
 */



/* harmony default export */ const styles_color = ([color_text, color_gradient, color_background]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/dimensions/index.js
/**
 * Internal dependencies
 */


const minHeight = {
  name: 'minHeight',
  generate: (style, options) => {
    return generateRule(style, options, ['dimensions', 'minHeight'], 'minHeight');
  }
};
const aspectRatio = {
  name: 'aspectRatio',
  generate: (style, options) => {
    return generateRule(style, options, ['dimensions', 'aspectRatio'], 'aspectRatio');
  }
};
/* harmony default export */ const dimensions = ([minHeight, aspectRatio]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/background/index.js
/**
 * Internal dependencies
 */


const backgroundImage = {
  name: 'backgroundImage',
  generate: (style, options) => {
    const _backgroundImage = style?.background?.backgroundImage;

    /*
     * The background image can be a string or an object.
     * If the background image is a string, it could already contain a url() function,
     * or have a linear-gradient value.
     */
    if (typeof _backgroundImage === 'object' && _backgroundImage?.url) {
      return [{
        selector: options.selector,
        key: 'backgroundImage',
        // Passed `url` may already be encoded. To prevent double encoding, decodeURI is executed to revert to the original string.
        value: `url( '${encodeURI(safeDecodeURI(_backgroundImage.url))}' )`
      }];
    }
    return generateRule(style, options, ['background', 'backgroundImage'], 'backgroundImage');
  }
};
const backgroundPosition = {
  name: 'backgroundPosition',
  generate: (style, options) => {
    return generateRule(style, options, ['background', 'backgroundPosition'], 'backgroundPosition');
  }
};
const backgroundRepeat = {
  name: 'backgroundRepeat',
  generate: (style, options) => {
    return generateRule(style, options, ['background', 'backgroundRepeat'], 'backgroundRepeat');
  }
};
const backgroundSize = {
  name: 'backgroundSize',
  generate: (style, options) => {
    return generateRule(style, options, ['background', 'backgroundSize'], 'backgroundSize');
  }
};
const backgroundAttachment = {
  name: 'backgroundAttachment',
  generate: (style, options) => {
    return generateRule(style, options, ['background', 'backgroundAttachment'], 'backgroundAttachment');
  }
};
/* harmony default export */ const styles_background = ([backgroundImage, backgroundPosition, backgroundRepeat, backgroundSize, backgroundAttachment]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/shadow/index.js
/**
 * Internal dependencies
 */


const shadow = {
  name: 'shadow',
  generate: (style, options) => {
    return generateRule(style, options, ['shadow'], 'boxShadow');
  }
};
/* harmony default export */ const styles_shadow = ([shadow]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/outline/index.js
/**
 * Internal dependencies
 */


const outline_color = {
  name: 'color',
  generate: (style, options, path = ['outline', 'color'], ruleKey = 'outlineColor') => {
    return generateRule(style, options, path, ruleKey);
  }
};
const offset = {
  name: 'offset',
  generate: (style, options, path = ['outline', 'offset'], ruleKey = 'outlineOffset') => {
    return generateRule(style, options, path, ruleKey);
  }
};
const outlineStyle = {
  name: 'style',
  generate: (style, options, path = ['outline', 'style'], ruleKey = 'outlineStyle') => {
    return generateRule(style, options, path, ruleKey);
  }
};
const outline_width = {
  name: 'width',
  generate: (style, options, path = ['outline', 'width'], ruleKey = 'outlineWidth') => {
    return generateRule(style, options, path, ruleKey);
  }
};
/* harmony default export */ const outline = ([outline_color, outlineStyle, offset, outline_width]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/spacing/padding.js
/**
 * Internal dependencies
 */


const padding = {
  name: 'padding',
  generate: (style, options) => {
    return generateBoxRules(style, options, ['spacing', 'padding'], {
      default: 'padding',
      individual: 'padding%s'
    });
  }
};
/* harmony default export */ const spacing_padding = (padding);
//# sourceMappingURL=padding.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/spacing/margin.js
/**
 * Internal dependencies
 */


const margin = {
  name: 'margin',
  generate: (style, options) => {
    return generateBoxRules(style, options, ['spacing', 'margin'], {
      default: 'margin',
      individual: 'margin%s'
    });
  }
};
/* harmony default export */ const spacing_margin = (margin);
//# sourceMappingURL=margin.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/spacing/index.js
/**
 * Internal dependencies
 */


/* harmony default export */ const spacing = ([spacing_margin, spacing_padding]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/typography/index.js
/**
 * Internal dependencies
 */


const fontSize = {
  name: 'fontSize',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'fontSize'], 'fontSize');
  }
};
const fontStyle = {
  name: 'fontStyle',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'fontStyle'], 'fontStyle');
  }
};
const fontWeight = {
  name: 'fontWeight',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'fontWeight'], 'fontWeight');
  }
};
const fontFamily = {
  name: 'fontFamily',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'fontFamily'], 'fontFamily');
  }
};
const letterSpacing = {
  name: 'letterSpacing',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'letterSpacing'], 'letterSpacing');
  }
};
const lineHeight = {
  name: 'lineHeight',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'lineHeight'], 'lineHeight');
  }
};
const textColumns = {
  name: 'textColumns',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'textColumns'], 'columnCount');
  }
};
const textDecoration = {
  name: 'textDecoration',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'textDecoration'], 'textDecoration');
  }
};
const textTransform = {
  name: 'textTransform',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'textTransform'], 'textTransform');
  }
};
const writingMode = {
  name: 'writingMode',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'writingMode'], 'writingMode');
  }
};
/* harmony default export */ const typography = ([fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textColumns, textDecoration, textTransform, writingMode]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/styles/index.js
/**
 * Internal dependencies
 */








const styleDefinitions = [...border, ...styles_color, ...dimensions, ...outline, ...spacing, ...typography, ...styles_shadow, ...styles_background];
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@2.10.0/node_modules/@wordpress/style-engine/build-module/index.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Generates a stylesheet for a given style object and selector.
 *
 * @since 6.1.0 Introduced in WordPress core.
 *
 * @param style   Style object, for example, the value of a block's attributes.style object or the top level styles in theme.json
 * @param options Options object with settings to adjust how the styles are generated.
 *
 * @return A generated stylesheet or inline style declarations.
 */
function compileCSS(style, options = {}) {
  const rules = getCSSRules(style, options);

  // If no selector is provided, treat generated rules as inline styles to be returned as a single string.
  if (!options?.selector) {
    const inlineRules = [];
    rules.forEach(rule => {
      inlineRules.push(`${(0,dist_es2015/* paramCase */.c)(rule.key)}: ${rule.value};`);
    });
    return inlineRules.join(' ');
  }
  const groupedRules = rules.reduce((acc, rule) => {
    const {
      selector
    } = rule;
    if (!selector) {
      return acc;
    }
    if (!acc[selector]) {
      acc[selector] = [];
    }
    acc[selector].push(rule);
    return acc;
  }, {});
  const selectorRules = Object.keys(groupedRules).reduce((acc, subSelector) => {
    acc.push(`${subSelector} { ${groupedRules[subSelector].map(rule => `${(0,dist_es2015/* paramCase */.c)(rule.key)}: ${rule.value};`).join(' ')} }`);
    return acc;
  }, []);
  return selectorRules.join('\n');
}

/**
 * Returns a JSON representation of the generated CSS rules.
 *
 * @since 6.1.0 Introduced in WordPress core.
 *
 * @param style   Style object, for example, the value of a block's attributes.style object or the top level styles in theme.json
 * @param options Options object with settings to adjust how the styles are generated.
 *
 * @return A collection of objects containing the selector, if any, the CSS property key (camelcase) and parsed CSS value.
 */
function getCSSRules(style, options = {}) {
  const rules = [];
  styleDefinitions.forEach(definition => {
    if (typeof definition.generate === 'function') {
      rules.push(...definition.generate(style, options));
    }
  });
  return rules;
}

// Export style utils.

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/layouts/constrained.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */








/* harmony default export */ const constrained = ({
  name: 'constrained',
  label: (0,i18n_build_module.__)('Constrained'),
  inspectorControls: function DefaultLayoutInspectorControls({
    layout,
    onChange,
    layoutBlockSupport = {}
  }) {
    const {
      wideSize,
      contentSize,
      justifyContent = 'center'
    } = layout;
    const {
      allowJustification = true,
      allowCustomContentAndWideSize = true
    } = layoutBlockSupport;
    const onJustificationChange = value => {
      onChange({
        ...layout,
        justifyContent: value
      });
    };
    const justificationOptions = [{
      value: 'left',
      icon: justify_left,
      label: (0,i18n_build_module.__)('Justify items left')
    }, {
      value: 'center',
      icon: justify_center,
      label: (0,i18n_build_module.__)('Justify items center')
    }, {
      value: 'right',
      icon: justify_right,
      label: (0,i18n_build_module.__)('Justify items right')
    }];
    const [availableUnits] = use_settings_useSettings('spacing.units');
    const units = useCustomUnits({
      availableUnits: availableUnits || ['%', 'px', 'em', 'rem', 'vw']
    });
    return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [allowCustomContentAndWideSize && /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          className: "block-editor-hooks__layout-controls",
          children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
            className: "block-editor-hooks__layout-controls-unit",
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
              className: "block-editor-hooks__layout-controls-unit-input",
              label: (0,i18n_build_module.__)('Content'),
              labelPosition: "top",
              __unstableInputWidth: "80px",
              value: contentSize || wideSize || '',
              onChange: nextWidth => {
                nextWidth = 0 > parseFloat(nextWidth) ? '0' : nextWidth;
                onChange({
                  ...layout,
                  contentSize: nextWidth
                });
              },
              units: units
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
              icon: position_center
            })]
          }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
            className: "block-editor-hooks__layout-controls-unit",
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
              className: "block-editor-hooks__layout-controls-unit-input",
              label: (0,i18n_build_module.__)('Wide'),
              labelPosition: "top",
              __unstableInputWidth: "80px",
              value: wideSize || contentSize || '',
              onChange: nextWidth => {
                nextWidth = 0 > parseFloat(nextWidth) ? '0' : nextWidth;
                onChange({
                  ...layout,
                  wideSize: nextWidth
                });
              },
              units: units
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
              icon: stretch_wide
            })]
          })]
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
          className: "block-editor-hooks__layout-controls-helptext",
          children: (0,i18n_build_module.__)('Customize the width for all elements that are assigned to the center or wide columns.')
        })]
      }), allowJustification && /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_component, {
        __nextHasNoMarginBottom: true,
        label: (0,i18n_build_module.__)('Justification'),
        value: justifyContent,
        onChange: onJustificationChange,
        children: justificationOptions.map(({
          value,
          icon,
          label
        }) => {
          return /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_icon_component, {
            value: value,
            icon: icon,
            label: label
          }, value);
        })
      })]
    });
  },
  toolBarControls: function DefaultLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    layout = {},
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const {
      contentSize,
      wideSize,
      justifyContent
    } = layout;
    const blockGapStyleValue = getGapCSSValue(style?.spacing?.blockGap);

    // If a block's block.json skips serialization for spacing or
    // spacing.blockGap, don't apply the user-defined value to the styles.
    let blockGapValue = '';
    if (!shouldSkipSerialization(blockName, 'spacing', 'blockGap')) {
      // If an object is provided only use the 'top' value for this kind of gap.
      if (blockGapStyleValue?.top) {
        blockGapValue = getGapCSSValue(blockGapStyleValue?.top);
      } else if (typeof blockGapStyleValue === 'string') {
        blockGapValue = getGapCSSValue(blockGapStyleValue);
      }
    }
    const marginLeft = justifyContent === 'left' ? '0 !important' : 'auto !important';
    const marginRight = justifyContent === 'right' ? '0 !important' : 'auto !important';
    let output = !!contentSize || !!wideSize ? `
					${appendSelectors(selector, '> :where(:not(.alignleft):not(.alignright):not(.alignfull))')} {
						max-width: ${contentSize !== null && contentSize !== void 0 ? contentSize : wideSize};
						margin-left: ${marginLeft};
						margin-right: ${marginRight};
					}
					${appendSelectors(selector, '> .alignwide')}  {
						max-width: ${wideSize !== null && wideSize !== void 0 ? wideSize : contentSize};
					}
					${appendSelectors(selector, '> .alignfull')} {
						max-width: none;
					}
				` : '';
    if (justifyContent === 'left') {
      output += `${appendSelectors(selector, '> :where(:not(.alignleft):not(.alignright):not(.alignfull))')}
			{ margin-left: ${marginLeft}; }`;
    } else if (justifyContent === 'right') {
      output += `${appendSelectors(selector, '> :where(:not(.alignleft):not(.alignright):not(.alignfull))')}
			{ margin-right: ${marginRight}; }`;
    }

    // If there is custom padding, add negative margins for alignfull blocks.
    if (style?.spacing?.padding) {
      // The style object might be storing a preset so we need to make sure we get a usable value.
      const paddingValues = getCSSRules(style);
      paddingValues.forEach(rule => {
        if (rule.key === 'paddingRight') {
          // Add unit if 0, to avoid calc(0 * -1) which is invalid.
          const paddingRightValue = rule.value === '0' ? '0px' : rule.value;
          output += `
					${appendSelectors(selector, '> .alignfull')} {
						margin-right: calc(${paddingRightValue} * -1);
					}
					`;
        } else if (rule.key === 'paddingLeft') {
          // Add unit if 0, to avoid calc(0 * -1) which is invalid.
          const paddingLeftValue = rule.value === '0' ? '0px' : rule.value;
          output += `
					${appendSelectors(selector, '> .alignfull')} {
						margin-left: calc(${paddingLeftValue} * -1);
					}
					`;
        }
      });
    }

    // Output blockGap styles based on rules contained in layout definitions in theme.json.
    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'constrained', blockGapValue);
    }
    return output;
  },
  getOrientation() {
    return 'vertical';
  },
  getAlignments(layout) {
    const alignmentInfo = getAlignmentsInfo(layout);
    if (layout.alignments !== undefined) {
      if (!layout.alignments.includes('none')) {
        layout.alignments.unshift('none');
      }
      return layout.alignments.map(alignment => ({
        name: alignment,
        info: alignmentInfo[alignment]
      }));
    }
    const {
      contentSize,
      wideSize
    } = layout;
    const alignments = [{
      name: 'left'
    }, {
      name: 'center'
    }, {
      name: 'right'
    }];
    if (contentSize) {
      alignments.unshift({
        name: 'full'
      });
    }
    if (wideSize) {
      alignments.unshift({
        name: 'wide',
        info: alignmentInfo.wide
      });
    }
    alignments.unshift({
      name: 'none',
      info: alignmentInfo.none
    });
    return alignments;
  }
});
//# sourceMappingURL=constrained.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-merge-refs/index.js
var use_merge_refs = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-merge-refs/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/math.js
var math = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/math.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/range-control/utils.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * A float supported clamp function for a specific value.
 *
 * @param value The value to clamp.
 * @param min   The minimum value.
 * @param max   The maximum value.
 *
 * @return A (float) number
 */
function floatClamp(value, min, max) {
  if (typeof value !== 'number') {
    return null;
  }
  return parseFloat(`${(0,math/* clamp */.qE)(value, min, max)}`);
}

/**
 * Hook to store a clamped value, derived from props.
 *
 * @param settings
 * @return The controlled value and the value setter.
 */
function useControlledRangeValue(settings) {
  const {
    min,
    max,
    value: valueProp,
    initial
  } = settings;
  const [state, setInternalState] = use_controlled_state(floatClamp(valueProp, min, max), {
    initial: floatClamp(initial !== null && initial !== void 0 ? initial : null, min, max),
    fallback: null
  });
  const setState = (0,react.useCallback)(nextValue => {
    if (nextValue === null) {
      setInternalState(null);
    } else {
      setInternalState(floatClamp(nextValue, min, max));
    }
  }, [min, max, setInternalState]);

  // `state` can't be an empty string because we specified a fallback value of
  // `null` in `useControlledState`
  return [state, setState];
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/range-control/styles/range-control-styles.js

function range_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



const rangeHeightValue = 30;
const railHeight = 4;
const rangeHeight = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
  height: rangeHeightValue,
  minHeight: rangeHeightValue
},  true ? "" : 0,  true ? "" : 0);
const thumbSize = 12;
const deprecatedHeight = ({
  __next40pxDefaultSize
}) => !__next40pxDefaultSize && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
  minHeight: rangeHeightValue
},  true ? "" : 0,  true ? "" : 0);
const Root = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1epgpqk14"
} : 0)("-webkit-tap-highlight-color:transparent;align-items:center;display:flex;justify-content:flex-start;padding:0;position:relative;touch-action:none;width:100%;min-height:40px;", deprecatedHeight, ";" + ( true ? "" : 0));
const wrapperColor = ({
  color = colors_values/* COLORS */.l.ui.borderFocus
}) => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
  color
},  true ? "" : 0,  true ? "" : 0);
const wrapperMargin = ({
  marks,
  __nextHasNoMarginBottom
}) => {
  if (!__nextHasNoMarginBottom) {
    return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
      marginBottom: marks ? 16 : undefined
    },  true ? "" : 0,  true ? "" : 0);
  }
  return '';
};
const range_control_styles_Wrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1epgpqk13"
} : 0)("display:block;flex:1;position:relative;width:100%;", wrapperColor, ";", rangeHeight, ";", wrapperMargin, ";" + ( true ? "" : 0));
const BeforeIconWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk12"
} : 0)("display:flex;margin-top:", railHeight, "px;", (0,rtl/* rtl */.h)({
  marginRight: 6
}), ";" + ( true ? "" : 0));
const AfterIconWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk11"
} : 0)("display:flex;margin-top:", railHeight, "px;", (0,rtl/* rtl */.h)({
  marginLeft: 6
}), ";" + ( true ? "" : 0));
const railBackgroundColor = ({
  disabled,
  railColor
}) => {
  let background = railColor || '';
  if (disabled) {
    background = colors_values/* COLORS */.l.ui.backgroundDisabled;
  }
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    background
  },  true ? "" : 0,  true ? "" : 0);
};
const Rail = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk10"
} : 0)("background-color:", colors_values/* COLORS */.l.gray[300], ";left:0;pointer-events:none;right:0;display:block;height:", railHeight, "px;position:absolute;margin-top:", (rangeHeightValue - railHeight) / 2, "px;top:0;border-radius:", railHeight, "px;", railBackgroundColor, ";" + ( true ? "" : 0));
const trackBackgroundColor = ({
  disabled,
  trackColor
}) => {
  let background = trackColor || 'currentColor';
  if (disabled) {
    background = colors_values/* COLORS */.l.gray[400];
  }
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    background
  },  true ? "" : 0,  true ? "" : 0);
};
const Track = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk9"
} : 0)("background-color:currentColor;border-radius:", railHeight, "px;height:", railHeight, "px;pointer-events:none;display:block;position:absolute;margin-top:", (rangeHeightValue - railHeight) / 2, "px;top:0;", trackBackgroundColor, ";" + ( true ? "" : 0));
const MarksWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk8"
} : 0)( true ? {
  name: "l7tjj5",
  styles: "display:block;pointer-events:none;position:relative;width:100%;user-select:none"
} : 0);
const markFill = ({
  disabled,
  isFilled
}) => {
  let backgroundColor = isFilled ? 'currentColor' : colors_values/* COLORS */.l.gray[300];
  if (disabled) {
    backgroundColor = colors_values/* COLORS */.l.gray[400];
  }
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    backgroundColor
  },  true ? "" : 0,  true ? "" : 0);
};
const Mark = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk7"
} : 0)("height:", thumbSize, "px;left:0;position:absolute;top:-4px;width:1px;", markFill, ";" + ( true ? "" : 0));
const markLabelFill = ({
  isFilled
}) => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    color: isFilled ? colors_values/* COLORS */.l.gray[700] : colors_values/* COLORS */.l.gray[300]
  },  true ? "" : 0,  true ? "" : 0);
};
const MarkLabel = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk6"
} : 0)("color:", colors_values/* COLORS */.l.gray[300], ";left:0;font-size:11px;position:absolute;top:12px;transform:translateX( -50% );white-space:nowrap;", markLabelFill, ";" + ( true ? "" : 0));
const thumbColor = ({
  disabled
}) => disabled ? /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("background-color:", colors_values/* COLORS */.l.gray[400], ";" + ( true ? "" : 0),  true ? "" : 0) : /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("background-color:", colors_values/* COLORS */.l.theme.accent, ";" + ( true ? "" : 0),  true ? "" : 0);
const ThumbWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk5"
} : 0)("align-items:center;display:flex;height:", thumbSize, "px;justify-content:center;margin-top:", (rangeHeightValue - thumbSize) / 2, "px;outline:0;pointer-events:none;position:absolute;top:0;user-select:none;width:", thumbSize, "px;border-radius:50%;", thumbColor, ";", (0,rtl/* rtl */.h)({
  marginLeft: -10
}), ";", (0,rtl/* rtl */.h)({
  transform: 'translateX( 4.5px )'
}, {
  transform: 'translateX( -4.5px )'
}), ";" + ( true ? "" : 0));
const thumbFocus = ({
  isFocused
}) => {
  return isFocused ? /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("&::before{content:' ';position:absolute;background-color:", colors_values/* COLORS */.l.theme.accent, ";opacity:0.4;border-radius:50%;height:", thumbSize + 8, "px;width:", thumbSize + 8, "px;top:-4px;left:-4px;}" + ( true ? "" : 0),  true ? "" : 0) : '';
};
const Thumb = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk4"
} : 0)("align-items:center;border-radius:50%;height:100%;outline:0;position:absolute;user-select:none;width:100%;", thumbColor, ";", thumbFocus, ";" + ( true ? "" : 0));
const InputRange = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("input",  true ? {
  target: "e1epgpqk3"
} : 0)("box-sizing:border-box;cursor:pointer;display:block;height:100%;left:0;margin:0 -", thumbSize / 2, "px;opacity:0;outline:none;position:absolute;right:0;top:0;width:calc( 100% + ", thumbSize, "px );" + ( true ? "" : 0));
const tooltipShow = ({
  show
}) => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    opacity: show ? 1 : 0
  },  true ? "" : 0,  true ? "" : 0);
};
var range_control_styles_ref =  true ? {
  name: "1cypxip",
  styles: "top:-80%"
} : 0;
var range_control_styles_ref2 =  true ? {
  name: "1lr98c4",
  styles: "bottom:-80%"
} : 0;
const tooltipPosition = ({
  position
}) => {
  const isBottom = position === 'bottom';
  if (isBottom) {
    return range_control_styles_ref2;
  }
  return range_control_styles_ref;
};
const Tooltip = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk2"
} : 0)("background:rgba( 0, 0, 0, 0.8 );border-radius:2px;color:white;display:inline-block;font-size:12px;min-width:32px;opacity:0;padding:4px 8px;pointer-events:none;position:absolute;text-align:center;user-select:none;line-height:1.4;@media not ( prefers-reduced-motion ){transition:opacity 120ms ease;}", tooltipShow, ";", tooltipPosition, ";", (0,rtl/* rtl */.h)({
  transform: 'translateX(-50%)'
}, {
  transform: 'translateX(50%)'
}), ";" + ( true ? "" : 0));

// @todo Refactor RangeControl with latest HStack configuration
// @see: packages/components/src/h-stack
const InputNumber = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(number_control/* default */.A,  true ? {
  target: "e1epgpqk1"
} : 0)("display:inline-block;font-size:13px;margin-top:0;input[type='number']&{", rangeHeight, ";}", (0,rtl/* rtl */.h)({
  marginLeft: `${(0,space/* space */.x)(4)} !important`
}), ";" + ( true ? "" : 0));
const ActionRightWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk0"
} : 0)("display:block;margin-top:0;button,button.is-small{margin-left:0;", rangeHeight, ";}", (0,rtl/* rtl */.h)({
  marginLeft: 8
}), ";" + ( true ? "" : 0));
//# sourceMappingURL=range-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/range-control/input-range.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function input_range_InputRange(props, ref) {
  const {
    describedBy,
    label,
    value,
    ...otherProps
  } = props;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(InputRange, {
    ...otherProps,
    "aria-describedby": describedBy,
    "aria-label": label,
    "aria-hidden": false,
    ref: ref,
    tabIndex: 0,
    type: "range",
    value: value
  });
}
const ForwardedComponent = (0,react.forwardRef)(input_range_InputRange);
/* harmony default export */ const input_range = (ForwardedComponent);
//# sourceMappingURL=input-range.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/range-control/mark.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */




function RangeMark(props) {
  const {
    className,
    isFilled = false,
    label,
    style = {},
    ...otherProps
  } = props;
  const classes = (0,dist_clsx/* default */.A)('components-range-control__mark', isFilled && 'is-filled', className);
  const labelClasses = (0,dist_clsx/* default */.A)('components-range-control__mark-label', isFilled && 'is-filled');
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Mark, {
      ...otherProps,
      "aria-hidden": "true",
      className: classes,
      isFilled: isFilled,
      style: style
    }), label && /*#__PURE__*/(0,jsx_runtime.jsx)(MarkLabel, {
      "aria-hidden": "true",
      className: labelClasses,
      isFilled: isFilled,
      style: style,
      children: label
    })]
  });
}
//# sourceMappingURL=mark.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/range-control/rail.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






function RangeRail(props) {
  const {
    disabled = false,
    marks = false,
    min = 0,
    max = 100,
    step = 1,
    value = 0,
    ...restProps
  } = props;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Rail, {
      disabled: disabled,
      ...restProps
    }), marks && /*#__PURE__*/(0,jsx_runtime.jsx)(Marks, {
      disabled: disabled,
      marks: marks,
      min: min,
      max: max,
      step: step,
      value: value
    })]
  });
}
function Marks(props) {
  const {
    disabled = false,
    marks = false,
    min = 0,
    max = 100,
    step: stepProp = 1,
    value = 0
  } = props;
  const step = stepProp === 'any' ? 1 : stepProp;
  const marksData = useMarks({
    marks,
    min,
    max,
    step,
    value
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(MarksWrapper, {
    "aria-hidden": "true",
    className: "components-range-control__marks",
    children: marksData.map(mark => /*#__PURE__*/(0,react.createElement)(RangeMark, {
      ...mark,
      key: mark.key,
      "aria-hidden": "true",
      disabled: disabled
    }))
  });
}
function useMarks({
  marks,
  min = 0,
  max = 100,
  step = 1,
  value = 0
}) {
  if (!marks) {
    return [];
  }
  const range = max - min;
  if (!Array.isArray(marks)) {
    marks = [];
    const count = 1 + Math.round(range / step);
    while (count > marks.push({
      value: step * marks.length + min
    })) {}
  }
  const placedMarks = [];
  marks.forEach((mark, index) => {
    if (mark.value < min || mark.value > max) {
      return;
    }
    const key = `mark-${index}`;
    const isFilled = mark.value <= value;
    const offset = `${(mark.value - min) / range * 100}%`;
    const offsetStyle = {
      [(0,i18n_build_module/* isRTL */.V8)() ? 'right' : 'left']: offset
    };
    placedMarks.push({
      ...mark,
      isFilled,
      key,
      style: offsetStyle
    });
  });
  return placedMarks;
}
//# sourceMappingURL=rail.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/range-control/tooltip.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function SimpleTooltip(props) {
  const {
    className,
    inputRef,
    tooltipPosition,
    show = false,
    style = {},
    value = 0,
    renderTooltipContent = v => v,
    zIndex = 100,
    ...restProps
  } = props;
  const position = useTooltipPosition({
    inputRef,
    tooltipPosition
  });
  const classes = (0,dist_clsx/* default */.A)('components-simple-tooltip', className);
  const styles = {
    ...style,
    zIndex
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Tooltip, {
    ...restProps,
    "aria-hidden": show,
    className: classes,
    position: position,
    show: show,
    role: "tooltip",
    style: styles,
    children: renderTooltipContent(value)
  });
}
function useTooltipPosition({
  inputRef,
  tooltipPosition
}) {
  const [position, setPosition] = (0,react.useState)();
  const setTooltipPosition = (0,react.useCallback)(() => {
    if (inputRef && inputRef.current) {
      setPosition(tooltipPosition);
    }
  }, [tooltipPosition, inputRef]);
  (0,react.useEffect)(() => {
    setTooltipPosition();
  }, [setTooltipPosition]);
  (0,react.useEffect)(() => {
    window.addEventListener('resize', setTooltipPosition);
    return () => {
      window.removeEventListener('resize', setTooltipPosition);
    };
  });
  return position;
}
//# sourceMappingURL=tooltip.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/range-control/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */













const noop = () => {};
function UnforwardedRangeControl(props, forwardedRef) {
  const {
    __nextHasNoMarginBottom = false,
    afterIcon,
    allowReset = false,
    beforeIcon,
    className,
    color: colorProp = colors_values/* COLORS */.l.theme.accent,
    currentInput,
    disabled = false,
    help,
    hideLabelFromVision = false,
    initialPosition,
    isShiftStepEnabled = true,
    label,
    marks = false,
    max = 100,
    min = 0,
    onBlur = noop,
    onChange = noop,
    onFocus = noop,
    onMouseLeave = noop,
    onMouseMove = noop,
    railColor,
    renderTooltipContent = v => v,
    resetFallbackValue,
    __next40pxDefaultSize = false,
    shiftStep = 10,
    showTooltip: showTooltipProp,
    step = 1,
    trackColor,
    value: valueProp,
    withInputField = true,
    ...otherProps
  } = props;
  const [value, setValue] = useControlledRangeValue({
    min,
    max,
    value: valueProp !== null && valueProp !== void 0 ? valueProp : null,
    initial: initialPosition
  });
  const isResetPendent = (0,react.useRef)(false);
  let hasTooltip = showTooltipProp;
  let hasInputField = withInputField;
  if (step === 'any') {
    // The tooltip and number input field are hidden when the step is "any"
    // because the decimals get too lengthy to fit well.
    hasTooltip = false;
    hasInputField = false;
  }
  const [showTooltip, setShowTooltip] = (0,react.useState)(hasTooltip);
  const [isFocused, setIsFocused] = (0,react.useState)(false);
  const inputRef = (0,react.useRef)();
  const isCurrentlyFocused = inputRef.current?.matches(':focus');
  const isThumbFocused = !disabled && isFocused;
  const isValueReset = value === null;
  const currentValue = value !== undefined ? value : currentInput;
  const inputSliderValue = isValueReset ? '' : currentValue;
  const rangeFillValue = isValueReset ? (max - min) / 2 + min : value;
  const fillValue = isValueReset ? 50 : (value - min) / (max - min) * 100;
  const fillValueOffset = `${(0,math/* clamp */.qE)(fillValue, 0, 100)}%`;
  const classes = (0,dist_clsx/* default */.A)('components-range-control', className);
  const wrapperClasses = (0,dist_clsx/* default */.A)('components-range-control__wrapper', !!marks && 'is-marked');
  const id = (0,use_instance_id/* default */.A)(UnforwardedRangeControl, 'inspector-range-control');
  const describedBy = !!help ? `${id}__help` : undefined;
  const enableTooltip = hasTooltip !== false && Number.isFinite(value);
  const handleOnRangeChange = event => {
    const nextValue = parseFloat(event.target.value);
    setValue(nextValue);
    onChange(nextValue);
  };
  const handleOnChange = next => {
    // @ts-expect-error TODO: Investigate if it's problematic for setValue() to
    // potentially receive a NaN when next is undefined.
    let nextValue = parseFloat(next);
    setValue(nextValue);

    /*
     * Calls onChange only when nextValue is numeric
     * otherwise may queue a reset for the blur event.
     */
    if (!isNaN(nextValue)) {
      if (nextValue < min || nextValue > max) {
        nextValue = floatClamp(nextValue, min, max);
      }
      onChange(nextValue);
      isResetPendent.current = false;
    } else if (allowReset) {
      isResetPendent.current = true;
    }
  };
  const handleOnInputNumberBlur = () => {
    if (isResetPendent.current) {
      handleOnReset();
      isResetPendent.current = false;
    }
  };
  const handleOnReset = () => {
    let resetValue = parseFloat(`${resetFallbackValue}`);
    let onChangeResetValue = resetValue;
    if (isNaN(resetValue)) {
      resetValue = null;
      onChangeResetValue = undefined;
    }
    setValue(resetValue);

    /**
     * Previously, this callback would always receive undefined as
     * an argument. This behavior is unexpected, specifically
     * when resetFallbackValue is defined.
     *
     * The value of undefined is not ideal. Passing it through
     * to internal <input /> elements would change it from a
     * controlled component to an uncontrolled component.
     *
     * For now, to minimize unexpected regressions, we're going to
     * preserve the undefined callback argument, except when a
     * resetFallbackValue is defined.
     */
    onChange(onChangeResetValue);
  };
  const handleShowTooltip = () => setShowTooltip(true);
  const handleHideTooltip = () => setShowTooltip(false);
  const handleOnBlur = event => {
    onBlur(event);
    setIsFocused(false);
    handleHideTooltip();
  };
  const handleOnFocus = event => {
    onFocus(event);
    setIsFocused(true);
    handleShowTooltip();
  };
  const offsetStyle = {
    [(0,i18n_build_module/* isRTL */.V8)() ? 'right' : 'left']: fillValueOffset
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default */.Ay, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    className: classes,
    label: label,
    hideLabelFromVision: hideLabelFromVision,
    id: `${id}`,
    help: help,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Root, {
      className: "components-range-control__root",
      __next40pxDefaultSize: __next40pxDefaultSize,
      children: [beforeIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(BeforeIconWrapper, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
          icon: beforeIcon
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(range_control_styles_Wrapper, {
        __nextHasNoMarginBottom: __nextHasNoMarginBottom,
        className: wrapperClasses,
        color: colorProp,
        marks: !!marks,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(input_range, {
          ...otherProps,
          className: "components-range-control__slider",
          describedBy: describedBy,
          disabled: disabled,
          id: `${id}`,
          label: label,
          max: max,
          min: min,
          onBlur: handleOnBlur,
          onChange: handleOnRangeChange,
          onFocus: handleOnFocus,
          onMouseMove: onMouseMove,
          onMouseLeave: onMouseLeave,
          ref: (0,use_merge_refs/* default */.A)([inputRef, forwardedRef]),
          step: step,
          value: inputSliderValue !== null && inputSliderValue !== void 0 ? inputSliderValue : undefined
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(RangeRail, {
          "aria-hidden": true,
          disabled: disabled,
          marks: marks,
          max: max,
          min: min,
          railColor: railColor,
          step: step,
          value: rangeFillValue
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(Track, {
          "aria-hidden": true,
          className: "components-range-control__track",
          disabled: disabled,
          style: {
            width: fillValueOffset
          },
          trackColor: trackColor
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(ThumbWrapper, {
          className: "components-range-control__thumb-wrapper",
          style: offsetStyle,
          disabled: disabled,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(Thumb, {
            "aria-hidden": true,
            isFocused: isThumbFocused,
            disabled: disabled
          })
        }), enableTooltip && /*#__PURE__*/(0,jsx_runtime.jsx)(SimpleTooltip, {
          className: "components-range-control__tooltip",
          inputRef: inputRef,
          tooltipPosition: "bottom",
          renderTooltipContent: renderTooltipContent,
          show: isCurrentlyFocused || showTooltip,
          style: offsetStyle,
          value: value
        })]
      }), afterIcon && /*#__PURE__*/(0,jsx_runtime.jsx)(AfterIconWrapper, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
          icon: afterIcon
        })
      }), hasInputField && /*#__PURE__*/(0,jsx_runtime.jsx)(InputNumber, {
        "aria-label": label,
        className: "components-range-control__number",
        disabled: disabled,
        inputMode: "decimal",
        isShiftStepEnabled: isShiftStepEnabled,
        max: max,
        min: min,
        onBlur: handleOnInputNumberBlur,
        onChange: handleOnChange,
        shiftStep: shiftStep,
        size: __next40pxDefaultSize ? '__unstable-large' : 'default',
        __unstableInputWidth: __next40pxDefaultSize ? (0,space/* space */.x)(20) : (0,space/* space */.x)(16),
        step: step
        // @ts-expect-error TODO: Investigate if the `null` value is necessary
        ,
        value: inputSliderValue
      }), allowReset && /*#__PURE__*/(0,jsx_runtime.jsx)(ActionRightWrapper, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          className: "components-range-control__reset",
          disabled: disabled || value === undefined,
          variant: "secondary",
          size: "small",
          onClick: handleOnReset,
          children: (0,i18n_build_module.__)('Reset')
        })
      })]
    })
  });
}

/**
 * RangeControls are used to make selections from a range of incremental values.
 *
 * ```jsx
 * import { RangeControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyRangeControl = () => {
 *   const [ isChecked, setChecked ] = useState( true );
 *   return (
 *     <RangeControl
 *       help="Please select how transparent you would like this."
 *       initialPosition={50}
 *       label="Opacity"
 *       max={100}
 *       min={0}
 *       onChange={() => {}}
 *     />
 *   );
 * };
 * ```
 */
const RangeControl = (0,react.forwardRef)(UnforwardedRangeControl);
/* harmony default export */ const range_control = (RangeControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option/component.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function UnforwardedToggleGroupControlOption(props, ref) {
  const {
    label,
    ...restProps
  } = props;
  const optionLabel = restProps['aria-label'] || label;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_base_component, {
    ...restProps,
    "aria-label": optionLabel,
    ref: ref,
    children: label
  });
}

/**
 * `ToggleGroupControlOption` is a form component and is meant to be used as a
 * child of `ToggleGroupControl`.
 *
 * ```jsx
 * import {
 *   __experimentalToggleGroupControl as ToggleGroupControl,
 *   __experimentalToggleGroupControlOption as ToggleGroupControlOption,
 * } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ToggleGroupControl label="my label" value="vertical" isBlock>
 *       <ToggleGroupControlOption value="horizontal" label="Horizontal" />
 *       <ToggleGroupControlOption value="vertical" label="Vertical" />
 *     </ToggleGroupControl>
 *   );
 * }
 * ```
 */
const ToggleGroupControlOption = (0,react.forwardRef)(UnforwardedToggleGroupControlOption);
/* harmony default export */ const toggle_group_control_option_component = (ToggleGroupControlOption);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-ref-effect/index.js
var use_ref_effect = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-ref-effect/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/observable-map/index.js
var observable_map = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/observable-map/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/provider/block-refs-provider.js
/**
 * WordPress dependencies
 */



const BlockRefs = (0,react.createContext)({
  refsMap: (0,observable_map/* observableMap */.u)()
});
function BlockRefsProvider({
  children
}) {
  const value = (0,react.useMemo)(() => ({
    refsMap: (0,observable_map/* observableMap */.u)()
  }), []);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockRefs.Provider, {
    value: value,
    children: children
  });
}
//# sourceMappingURL=block-refs-provider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-refs.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/element').RefCallback} RefCallback */
/** @typedef {import('@wordpress/element').RefObject} RefObject */

/**
 * Provides a ref to the BlockRefs context.
 *
 * @param {string} clientId The client ID of the element ref.
 *
 * @return {RefCallback} Ref callback.
 */
function useBlockRefProvider(clientId) {
  const {
    refsMap
  } = (0,react.useContext)(BlockRefs);
  return (0,use_ref_effect/* default */.A)(element => {
    refsMap.set(clientId, element);
    return () => refsMap.delete(clientId);
  }, [clientId]);
}

/**
 * Gets a ref pointing to the current block element. Continues to return the same
 * stable ref object even if the `clientId` argument changes. This hook is not
 * reactive, i.e., it won't trigger a rerender of the calling component if the
 * ref value changes. For reactive use cases there is the `useBlockElement` hook.
 *
 * @param {string} clientId The client ID to get a ref for.
 *
 * @return {RefObject} A ref containing the element.
 */
function useBlockRef(clientId) {
  const {
    refsMap
  } = (0,react.useContext)(BlockRefs);
  const latestClientId = (0,react.useRef)();
  latestClientId.current = clientId;

  // Always return an object, even if no ref exists for a given client ID, so
  // that `current` works at a later point.
  return (0,react.useMemo)(() => ({
    get current() {
      var _refsMap$get;
      return (_refsMap$get = refsMap.get(latestClientId.current)) !== null && _refsMap$get !== void 0 ? _refsMap$get : null;
    }
  }), [refsMap]);
}

/**
 * Return the element for a given client ID. Updates whenever the element
 * changes, becomes available, or disappears.
 *
 * @param {string} clientId The client ID to an element for.
 *
 * @return {Element|null} The block's wrapper element.
 */
function useBlockElement(clientId) {
  const {
    refsMap
  } = (0,react.useContext)(BlockRefs);
  const [blockElement, setBlockElement] = (0,react.useState)(null);
  // Delay setting the resulting `blockElement` until an effect. If the block element
  // changes (i.e., the block is unmounted and re-mounted), this allows enough time
  // for the ref callbacks to clean up the old element and set the new one.
  (0,react.useLayoutEffect)(() => {
    setBlockElement(refsMap.get(clientId));
    return refsMap.subscribe(clientId, () => setBlockElement(refsMap.get(clientId)));
  }, [refsMap, clientId]);
  return blockElement;
}


//# sourceMappingURL=use-block-refs.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/popover/index.js + 3 modules
var popover = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/popover/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-popover/use-popover-scroll.js
/**
 * WordPress dependencies
 */


/**
 * Allow scrolling "through" popovers over the canvas. This is only called for
 * as long as the pointer is over a popover. Do not use React events because it
 * will bubble through portals.
 *
 * @param {Object} scrollableRef
 */
function usePopoverScroll(scrollableRef) {
  return (0,use_ref_effect/* default */.A)(node => {
    if (!scrollableRef) {
      return;
    }
    function onWheel(event) {
      const {
        deltaX,
        deltaY
      } = event;
      scrollableRef.current.scrollBy(deltaX, deltaY);
    }
    // Tell the browser that we do not call event.preventDefault
    // See https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scrolling_performance_with_passive_listeners
    const options = {
      passive: true
    };
    node.addEventListener('wheel', onWheel, options);
    return () => {
      node.removeEventListener('wheel', onWheel, options);
    };
  }, [scrollableRef]);
}
/* harmony default export */ const use_popover_scroll = (usePopoverScroll);
//# sourceMappingURL=use-popover-scroll.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-popover/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const MAX_POPOVER_RECOMPUTE_COUNTER = Number.MAX_SAFE_INTEGER;
function BlockPopover({
  clientId,
  bottomClientId,
  children,
  __unstablePopoverSlot,
  __unstableContentRef,
  shift = true,
  ...props
}, ref) {
  const selectedElement = useBlockElement(clientId);
  const lastSelectedElement = useBlockElement(bottomClientId !== null && bottomClientId !== void 0 ? bottomClientId : clientId);
  const mergedRefs = (0,use_merge_refs/* default */.A)([ref, use_popover_scroll(__unstableContentRef)]);
  const [popoverDimensionsRecomputeCounter, forceRecomputePopoverDimensions] = (0,react.useReducer)(
  // Module is there to make sure that the counter doesn't overflow.
  s => (s + 1) % MAX_POPOVER_RECOMPUTE_COUNTER, 0);

  // When blocks are moved up/down, they are animated to their new position by
  // updating the `transform` property manually (i.e. without using CSS
  // transitions or animations). The animation, which can also scroll the block
  // editor, can sometimes cause the position of the Popover to get out of sync.
  // A MutationObserver is therefore used to make sure that changes to the
  // selectedElement's attribute (i.e. `transform`) can be tracked and used to
  // trigger the Popover to rerender.
  (0,react.useLayoutEffect)(() => {
    if (!selectedElement) {
      return;
    }
    const observer = new window.MutationObserver(forceRecomputePopoverDimensions);
    observer.observe(selectedElement, {
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [selectedElement]);
  const popoverAnchor = (0,react.useMemo)(() => {
    if (
    // popoverDimensionsRecomputeCounter is by definition always equal or greater
    // than 0. This check is only there to satisfy the correctness of the
    // exhaustive-deps rule for the `useMemo` hook.
    popoverDimensionsRecomputeCounter < 0 || !selectedElement || bottomClientId && !lastSelectedElement) {
      return undefined;
    }
    return {
      getBoundingClientRect() {
        var _lastSelectedBCR$left, _lastSelectedBCR$top, _lastSelectedBCR$righ, _lastSelectedBCR$bott;
        const selectedBCR = selectedElement.getBoundingClientRect();
        const lastSelectedBCR = lastSelectedElement?.getBoundingClientRect();

        // Get the biggest rectangle that encompasses completely the currently
        // selected element and the last selected element:
        // - for top/left coordinates, use the smaller numbers
        // - for the bottom/right coordinates, use the largest numbers
        const left = Math.min(selectedBCR.left, (_lastSelectedBCR$left = lastSelectedBCR?.left) !== null && _lastSelectedBCR$left !== void 0 ? _lastSelectedBCR$left : Infinity);
        const top = Math.min(selectedBCR.top, (_lastSelectedBCR$top = lastSelectedBCR?.top) !== null && _lastSelectedBCR$top !== void 0 ? _lastSelectedBCR$top : Infinity);
        const right = Math.max(selectedBCR.right, (_lastSelectedBCR$righ = lastSelectedBCR.right) !== null && _lastSelectedBCR$righ !== void 0 ? _lastSelectedBCR$righ : -Infinity);
        const bottom = Math.max(selectedBCR.bottom, (_lastSelectedBCR$bott = lastSelectedBCR.bottom) !== null && _lastSelectedBCR$bott !== void 0 ? _lastSelectedBCR$bott : -Infinity);
        const width = right - left;
        const height = bottom - top;
        return new window.DOMRect(left, top, width, height);
      },
      contextElement: selectedElement
    };
  }, [bottomClientId, lastSelectedElement, selectedElement, popoverDimensionsRecomputeCounter]);
  if (!selectedElement || bottomClientId && !lastSelectedElement) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(popover/* default */.Ay, {
    ref: mergedRefs,
    animate: false,
    focusOnMount: false,
    anchor: popoverAnchor
    // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot,
    inline: !__unstablePopoverSlot,
    placement: "top-start",
    resize: false,
    flip: false,
    shift: shift,
    ...props,
    className: (0,dist_clsx/* default */.A)('block-editor-block-popover', props.className),
    variant: "unstyled",
    children: children
  });
}
const PrivateBlockPopover = (0,react.forwardRef)(BlockPopover);
const PublicBlockPopover = ({
  clientId,
  bottomClientId,
  children,
  ...props
}, ref) => /*#__PURE__*/(0,jsx_runtime.jsx)(PrivateBlockPopover, {
  ...props,
  bottomClientId: bottomClientId,
  clientId: clientId,
  __unstableContentRef: undefined,
  __unstablePopoverSlot: undefined,
  ref: ref,
  children: children
});

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-popover/README.md
 */
/* harmony default export */ const block_popover = ((0,react.forwardRef)(PublicBlockPopover));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-popover/cover.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function BlockPopoverCover({
  clientId,
  bottomClientId,
  children,
  shift = false,
  additionalStyles,
  ...props
}, ref) {
  var _bottomClientId;
  (_bottomClientId = bottomClientId) !== null && _bottomClientId !== void 0 ? _bottomClientId : bottomClientId = clientId;
  const selectedElement = useBlockElement(clientId);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(PrivateBlockPopover, {
    ref: ref,
    clientId: clientId,
    bottomClientId: bottomClientId,
    shift: shift,
    ...props,
    children: selectedElement && clientId === bottomClientId ? /*#__PURE__*/(0,jsx_runtime.jsx)(CoverContainer, {
      selectedElement: selectedElement,
      additionalStyles: additionalStyles,
      children: children
    }) : children
  });
}
function CoverContainer({
  selectedElement,
  additionalStyles = {},
  children
}) {
  const [width, setWidth] = (0,react.useState)(selectedElement.offsetWidth);
  const [height, setHeight] = (0,react.useState)(selectedElement.offsetHeight);
  (0,react.useEffect)(() => {
    const observer = new window.ResizeObserver(() => {
      setWidth(selectedElement.offsetWidth);
      setHeight(selectedElement.offsetHeight);
    });
    observer.observe(selectedElement, {
      box: 'border-box'
    });
    return () => observer.disconnect();
  }, [selectedElement]);
  const style = (0,react.useMemo)(() => {
    return {
      position: 'absolute',
      width,
      height,
      ...additionalStyles
    };
  }, [width, height, additionalStyles]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    style: style,
    children: children
  });
}
/* harmony default export */ const cover = ((0,react.forwardRef)(BlockPopoverCover));
//# sourceMappingURL=cover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/grid-visualizer/utils.js
function getComputedCSS(element, property) {
  return element.ownerDocument.defaultView.getComputedStyle(element).getPropertyValue(property);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/grid-visualizer/grid-visualizer.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





function GridVisualizer({
  clientId,
  contentRef
}) {
  const isDistractionFree = (0,use_select/* default */.A)(select => select(store_store).getSettings().isDistractionFree, []);
  const blockElement = useBlockElement(clientId);
  if (isDistractionFree || !blockElement) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(cover, {
    className: "block-editor-grid-visualizer",
    clientId: clientId,
    __unstablePopoverSlot: "block-toolbar",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(GridVisualizerGrid, {
      ref: contentRef,
      blockElement: blockElement
    })
  });
}
const GridVisualizerGrid = (0,react.forwardRef)(({
  blockElement
}, ref) => {
  const [gridInfo, setGridInfo] = (0,react.useState)(() => getGridInfo(blockElement));
  (0,react.useEffect)(() => {
    const observers = [];
    for (const element of [blockElement, ...blockElement.children]) {
      const observer = new window.ResizeObserver(() => {
        setGridInfo(getGridInfo(blockElement));
      });
      observer.observe(element);
      observers.push(observer);
    }
    return () => {
      for (const observer of observers) {
        observer.disconnect();
      }
    };
  }, [blockElement]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ref: ref,
    className: "block-editor-grid-visualizer__grid",
    style: gridInfo.style,
    children: Array.from({
      length: gridInfo.numItems
    }, (_, i) => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-grid-visualizer__item",
      style: {
        boxShadow: `inset 0 0 0 1px color-mix(in srgb, ${gridInfo.currentColor} 20%, #0000)`
      }
    }, i))
  });
});
function getGridInfo(blockElement) {
  const gridTemplateColumns = getComputedCSS(blockElement, 'grid-template-columns');
  const gridTemplateRows = getComputedCSS(blockElement, 'grid-template-rows');
  const numColumns = gridTemplateColumns.split(' ').length;
  const numRows = gridTemplateRows.split(' ').length;
  const numItems = numColumns * numRows;
  return {
    numItems,
    currentColor: getComputedCSS(blockElement, 'color'),
    style: {
      gridTemplateColumns,
      gridTemplateRows,
      gap: getComputedCSS(blockElement, 'gap'),
      padding: getComputedCSS(blockElement, 'padding')
    }
  };
}
//# sourceMappingURL=grid-visualizer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/layouts/grid.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */








const RANGE_CONTROL_MAX_VALUES = {
  px: 600,
  '%': 100,
  vw: 100,
  vh: 100,
  em: 38,
  rem: 38,
  svw: 100,
  lvw: 100,
  dvw: 100,
  svh: 100,
  lvh: 100,
  dvh: 100,
  vi: 100,
  svi: 100,
  lvi: 100,
  dvi: 100,
  vb: 100,
  svb: 100,
  lvb: 100,
  dvb: 100,
  vmin: 100,
  svmin: 100,
  lvmin: 100,
  dvmin: 100,
  vmax: 100,
  svmax: 100,
  lvmax: 100,
  dvmax: 100
};
const units = [{
  value: 'px',
  label: 'px',
  default: 0
}, {
  value: 'rem',
  label: 'rem',
  default: 0
}, {
  value: 'em',
  label: 'em',
  default: 0
}];
/* harmony default export */ const grid = ({
  name: 'grid',
  label: (0,i18n_build_module.__)('Grid'),
  inspectorControls: function GridLayoutInspectorControls({
    layout = {},
    onChange,
    layoutBlockSupport = {}
  }) {
    const {
      allowSizingOnChildren = false
    } = layoutBlockSupport;
    return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(GridLayoutTypeControl, {
        layout: layout,
        onChange: onChange
      }), layout?.columnCount ? /*#__PURE__*/(0,jsx_runtime.jsx)(GridLayoutColumnsAndRowsControl, {
        layout: layout,
        onChange: onChange,
        allowSizingOnChildren: allowSizingOnChildren
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)(GridLayoutMinimumWidthControl, {
        layout: layout,
        onChange: onChange
      })]
    });
  },
  toolBarControls: function GridLayoutToolbarControls({
    clientId
  }) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(GridVisualizer, {
      clientId: clientId
    });
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    layout,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const {
      minimumColumnWidth = '12rem',
      columnCount = null,
      rowCount = null
    } = layout;

    // If a block's block.json skips serialization for spacing or spacing.blockGap,
    // don't apply the user-defined value to the styles.
    const blockGapValue = style?.spacing?.blockGap && !shouldSkipSerialization(blockName, 'spacing', 'blockGap') ? getGapCSSValue(style?.spacing?.blockGap, '0.5em') : undefined;
    let output = '';
    const rules = [];
    if (columnCount) {
      rules.push(`grid-template-columns: repeat(${columnCount}, minmax(0, 1fr))`);
      if (rowCount) {
        rules.push(`grid-template-rows: repeat(${rowCount}, minmax(0, 1fr))`);
      }
    } else if (minimumColumnWidth) {
      rules.push(`grid-template-columns: repeat(auto-fill, minmax(min(${minimumColumnWidth}, 100%), 1fr))`, 'container-type: inline-size');
    }
    if (rules.length) {
      // Reason to disable: the extra line breaks added by prettier mess with the unit tests.
      // eslint-disable-next-line prettier/prettier
      output = `${appendSelectors(selector)} { ${rules.join('; ')}; }`;
    }

    // Output blockGap styles based on rules contained in layout definitions in theme.json.
    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'grid', blockGapValue);
    }
    return output;
  },
  getOrientation() {
    return 'horizontal';
  },
  getAlignments() {
    return [];
  }
});

// Enables setting minimum width of grid items.
function GridLayoutMinimumWidthControl({
  layout,
  onChange
}) {
  const {
    minimumColumnWidth: value = '12rem'
  } = layout;
  const [quantity, unit] = parseQuantityAndUnitFromRawValue(value);
  const handleSliderChange = next => {
    onChange({
      ...layout,
      minimumColumnWidth: [next, unit].join('')
    });
  };

  // Mostly copied from HeightControl.
  const handleUnitChange = newUnit => {
    // Attempt to smooth over differences between currentUnit and newUnit.
    // This should slightly improve the experience of switching between unit types.
    let newValue;
    if (['em', 'rem'].includes(newUnit) && unit === 'px') {
      // Convert pixel value to an approximate of the new unit, assuming a root size of 16px.
      newValue = (quantity / 16).toFixed(2) + newUnit;
    } else if (['em', 'rem'].includes(unit) && newUnit === 'px') {
      // Convert to pixel value assuming a root size of 16px.
      newValue = Math.round(quantity * 16) + newUnit;
    }
    onChange({
      ...layout,
      minimumColumnWidth: newValue
    });
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
      as: "legend",
      children: (0,i18n_build_module.__)('Minimum column width')
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
      gap: 4,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        isBlock: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
          size: "__unstable-large",
          onChange: newValue => {
            onChange({
              ...layout,
              minimumColumnWidth: newValue
            });
          },
          onUnitChange: handleUnitChange,
          value: value,
          units: units,
          min: 0,
          label: (0,i18n_build_module.__)('Minimum column width'),
          hideLabelFromVision: true
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        isBlock: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(range_control, {
          onChange: handleSliderChange,
          value: quantity,
          min: 0,
          max: RANGE_CONTROL_MAX_VALUES[unit] || 600,
          withInputField: false,
          label: (0,i18n_build_module.__)('Minimum column width'),
          hideLabelFromVision: true
        })
      })]
    })]
  });
}

// Enables setting number of grid columns
function GridLayoutColumnsAndRowsControl({
  layout,
  onChange,
  allowSizingOnChildren
}) {
  const {
    columnCount = 3,
    rowCount
  } = layout;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
        as: "legend",
        children: (0,i18n_build_module.__)('Columns')
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
        gap: 4,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          isBlock: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(number_control/* default */.A, {
            size: "__unstable-large",
            onChange: value => {
              /**
               * If the input is cleared, avoid switching
               * back to "Auto" by setting a value of "1".
               */
              const validValue = value !== '' ? value : '1';
              onChange({
                ...layout,
                columnCount: validValue
              });
            },
            value: columnCount,
            min: 1,
            label: (0,i18n_build_module.__)('Columns'),
            hideLabelFromVision: true
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          isBlock: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(range_control, {
            value: parseInt(columnCount, 10) // RangeControl can't deal with strings.
            ,
            onChange: value => onChange({
              ...layout,
              columnCount: value
            }),
            min: 1,
            max: 16,
            withInputField: false,
            label: (0,i18n_build_module.__)('Columns'),
            hideLabelFromVision: true
          })
        })]
      })]
    }), allowSizingOnChildren && window.__experimentalEnableGridInteractivity && /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
        as: "legend",
        children: (0,i18n_build_module.__)('Rows')
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
        gap: 4,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          isBlock: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(number_control/* default */.A, {
            size: "__unstable-large",
            onChange: value => {
              onChange({
                ...layout,
                rowCount: value
              });
            },
            value: rowCount,
            min: 1,
            label: (0,i18n_build_module.__)('Rows'),
            hideLabelFromVision: true
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          isBlock: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(range_control, {
            value: parseInt(rowCount, 10) // RangeControl can't deal with strings.
            ,
            onChange: value => onChange({
              ...layout,
              rowCount: value
            }),
            min: 1,
            max: 16,
            withInputField: false,
            label: (0,i18n_build_module.__)('Rows'),
            hideLabelFromVision: true
          })
        })]
      })]
    })]
  });
}

// Enables switching between grid types
function GridLayoutTypeControl({
  layout,
  onChange
}) {
  const {
    columnCount,
    minimumColumnWidth
  } = layout;

  /**
   * When switching, temporarily save any custom values set on the
   * previous type so we can switch back without loss.
   */
  const [tempColumnCount, setTempColumnCount] = (0,react.useState)(columnCount || 3);
  const [tempMinimumColumnWidth, setTempMinimumColumnWidth] = (0,react.useState)(minimumColumnWidth || '12rem');
  const isManual = !!columnCount ? 'manual' : 'auto';
  const onChangeType = value => {
    if (value === 'manual') {
      setTempMinimumColumnWidth(minimumColumnWidth || '12rem');
    } else {
      setTempColumnCount(columnCount || 3);
    }
    onChange({
      ...layout,
      columnCount: value === 'manual' ? tempColumnCount : null,
      minimumColumnWidth: value === 'auto' ? tempMinimumColumnWidth : null
    });
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(toggle_group_control_component, {
    __nextHasNoMarginBottom: true,
    label: (0,i18n_build_module.__)('Type'),
    value: isManual,
    onChange: onChangeType,
    isBlock: true,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_component, {
      value: "auto",
      label: (0,i18n_build_module.__)('Auto')
    }, "auto"), /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_component, {
      value: "manual",
      label: (0,i18n_build_module.__)('Manual')
    }, "manual")]
  });
}
//# sourceMappingURL=grid.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/layouts/index.js
/**
 * Internal dependencies
 */




const layoutTypes = [flow, flex, constrained, grid];

/**
 * Retrieves a layout type by name.
 *
 * @param {string} name - The name of the layout type.
 * @return {Object} Layout type.
 */
function layouts_getLayoutType(name = 'default') {
  return layoutTypes.find(layoutType => layoutType.name === name);
}

/**
 * Retrieves the available layout types.
 *
 * @return {Array} Layout types.
 */
function getLayoutTypes() {
  return layoutTypes;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/use-available-alignments.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const use_available_alignments_EMPTY_ARRAY = [];
const use_available_alignments_DEFAULT_CONTROLS = ['none', 'left', 'center', 'right', 'wide', 'full'];
const WIDE_CONTROLS = ['wide', 'full'];
function useAvailableAlignments(controls = use_available_alignments_DEFAULT_CONTROLS) {
  // Always add the `none` option if not exists.
  if (!controls.includes('none')) {
    controls = ['none', ...controls];
  }
  const isNoneOnly = controls.length === 1 && controls[0] === 'none';
  const [wideControlsEnabled, themeSupportsLayout, isBlockBasedTheme] = (0,use_select/* default */.A)(select => {
    var _settings$alignWide;
    // If `isNoneOnly` is true, we'll be returning early because there is
    // nothing to filter on an empty array. We won't need the info from
    // the `useSelect` but we must call it anyway because Rules of Hooks.
    // So the callback returns early to avoid block editor subscription.
    if (isNoneOnly) {
      return [false, false, false];
    }
    const settings = select(store_store).getSettings();
    return [(_settings$alignWide = settings.alignWide) !== null && _settings$alignWide !== void 0 ? _settings$alignWide : false, settings.supportsLayout, settings.__unstableIsBlockBasedTheme];
  }, [isNoneOnly]);
  const layout = useLayout();
  if (isNoneOnly) {
    return use_available_alignments_EMPTY_ARRAY;
  }
  const layoutType = layouts_getLayoutType(layout?.type);
  if (themeSupportsLayout) {
    const layoutAlignments = layoutType.getAlignments(layout, isBlockBasedTheme);
    const alignments = layoutAlignments.filter(alignment => controls.includes(alignment.name));
    // While we treat `none` as an alignment, we shouldn't return it if no
    // other alignments exist.
    if (alignments.length === 1 && alignments[0].name === 'none') {
      return use_available_alignments_EMPTY_ARRAY;
    }
    return alignments;
  }

  // Starting here, it's the fallback for themes not supporting the layout config.
  if (layoutType.name !== 'default' && layoutType.name !== 'constrained') {
    return use_available_alignments_EMPTY_ARRAY;
  }
  const alignments = controls.filter(control => {
    if (layout.alignments) {
      return layout.alignments.includes(control);
    }
    if (!wideControlsEnabled && WIDE_CONTROLS.includes(control)) {
      return false;
    }
    return use_available_alignments_DEFAULT_CONTROLS.includes(control);
  }).map(name => ({
    name
  }));

  // While we treat `none` as an alignment, we shouldn't return it if no
  // other alignments exist.
  if (alignments.length === 1 && alignments[0].name === 'none') {
    return use_available_alignments_EMPTY_ARRAY;
  }
  return alignments;
}
//# sourceMappingURL=use-available-alignments.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/align-none.js
/**
 * WordPress dependencies
 */


const alignNone = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM5 9h14v6H5V9Z"
  })
});
/* harmony default export */ const align_none = (alignNone);
//# sourceMappingURL=align-none.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/position-left.js
/**
 * WordPress dependencies
 */


const positionLeft = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M5 5.5h8V4H5v1.5ZM5 20h8v-1.5H5V20ZM19 9H5v6h14V9Z"
  })
});
/* harmony default export */ const position_left = (positionLeft);
//# sourceMappingURL=position-left.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/position-right.js
/**
 * WordPress dependencies
 */


const positionRight = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M19 5.5h-8V4h8v1.5ZM19 20h-8v-1.5h8V20ZM5 9h14v6H5V9Z"
  })
});
/* harmony default export */ const position_right = (positionRight);
//# sourceMappingURL=position-right.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/stretch-full-width.js
/**
 * WordPress dependencies
 */


const stretchFullWidth = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M5 4h14v11H5V4Zm11 16H8v-1.5h8V20Z"
  })
});
/* harmony default export */ const stretch_full_width = (stretchFullWidth);
//# sourceMappingURL=stretch-full-width.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/constants.js
/**
 * WordPress dependencies
 */


const constants_BLOCK_ALIGNMENTS_CONTROLS = {
  none: {
    icon: align_none,
    title: (0,i18n_build_module._x)('None', 'Alignment option')
  },
  left: {
    icon: position_left,
    title: (0,i18n_build_module.__)('Align left')
  },
  center: {
    icon: position_center,
    title: (0,i18n_build_module.__)('Align center')
  },
  right: {
    icon: position_right,
    title: (0,i18n_build_module.__)('Align right')
  },
  wide: {
    icon: stretch_wide,
    title: (0,i18n_build_module.__)('Wide width')
  },
  full: {
    icon: stretch_full_width,
    title: (0,i18n_build_module.__)('Full width')
  }
};
const constants_DEFAULT_CONTROL = 'none';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/ui.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function ui_BlockAlignmentUI({
  value,
  onChange,
  controls,
  isToolbar,
  isCollapsed = true
}) {
  const enabledControls = useAvailableAlignments(controls);
  const hasEnabledControls = !!enabledControls.length;
  if (!hasEnabledControls) {
    return null;
  }
  function onChangeAlignment(align) {
    onChange([value, 'none'].includes(align) ? undefined : align);
  }
  const activeAlignmentControl = constants_BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = constants_BLOCK_ALIGNMENTS_CONTROLS[constants_DEFAULT_CONTROL];
  const UIComponent = isToolbar ? toolbar_group/* default */.A : toolbar_dropdown_menu;
  const commonProps = {
    icon: activeAlignmentControl ? activeAlignmentControl.icon : defaultAlignmentControl.icon,
    label: (0,i18n_build_module.__)('Align')
  };
  const extraProps = isToolbar ? {
    isCollapsed,
    controls: enabledControls.map(({
      name: controlName
    }) => {
      return {
        ...constants_BLOCK_ALIGNMENTS_CONTROLS[controlName],
        isActive: value === controlName || !value && controlName === 'none',
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: () => onChangeAlignment(controlName)
      };
    })
  } : {
    toggleProps: {
      describedBy: (0,i18n_build_module.__)('Change alignment')
    },
    children: ({
      onClose
    }) => {
      return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
          className: "block-editor-block-alignment-control__menu-group",
          children: enabledControls.map(({
            name: controlName,
            info
          }) => {
            const {
              icon,
              title
            } = constants_BLOCK_ALIGNMENTS_CONTROLS[controlName];
            // If no value is provided, mark as selected the `none` option.
            const isSelected = controlName === value || !value && controlName === 'none';
            return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
              icon: icon,
              iconPosition: "left",
              className: (0,dist_clsx/* default */.A)('components-dropdown-menu__menu-item', {
                'is-active': isSelected
              }),
              isSelected: isSelected,
              onClick: () => {
                onChangeAlignment(controlName);
                onClose();
              },
              role: "menuitemradio",
              info: info,
              children: title
            }, controlName);
          })
        })
      });
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(UIComponent, {
    ...commonProps,
    ...extraProps
  });
}
/* harmony default export */ const block_alignment_control_ui = (ui_BlockAlignmentUI);
//# sourceMappingURL=ui.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/index.js
/**
 * Internal dependencies
 */


const BlockAlignmentControl = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(block_alignment_control_ui, {
    ...props,
    isToolbar: false
  });
};
const BlockAlignmentToolbar = props => {
  return /*#__PURE__*/_jsx(BlockAlignmentUI, {
    ...props,
    isToolbar: true
  });
};

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-alignment-control/README.md
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-editing-mode/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * @typedef {'disabled'|'contentOnly'|'default'} BlockEditingMode
 */

/**
 * Allows a block to restrict the user interface that is displayed for editing
 * that block and its inner blocks.
 *
 * @example
 * ```js
 * function MyBlock( { attributes, setAttributes } ) {
 *     useBlockEditingMode( 'disabled' );
 *     return <div { ...useBlockProps() }></div>;
 * }
 * ```
 *
 * `mode` can be one of three options:
 *
 * - `'disabled'`: Prevents editing the block entirely, i.e. it cannot be
 *   selected.
 * - `'contentOnly'`: Hides all non-content UI, e.g. auxiliary controls in the
 *   toolbar, the block movers, block settings.
 * - `'default'`: Allows editing the block as normal.
 *
 * The mode is inherited by all of the block's inner blocks, unless they have
 * their own mode.
 *
 * If called outside of a block context, the mode is applied to all blocks.
 *
 * @param {?BlockEditingMode} mode The editing mode to apply. If undefined, the
 *                                 current editing mode is not changed.
 *
 * @return {BlockEditingMode} The current editing mode.
 */
function useBlockEditingMode(mode) {
  const context = context_useBlockEditContext();
  const {
    clientId = ''
  } = context;
  const {
    setBlockEditingMode,
    unsetBlockEditingMode
  } = (0,use_dispatch/* default */.A)(store_store);
  const globalBlockEditingMode = (0,use_select/* default */.A)(select =>
  // Avoid adding the subscription if not needed!
  clientId ? null : select(store_store).getBlockEditingMode(), [clientId]);
  (0,react.useEffect)(() => {
    if (mode) {
      setBlockEditingMode(clientId, mode);
    }
    return () => {
      if (mode) {
        unsetBlockEditingMode(clientId);
      }
    };
  }, [clientId, mode, setBlockEditingMode, unsetBlockEditingMode]);
  return clientId ? context[blockEditingModeKey] : globalBlockEditingMode;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/align.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




/**
 * An array which includes all possible valid alignments,
 * used to validate if an alignment is valid or not.
 *
 * @constant
 * @type {string[]}
 */

const ALL_ALIGNMENTS = ['left', 'center', 'right', 'wide', 'full'];

/**
 * An array which includes all wide alignments.
 * In order for this alignments to be valid they need to be supported by the block,
 * and by the theme.
 *
 * @constant
 * @type {string[]}
 */
const WIDE_ALIGNMENTS = ['wide', 'full'];

/**
 * Returns the valid alignments.
 * Takes into consideration the aligns supported by a block, if the block supports wide controls or not and if theme supports wide controls or not.
 * Exported just for testing purposes, not exported outside the module.
 *
 * @param {?boolean|string[]} blockAlign          Aligns supported by the block.
 * @param {?boolean}          hasWideBlockSupport True if block supports wide alignments. And False otherwise.
 * @param {?boolean}          hasWideEnabled      True if theme supports wide alignments. And False otherwise.
 *
 * @return {string[]} Valid alignments.
 */
function getValidAlignments(blockAlign, hasWideBlockSupport = true, hasWideEnabled = true) {
  let validAlignments;
  if (Array.isArray(blockAlign)) {
    validAlignments = ALL_ALIGNMENTS.filter(value => blockAlign.includes(value));
  } else if (blockAlign === true) {
    // `true` includes all alignments...
    validAlignments = [...ALL_ALIGNMENTS];
  } else {
    validAlignments = [];
  }
  if (!hasWideEnabled || blockAlign === true && !hasWideBlockSupport) {
    return validAlignments.filter(alignment => !WIDE_ALIGNMENTS.includes(alignment));
  }
  return validAlignments;
}

/**
 * Filters registered block settings, extending attributes to include `align`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function addAttribute(settings) {
  var _settings$attributes$;
  // Allow blocks to specify their own attribute definition with default values if needed.
  if ('type' in ((_settings$attributes$ = settings.attributes?.align) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  }
  if ((0,build_module/* hasBlockSupport */.pN)(settings, 'align')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = {
      ...settings.attributes,
      align: {
        type: 'string',
        // Allow for '' since it is used by the `updateAlignment` function
        // in toolbar controls for special cases with defined default values.
        enum: [...ALL_ALIGNMENTS, '']
      }
    };
  }
  return settings;
}
function BlockEditAlignmentToolbarControlsPure({
  name: blockName,
  align,
  setAttributes
}) {
  // Compute the block valid alignments by taking into account,
  // if the theme supports wide alignments or not and the layout's
  // available alignments. We do that for conditionally rendering
  // Slot.
  const blockAllowedAlignments = getValidAlignments((0,build_module/* getBlockSupport */.bI)(blockName, 'align'), (0,build_module/* hasBlockSupport */.pN)(blockName, 'alignWide', true));
  const validAlignments = useAvailableAlignments(blockAllowedAlignments).map(({
    name
  }) => name);
  const blockEditingMode = useBlockEditingMode();
  if (!validAlignments.length || blockEditingMode !== 'default') {
    return null;
  }
  const updateAlignment = nextAlign => {
    if (!nextAlign) {
      const blockType = (0,build_module/* getBlockType */.E7)(blockName);
      const blockDefaultAlign = blockType?.attributes?.align?.default;
      if (blockDefaultAlign) {
        nextAlign = '';
      }
    }
    setAttributes({
      align: nextAlign
    });
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(block_controls, {
    group: "block",
    __experimentalShareWithChildBlocks: true,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(BlockAlignmentControl, {
      value: align,
      onChange: updateAlignment,
      controls: validAlignments
    })
  });
}
/* harmony default export */ const align = ({
  shareWithChildBlocks: true,
  edit: BlockEditAlignmentToolbarControlsPure,
  useBlockProps,
  addSaveProps: addAssignedAlign,
  attributeKeys: ['align'],
  hasSupport(name) {
    return (0,build_module/* hasBlockSupport */.pN)(name, 'align', false);
  }
});
function useBlockProps({
  name,
  align
}) {
  const blockAllowedAlignments = getValidAlignments((0,build_module/* getBlockSupport */.bI)(name, 'align'), (0,build_module/* hasBlockSupport */.pN)(name, 'alignWide', true));
  const validAlignments = useAvailableAlignments(blockAllowedAlignments);
  if (validAlignments.some(alignment => alignment.name === align)) {
    return {
      'data-align': align
    };
  }
  return {};
}

/**
 * Override props assigned to save component to inject alignment class name if
 * block supports it.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */
function addAssignedAlign(props, blockType, attributes) {
  const {
    align
  } = attributes;
  const blockAlign = (0,build_module/* getBlockSupport */.bI)(blockType, 'align');
  const hasWideBlockSupport = (0,build_module/* hasBlockSupport */.pN)(blockType, 'alignWide', true);

  // Compute valid alignments without taking into account if
  // the theme supports wide alignments or not.
  // This way changing themes does not impact the block save.
  const isAlignValid = getValidAlignments(blockAlign, hasWideBlockSupport).includes(align);
  if (isAlignValid) {
    props.className = (0,dist_clsx/* default */.A)(`align${align}`, props.className);
  }
  return props;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/editor/align/addAttribute', addAttribute);
//# sourceMappingURL=align.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tools-panel/context.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

const context_noop = () => undefined;
const ToolsPanelContext = (0,react.createContext)({
  menuItems: {
    default: {},
    optional: {}
  },
  hasMenuItems: false,
  isResetting: false,
  shouldRenderPlaceholderItems: false,
  registerPanelItem: context_noop,
  deregisterPanelItem: context_noop,
  flagItemCustomization: context_noop,
  registerResetAllFilter: context_noop,
  deregisterResetAllFilter: context_noop,
  areAllOptionalControlsHidden: true
});
const useToolsPanelContext = () => (0,react.useContext)(ToolsPanelContext);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/groups.js
/**
 * WordPress dependencies
 */

const InspectorControlsDefault = (0,slot_fill/* createSlotFill */.QJ)('InspectorControls');
const InspectorControlsAdvanced = (0,slot_fill/* createSlotFill */.QJ)('InspectorAdvancedControls');
const InspectorControlsBackground = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsBackground');
const InspectorControlsBorder = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsBorder');
const InspectorControlsColor = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsColor');
const InspectorControlsFilter = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsFilter');
const InspectorControlsDimensions = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsDimensions');
const InspectorControlsPosition = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsPosition');
const InspectorControlsTypography = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsTypography');
const InspectorControlsListView = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsListView');
const InspectorControlsStyles = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsStyles');
const InspectorControlsEffects = (0,slot_fill/* createSlotFill */.QJ)('InspectorControlsEffects');
const groups_groups = {
  default: InspectorControlsDefault,
  advanced: InspectorControlsAdvanced,
  background: InspectorControlsBackground,
  border: InspectorControlsBorder,
  color: InspectorControlsColor,
  dimensions: InspectorControlsDimensions,
  effects: InspectorControlsEffects,
  filter: InspectorControlsFilter,
  list: InspectorControlsListView,
  position: InspectorControlsPosition,
  settings: InspectorControlsDefault,
  // Alias for default.
  styles: InspectorControlsStyles,
  typography: InspectorControlsTypography
};
/* harmony default export */ const inspector_controls_groups = (groups_groups);
//# sourceMappingURL=groups.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/fill.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



function InspectorControlsFill({
  children,
  group = 'default',
  __experimentalGroup,
  resetAllFilter
}) {
  if (__experimentalGroup) {
    (0,deprecated_build_module/* default */.A)('`__experimentalGroup` property in `InspectorControlsFill`', {
      since: '6.2',
      version: '6.4',
      alternative: '`group`'
    });
    group = __experimentalGroup;
  }
  const context = context_useBlockEditContext();
  const Fill = inspector_controls_groups[group]?.Fill;
  if (!Fill) {
    globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)(`Unknown InspectorControls group "${group}" provided.`) : void 0;
    return null;
  }
  if (!context[mayDisplayControlsKey]) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(style_provider/* default */.A, {
    document: document,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Fill, {
      children: fillProps => {
        return /*#__PURE__*/(0,jsx_runtime.jsx)(ToolsPanelInspectorControl, {
          fillProps: fillProps,
          children: children,
          resetAllFilter: resetAllFilter
        });
      }
    })
  });
}
function RegisterResetAll({
  resetAllFilter,
  children
}) {
  const {
    registerResetAllFilter,
    deregisterResetAllFilter
  } = (0,react.useContext)(ToolsPanelContext);
  (0,react.useEffect)(() => {
    if (resetAllFilter && registerResetAllFilter && deregisterResetAllFilter) {
      registerResetAllFilter(resetAllFilter);
      return () => {
        deregisterResetAllFilter(resetAllFilter);
      };
    }
  }, [resetAllFilter, registerResetAllFilter, deregisterResetAllFilter]);
  return children;
}
function ToolsPanelInspectorControl({
  children,
  resetAllFilter,
  fillProps
}) {
  // `fillProps.forwardedContext` is an array of context provider entries, provided by slot,
  // that should wrap the fill markup.
  const {
    forwardedContext = []
  } = fillProps;

  // Children passed to InspectorControlsFill will not have
  // access to any React Context whose Provider is part of
  // the InspectorControlsSlot tree. So we re-create the
  // Provider in this subtree.
  const innerMarkup = /*#__PURE__*/(0,jsx_runtime.jsx)(RegisterResetAll, {
    resetAllFilter: resetAllFilter,
    children: children
  });
  return forwardedContext.reduce((inner, [Provider, props]) => /*#__PURE__*/(0,jsx_runtime.jsx)(Provider, {
    ...props,
    children: inner
  }), innerMarkup);
}
//# sourceMappingURL=fill.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
var MotionContext = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/MotionContext/index.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/plus.js
var plus = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/plus.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/more-vertical.js
var more_vertical = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/more-vertical.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/h-stack/component.js
var h_stack_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/h-stack/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/heading/component.js + 1 modules
var heading_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/heading/component.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tools-panel/styles.js

function tools_panel_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */



/**
 * Internal dependencies
 */




const toolsPanelGrid = {
  columns: columns => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("grid-template-columns:", `repeat( ${columns}, minmax(0, 1fr) )`, ";" + ( true ? "" : 0),  true ? "" : 0),
  spacing: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("column-gap:", (0,space/* space */.x)(2), ";row-gap:", (0,space/* space */.x)(4), ";" + ( true ? "" : 0),  true ? "" : 0),
  item: {
    fullWidth:  true ? {
      name: "18iuzk9",
      styles: "grid-column:1/-1"
    } : 0
  }
};
const ToolsPanel = columns => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(toolsPanelGrid.columns(columns), " ", toolsPanelGrid.spacing, " border-top:", config_values/* default */.A.borderWidth, " solid ", colors_values/* COLORS */.l.gray[300], ";margin-top:-1px;padding:", (0,space/* space */.x)(4), ";" + ( true ? "" : 0),  true ? "" : 0);

/**
 * Items injected into a ToolsPanel via a virtual bubbling slot will require
 * an inner dom element to be injected. The following rule allows for the
 * CSS grid display to be re-established.
 */

const ToolsPanelWithInnerWrapper = columns => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(">div:not( :first-of-type ){display:grid;", toolsPanelGrid.columns(columns), " ", toolsPanelGrid.spacing, " ", toolsPanelGrid.item.fullWidth, ";}" + ( true ? "" : 0),  true ? "" : 0);
};
const ToolsPanelHiddenInnerWrapper =  true ? {
  name: "huufmu",
  styles: ">div:not( :first-of-type ){display:none;}"
} : 0;
const ToolsPanelHeader = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(toolsPanelGrid.item.fullWidth, " gap:", (0,space/* space */.x)(2), ";.components-dropdown-menu{margin:", (0,space/* space */.x)(-1), " 0;line-height:0;}&&&& .components-dropdown-menu__toggle{padding:0;min-width:", (0,space/* space */.x)(6), ";}" + ( true ? "" : 0),  true ? "" : 0);
const ToolsPanelHeading =  true ? {
  name: "1pmxm02",
  styles: "font-size:inherit;font-weight:500;line-height:normal;&&{margin:0;}"
} : 0;
const ToolsPanelItem = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(toolsPanelGrid.item.fullWidth, "&>div,&>fieldset{padding-bottom:0;margin-bottom:0;max-width:100%;}&& ", base_control_styles/* Wrapper */.mO, "{margin-bottom:0;", base_control_styles/* StyledField */.mh, ":last-child{margin-bottom:0;}}", base_control_styles/* StyledHelp */.te, "{margin-bottom:0;}&& ", input_control_styles/* LabelWrapper */.cR, "{label{line-height:1.4em;}}" + ( true ? "" : 0),  true ? "" : 0);
const ToolsPanelItemPlaceholder =  true ? {
  name: "eivff4",
  styles: "display:none"
} : 0;
const styles_DropdownMenu =  true ? {
  name: "16gsvie",
  styles: "min-width:200px"
} : 0;
const ResetLabel = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "ews648u0"
} : 0)("color:", colors_values/* COLORS */.l.theme.accentDarker10, ";font-size:11px;font-weight:500;line-height:1.4;", (0,rtl/* rtl */.h)({
  marginLeft: (0,space/* space */.x)(3)
}), " text-transform:uppercase;" + ( true ? "" : 0));
const DefaultControlsItem = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("color:", colors_values/* COLORS */.l.gray[900], ";&&[aria-disabled='true']{color:", colors_values/* COLORS */.l.gray[700], ";opacity:1;&:hover{color:", colors_values/* COLORS */.l.gray[700], ";}", ResetLabel, "{opacity:0.3;}}" + ( true ? "" : 0),  true ? "" : 0);
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tools-panel/tools-panel-header/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function useToolsPanelHeader(props) {
  const {
    className,
    headingLevel = 2,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'ToolsPanelHeader');
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    return cx(ToolsPanelHeader, className);
  }, [className, cx]);
  const dropdownMenuClassName = (0,react.useMemo)(() => {
    return cx(styles_DropdownMenu);
  }, [cx]);
  const headingClassName = (0,react.useMemo)(() => {
    return cx(ToolsPanelHeading);
  }, [cx]);
  const defaultControlsItemClassName = (0,react.useMemo)(() => {
    return cx(DefaultControlsItem);
  }, [cx]);
  const {
    menuItems,
    hasMenuItems,
    areAllOptionalControlsHidden
  } = useToolsPanelContext();
  return {
    ...otherProps,
    areAllOptionalControlsHidden,
    defaultControlsItemClassName,
    dropdownMenuClassName,
    hasMenuItems,
    headingClassName,
    headingLevel,
    menuItems,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tools-panel/tools-panel-header/component.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */











const DefaultControlsGroup = ({
  itemClassName,
  items,
  toggleItem
}) => {
  if (!items.length) {
    return null;
  }
  const resetSuffix = /*#__PURE__*/(0,jsx_runtime.jsx)(ResetLabel, {
    "aria-hidden": true,
    children: (0,i18n_build_module.__)('Reset')
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: items.map(([label, hasValue]) => {
      if (hasValue) {
        return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
          className: itemClassName,
          role: "menuitem",
          label: (0,i18n_build_module/* sprintf */.nv)(
          // translators: %s: The name of the control being reset e.g. "Padding".
          (0,i18n_build_module.__)('Reset %s'), label),
          onClick: () => {
            toggleItem(label);
            (0,a11y_build_module/* speak */.L)((0,i18n_build_module/* sprintf */.nv)(
            // translators: %s: The name of the control being reset e.g. "Padding".
            (0,i18n_build_module.__)('%s reset to default'), label), 'assertive');
          },
          suffix: resetSuffix,
          children: label
        }, label);
      }
      return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
        icon: check/* default */.A,
        className: itemClassName,
        role: "menuitemcheckbox",
        isSelected: true,
        "aria-disabled": true,
        children: label
      }, label);
    })
  });
};
const OptionalControlsGroup = ({
  items,
  toggleItem
}) => {
  if (!items.length) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: items.map(([label, isSelected]) => {
      const itemLabel = isSelected ? (0,i18n_build_module/* sprintf */.nv)(
      // translators: %s: The name of the control being hidden and reset e.g. "Padding".
      (0,i18n_build_module.__)('Hide and reset %s'), label) : (0,i18n_build_module/* sprintf */.nv)(
      // translators: %s: The name of the control to display e.g. "Padding".
      (0,i18n_build_module.__)('Show %s'), label);
      return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
        icon: isSelected ? check/* default */.A : null,
        isSelected: isSelected,
        label: itemLabel,
        onClick: () => {
          if (isSelected) {
            (0,a11y_build_module/* speak */.L)((0,i18n_build_module/* sprintf */.nv)(
            // translators: %s: The name of the control being reset e.g. "Padding".
            (0,i18n_build_module.__)('%s hidden and reset to default'), label), 'assertive');
          } else {
            (0,a11y_build_module/* speak */.L)((0,i18n_build_module/* sprintf */.nv)(
            // translators: %s: The name of the control being reset e.g. "Padding".
            (0,i18n_build_module.__)('%s is now visible'), label), 'assertive');
          }
          toggleItem(label);
        },
        role: "menuitemcheckbox",
        children: label
      }, label);
    })
  });
};
const component_ToolsPanelHeader = (props, forwardedRef) => {
  const {
    areAllOptionalControlsHidden,
    defaultControlsItemClassName,
    dropdownMenuClassName,
    hasMenuItems,
    headingClassName,
    headingLevel = 2,
    label: labelText,
    menuItems,
    resetAll,
    toggleItem,
    dropdownMenuProps,
    ...headerProps
  } = useToolsPanelHeader(props);
  if (!labelText) {
    return null;
  }
  const defaultItems = Object.entries(menuItems?.default || {});
  const optionalItems = Object.entries(menuItems?.optional || {});
  const dropDownMenuIcon = areAllOptionalControlsHidden ? plus/* default */.A : more_vertical/* default */.A;
  const dropDownMenuLabelText = (0,i18n_build_module/* sprintf */.nv)(
  // translators: %s: The name of the tool e.g. "Color" or "Typography".
  (0,i18n_build_module._x)('%s options', 'Button label to reveal tool panel options'), labelText);
  const dropdownMenuDescriptionText = areAllOptionalControlsHidden ? (0,i18n_build_module.__)('All options are currently hidden') : undefined;
  const canResetAll = [...defaultItems, ...optionalItems].some(([, isSelected]) => isSelected);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
    ...headerProps,
    ref: forwardedRef,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(heading_component/* default */.A, {
      level: headingLevel,
      className: headingClassName,
      children: labelText
    }), hasMenuItems && /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_menu/* default */.A, {
      ...dropdownMenuProps,
      icon: dropDownMenuIcon,
      label: dropDownMenuLabelText,
      menuProps: {
        className: dropdownMenuClassName
      },
      toggleProps: {
        size: 'small',
        describedBy: dropdownMenuDescriptionText
      },
      children: () => /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(menu_group/* default */.A, {
          label: labelText,
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(DefaultControlsGroup, {
            items: defaultItems,
            toggleItem: toggleItem,
            itemClassName: defaultControlsItemClassName
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(OptionalControlsGroup, {
            items: optionalItems,
            toggleItem: toggleItem
          })]
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
            "aria-disabled": !canResetAll
            // @ts-expect-error - TODO: If this "tertiary" style is something we really want to allow on MenuItem,
            // we should rename it and explicitly allow it as an official API. All the other Button variants
            // don't make sense in a MenuItem context, and should be disallowed.
            ,
            variant: "tertiary",
            onClick: () => {
              if (canResetAll) {
                resetAll();
                (0,a11y_build_module/* speak */.L)((0,i18n_build_module.__)('All options reset'), 'assertive');
              }
            },
            children: (0,i18n_build_module.__)('Reset all')
          })
        })]
      })
    })]
  });
};
const ConnectedToolsPanelHeader = (0,context_connect/* contextConnect */.KZ)(component_ToolsPanelHeader, 'ToolsPanelHeader');
/* harmony default export */ const tools_panel_header_component = (ConnectedToolsPanelHeader);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tools-panel/tools-panel/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const DEFAULT_COLUMNS = 2;
const generateMenuItems = ({
  panelItems,
  shouldReset,
  currentMenuItems,
  menuItemOrder
}) => {
  const newMenuItems = {
    default: {},
    optional: {}
  };
  const menuItems = {
    default: {},
    optional: {}
  };
  panelItems.forEach(({
    hasValue,
    isShownByDefault,
    label
  }) => {
    const group = isShownByDefault ? 'default' : 'optional';

    // If a menu item for this label has already been flagged as customized
    // (for default controls), or toggled on (for optional controls), do not
    // overwrite its value as those controls would lose that state.
    const existingItemValue = currentMenuItems?.[group]?.[label];
    const value = existingItemValue ? existingItemValue : hasValue();
    newMenuItems[group][label] = shouldReset ? false : value;
  });

  // Loop the known, previously registered items first to maintain menu order.
  menuItemOrder.forEach(key => {
    if (newMenuItems.default.hasOwnProperty(key)) {
      menuItems.default[key] = newMenuItems.default[key];
    }
    if (newMenuItems.optional.hasOwnProperty(key)) {
      menuItems.optional[key] = newMenuItems.optional[key];
    }
  });

  // Loop newMenuItems object adding any that aren't in the known items order.
  Object.keys(newMenuItems.default).forEach(key => {
    if (!menuItems.default.hasOwnProperty(key)) {
      menuItems.default[key] = newMenuItems.default[key];
    }
  });
  Object.keys(newMenuItems.optional).forEach(key => {
    if (!menuItems.optional.hasOwnProperty(key)) {
      menuItems.optional[key] = newMenuItems.optional[key];
    }
  });
  return menuItems;
};
const isMenuItemTypeEmpty = obj => obj && Object.keys(obj).length === 0;
function useToolsPanel(props) {
  const {
    className,
    headingLevel = 2,
    resetAll,
    panelId,
    hasInnerWrapper = false,
    shouldRenderPlaceholderItems = false,
    __experimentalFirstVisibleItemClass,
    __experimentalLastVisibleItemClass,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'ToolsPanel');
  const isResetting = (0,react.useRef)(false);
  const wasResetting = isResetting.current;

  // `isResetting` is cleared via this hook to effectively batch together
  // the resetAll task. Without this, the flag is cleared after the first
  // control updates and forces a rerender with subsequent controls then
  // believing they need to reset, unfortunately using stale data.
  (0,react.useEffect)(() => {
    if (wasResetting) {
      isResetting.current = false;
    }
  }, [wasResetting]);

  // Allow panel items to register themselves.
  const [panelItems, setPanelItems] = (0,react.useState)([]);
  const [menuItemOrder, setMenuItemOrder] = (0,react.useState)([]);
  const [resetAllFilters, setResetAllFilters] = (0,react.useState)([]);
  const registerPanelItem = (0,react.useCallback)(item => {
    // Add item to panel items.
    setPanelItems(items => {
      const newItems = [...items];
      // If an item with this label has already been registered, remove it
      // first. This can happen when an item is moved between the default
      // and optional groups.
      const existingIndex = newItems.findIndex(oldItem => oldItem.label === item.label);
      if (existingIndex !== -1) {
        newItems.splice(existingIndex, 1);
      }
      return [...newItems, item];
    });

    // Track the initial order of item registration. This is used for
    // maintaining menu item order later.
    setMenuItemOrder(items => {
      if (items.includes(item.label)) {
        return items;
      }
      return [...items, item.label];
    });
  }, [setPanelItems, setMenuItemOrder]);

  // Panels need to deregister on unmount to avoid orphans in menu state.
  // This is an issue when panel items are being injected via SlotFills.
  const deregisterPanelItem = (0,react.useCallback)(label => {
    // When switching selections between components injecting matching
    // controls, e.g. both panels have a "padding" control, the
    // deregistration of the first panel doesn't occur until after the
    // registration of the next.
    setPanelItems(items => {
      const newItems = [...items];
      const index = newItems.findIndex(item => item.label === label);
      if (index !== -1) {
        newItems.splice(index, 1);
      }
      return newItems;
    });
  }, [setPanelItems]);
  const registerResetAllFilter = (0,react.useCallback)(newFilter => {
    setResetAllFilters(filters => {
      return [...filters, newFilter];
    });
  }, [setResetAllFilters]);
  const deregisterResetAllFilter = (0,react.useCallback)(filterToRemove => {
    setResetAllFilters(filters => {
      return filters.filter(filter => filter !== filterToRemove);
    });
  }, [setResetAllFilters]);

  // Manage and share display state of menu items representing child controls.
  const [menuItems, setMenuItems] = (0,react.useState)({
    default: {},
    optional: {}
  });

  // Setup menuItems state as panel items register themselves.
  (0,react.useEffect)(() => {
    setMenuItems(prevState => {
      const items = generateMenuItems({
        panelItems,
        shouldReset: false,
        currentMenuItems: prevState,
        menuItemOrder
      });
      return items;
    });
  }, [panelItems, setMenuItems, menuItemOrder]);

  // Updates the status of the panel’s menu items. For default items the
  // value represents whether it differs from the default and for optional
  // items whether the item is shown.
  const flagItemCustomization = (0,react.useCallback)((value, label, group = 'default') => {
    setMenuItems(items => {
      const newState = {
        ...items,
        [group]: {
          ...items[group],
          [label]: value
        }
      };
      return newState;
    });
  }, [setMenuItems]);

  // Whether all optional menu items are hidden or not must be tracked
  // in order to later determine if the panel display is empty and handle
  // conditional display of a plus icon to indicate the presence of further
  // menu items.
  const [areAllOptionalControlsHidden, setAreAllOptionalControlsHidden] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    if (isMenuItemTypeEmpty(menuItems?.default) && !isMenuItemTypeEmpty(menuItems?.optional)) {
      const allControlsHidden = !Object.entries(menuItems.optional).some(([, isSelected]) => isSelected);
      setAreAllOptionalControlsHidden(allControlsHidden);
    }
  }, [menuItems, setAreAllOptionalControlsHidden]);
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    const wrapperStyle = hasInnerWrapper && ToolsPanelWithInnerWrapper(DEFAULT_COLUMNS);
    const emptyStyle = isMenuItemTypeEmpty(menuItems?.default) && areAllOptionalControlsHidden && ToolsPanelHiddenInnerWrapper;
    return cx(ToolsPanel(DEFAULT_COLUMNS), wrapperStyle, emptyStyle, className);
  }, [areAllOptionalControlsHidden, className, cx, hasInnerWrapper, menuItems]);

  // Toggle the checked state of a menu item which is then used to determine
  // display of the item within the panel.
  const toggleItem = (0,react.useCallback)(label => {
    const currentItem = panelItems.find(item => item.label === label);
    if (!currentItem) {
      return;
    }
    const menuGroup = currentItem.isShownByDefault ? 'default' : 'optional';
    const newMenuItems = {
      ...menuItems,
      [menuGroup]: {
        ...menuItems[menuGroup],
        [label]: !menuItems[menuGroup][label]
      }
    };
    setMenuItems(newMenuItems);
  }, [menuItems, panelItems, setMenuItems]);

  // Resets display of children and executes resetAll callback if available.
  const resetAllItems = (0,react.useCallback)(() => {
    if (typeof resetAll === 'function') {
      isResetting.current = true;
      resetAll(resetAllFilters);
    }

    // Turn off display of all non-default items.
    const resetMenuItems = generateMenuItems({
      panelItems,
      menuItemOrder,
      shouldReset: true
    });
    setMenuItems(resetMenuItems);
  }, [panelItems, resetAllFilters, resetAll, setMenuItems, menuItemOrder]);

  // Assist ItemGroup styling when there are potentially hidden placeholder
  // items by identifying first & last items that are toggled on for display.
  const getFirstVisibleItemLabel = items => {
    const optionalItems = menuItems.optional || {};
    const firstItem = items.find(item => item.isShownByDefault || !!optionalItems[item.label]);
    return firstItem?.label;
  };
  const firstDisplayedItem = getFirstVisibleItemLabel(panelItems);
  const lastDisplayedItem = getFirstVisibleItemLabel([...panelItems].reverse());
  const panelContext = (0,react.useMemo)(() => ({
    areAllOptionalControlsHidden,
    deregisterPanelItem,
    deregisterResetAllFilter,
    firstDisplayedItem,
    flagItemCustomization,
    hasMenuItems: !!panelItems.length,
    isResetting: isResetting.current,
    lastDisplayedItem,
    menuItems,
    panelId,
    registerPanelItem,
    registerResetAllFilter,
    shouldRenderPlaceholderItems,
    __experimentalFirstVisibleItemClass,
    __experimentalLastVisibleItemClass
  }), [areAllOptionalControlsHidden, deregisterPanelItem, deregisterResetAllFilter, firstDisplayedItem, flagItemCustomization, lastDisplayedItem, menuItems, panelId, panelItems, registerResetAllFilter, registerPanelItem, shouldRenderPlaceholderItems, __experimentalFirstVisibleItemClass, __experimentalLastVisibleItemClass]);
  return {
    ...otherProps,
    headingLevel,
    panelContext,
    resetAllItems,
    toggleItem,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/grid/utils.js
/**
 * External dependencies
 */

const ALIGNMENTS = {
  bottom: {
    alignItems: 'flex-end',
    justifyContent: 'center'
  },
  bottomLeft: {
    alignItems: 'flex-start',
    justifyContent: 'flex-end'
  },
  bottomRight: {
    alignItems: 'flex-end',
    justifyContent: 'flex-end'
  },
  center: {
    alignItems: 'center',
    justifyContent: 'center'
  },
  spaced: {
    alignItems: 'center',
    justifyContent: 'space-between'
  },
  left: {
    alignItems: 'center',
    justifyContent: 'flex-start'
  },
  right: {
    alignItems: 'center',
    justifyContent: 'flex-end'
  },
  stretch: {
    alignItems: 'stretch'
  },
  top: {
    alignItems: 'flex-start',
    justifyContent: 'center'
  },
  topLeft: {
    alignItems: 'flex-start',
    justifyContent: 'flex-start'
  },
  topRight: {
    alignItems: 'flex-start',
    justifyContent: 'flex-end'
  }
};
function getAlignmentProps(alignment) {
  const alignmentProps = alignment ? ALIGNMENTS[alignment] : {};
  return alignmentProps;
}
//# sourceMappingURL=utils.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/use-responsive-value.js
var use_responsive_value = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/use-responsive-value.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/grid/hook.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






function useGrid(props) {
  const {
    align,
    alignment,
    className,
    columnGap,
    columns = 2,
    gap = 3,
    isInline = false,
    justify,
    rowGap,
    rows,
    templateColumns,
    templateRows,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'Grid');
  const columnsAsArray = Array.isArray(columns) ? columns : [columns];
  const column = (0,use_responsive_value/* useResponsiveValue */.t)(columnsAsArray);
  const rowsAsArray = Array.isArray(rows) ? rows : [rows];
  const row = (0,use_responsive_value/* useResponsiveValue */.t)(rowsAsArray);
  const gridTemplateColumns = templateColumns || !!columns && `repeat( ${column}, 1fr )`;
  const gridTemplateRows = templateRows || !!rows && `repeat( ${row}, 1fr )`;
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    const alignmentProps = getAlignmentProps(alignment);
    const gridClasses = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
      alignItems: align,
      display: isInline ? 'inline-grid' : 'grid',
      gap: `calc( ${config_values/* default */.A.gridBase} * ${gap} )`,
      gridTemplateColumns: gridTemplateColumns || undefined,
      gridTemplateRows: gridTemplateRows || undefined,
      gridRowGap: rowGap,
      gridColumnGap: columnGap,
      justifyContent: justify,
      verticalAlign: isInline ? 'middle' : undefined,
      ...alignmentProps
    },  true ? "" : 0,  true ? "" : 0);
    return cx(gridClasses, className);
  }, [align, alignment, className, columnGap, cx, gap, gridTemplateColumns, gridTemplateRows, isInline, justify, rowGap]);
  return {
    ...otherProps,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/grid/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function UnconnectedGrid(props, forwardedRef) {
  const gridProps = useGrid(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
    ...gridProps,
    ref: forwardedRef
  });
}

/**
 * `Grid` is a primitive layout component that can arrange content in a grid configuration.
 *
 * ```jsx
 * import {
 * 	__experimentalGrid as Grid,
 * 	__experimentalText as Text
 * } from `@wordpress/components`;
 *
 * function Example() {
 * 	return (
 * 		<Grid columns={ 3 }>
 * 			<Text>Code</Text>
 * 			<Text>is</Text>
 * 			<Text>Poetry</Text>
 * 		</Grid>
 * 	);
 * }
 * ```
 */
const Grid = (0,context_connect/* contextConnect */.KZ)(UnconnectedGrid, 'Grid');
/* harmony default export */ const grid_component = (Grid);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tools-panel/tools-panel/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */







const UnconnectedToolsPanel = (props, forwardedRef) => {
  const {
    children,
    label,
    panelContext,
    resetAllItems,
    toggleItem,
    headingLevel,
    dropdownMenuProps,
    ...toolsPanelProps
  } = useToolsPanel(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(grid_component, {
    ...toolsPanelProps,
    columns: 2,
    ref: forwardedRef,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(ToolsPanelContext.Provider, {
      value: panelContext,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_header_component, {
        label: label,
        resetAll: resetAllItems,
        toggleItem: toggleItem,
        headingLevel: headingLevel,
        dropdownMenuProps: dropdownMenuProps
      }), children]
    })
  });
};

/**
 * The `ToolsPanel` is a container component that displays its children preceded
 * by a header. The header includes a dropdown menu which is automatically
 * generated from the panel's inner `ToolsPanelItems`.
 *
 * ```jsx
 * import { __ } from '@wordpress/i18n';
 * import {
 *   __experimentalToolsPanel as ToolsPanel,
 *   __experimentalToolsPanelItem as ToolsPanelItem,
 *   __experimentalUnitControl as UnitControl
 * } from '@wordpress/components';
 *
 * function Example() {
 *   const [ height, setHeight ] = useState();
 *   const [ width, setWidth ] = useState();
 *
 *   const resetAll = () => {
 *     setHeight();
 *     setWidth();
 *   }
 *
 *   return (
 *     <ToolsPanel label={ __( 'Dimensions' ) } resetAll={ resetAll }>
 *       <ToolsPanelItem
 *         hasValue={ () => !! height }
 *         label={ __( 'Height' ) }
 *         onDeselect={ () => setHeight() }
 *       >
 *         <UnitControl
 *           label={ __( 'Height' ) }
 *           onChange={ setHeight }
 *           value={ height }
 *         />
 *       </ToolsPanelItem>
 *       <ToolsPanelItem
 *         hasValue={ () => !! width }
 *         label={ __( 'Width' ) }
 *         onDeselect={ () => setWidth() }
 *       >
 *         <UnitControl
 *           label={ __( 'Width' ) }
 *           onChange={ setWidth }
 *           value={ width }
 *         />
 *       </ToolsPanelItem>
 *     </ToolsPanel>
 *   );
 * }
 * ```
 */
const component_ToolsPanel = (0,context_connect/* contextConnect */.KZ)(UnconnectedToolsPanel, 'ToolsPanel');
/* harmony default export */ const tools_panel_component = (component_ToolsPanel);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-viewport-match/index.js
var use_viewport_match = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-viewport-match/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/font-sizes/fluid-utils.js
/**
 * The fluid utilities must match the backend equivalent.
 * See: gutenberg_get_typography_font_size_value() in lib/block-supports/typography.php
 * ---------------------------------------------------------------
 */

// Defaults.
const DEFAULT_MAXIMUM_VIEWPORT_WIDTH = '1600px';
const DEFAULT_MINIMUM_VIEWPORT_WIDTH = '320px';
const DEFAULT_SCALE_FACTOR = 1;
const DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN = 0.25;
const DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX = 0.75;
const DEFAULT_MINIMUM_FONT_SIZE_LIMIT = '14px';

/**
 * Computes a fluid font-size value that uses clamp(). A minimum and maximum
 * font size OR a single font size can be specified.
 *
 * If a single font size is specified, it is scaled up and down using a logarithmic scale.
 *
 * @example
 * ```js
 * // Calculate fluid font-size value from a minimum and maximum value.
 * const fontSize = getComputedFluidTypographyValue( {
 *     minimumFontSize: '20px',
 *     maximumFontSize: '45px'
 * } );
 * // Calculate fluid font-size value from a single font size.
 * const fontSize = getComputedFluidTypographyValue( {
 *     fontSize: '30px',
 * } );
 * ```
 *
 * @param {Object}        args
 * @param {?string}       args.minimumViewportWidth Minimum viewport size from which type will have fluidity. Optional if fontSize is specified.
 * @param {?string}       args.maximumViewportWidth Maximum size up to which type will have fluidity. Optional if fontSize is specified.
 * @param {string|number} [args.fontSize]           Size to derive maximumFontSize and minimumFontSize from, if necessary. Optional if minimumFontSize and maximumFontSize are specified.
 * @param {?string}       args.maximumFontSize      Maximum font size for any clamp() calculation. Optional.
 * @param {?string}       args.minimumFontSize      Minimum font size for any clamp() calculation. Optional.
 * @param {?number}       args.scaleFactor          A scale factor to determine how fast a font scales within boundaries. Optional.
 * @param {?string}       args.minimumFontSizeLimit The smallest a calculated font size may be. Optional.
 *
 * @return {string|null} A font-size value using clamp().
 */
function getComputedFluidTypographyValue({
  minimumFontSize,
  maximumFontSize,
  fontSize,
  minimumViewportWidth = DEFAULT_MINIMUM_VIEWPORT_WIDTH,
  maximumViewportWidth = DEFAULT_MAXIMUM_VIEWPORT_WIDTH,
  scaleFactor = DEFAULT_SCALE_FACTOR,
  minimumFontSizeLimit
}) {
  // Validate incoming settings and set defaults.
  minimumFontSizeLimit = !!getTypographyValueAndUnit(minimumFontSizeLimit) ? minimumFontSizeLimit : DEFAULT_MINIMUM_FONT_SIZE_LIMIT;

  /*
   * Calculates missing minimumFontSize and maximumFontSize from
   * defaultFontSize if provided.
   */
  if (fontSize) {
    // Parses default font size.
    const fontSizeParsed = getTypographyValueAndUnit(fontSize);

    // Protect against invalid units.
    if (!fontSizeParsed?.unit) {
      return null;
    }

    // Parses the minimum font size limit, so we can perform checks using it.
    const minimumFontSizeLimitParsed = getTypographyValueAndUnit(minimumFontSizeLimit, {
      coerceTo: fontSizeParsed.unit
    });

    // Don't enforce minimum font size if a font size has explicitly set a min and max value.
    if (!!minimumFontSizeLimitParsed?.value && !minimumFontSize && !maximumFontSize) {
      /*
       * If a minimum size was not passed to this function
       * and the user-defined font size is lower than $minimum_font_size_limit,
       * do not calculate a fluid value.
       */
      if (fontSizeParsed?.value <= minimumFontSizeLimitParsed?.value) {
        return null;
      }
    }

    // If no fluid max font size is available use the incoming value.
    if (!maximumFontSize) {
      maximumFontSize = `${fontSizeParsed.value}${fontSizeParsed.unit}`;
    }

    /*
     * If no minimumFontSize is provided, create one using
     * the given font size multiplied by the min font size scale factor.
     */
    if (!minimumFontSize) {
      const fontSizeValueInPx = fontSizeParsed.unit === 'px' ? fontSizeParsed.value : fontSizeParsed.value * 16;

      /*
       * The scale factor is a multiplier that affects how quickly the curve will move towards the minimum,
       * that is, how quickly the size factor reaches 0 given increasing font size values.
       * For a - b * log2(), lower values of b will make the curve move towards the minimum faster.
       * The scale factor is constrained between min and max values.
       */
      const minimumFontSizeFactor = Math.min(Math.max(1 - 0.075 * Math.log2(fontSizeValueInPx), DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN), DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX);

      // Calculates the minimum font size.
      const calculatedMinimumFontSize = roundToPrecision(fontSizeParsed.value * minimumFontSizeFactor, 3);

      // Only use calculated min font size if it's > $minimum_font_size_limit value.
      if (!!minimumFontSizeLimitParsed?.value && calculatedMinimumFontSize < minimumFontSizeLimitParsed?.value) {
        minimumFontSize = `${minimumFontSizeLimitParsed.value}${minimumFontSizeLimitParsed.unit}`;
      } else {
        minimumFontSize = `${calculatedMinimumFontSize}${fontSizeParsed.unit}`;
      }
    }
  }

  // Grab the minimum font size and normalize it in order to use the value for calculations.
  const minimumFontSizeParsed = getTypographyValueAndUnit(minimumFontSize);

  // We get a 'preferred' unit to keep units consistent when calculating,
  // otherwise the result will not be accurate.
  const fontSizeUnit = minimumFontSizeParsed?.unit || 'rem';

  // Grabs the maximum font size and normalize it in order to use the value for calculations.
  const maximumFontSizeParsed = getTypographyValueAndUnit(maximumFontSize, {
    coerceTo: fontSizeUnit
  });

  // Checks for mandatory min and max sizes, and protects against unsupported units.
  if (!minimumFontSizeParsed || !maximumFontSizeParsed) {
    return null;
  }

  // Uses rem for accessible fluid target font scaling.
  const minimumFontSizeRem = getTypographyValueAndUnit(minimumFontSize, {
    coerceTo: 'rem'
  });

  // Viewport widths defined for fluid typography. Normalize units
  const maximumViewportWidthParsed = getTypographyValueAndUnit(maximumViewportWidth, {
    coerceTo: fontSizeUnit
  });
  const minimumViewportWidthParsed = getTypographyValueAndUnit(minimumViewportWidth, {
    coerceTo: fontSizeUnit
  });

  // Protect against unsupported units.
  if (!maximumViewportWidthParsed || !minimumViewportWidthParsed || !minimumFontSizeRem) {
    return null;
  }

  // Calculates the linear factor denominator. If it's 0, we cannot calculate a fluid value.
  const linearDenominator = maximumViewportWidthParsed.value - minimumViewportWidthParsed.value;
  if (!linearDenominator) {
    return null;
  }

  // Build CSS rule.
  // Borrowed from https://websemantics.uk/tools/responsive-font-calculator/.
  const minViewportWidthOffsetValue = roundToPrecision(minimumViewportWidthParsed.value / 100, 3);
  const viewportWidthOffset = roundToPrecision(minViewportWidthOffsetValue, 3) + fontSizeUnit;
  const linearFactor = 100 * ((maximumFontSizeParsed.value - minimumFontSizeParsed.value) / linearDenominator);
  const linearFactorScaled = roundToPrecision((linearFactor || 1) * scaleFactor, 3);
  const fluidTargetFontSize = `${minimumFontSizeRem.value}${minimumFontSizeRem.unit} + ((1vw - ${viewportWidthOffset}) * ${linearFactorScaled})`;
  return `clamp(${minimumFontSize}, ${fluidTargetFontSize}, ${maximumFontSize})`;
}

/**
 * Internal method that checks a string for a unit and value and returns an array consisting of `'value'` and `'unit'`, e.g., [ '42', 'rem' ].
 * A raw font size of `value + unit` is expected. If the value is an integer, it will convert to `value + 'px'`.
 *
 * @param {string|number}    rawValue Raw size value from theme.json.
 * @param {Object|undefined} options  Calculation options.
 *
 * @return {{ unit: string, value: number }|null} An object consisting of `'value'` and `'unit'` properties.
 */
function getTypographyValueAndUnit(rawValue, options = {}) {
  if (typeof rawValue !== 'string' && typeof rawValue !== 'number') {
    return null;
  }

  // Converts numeric values to pixel values by default.
  if (isFinite(rawValue)) {
    rawValue = `${rawValue}px`;
  }
  const {
    coerceTo,
    rootSizeValue,
    acceptableUnits
  } = {
    coerceTo: '',
    // Default browser font size. Later we could inject some JS to compute this `getComputedStyle( document.querySelector( "html" ) ).fontSize`.
    rootSizeValue: 16,
    acceptableUnits: ['rem', 'px', 'em'],
    ...options
  };
  const acceptableUnitsGroup = acceptableUnits?.join('|');
  const regexUnits = new RegExp(`^(\\d*\\.?\\d+)(${acceptableUnitsGroup}){1,1}$`);
  const matches = rawValue.match(regexUnits);

  // We need a number value and a unit.
  if (!matches || matches.length < 3) {
    return null;
  }
  let [, value, unit] = matches;
  let returnValue = parseFloat(value);
  if ('px' === coerceTo && ('em' === unit || 'rem' === unit)) {
    returnValue = returnValue * rootSizeValue;
    unit = coerceTo;
  }
  if ('px' === unit && ('em' === coerceTo || 'rem' === coerceTo)) {
    returnValue = returnValue / rootSizeValue;
    unit = coerceTo;
  }

  /*
   * No calculation is required if swapping between em and rem yet,
   * since we assume a root size value. Later we might like to differentiate between
   * :root font size (rem) and parent element font size (em) relativity.
   */
  if (('em' === coerceTo || 'rem' === coerceTo) && ('em' === unit || 'rem' === unit)) {
    unit = coerceTo;
  }
  return {
    value: roundToPrecision(returnValue, 3),
    unit
  };
}

/**
 * Returns a value rounded to defined precision.
 * Returns `undefined` if the value is not a valid finite number.
 *
 * @param {number} value  Raw value.
 * @param {number} digits The number of digits to appear after the decimal point
 *
 * @return {number|undefined} Value rounded to standard precision.
 */
function roundToPrecision(value, digits = 3) {
  const base = Math.pow(10, digits);
  return Number.isFinite(value) ? parseFloat(Math.round(value * base) / base) : undefined;
}
//# sourceMappingURL=fluid-utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/typography-utils.js
/**
 * The fluid utilities must match the backend equivalent.
 * See: gutenberg_get_typography_font_size_value() in lib/block-supports/typography.php
 * ---------------------------------------------------------------
 */

/**
 * Internal dependencies
 */


/**
 * @typedef {Object} FluidPreset
 * @property {string|undefined}  max A maximum font size value.
 * @property {?string|undefined} min A minimum font size value.
 */

/**
 * @typedef {Object} Preset
 * @property {?string|?number}               size  A default font size.
 * @property {string}                        name  A font size name, displayed in the UI.
 * @property {string}                        slug  A font size slug
 * @property {boolean|FluidPreset|undefined} fluid Specifies the minimum and maximum font size value of a fluid font size.
 */

/**
 * @typedef {Object} TypographySettings
 * @property {?string} minViewportWidth  Minimum viewport size from which type will have fluidity. Optional if size is specified.
 * @property {?string} maxViewportWidth  Maximum size up to which type will have fluidity. Optional if size is specified.
 * @property {?number} scaleFactor       A scale factor to determine how fast a font scales within boundaries. Optional.
 * @property {?number} minFontSizeFactor How much to scale defaultFontSize by to derive minimumFontSize. Optional.
 * @property {?string} minFontSize       The smallest a calculated font size may be. Optional.
 */

/**
 * Returns a font-size value based on a given font-size preset.
 * Takes into account fluid typography parameters and attempts to return a css formula depending on available, valid values.
 *
 * @param {Preset}                     preset
 * @param {Object}                     settings
 * @param {boolean|TypographySettings} settings.typography.fluid  Whether fluid typography is enabled, and, optionally, fluid font size options.
 * @param {Object?}                    settings.typography.layout Layout options.
 *
 * @return {string|*} A font-size value or the value of preset.size.
 */
function typography_utils_getTypographyFontSizeValue(preset, settings) {
  const {
    size: defaultSize
  } = preset;
  if (!isFluidTypographyEnabled(settings?.typography)) {
    return defaultSize;
  }
  /*
   * Checks whether a font size has explicitly bypassed fluid calculations.
   * Also catches falsy values and 0/'0'.
   * Fluid calculations cannot be performed on `0`.
   */
  if (!defaultSize || '0' === defaultSize || false === preset?.fluid) {
    return defaultSize;
  }
  let fluidTypographySettings = getFluidTypographyOptionsFromSettings(settings);
  fluidTypographySettings = typeof fluidTypographySettings?.fluid === 'object' ? fluidTypographySettings?.fluid : {};
  const fluidFontSizeValue = getComputedFluidTypographyValue({
    minimumFontSize: preset?.fluid?.min,
    maximumFontSize: preset?.fluid?.max,
    fontSize: defaultSize,
    minimumFontSizeLimit: fluidTypographySettings?.minFontSize,
    maximumViewportWidth: fluidTypographySettings?.maxViewportWidth,
    minimumViewportWidth: fluidTypographySettings?.minViewportWidth
  });
  if (!!fluidFontSizeValue) {
    return fluidFontSizeValue;
  }
  return defaultSize;
}
function isFluidTypographyEnabled(typographySettings) {
  const fluidSettings = typographySettings?.fluid;
  return true === fluidSettings || fluidSettings && typeof fluidSettings === 'object' && Object.keys(fluidSettings).length > 0;
}

/**
 * Returns fluid typography settings from theme.json setting object.
 *
 * @param {Object} settings            Theme.json settings
 * @param {Object} settings.typography Theme.json typography settings
 * @param {Object} settings.layout     Theme.json layout settings
 * @return {TypographySettings} Fluid typography settings
 */
function getFluidTypographyOptionsFromSettings(settings) {
  const typographySettings = settings?.typography;
  const layoutSettings = settings?.layout;
  const defaultMaxViewportWidth = getTypographyValueAndUnit(layoutSettings?.wideSize) ? layoutSettings?.wideSize : null;
  return isFluidTypographyEnabled(typographySettings) && defaultMaxViewportWidth ? {
    fluid: {
      maxViewportWidth: defaultMaxViewportWidth,
      ...typographySettings.fluid
    }
  } : {
    fluid: typographySettings?.fluid
  };
}
//# sourceMappingURL=typography-utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/utils.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/* Supporting data. */
const ROOT_BLOCK_SELECTOR = 'body';
const ROOT_CSS_PROPERTIES_SELECTOR = ':root';
const utils_PRESET_METADATA = [{
  path: ['color', 'palette'],
  valueKey: 'color',
  cssVarInfix: 'color',
  classes: [{
    classSuffix: 'color',
    propertyName: 'color'
  }, {
    classSuffix: 'background-color',
    propertyName: 'background-color'
  }, {
    classSuffix: 'border-color',
    propertyName: 'border-color'
  }]
}, {
  path: ['color', 'gradients'],
  valueKey: 'gradient',
  cssVarInfix: 'gradient',
  classes: [{
    classSuffix: 'gradient-background',
    propertyName: 'background'
  }]
}, {
  path: ['color', 'duotone'],
  valueKey: 'colors',
  cssVarInfix: 'duotone',
  valueFunc: ({
    slug
  }) => `url( '#wp-duotone-${slug}' )`,
  classes: []
}, {
  path: ['shadow', 'presets'],
  valueKey: 'shadow',
  cssVarInfix: 'shadow',
  classes: []
}, {
  path: ['typography', 'fontSizes'],
  valueFunc: (preset, settings) => typography_utils_getTypographyFontSizeValue(preset, settings),
  valueKey: 'size',
  cssVarInfix: 'font-size',
  classes: [{
    classSuffix: 'font-size',
    propertyName: 'font-size'
  }]
}, {
  path: ['typography', 'fontFamilies'],
  valueKey: 'fontFamily',
  cssVarInfix: 'font-family',
  classes: [{
    classSuffix: 'font-family',
    propertyName: 'font-family'
  }]
}, {
  path: ['spacing', 'spacingSizes'],
  valueKey: 'size',
  cssVarInfix: 'spacing',
  valueFunc: ({
    size
  }) => size,
  classes: []
}];
const STYLE_PATH_TO_CSS_VAR_INFIX = {
  'color.background': 'color',
  'color.text': 'color',
  'filter.duotone': 'duotone',
  'elements.link.color.text': 'color',
  'elements.link.:hover.color.text': 'color',
  'elements.link.typography.fontFamily': 'font-family',
  'elements.link.typography.fontSize': 'font-size',
  'elements.button.color.text': 'color',
  'elements.button.color.background': 'color',
  'elements.caption.color.text': 'color',
  'elements.button.typography.fontFamily': 'font-family',
  'elements.button.typography.fontSize': 'font-size',
  'elements.heading.color': 'color',
  'elements.heading.color.background': 'color',
  'elements.heading.typography.fontFamily': 'font-family',
  'elements.heading.gradient': 'gradient',
  'elements.heading.color.gradient': 'gradient',
  'elements.h1.color': 'color',
  'elements.h1.color.background': 'color',
  'elements.h1.typography.fontFamily': 'font-family',
  'elements.h1.color.gradient': 'gradient',
  'elements.h2.color': 'color',
  'elements.h2.color.background': 'color',
  'elements.h2.typography.fontFamily': 'font-family',
  'elements.h2.color.gradient': 'gradient',
  'elements.h3.color': 'color',
  'elements.h3.color.background': 'color',
  'elements.h3.typography.fontFamily': 'font-family',
  'elements.h3.color.gradient': 'gradient',
  'elements.h4.color': 'color',
  'elements.h4.color.background': 'color',
  'elements.h4.typography.fontFamily': 'font-family',
  'elements.h4.color.gradient': 'gradient',
  'elements.h5.color': 'color',
  'elements.h5.color.background': 'color',
  'elements.h5.typography.fontFamily': 'font-family',
  'elements.h5.color.gradient': 'gradient',
  'elements.h6.color': 'color',
  'elements.h6.color.background': 'color',
  'elements.h6.typography.fontFamily': 'font-family',
  'elements.h6.color.gradient': 'gradient',
  'color.gradient': 'gradient',
  shadow: 'shadow',
  'typography.fontSize': 'font-size',
  'typography.fontFamily': 'font-family'
};

// A static list of block attributes that store global style preset slugs.
const STYLE_PATH_TO_PRESET_BLOCK_ATTRIBUTE = {
  'color.background': 'backgroundColor',
  'color.text': 'textColor',
  'color.gradient': 'gradient',
  'typography.fontSize': 'fontSize',
  'typography.fontFamily': 'fontFamily'
};
function useToolsPanelDropdownMenuProps() {
  const isMobile = (0,use_viewport_match/* default */.A)('medium', '<');
  return !isMobile ? {
    popoverProps: {
      placement: 'left-start',
      // For non-mobile, inner sidebar width (248px) - button width (24px) - border (1px) + padding (16px) + spacing (20px)
      offset: 259
    }
  } : {};
}
function findInPresetsBy(features, blockName, presetPath, presetProperty, presetValueValue) {
  // Block presets take priority above root level presets.
  const orderedPresetsByOrigin = [object_getValueFromObjectPath(features, ['blocks', blockName, ...presetPath]), object_getValueFromObjectPath(features, presetPath)];
  for (const presetByOrigin of orderedPresetsByOrigin) {
    if (presetByOrigin) {
      // Preset origins ordered by priority.
      const origins = ['custom', 'theme', 'default'];
      for (const origin of origins) {
        const presets = presetByOrigin[origin];
        if (presets) {
          const presetObject = presets.find(preset => preset[presetProperty] === presetValueValue);
          if (presetObject) {
            if (presetProperty === 'slug') {
              return presetObject;
            }
            // If there is a highest priority preset with the same slug but different value the preset we found was overwritten and should be ignored.
            const highestPresetObjectWithSameSlug = findInPresetsBy(features, blockName, presetPath, 'slug', presetObject.slug);
            if (highestPresetObjectWithSameSlug[presetProperty] === presetObject[presetProperty]) {
              return presetObject;
            }
            return undefined;
          }
        }
      }
    }
  }
}
function utils_getPresetVariableFromValue(features, blockName, variableStylePath, presetPropertyValue) {
  if (!presetPropertyValue) {
    return presetPropertyValue;
  }
  const cssVarInfix = STYLE_PATH_TO_CSS_VAR_INFIX[variableStylePath];
  const metadata = utils_PRESET_METADATA.find(data => data.cssVarInfix === cssVarInfix);
  if (!metadata) {
    // The property doesn't have preset data
    // so the value should be returned as it is.
    return presetPropertyValue;
  }
  const {
    valueKey,
    path
  } = metadata;
  const presetObject = findInPresetsBy(features, blockName, path, valueKey, presetPropertyValue);
  if (!presetObject) {
    // Value wasn't found in the presets,
    // so it must be a custom value.
    return presetPropertyValue;
  }
  return `var:preset|${cssVarInfix}|${presetObject.slug}`;
}
function getValueFromPresetVariable(features, blockName, variable, [presetType, slug]) {
  const metadata = utils_PRESET_METADATA.find(data => data.cssVarInfix === presetType);
  if (!metadata) {
    return variable;
  }
  const presetObject = findInPresetsBy(features.settings, blockName, metadata.path, 'slug', slug);
  if (presetObject) {
    const {
      valueKey
    } = metadata;
    const result = presetObject[valueKey];
    return utils_getValueFromVariable(features, blockName, result);
  }
  return variable;
}
function getValueFromCustomVariable(features, blockName, variable, path) {
  var _getValueFromObjectPa;
  const result = (_getValueFromObjectPa = object_getValueFromObjectPath(features.settings, ['blocks', blockName, 'custom', ...path])) !== null && _getValueFromObjectPa !== void 0 ? _getValueFromObjectPa : object_getValueFromObjectPath(features.settings, ['custom', ...path]);
  if (!result) {
    return variable;
  }
  // A variable may reference another variable so we need recursion until we find the value.
  return utils_getValueFromVariable(features, blockName, result);
}

/**
 * Attempts to fetch the value of a theme.json CSS variable.
 *
 * @param {Object}   features  GlobalStylesContext config, e.g., user, base or merged. Represents the theme.json tree.
 * @param {string}   blockName The name of a block as represented in the styles property. E.g., 'root' for root-level, and 'core/${blockName}' for blocks.
 * @param {string|*} variable  An incoming style value. A CSS var value is expected, but it could be any value.
 * @return {string|*|{ref}} The value of the CSS var, if found. If not found, the passed variable argument.
 */
function utils_getValueFromVariable(features, blockName, variable) {
  if (!variable || typeof variable !== 'string') {
    if (variable?.ref && typeof variable?.ref === 'string') {
      const refPath = variable.ref.split('.');
      variable = object_getValueFromObjectPath(features, refPath);
      // Presence of another ref indicates a reference to another dynamic value.
      // Pointing to another dynamic value is not supported.
      if (!variable || !!variable?.ref) {
        return variable;
      }
    } else {
      return variable;
    }
  }
  const USER_VALUE_PREFIX = 'var:';
  const THEME_VALUE_PREFIX = 'var(--wp--';
  const THEME_VALUE_SUFFIX = ')';
  let parsedVar;
  if (variable.startsWith(USER_VALUE_PREFIX)) {
    parsedVar = variable.slice(USER_VALUE_PREFIX.length).split('|');
  } else if (variable.startsWith(THEME_VALUE_PREFIX) && variable.endsWith(THEME_VALUE_SUFFIX)) {
    parsedVar = variable.slice(THEME_VALUE_PREFIX.length, -THEME_VALUE_SUFFIX.length).split('--');
  } else {
    // We don't know how to parse the value: either is raw of uses complex CSS such as `calc(1px * var(--wp--variable) )`
    return variable;
  }
  const [type, ...path] = parsedVar;
  if (type === 'preset') {
    return getValueFromPresetVariable(features, blockName, variable, path);
  }
  if (type === 'custom') {
    return getValueFromCustomVariable(features, blockName, variable, path);
  }
  return variable;
}

/**
 * Function that scopes a selector with another one. This works a bit like
 * SCSS nesting except the `&` operator isn't supported.
 *
 * @example
 * ```js
 * const scope = '.a, .b .c';
 * const selector = '> .x, .y';
 * const merged = scopeSelector( scope, selector );
 * // merged is '.a > .x, .a .y, .b .c > .x, .b .c .y'
 * ```
 *
 * @param {string} scope    Selector to scope to.
 * @param {string} selector Original selector.
 *
 * @return {string} Scoped selector.
 */
function scopeSelector(scope, selector) {
  if (!scope || !selector) {
    return selector;
  }
  const scopes = scope.split(',');
  const selectors = selector.split(',');
  const selectorsScoped = [];
  scopes.forEach(outer => {
    selectors.forEach(inner => {
      selectorsScoped.push(`${outer.trim()} ${inner.trim()}`);
    });
  });
  return selectorsScoped.join(', ');
}

/**
 * Scopes a collection of selectors for features and subfeatures.
 *
 * @example
 * ```js
 * const scope = '.custom-scope';
 * const selectors = {
 *     color: '.wp-my-block p',
 *     typography: { fontSize: '.wp-my-block caption' },
 * };
 * const result = scopeFeatureSelector( scope, selectors );
 * // result is {
 * //     color: '.custom-scope .wp-my-block p',
 * //     typography: { fonSize: '.custom-scope .wp-my-block caption' },
 * // }
 * ```
 *
 * @param {string} scope     Selector to scope collection of selectors with.
 * @param {Object} selectors Collection of feature selectors e.g.
 *
 * @return {Object|undefined} Scoped collection of feature selectors.
 */
function scopeFeatureSelectors(scope, selectors) {
  if (!scope || !selectors) {
    return;
  }
  const featureSelectors = {};
  Object.entries(selectors).forEach(([feature, selector]) => {
    if (typeof selector === 'string') {
      featureSelectors[feature] = scopeSelector(scope, selector);
    }
    if (typeof selector === 'object') {
      featureSelectors[feature] = {};
      Object.entries(selector).forEach(([subfeature, subfeatureSelector]) => {
        featureSelectors[feature][subfeature] = scopeSelector(scope, subfeatureSelector);
      });
    }
  });
  return featureSelectors;
}

/**
 * Appends a sub-selector to an existing one.
 *
 * Given the compounded `selector` "h1, h2, h3"
 * and the `toAppend` selector ".some-class" the result will be
 * "h1.some-class, h2.some-class, h3.some-class".
 *
 * @param {string} selector Original selector.
 * @param {string} toAppend Selector to append.
 *
 * @return {string} The new selector.
 */
function appendToSelector(selector, toAppend) {
  if (!selector.includes(',')) {
    return selector + toAppend;
  }
  const selectors = selector.split(',');
  const newSelectors = selectors.map(sel => sel + toAppend);
  return newSelectors.join(',');
}

/**
 * Compares global style variations according to their styles and settings properties.
 *
 * @example
 * ```js
 * const globalStyles = { styles: { typography: { fontSize: '10px' } }, settings: {} };
 * const variation = { styles: { typography: { fontSize: '10000px' } }, settings: {} };
 * const isEqual = areGlobalStyleConfigsEqual( globalStyles, variation );
 * // false
 * ```
 *
 * @param {Object} original  A global styles object.
 * @param {Object} variation A global styles object.
 *
 * @return {boolean} Whether `original` and `variation` match.
 */
function areGlobalStyleConfigsEqual(original, variation) {
  if (typeof original !== 'object' || typeof variation !== 'object') {
    return original === variation;
  }
  return fastDeepEqual(original?.styles, variation?.styles) && fastDeepEqual(original?.settings, variation?.settings);
}

/**
 * Generates the selector for a block style variation by creating the
 * appropriate CSS class and adding it to the ancestor portion of the block's
 * selector.
 *
 * For example, take the Button block which has a compound selector:
 * `.wp-block-button .wp-block-button__link`. With a variation named 'custom',
 * the class `.is-style-custom` should be added to the `.wp-block-button`
 * ancestor only.
 *
 * This function will take into account comma separated and complex selectors.
 *
 * @param {string} variation     Name for the variation.
 * @param {string} blockSelector CSS selector for the block.
 *
 * @return {string} CSS selector for the block style variation.
 */
function getBlockStyleVariationSelector(variation, blockSelector) {
  const variationClass = `.is-style-${variation}`;
  if (!blockSelector) {
    return variationClass;
  }
  const ancestorRegex = /((?::\([^)]+\))?\s*)([^\s:]+)/;
  const addVariationClass = (_match, group1, group2) => {
    return group1 + group2 + variationClass;
  };
  const result = blockSelector.split(',').map(part => part.replace(ancestorRegex, addVariationClass));
  return result.join(',');
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/block-support-tools-panel.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




function BlockSupportToolsPanel({
  children,
  group,
  label
}) {
  const {
    updateBlockAttributes
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    getBlockAttributes,
    getMultiSelectedBlockClientIds,
    getSelectedBlockClientId,
    hasMultiSelection
  } = (0,use_select/* default */.A)(store_store);
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const panelId = getSelectedBlockClientId();
  const resetAll = (0,react.useCallback)((resetFilters = []) => {
    const newAttributes = {};
    const clientIds = hasMultiSelection() ? getMultiSelectedBlockClientIds() : [panelId];
    clientIds.forEach(clientId => {
      const {
        style
      } = getBlockAttributes(clientId);
      let newBlockAttributes = {
        style
      };
      resetFilters.forEach(resetFilter => {
        newBlockAttributes = {
          ...newBlockAttributes,
          ...resetFilter(newBlockAttributes)
        };
      });

      // Enforce a cleaned style object.
      newBlockAttributes = {
        ...newBlockAttributes,
        style: utils_cleanEmptyObject(newBlockAttributes.style)
      };
      newAttributes[clientId] = newBlockAttributes;
    });
    updateBlockAttributes(clientIds, newAttributes, true);
  }, [getBlockAttributes, getMultiSelectedBlockClientIds, hasMultiSelection, panelId, updateBlockAttributes]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_component, {
    className: `${group}-block-support-panel`,
    label: label,
    resetAll: resetAll,
    panelId: panelId,
    hasInnerWrapper: true,
    shouldRenderPlaceholderItems: true // Required to maintain fills ordering.
    ,
    __experimentalFirstVisibleItemClass: "first",
    __experimentalLastVisibleItemClass: "last",
    dropdownMenuProps: dropdownMenuProps,
    children: children
  }, panelId);
}
//# sourceMappingURL=block-support-tools-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/block-support-slot-container.js
/**
 * WordPress dependencies
 */



function BlockSupportSlotContainer({
  Slot,
  fillProps,
  ...props
}) {
  // Add the toolspanel context provider and value to existing fill props
  const toolsPanelContext = (0,react.useContext)(ToolsPanelContext);
  const computedFillProps = (0,react.useMemo)(() => {
    var _fillProps$forwardedC;
    return {
      ...(fillProps !== null && fillProps !== void 0 ? fillProps : {}),
      forwardedContext: [...((_fillProps$forwardedC = fillProps?.forwardedContext) !== null && _fillProps$forwardedC !== void 0 ? _fillProps$forwardedC : []), [ToolsPanelContext.Provider, {
        value: toolsPanelContext
      }]]
    };
  }, [toolsPanelContext, fillProps]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Slot, {
    ...props,
    fillProps: computedFillProps,
    bubblesVirtually: true
  });
}
//# sourceMappingURL=block-support-slot-container.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/slot.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function InspectorControlsSlot({
  __experimentalGroup,
  group = 'default',
  label,
  fillProps,
  ...props
}) {
  if (__experimentalGroup) {
    (0,deprecated_build_module/* default */.A)('`__experimentalGroup` property in `InspectorControlsSlot`', {
      since: '6.2',
      version: '6.4',
      alternative: '`group`'
    });
    group = __experimentalGroup;
  }
  const Slot = inspector_controls_groups[group]?.Slot;
  const fills = useSlotFills(Slot?.__unstableName);
  const motionContextValue = (0,react.useContext)(MotionContext/* MotionContext */.A);
  const computedFillProps = (0,react.useMemo)(() => {
    var _fillProps$forwardedC;
    return {
      ...(fillProps !== null && fillProps !== void 0 ? fillProps : {}),
      forwardedContext: [...((_fillProps$forwardedC = fillProps?.forwardedContext) !== null && _fillProps$forwardedC !== void 0 ? _fillProps$forwardedC : []), [MotionContext/* MotionContext */.A.Provider, {
        value: motionContextValue
      }]]
    };
  }, [motionContextValue, fillProps]);
  if (!Slot) {
    globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)(`Unknown InspectorControls group "${group}" provided.`) : void 0;
    return null;
  }
  if (!fills?.length) {
    return null;
  }
  if (label) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockSupportToolsPanel, {
      group: group,
      label: label,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(BlockSupportSlotContainer, {
        ...props,
        fillProps: computedFillProps,
        Slot: Slot
      })
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Slot, {
    ...props,
    fillProps: computedFillProps,
    bubblesVirtually: true
  });
}
//# sourceMappingURL=slot.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/index.js
/**
 * Internal dependencies
 */



const InspectorControls = InspectorControlsFill;
InspectorControls.Slot = InspectorControlsSlot;

// This is just here for backward compatibility.
const InspectorAdvancedControls = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(InspectorControlsFill, {
    ...props,
    group: "advanced"
  });
};
InspectorAdvancedControls.Slot = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(InspectorControlsSlot, {
    ...props,
    group: "advanced"
  });
};
InspectorAdvancedControls.slotName = 'InspectorAdvancedControls';

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inspector-controls/README.md
 */
/* harmony default export */ const inspector_controls = (InspectorControls);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/item-group/styles.js
function item_group_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */

const unstyledButton = as => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("font-size:", (0,font/* font */.g)('default.fontSize'), ";font-family:inherit;appearance:none;border:1px solid transparent;cursor:pointer;background:none;text-align:start;text-decoration:", as === 'a' ? 'none' : undefined, ";svg,path{fill:currentColor;}&:hover{color:", colors_values/* COLORS */.l.theme.accent, ";}&:focus{box-shadow:none;outline:none;}&:focus-visible{box-shadow:0 0 0 var( --wp-admin-border-width-focus ) ", colors_values/* COLORS */.l.theme.accent, ";outline:2px solid transparent;outline-offset:0;}" + ( true ? "" : 0),  true ? "" : 0);
};
const itemWrapper =  true ? {
  name: "1bcj5ek",
  styles: "width:100%;display:block"
} : 0;
const item =  true ? {
  name: "150ruhm",
  styles: "box-sizing:border-box;width:100%;display:block;margin:0;color:inherit"
} : 0;
const bordered = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border:1px solid ", config_values/* default */.A.surfaceBorderColor, ";" + ( true ? "" : 0),  true ? "" : 0);
const separated = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(">*:not( marquee )>*{border-bottom:1px solid ", config_values/* default */.A.surfaceBorderColor, ";}>*:last-of-type>*:not( :focus ){border-bottom-color:transparent;}" + ( true ? "" : 0),  true ? "" : 0);
const borderRadius = config_values/* default */.A.controlBorderRadius;
const styles_spacedAround = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border-radius:", borderRadius, ";" + ( true ? "" : 0),  true ? "" : 0);
const rounded = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border-radius:", borderRadius, ";>*:first-of-type>*{border-top-left-radius:", borderRadius, ";border-top-right-radius:", borderRadius, ";}>*:last-of-type>*{border-bottom-left-radius:", borderRadius, ";border-bottom-right-radius:", borderRadius, ";}" + ( true ? "" : 0),  true ? "" : 0);
const baseFontHeight = `calc(${config_values/* default */.A.fontSize} * ${config_values/* default */.A.fontLineHeightBase})`;

/*
 * Math:
 * - Use the desired height as the base value
 * - Subtract the computed height of (default) text
 * - Subtract the effects of border
 * - Divide the calculated number by 2, in order to get an individual top/bottom padding
 */
const paddingY = `calc((${config_values/* default */.A.controlHeight} - ${baseFontHeight} - 2px) / 2)`;
const paddingYSmall = `calc((${config_values/* default */.A.controlHeightSmall} - ${baseFontHeight} - 2px) / 2)`;
const paddingYLarge = `calc((${config_values/* default */.A.controlHeightLarge} - ${baseFontHeight} - 2px) / 2)`;
const itemSizes = {
  small: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding:", paddingYSmall, " ", config_values/* default */.A.controlPaddingXSmall, ";" + ( true ? "" : 0),  true ? "" : 0),
  medium: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding:", paddingY, " ", config_values/* default */.A.controlPaddingX, ";" + ( true ? "" : 0),  true ? "" : 0),
  large: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding:", paddingYLarge, " ", config_values/* default */.A.controlPaddingXLarge, ";" + ( true ? "" : 0),  true ? "" : 0)
};
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/item-group/item-group/hook.js
/**
 * Internal dependencies
 */



/**
 * Internal dependencies
 */


function useItemGroup(props) {
  const {
    className,
    isBordered = false,
    isRounded = true,
    isSeparated = false,
    role = 'list',
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'ItemGroup');
  const cx = (0,use_cx/* useCx */.l)();
  const classes = cx(isBordered && bordered, isSeparated && separated, isRounded && rounded, className);
  return {
    isBordered,
    className: classes,
    role,
    isSeparated,
    ...otherProps
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/item-group/context.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

const ItemGroupContext = (0,react.createContext)({
  size: 'medium'
});
const useItemGroupContext = () => (0,react.useContext)(ItemGroupContext);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/item-group/item-group/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */






function UnconnectedItemGroup(props, forwardedRef) {
  const {
    isBordered,
    isSeparated,
    size: sizeProp,
    ...otherProps
  } = useItemGroup(props);
  const {
    size: contextSize
  } = useItemGroupContext();
  const spacedAround = !isBordered && !isSeparated;
  const size = sizeProp || contextSize;
  const contextValue = {
    spacedAround,
    size
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(ItemGroupContext.Provider, {
    value: contextValue,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
      ...otherProps,
      ref: forwardedRef
    })
  });
}

/**
 * `ItemGroup` displays a list of `Item`s grouped and styled together.
 *
 * ```jsx
 * import {
 *   __experimentalItemGroup as ItemGroup,
 *   __experimentalItem as Item,
 * } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ItemGroup>
 *       <Item>Code</Item>
 *       <Item>is</Item>
 *       <Item>Poetry</Item>
 *     </ItemGroup>
 *   );
 * }
 * ```
 */
const ItemGroup = (0,context_connect/* contextConnect */.KZ)(UnconnectedItemGroup, 'ItemGroup');
/* harmony default export */ const item_group_component = (ItemGroup);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tools-panel/tools-panel-item/hook.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const hook_noop = () => {};
function useToolsPanelItem(props) {
  const {
    className,
    hasValue,
    isShownByDefault = false,
    label,
    panelId,
    resetAllFilter = hook_noop,
    onDeselect,
    onSelect,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'ToolsPanelItem');
  const {
    panelId: currentPanelId,
    menuItems,
    registerResetAllFilter,
    deregisterResetAllFilter,
    registerPanelItem,
    deregisterPanelItem,
    flagItemCustomization,
    isResetting,
    shouldRenderPlaceholderItems: shouldRenderPlaceholder,
    firstDisplayedItem,
    lastDisplayedItem,
    __experimentalFirstVisibleItemClass,
    __experimentalLastVisibleItemClass
  } = useToolsPanelContext();

  // hasValue is a new function on every render, so do not add it as a
  // dependency to the useCallback hook! If needed, we should use a ref.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const hasValueCallback = (0,react.useCallback)(hasValue, [panelId]);
  // resetAllFilter is a new function on every render, so do not add it as a
  // dependency to the useCallback hook! If needed, we should use a ref.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const resetAllFilterCallback = (0,react.useCallback)(resetAllFilter, [panelId]);
  const previousPanelId = (0,use_previous/* default */.A)(currentPanelId);
  const hasMatchingPanel = currentPanelId === panelId || currentPanelId === null;

  // Registering the panel item allows the panel to include it in its
  // automatically generated menu and determine its initial checked status.
  //
  // This is performed in a layout effect to ensure that the panel item
  // is registered before it is rendered preventing a rendering glitch.
  // See: https://github.com/WordPress/gutenberg/issues/56470
  (0,react.useLayoutEffect)(() => {
    if (hasMatchingPanel && previousPanelId !== null) {
      registerPanelItem({
        hasValue: hasValueCallback,
        isShownByDefault,
        label,
        panelId
      });
    }
    return () => {
      if (previousPanelId === null && !!currentPanelId || currentPanelId === panelId) {
        deregisterPanelItem(label);
      }
    };
  }, [currentPanelId, hasMatchingPanel, isShownByDefault, label, hasValueCallback, panelId, previousPanelId, registerPanelItem, deregisterPanelItem]);
  (0,react.useEffect)(() => {
    if (hasMatchingPanel) {
      registerResetAllFilter(resetAllFilterCallback);
    }
    return () => {
      if (hasMatchingPanel) {
        deregisterResetAllFilter(resetAllFilterCallback);
      }
    };
  }, [registerResetAllFilter, deregisterResetAllFilter, resetAllFilterCallback, hasMatchingPanel]);

  // Note: `label` is used as a key when building menu item state in
  // `ToolsPanel`.
  const menuGroup = isShownByDefault ? 'default' : 'optional';
  const isMenuItemChecked = menuItems?.[menuGroup]?.[label];
  const wasMenuItemChecked = (0,use_previous/* default */.A)(isMenuItemChecked);
  const isRegistered = menuItems?.[menuGroup]?.[label] !== undefined;
  const isValueSet = hasValue();
  // Notify the panel when an item's value has changed except for optional
  // items without value because the item should not cause itself to hide.
  (0,react.useEffect)(() => {
    if (!isShownByDefault && !isValueSet) {
      return;
    }
    flagItemCustomization(isValueSet, label, menuGroup);
  }, [isValueSet, menuGroup, label, flagItemCustomization, isShownByDefault]);

  // Determine if the panel item's corresponding menu is being toggled and
  // trigger appropriate callback if it is.
  (0,react.useEffect)(() => {
    // We check whether this item is currently registered as items rendered
    // via fills can persist through the parent panel being remounted.
    // See: https://github.com/WordPress/gutenberg/pull/45673
    if (!isRegistered || isResetting || !hasMatchingPanel) {
      return;
    }
    if (isMenuItemChecked && !isValueSet && !wasMenuItemChecked) {
      onSelect?.();
    }
    if (!isMenuItemChecked && isValueSet && wasMenuItemChecked) {
      onDeselect?.();
    }
  }, [hasMatchingPanel, isMenuItemChecked, isRegistered, isResetting, isValueSet, wasMenuItemChecked, onSelect, onDeselect]);

  // The item is shown if it is a default control regardless of whether it
  // has a value. Optional items are shown when they are checked or have
  // a value.
  const isShown = isShownByDefault ? menuItems?.[menuGroup]?.[label] !== undefined : isMenuItemChecked;
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    const shouldApplyPlaceholderStyles = shouldRenderPlaceholder && !isShown;
    const firstItemStyle = firstDisplayedItem === label && __experimentalFirstVisibleItemClass;
    const lastItemStyle = lastDisplayedItem === label && __experimentalLastVisibleItemClass;
    return cx(ToolsPanelItem, shouldApplyPlaceholderStyles && ToolsPanelItemPlaceholder, !shouldApplyPlaceholderStyles && className, firstItemStyle, lastItemStyle);
  }, [isShown, shouldRenderPlaceholder, className, cx, firstDisplayedItem, lastDisplayedItem, __experimentalFirstVisibleItemClass, __experimentalLastVisibleItemClass, label]);
  return {
    ...otherProps,
    isShown,
    shouldRenderPlaceholder,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tools-panel/tools-panel-item/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




// This wraps controls to be conditionally displayed within a tools panel. It
// prevents props being applied to HTML elements that would make them invalid.
const UnconnectedToolsPanelItem = (props, forwardedRef) => {
  const {
    children,
    isShown,
    shouldRenderPlaceholder,
    ...toolsPanelItemProps
  } = useToolsPanelItem(props);
  if (!isShown) {
    return shouldRenderPlaceholder ? /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
      ...toolsPanelItemProps,
      ref: forwardedRef
    }) : null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
    ...toolsPanelItemProps,
    ref: forwardedRef,
    children: children
  });
};
const component_ToolsPanelItem = (0,context_connect/* contextConnect */.KZ)(UnconnectedToolsPanelItem, 'ToolsPanelItem');
/* harmony default export */ const tools_panel_item_component = (component_ToolsPanelItem);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/drop-zone/index.js
var drop_zone = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/drop-zone/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/v-stack/component.js + 1 modules
var v_stack_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/v-stack/component.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-isomorphic-layout-effect/index.js
/**
 * WordPress dependencies
 */


/**
 * Preferred over direct usage of `useLayoutEffect` when supporting
 * server rendered components (SSR) because currently React
 * throws a warning when using useLayoutEffect in that environment.
 */
const use_isomorphic_layout_effect_useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;
/* harmony default export */ const use_isomorphic_layout_effect = (use_isomorphic_layout_effect_useIsomorphicLayoutEffect);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-dragging/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


// Event handlers that are triggered from `document` listeners accept a MouseEvent,
// while those triggered from React listeners accept a React.MouseEvent.
/**
 * @param {Object}                                  props
 * @param {(e: import('react').MouseEvent) => void} props.onDragStart
 * @param {(e: MouseEvent) => void}                 props.onDragMove
 * @param {(e?: MouseEvent) => void}                props.onDragEnd
 */
function useDragging({
  onDragStart,
  onDragMove,
  onDragEnd
}) {
  const [isDragging, setIsDragging] = (0,react.useState)(false);
  const eventsRef = (0,react.useRef)({
    onDragStart,
    onDragMove,
    onDragEnd
  });
  use_isomorphic_layout_effect(() => {
    eventsRef.current.onDragStart = onDragStart;
    eventsRef.current.onDragMove = onDragMove;
    eventsRef.current.onDragEnd = onDragEnd;
  }, [onDragStart, onDragMove, onDragEnd]);

  /** @type {(e: MouseEvent) => void} */
  const onMouseMove = (0,react.useCallback)(event => eventsRef.current.onDragMove && eventsRef.current.onDragMove(event), []);
  /** @type {(e?: MouseEvent) => void} */
  const endDrag = (0,react.useCallback)(event => {
    if (eventsRef.current.onDragEnd) {
      eventsRef.current.onDragEnd(event);
    }
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', endDrag);
    setIsDragging(false);
  }, []);
  /** @type {(e: import('react').MouseEvent) => void} */
  const startDrag = (0,react.useCallback)(event => {
    if (eventsRef.current.onDragStart) {
      eventsRef.current.onDragStart(event);
    }
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', endDrag);
    setIsDragging(true);
  }, []);

  // Remove the global events when unmounting if needed.
  (0,react.useEffect)(() => {
    return () => {
      if (isDragging) {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', endDrag);
      }
    };
  }, [isDragging]);
  return {
    startDrag,
    endDrag,
    isDragging
  };
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/focal-point-picker/utils.js
const INITIAL_BOUNDS = {
  width: 200,
  height: 170
};
const VIDEO_EXTENSIONS = ['avi', 'mpg', 'mpeg', 'mov', 'mp4', 'm4v', 'ogg', 'ogv', 'webm', 'wmv'];

/**
 * Gets the extension of a file name.
 *
 * @param filename The file name.
 * @return  The extension of the file name.
 */
function getExtension(filename = '') {
  const parts = filename.split('.');
  return parts[parts.length - 1];
}

/**
 * Checks if a file is a video.
 *
 * @param filename The file name.
 * @return Whether the file is a video.
 */
function isVideoType(filename = '') {
  if (!filename) {
    return false;
  }
  return filename.startsWith('data:video/') || VIDEO_EXTENSIONS.includes(getExtension(filename));
}

/**
 * Transforms a fraction value to a percentage value.
 *
 * @param fraction The fraction value.
 * @return A percentage value.
 */
function fractionToPercentage(fraction) {
  return Math.round(fraction * 100);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/focal-point-picker/styles/focal-point-picker-style.js

function focal_point_picker_style_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




const MediaWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eeew7dm8"
} : 0)( true ? {
  name: "jqnsxy",
  styles: "background-color:transparent;display:flex;text-align:center;width:100%"
} : 0);
const MediaContainer = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eeew7dm7"
} : 0)("align-items:center;border-radius:", config_values/* default */.A.radiusBlockUi, ";cursor:pointer;display:inline-flex;justify-content:center;margin:auto;position:relative;height:100%;&:after{border-radius:inherit;bottom:0;box-shadow:inset 0 0 0 1px rgba( 0, 0, 0, 0.1 );content:'';left:0;pointer-events:none;position:absolute;right:0;top:0;}img,video{border-radius:inherit;box-sizing:border-box;display:block;height:auto;margin:0;max-height:100%;max-width:100%;pointer-events:none;user-select:none;width:auto;}" + ( true ? "" : 0));
const MediaPlaceholder = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eeew7dm6"
} : 0)("background:", colors_values/* COLORS */.l.gray[100], ";border-radius:inherit;box-sizing:border-box;height:", INITIAL_BOUNDS.height, "px;max-width:280px;min-width:", INITIAL_BOUNDS.width, "px;width:100%;" + ( true ? "" : 0));
const StyledUnitControl = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(unit_control,  true ? {
  target: "eeew7dm5"
} : 0)( true ? {
  name: "1d3w5wq",
  styles: "width:100%"
} : 0);
var focal_point_picker_style_ref2 =  true ? {
  name: "1mn7kwb",
  styles: "padding-bottom:1em"
} : 0;
const deprecatedBottomMargin = ({
  __nextHasNoMarginBottom
}) => {
  return !__nextHasNoMarginBottom ? focal_point_picker_style_ref2 : undefined;
};
var focal_point_picker_style_ref =  true ? {
  name: "1mn7kwb",
  styles: "padding-bottom:1em"
} : 0;
const extraHelpTextMargin = ({
  hasHelpText = false
}) => {
  return hasHelpText ? focal_point_picker_style_ref : undefined;
};
const ControlWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_component/* default */.A,  true ? {
  target: "eeew7dm4"
} : 0)("max-width:320px;padding-top:1em;", extraHelpTextMargin, " ", deprecatedBottomMargin, ";" + ( true ? "" : 0));
const GridView = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eeew7dm3"
} : 0)("left:50%;overflow:hidden;pointer-events:none;position:absolute;top:50%;transform:translate3d( -50%, -50%, 0 );z-index:1;@media not ( prefers-reduced-motion ){transition:opacity 100ms linear;}opacity:", ({
  showOverlay
}) => showOverlay ? 1 : 0, ";" + ( true ? "" : 0));
const GridLine = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eeew7dm2"
} : 0)( true ? {
  name: "1yzbo24",
  styles: "background:rgba( 255, 255, 255, 0.4 );backdrop-filter:blur( 16px ) saturate( 180% );position:absolute;transform:translateZ( 0 )"
} : 0);
const GridLineX = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(GridLine,  true ? {
  target: "eeew7dm1"
} : 0)( true ? {
  name: "1sw8ur",
  styles: "height:1px;left:1px;right:1px"
} : 0);
const GridLineY = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(GridLine,  true ? {
  target: "eeew7dm0"
} : 0)( true ? {
  name: "188vg4t",
  styles: "width:1px;top:1px;bottom:1px"
} : 0);
//# sourceMappingURL=focal-point-picker-style.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/focal-point-picker/controls.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




const TEXTCONTROL_MIN = 0;
const TEXTCONTROL_MAX = 100;
const controls_noop = () => {};
function FocalPointPickerControls({
  __nextHasNoMarginBottom,
  __next40pxDefaultSize,
  hasHelpText,
  onChange = controls_noop,
  point = {
    x: 0.5,
    y: 0.5
  }
}) {
  const valueX = fractionToPercentage(point.x);
  const valueY = fractionToPercentage(point.y);
  const handleChange = (value, axis) => {
    if (value === undefined) {
      return;
    }
    const num = parseInt(value, 10);
    if (!isNaN(num)) {
      onChange({
        ...point,
        [axis]: num / 100
      });
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(ControlWrapper, {
    className: "focal-point-picker__controls",
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    hasHelpText: hasHelpText,
    gap: 4,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(FocalPointUnitControl, {
      __next40pxDefaultSize: __next40pxDefaultSize,
      label: (0,i18n_build_module.__)('Left'),
      "aria-label": (0,i18n_build_module.__)('Focal point left position'),
      value: [valueX, '%'].join(''),
      onChange: next => handleChange(next, 'x'),
      dragDirection: "e"
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(FocalPointUnitControl, {
      __next40pxDefaultSize: __next40pxDefaultSize,
      label: (0,i18n_build_module.__)('Top'),
      "aria-label": (0,i18n_build_module.__)('Focal point top position'),
      value: [valueY, '%'].join(''),
      onChange: next => handleChange(next, 'y'),
      dragDirection: "s"
    })]
  });
}
function FocalPointUnitControl(props) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(StyledUnitControl, {
    className: "focal-point-picker__controls-position-unit-control",
    labelPosition: "top",
    max: TEXTCONTROL_MAX,
    min: TEXTCONTROL_MIN,
    units: [{
      value: '%',
      label: '%'
    }],
    ...props
  });
}
//# sourceMappingURL=controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/focal-point-picker/styles/focal-point-style.js

/**
 * External dependencies
 */

const PointerCircle = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e19snlhg0"
} : 0)("background-color:transparent;cursor:grab;height:40px;margin:-20px 0 0 -20px;position:absolute;user-select:none;width:40px;will-change:transform;z-index:10000;background:rgba( 255, 255, 255, 0.4 );border:1px solid rgba( 255, 255, 255, 0.4 );border-radius:50%;backdrop-filter:blur( 16px ) saturate( 180% );box-shadow:rgb( 0 0 0 / 10% ) 0px 0px 8px;@media not ( prefers-reduced-motion ){transition:transform 100ms linear;}", ({
  isDragging
}) => isDragging && `
			box-shadow: rgb( 0 0 0 / 12% ) 0px 0px 10px;
			transform: scale( 1.1 );
			cursor: grabbing;
			`, ";" + ( true ? "" : 0));
//# sourceMappingURL=focal-point-style.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/focal-point-picker/focal-point.js
/**
 * Internal dependencies
 */


/**
 * External dependencies
 */

function FocalPoint({
  left = '50%',
  top = '50%',
  ...props
}) {
  const style = {
    left,
    top
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(PointerCircle, {
    ...props,
    className: "components-focal-point-picker__icon_container",
    style: style
  });
}
//# sourceMappingURL=focal-point.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/focal-point-picker/grid.js
/**
 * Internal dependencies
 */



function FocalPointPickerGrid({
  bounds,
  ...props
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(GridView, {
    ...props,
    className: "components-focal-point-picker__grid",
    style: {
      width: bounds.width,
      height: bounds.height
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(GridLineX, {
      style: {
        top: '33%'
      }
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(GridLineX, {
      style: {
        top: '66%'
      }
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(GridLineY, {
      style: {
        left: '33%'
      }
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(GridLineY, {
      style: {
        left: '66%'
      }
    })]
  });
}
//# sourceMappingURL=grid.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/focal-point-picker/media.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



function Media({
  alt,
  autoPlay,
  src,
  onLoad,
  mediaRef,
  // Exposing muted prop for test rendering purposes
  // https://github.com/testing-library/react-testing-library/issues/470
  muted = true,
  ...props
}) {
  if (!src) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(MediaPlaceholder, {
      className: "components-focal-point-picker__media components-focal-point-picker__media--placeholder",
      ref: mediaRef,
      ...props
    });
  }
  const isVideo = isVideoType(src);
  return isVideo ? /*#__PURE__*/(0,jsx_runtime.jsx)("video", {
    ...props,
    autoPlay: autoPlay,
    className: "components-focal-point-picker__media components-focal-point-picker__media--video",
    loop: true,
    muted: muted,
    onLoadedData: onLoad,
    ref: mediaRef,
    src: src
  }) : /*#__PURE__*/(0,jsx_runtime.jsx)("img", {
    ...props,
    alt: alt,
    className: "components-focal-point-picker__media components-focal-point-picker__media--image",
    onLoad: onLoad,
    ref: mediaRef,
    src: src
  });
}
//# sourceMappingURL=media.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-update-effect.js
var use_update_effect = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-update-effect.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/focal-point-picker/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */










const GRID_OVERLAY_TIMEOUT = 600;

/**
 * Focal Point Picker is a component which creates a UI for identifying the most important visual point of an image.
 *
 * This component addresses a specific problem: with large background images it is common to see undesirable crops,
 * especially when viewing on smaller viewports such as mobile phones. This component allows the selection of
 * the point with the most important visual information and returns it as a pair of numbers between 0 and 1.
 * This value can be easily converted into the CSS `background-position` attribute, and will ensure that the
 * focal point is never cropped out, regardless of viewport.
 *
 * - Example focal point picker value: `{ x: 0.5, y: 0.1 }`
 * - Corresponding CSS: `background-position: 50% 10%;`
 *
 * ```jsx
 * import { FocalPointPicker } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const Example = () => {
 * 	const [ focalPoint, setFocalPoint ] = useState( {
 * 		x: 0.5,
 * 		y: 0.5,
 * 	} );
 *
 * 	const url = '/path/to/image';
 *
 * 	// Example function to render the CSS styles based on Focal Point Picker value
 * 	const style = {
 * 		backgroundImage: `url(${ url })`,
 * 		backgroundPosition: `${ focalPoint.x * 100 }% ${ focalPoint.y * 100 }%`,
 * 	};
 *
 * 	return (
 * 		<>
 * 			<FocalPointPicker
 * 				url={ url }
 * 				value={ focalPoint }
 * 				onDragStart={ setFocalPoint }
 * 				onDrag={ setFocalPoint }
 * 				onChange={ setFocalPoint }
 * 			/>
 * 			<div style={ style } />
 * 		</>
 * 	);
 * };
 * ```
 */
function FocalPointPicker({
  __nextHasNoMarginBottom,
  __next40pxDefaultSize = false,
  autoPlay = true,
  className,
  help,
  label,
  onChange,
  onDrag,
  onDragEnd,
  onDragStart,
  resolvePoint,
  url,
  value: valueProp = {
    x: 0.5,
    y: 0.5
  },
  ...restProps
}) {
  const [point, setPoint] = (0,react.useState)(valueProp);
  const [showGridOverlay, setShowGridOverlay] = (0,react.useState)(false);
  const {
    startDrag,
    endDrag,
    isDragging
  } = useDragging({
    onDragStart: event => {
      dragAreaRef.current?.focus();
      const value = getValueWithinDragArea(event);

      // `value` can technically be undefined if getValueWithinDragArea() is
      // called before dragAreaRef is set, but this shouldn't happen in reality.
      if (!value) {
        return;
      }
      onDragStart?.(value, event);
      setPoint(value);
    },
    onDragMove: event => {
      // Prevents text-selection when dragging.
      event.preventDefault();
      const value = getValueWithinDragArea(event);
      if (!value) {
        return;
      }
      onDrag?.(value, event);
      setPoint(value);
    },
    onDragEnd: () => {
      onDragEnd?.();
      onChange?.(point);
    }
  });

  // Uses the internal point while dragging or else the value from props.
  const {
    x,
    y
  } = isDragging ? point : valueProp;
  const dragAreaRef = (0,react.useRef)(null);
  const [bounds, setBounds] = (0,react.useState)(INITIAL_BOUNDS);
  const refUpdateBounds = (0,react.useRef)(() => {
    if (!dragAreaRef.current) {
      return;
    }
    const {
      clientWidth: width,
      clientHeight: height
    } = dragAreaRef.current;
    // Falls back to initial bounds if the ref has no size. Since styles
    // give the drag area dimensions even when the media has not loaded
    // this should only happen in unit tests (jsdom).
    setBounds(width > 0 && height > 0 ? {
      width,
      height
    } : {
      ...INITIAL_BOUNDS
    });
  });
  (0,react.useEffect)(() => {
    const updateBounds = refUpdateBounds.current;
    if (!dragAreaRef.current) {
      return;
    }
    const {
      defaultView
    } = dragAreaRef.current.ownerDocument;
    defaultView?.addEventListener('resize', updateBounds);
    return () => defaultView?.removeEventListener('resize', updateBounds);
  }, []);

  // Updates the bounds to cover cases of unspecified media or load failures.
  use_isomorphic_layout_effect(() => void refUpdateBounds.current(), []);

  // TODO: Consider refactoring getValueWithinDragArea() into a pure function.
  // https://github.com/WordPress/gutenberg/pull/43872#discussion_r963455173
  const getValueWithinDragArea = ({
    clientX,
    clientY,
    shiftKey
  }) => {
    if (!dragAreaRef.current) {
      return;
    }
    const {
      top,
      left
    } = dragAreaRef.current.getBoundingClientRect();
    let nextX = (clientX - left) / bounds.width;
    let nextY = (clientY - top) / bounds.height;
    // Enables holding shift to jump values by 10%.
    if (shiftKey) {
      nextX = Math.round(nextX / 0.1) * 0.1;
      nextY = Math.round(nextY / 0.1) * 0.1;
    }
    return getFinalValue({
      x: nextX,
      y: nextY
    });
  };
  const getFinalValue = value => {
    var _resolvePoint;
    const resolvedValue = (_resolvePoint = resolvePoint?.(value)) !== null && _resolvePoint !== void 0 ? _resolvePoint : value;
    resolvedValue.x = Math.max(0, Math.min(resolvedValue.x, 1));
    resolvedValue.y = Math.max(0, Math.min(resolvedValue.y, 1));
    const roundToTwoDecimalPlaces = n => Math.round(n * 1e2) / 1e2;
    return {
      x: roundToTwoDecimalPlaces(resolvedValue.x),
      y: roundToTwoDecimalPlaces(resolvedValue.y)
    };
  };
  const arrowKeyStep = event => {
    const {
      code,
      shiftKey
    } = event;
    if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(code)) {
      return;
    }
    event.preventDefault();
    const value = {
      x,
      y
    };
    const step = shiftKey ? 0.1 : 0.01;
    const delta = code === 'ArrowUp' || code === 'ArrowLeft' ? -1 * step : step;
    const axis = code === 'ArrowUp' || code === 'ArrowDown' ? 'y' : 'x';
    value[axis] = value[axis] + delta;
    onChange?.(getFinalValue(value));
  };
  const focalPointPosition = {
    left: x !== undefined ? x * bounds.width : 0.5 * bounds.width,
    top: y !== undefined ? y * bounds.height : 0.5 * bounds.height
  };
  const classes = (0,dist_clsx/* default */.A)('components-focal-point-picker-control', className);
  const instanceId = (0,use_instance_id/* default */.A)(FocalPointPicker);
  const id = `inspector-focal-point-picker-control-${instanceId}`;
  (0,use_update_effect/* default */.A)(() => {
    setShowGridOverlay(true);
    const timeout = window.setTimeout(() => {
      setShowGridOverlay(false);
    }, GRID_OVERLAY_TIMEOUT);
    return () => window.clearTimeout(timeout);
  }, [x, y]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(base_control/* default */.Ay, {
    ...restProps,
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    label: label,
    id: id,
    help: help,
    className: classes,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(MediaWrapper, {
      className: "components-focal-point-picker-wrapper",
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(MediaContainer, {
        className: "components-focal-point-picker",
        onKeyDown: arrowKeyStep,
        onMouseDown: startDrag,
        onBlur: () => {
          if (isDragging) {
            endDrag();
          }
        },
        ref: dragAreaRef,
        role: "button",
        tabIndex: -1,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(FocalPointPickerGrid, {
          bounds: bounds,
          showOverlay: showGridOverlay
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(Media, {
          alt: (0,i18n_build_module.__)('Media preview'),
          autoPlay: autoPlay,
          onLoad: refUpdateBounds.current,
          src: url
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FocalPoint, {
          ...focalPointPosition,
          isDragging: isDragging
        })]
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(FocalPointPickerControls, {
      __nextHasNoMarginBottom: __nextHasNoMarginBottom,
      __next40pxDefaultSize: __next40pxDefaultSize,
      hasHelpText: !!help,
      point: {
        x,
        y
      },
      onChange: value => {
        onChange?.(getFinalValue(value));
      }
    })]
  });
}
/* harmony default export */ const focal_point_picker = (FocalPointPicker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/get-filename.js
/**
 * Returns the filename part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const filename1 = getFilename( 'http://localhost:8080/this/is/a/test.jpg' ); // 'test.jpg'
 * const filename2 = getFilename( '/this/is/a/test.png' ); // 'test.png'
 * ```
 *
 * @return {string|void} The filename part of the URL.
 */
function getFilename(url) {
  let filename;
  if (!url) {
    return;
  }
  try {
    filename = new URL(url, 'http://example.com').pathname.split('/').pop();
  } catch (error) {}
  if (filename) {
    return filename;
  }
}
//# sourceMappingURL=get-filename.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/index.js + 2 modules
var dom_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+blob@4.0.1/node_modules/@wordpress/blob/build-module/index.js
var blob_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+blob@4.0.1/node_modules/@wordpress/blob/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/dropdown/index.js
var dropdown = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/dropdown/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar-button/index.js + 1 modules
var toolbar_button = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar-button/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigable-container/menu.js + 1 modules
var navigable_container_menu = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigable-container/menu.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/form-file-upload/index.js
var form_file_upload = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/form-file-upload/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/debounce/index.js
var debounce = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/debounce/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/higher-order/with-filters/index.js
/**
 * WordPress dependencies
 */




const ANIMATION_FRAME_PERIOD = 16;

/**
 * Creates a higher-order component which adds filtering capability to the
 * wrapped component. Filters get applied when the original component is about
 * to be mounted. When a filter is added or removed that matches the hook name,
 * the wrapped component re-renders.
 *
 * @param hookName Hook name exposed to be used by filters.
 *
 * @return Higher-order component factory.
 *
 * ```jsx
 * import { withFilters } from '@wordpress/components';
 * import { addFilter } from '@wordpress/hooks';
 *
 * const MyComponent = ( { title } ) => <h1>{ title }</h1>;
 *
 * const ComponentToAppend = () => <div>Appended component</div>;
 *
 * function withComponentAppended( FilteredComponent ) {
 * 	return ( props ) => (
 * 		<>
 * 			<FilteredComponent { ...props } />
 * 			<ComponentToAppend />
 * 		</>
 * 	);
 * }
 *
 * addFilter(
 * 	'MyHookName',
 * 	'my-plugin/with-component-appended',
 * 	withComponentAppended
 * );
 *
 * const MyComponentWithFilters = withFilters( 'MyHookName' )( MyComponent );
 * ```
 */
function withFilters(hookName) {
  return (0,create_higher_order_component/* createHigherOrderComponent */.f)(OriginalComponent => {
    const namespace = 'core/with-filters/' + hookName;

    /**
     * The component definition with current filters applied. Each instance
     * reuse this shared reference as an optimization to avoid excessive
     * calls to `applyFilters` when many instances exist.
     */
    let FilteredComponent;

    /**
     * Initializes the FilteredComponent variable once, if not already
     * assigned. Subsequent calls are effectively a noop.
     */
    function ensureFilteredComponent() {
      if (FilteredComponent === undefined) {
        FilteredComponent = (0,hooks_build_module/* applyFilters */.W5)(hookName, OriginalComponent);
      }
    }
    class FilteredComponentRenderer extends react.Component {
      constructor(props) {
        super(props);
        ensureFilteredComponent();
      }
      componentDidMount() {
        FilteredComponentRenderer.instances.push(this);

        // If there were previously no mounted instances for components
        // filtered on this hook, add the hook handler.
        if (FilteredComponentRenderer.instances.length === 1) {
          (0,hooks_build_module/* addAction */.ip)('hookRemoved', namespace, onHooksUpdated);
          (0,hooks_build_module/* addAction */.ip)('hookAdded', namespace, onHooksUpdated);
        }
      }
      componentWillUnmount() {
        FilteredComponentRenderer.instances = FilteredComponentRenderer.instances.filter(instance => instance !== this);

        // If this was the last of the mounted components filtered on
        // this hook, remove the hook handler.
        if (FilteredComponentRenderer.instances.length === 0) {
          (0,hooks_build_module/* removeAction */.V5)('hookRemoved', namespace);
          (0,hooks_build_module/* removeAction */.V5)('hookAdded', namespace);
        }
      }
      render() {
        return /*#__PURE__*/(0,jsx_runtime.jsx)(FilteredComponent, {
          ...this.props
        });
      }
    }
    FilteredComponentRenderer.instances = [];

    /**
     * Updates the FilteredComponent definition, forcing a render for each
     * mounted instance. This occurs a maximum of once per animation frame.
     */
    const throttledForceUpdate = (0,debounce/* debounce */.s)(() => {
      // Recreate the filtered component, only after delay so that it's
      // computed once, even if many filters added.
      FilteredComponent = (0,hooks_build_module/* applyFilters */.W5)(hookName, OriginalComponent);

      // Force each instance to render.
      FilteredComponentRenderer.instances.forEach(instance => {
        instance.forceUpdate();
      });
    }, ANIMATION_FRAME_PERIOD);

    /**
     * When a filter is added or removed for the matching hook name, each
     * mounted instance should re-render with the new filters having been
     * applied to the original component.
     *
     * @param updatedHookName Name of the hook that was updated.
     */
    function onHooksUpdated(updatedHookName) {
      if (updatedHookName === hookName) {
        throttledForceUpdate();
      }
    }
    return FilteredComponentRenderer;
  }, 'withFilters');
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/use-dispatch/use-dispatch-with-map.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Custom react hook for returning aggregate dispatch actions using the provided
 * dispatchMap.
 *
 * Currently this is an internal api only and is implemented by `withDispatch`
 *
 * @param {Function} dispatchMap Receives the `registry.dispatch` function as
 *                               the first argument and the `registry` object
 *                               as the second argument.  Should return an
 *                               object mapping props to functions.
 * @param {Array}    deps        An array of dependencies for the hook.
 * @return {Object}  An object mapping props to functions created by the passed
 *                   in dispatchMap.
 */
const useDispatchWithMap = (dispatchMap, deps) => {
  const registry = (0,use_registry/* default */.A)();
  const currentDispatchMap = (0,react.useRef)(dispatchMap);
  use_isomorphic_layout_effect(() => {
    currentDispatchMap.current = dispatchMap;
  });
  return (0,react.useMemo)(() => {
    const currentDispatchProps = currentDispatchMap.current(registry.dispatch, registry);
    return Object.fromEntries(Object.entries(currentDispatchProps).map(([propName, dispatcher]) => {
      if (typeof dispatcher !== 'function') {
        // eslint-disable-next-line no-console
        console.warn(`Property ${propName} returned from dispatchMap in useDispatchWithMap must be a function.`);
      }
      return [propName, (...args) => currentDispatchMap.current(registry.dispatch, registry)[propName](...args)];
    }));
  }, [registry, ...deps]);
};
/* harmony default export */ const use_dispatch_with_map = (useDispatchWithMap);
//# sourceMappingURL=use-dispatch-with-map.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/with-dispatch/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/** @typedef {import('react').ComponentType} ComponentType */

/**
 * Higher-order component used to add dispatch props using registered action
 * creators.
 *
 * @param {Function} mapDispatchToProps A function of returning an object of
 *                                      prop names where value is a
 *                                      dispatch-bound action creator, or a
 *                                      function to be called with the
 *                                      component's props and returning an
 *                                      action creator.
 *
 * @example
 * ```jsx
 * function Button( { onClick, children } ) {
 *     return <button type="button" onClick={ onClick }>{ children }</button>;
 * }
 *
 * import { withDispatch } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * const SaleButton = withDispatch( ( dispatch, ownProps ) => {
 *     const { startSale } = dispatch( myCustomStore );
 *     const { discountPercent } = ownProps;
 *
 *     return {
 *         onClick() {
 *             startSale( discountPercent );
 *         },
 *     };
 * } )( Button );
 *
 * // Rendered in the application:
 * //
 * // <SaleButton discountPercent="20">Start Sale!</SaleButton>
 * ```
 *
 * @example
 * In the majority of cases, it will be sufficient to use only two first params
 * passed to `mapDispatchToProps` as illustrated in the previous example.
 * However, there might be some very advanced use cases where using the
 * `registry` object might be used as a tool to optimize the performance of
 * your component. Using `select` function from the registry might be useful
 * when you need to fetch some dynamic data from the store at the time when the
 * event is fired, but at the same time, you never use it to render your
 * component. In such scenario, you can avoid using the `withSelect` higher
 * order component to compute such prop, which might lead to unnecessary
 * re-renders of your component caused by its frequent value change.
 * Keep in mind, that `mapDispatchToProps` must return an object with functions
 * only.
 *
 * ```jsx
 * function Button( { onClick, children } ) {
 *     return <button type="button" onClick={ onClick }>{ children }</button>;
 * }
 *
 * import { withDispatch } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * const SaleButton = withDispatch( ( dispatch, ownProps, { select } ) => {
 *    // Stock number changes frequently.
 *    const { getStockNumber } = select( myCustomStore );
 *    const { startSale } = dispatch( myCustomStore );
 *    return {
 *        onClick() {
 *            const discountPercent = getStockNumber() > 50 ? 10 : 20;
 *            startSale( discountPercent );
 *        },
 *    };
 * } )( Button );
 *
 * // Rendered in the application:
 * //
 * //  <SaleButton>Start Sale!</SaleButton>
 * ```
 *
 * _Note:_ It is important that the `mapDispatchToProps` function always
 * returns an object with the same keys. For example, it should not contain
 * conditions under which a different value would be returned.
 *
 * @return {ComponentType} Enhanced component with merged dispatcher props.
 */

const withDispatch = mapDispatchToProps => (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => ownProps => {
  const mapDispatch = (dispatch, registry) => mapDispatchToProps(dispatch, ownProps, registry);
  const dispatchProps = use_dispatch_with_map(mapDispatch, []);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(WrappedComponent, {
    ...ownProps,
    ...dispatchProps
  });
}, 'withDispatch');
/* harmony default export */ const with_dispatch = (withDispatch);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+keycodes@4.0.1/node_modules/@wordpress/keycodes/build-module/index.js
var keycodes_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+keycodes@4.0.1/node_modules/@wordpress/keycodes/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/media.js
/**
 * WordPress dependencies
 */


const media = /*#__PURE__*/(0,jsx_runtime.jsxs)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m7 6.5 4 2.5-4 2.5z"
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "m5 3c-1.10457 0-2 .89543-2 2v14c0 1.1046.89543 2 2 2h14c1.1046 0 2-.8954 2-2v-14c0-1.10457-.8954-2-2-2zm14 1.5h-14c-.27614 0-.5.22386-.5.5v10.7072l3.62953-2.6465c.25108-.1831.58905-.1924.84981-.0234l2.92666 1.8969 3.5712-3.4719c.2911-.2831.7545-.2831 1.0456 0l2.9772 2.8945v-9.3568c0-.27614-.2239-.5-.5-.5zm-14.5 14.5v-1.4364l4.09643-2.987 2.99567 1.9417c.2936.1903.6798.1523.9307-.0917l3.4772-3.3806 3.4772 3.3806.0228-.0234v2.5968c0 .2761-.2239.5-.5.5h-14c-.27614 0-.5-.2239-.5-.5z"
  })]
});
/* harmony default export */ const library_media = (media);
//# sourceMappingURL=media.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/upload.js
var upload = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/upload.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/post-featured-image.js
/**
 * WordPress dependencies
 */


const postFeaturedImage = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M19 3H5c-.6 0-1 .4-1 1v7c0 .5.4 1 1 1h14c.5 0 1-.4 1-1V4c0-.6-.4-1-1-1zM5.5 10.5v-.4l1.8-1.3 1.3.8c.3.2.7.2.9-.1L11 8.1l2.4 2.4H5.5zm13 0h-2.9l-4-4c-.3-.3-.8-.3-1.1 0L8.9 8l-1.2-.8c-.3-.2-.6-.2-.9 0l-1.3 1V4.5h13v6zM4 20h9v-1.5H4V20zm0-4h16v-1.5H4V16z"
  })
});
/* harmony default export */ const post_featured_image = (postFeaturedImage);
//# sourceMappingURL=post-featured-image.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/compose.js
var compose = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/compose.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/strip-html.js
var strip_html = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/strip-html.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/media-upload/index.js
/**
 * WordPress dependencies
 */


/**
 * This is a placeholder for the media upload component necessary to make it possible to provide
 * an integration with the core blocks that handle media files. By default it renders nothing but
 * it provides a way to have it overridden with the `editor.MediaUpload` filter.
 *
 * @return {Component} The component to be rendered.
 */
const MediaUpload = () => null;

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-upload/README.md
 */
/* harmony default export */ const media_upload = (withFilters('editor.MediaUpload')(MediaUpload));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/media-upload/check.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

function MediaUploadCheck({
  fallback = null,
  children
}) {
  const hasUploadPermissions = (0,use_select/* default */.A)(select => {
    const {
      getSettings
    } = select(store_store);
    return !!getSettings().mediaUpload;
  }, []);
  return hasUploadPermissions ? children : fallback;
}

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-upload/README.md
 */
/* harmony default export */ const media_upload_check = (MediaUploadCheck);
//# sourceMappingURL=check.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/spinner/index.js + 1 modules
var spinner = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/spinner/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/text-control/index.js
var text_control = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/text-control/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/notice/index.js
var notice = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/notice/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.10.0/node_modules/@wordpress/is-shallow-equal/build-module/objects.js
var objects = __webpack_require__("../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.10.0/node_modules/@wordpress/is-shallow-equal/build-module/objects.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+preferences@4.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_sgab4ar2tci4ud4kulkqwbhmly/node_modules/@wordpress/preferences/build-module/store/reducer.js
/**
 * WordPress dependencies
 */


/**
 * Reducer returning the defaults for user preferences.
 *
 * This is kept intentionally separate from the preferences
 * themselves so that defaults are not persisted.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function defaults(state = {}, action) {
  if (action.type === 'SET_PREFERENCE_DEFAULTS') {
    const {
      scope,
      defaults: values
    } = action;
    return {
      ...state,
      [scope]: {
        ...state[scope],
        ...values
      }
    };
  }
  return state;
}

/**
 * Higher order reducer that does the following:
 * - Merges any data from the persistence layer into the state when the
 *   `SET_PERSISTENCE_LAYER` action is received.
 * - Passes any preferences changes to the persistence layer.
 *
 * @param {Function} reducer The preferences reducer.
 *
 * @return {Function} The enhanced reducer.
 */
function withPersistenceLayer(reducer) {
  let persistenceLayer;
  return (state, action) => {
    // Setup the persistence layer, and return the persisted data
    // as the state.
    if (action.type === 'SET_PERSISTENCE_LAYER') {
      const {
        persistenceLayer: persistence,
        persistedData
      } = action;
      persistenceLayer = persistence;
      return persistedData;
    }
    const nextState = reducer(state, action);
    if (action.type === 'SET_PREFERENCE_VALUE') {
      persistenceLayer?.set(nextState);
    }
    return nextState;
  };
}

/**
 * Reducer returning the user preferences.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
const reducer_preferences = withPersistenceLayer((state = {}, action) => {
  if (action.type === 'SET_PREFERENCE_VALUE') {
    const {
      scope,
      name,
      value
    } = action;
    return {
      ...state,
      [scope]: {
        ...state[scope],
        [name]: value
      }
    };
  }
  return state;
});
/* harmony default export */ const build_module_store_reducer = ((0,data_build_module/* combineReducers */.HY)({
  defaults,
  preferences: reducer_preferences
}));
//# sourceMappingURL=reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+preferences@4.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_sgab4ar2tci4ud4kulkqwbhmly/node_modules/@wordpress/preferences/build-module/store/actions.js
/**
 * Returns an action object used in signalling that a preference should be
 * toggled.
 *
 * @param {string} scope The preference scope (e.g. core/edit-post).
 * @param {string} name  The preference name.
 */
function toggle(scope, name) {
  return function ({
    select,
    dispatch
  }) {
    const currentValue = select.get(scope, name);
    dispatch.set(scope, name, !currentValue);
  };
}

/**
 * Returns an action object used in signalling that a preference should be set
 * to a value
 *
 * @param {string} scope The preference scope (e.g. core/edit-post).
 * @param {string} name  The preference name.
 * @param {*}      value The value to set.
 *
 * @return {Object} Action object.
 */
function set(scope, name, value) {
  return {
    type: 'SET_PREFERENCE_VALUE',
    scope,
    name,
    value
  };
}

/**
 * Returns an action object used in signalling that preference defaults should
 * be set.
 *
 * @param {string}            scope    The preference scope (e.g. core/edit-post).
 * @param {Object<string, *>} defaults A key/value map of preference names to values.
 *
 * @return {Object} Action object.
 */
function setDefaults(scope, defaults) {
  return {
    type: 'SET_PREFERENCE_DEFAULTS',
    scope,
    defaults
  };
}

/** @typedef {() => Promise<Object>} WPPreferencesPersistenceLayerGet */
/** @typedef {(Object) => void} WPPreferencesPersistenceLayerSet */
/**
 * @typedef WPPreferencesPersistenceLayer
 *
 * @property {WPPreferencesPersistenceLayerGet} get An async function that gets data from the persistence layer.
 * @property {WPPreferencesPersistenceLayerSet} set A function that sets data in the persistence layer.
 */

/**
 * Sets the persistence layer.
 *
 * When a persistence layer is set, the preferences store will:
 * - call `get` immediately and update the store state to the value returned.
 * - call `set` with all preferences whenever a preference changes value.
 *
 * `setPersistenceLayer` should ideally be dispatched at the start of an
 * application's lifecycle, before any other actions have been dispatched to
 * the preferences store.
 *
 * @param {WPPreferencesPersistenceLayer} persistenceLayer The persistence layer.
 *
 * @return {Object} Action object.
 */
async function setPersistenceLayer(persistenceLayer) {
  const persistedData = await persistenceLayer.get();
  return {
    type: 'SET_PERSISTENCE_LAYER',
    persistenceLayer,
    persistedData
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+preferences@4.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_sgab4ar2tci4ud4kulkqwbhmly/node_modules/@wordpress/preferences/build-module/store/selectors.js
/**
 * WordPress dependencies
 */

const withDeprecatedKeys = originalGet => (state, scope, name) => {
  const settingsToMoveToCore = ['allowRightClickOverrides', 'distractionFree', 'editorMode', 'fixedToolbar', 'focusMode', 'hiddenBlockTypes', 'inactivePanels', 'keepCaretInsideBlock', 'mostUsedBlocks', 'openPanels', 'showBlockBreadcrumbs', 'showIconLabels', 'showListViewByDefault', 'isPublishSidebarEnabled', 'isComplementaryAreaVisible', 'pinnedItems'];
  if (settingsToMoveToCore.includes(name) && ['core/edit-post', 'core/edit-site'].includes(scope)) {
    (0,deprecated_build_module/* default */.A)(`wp.data.select( 'core/preferences' ).get( '${scope}', '${name}' )`, {
      since: '6.5',
      alternative: `wp.data.select( 'core/preferences' ).get( 'core', '${name}' )`
    });
    return originalGet(state, 'core', name);
  }
  return originalGet(state, scope, name);
};

/**
 * Returns a boolean indicating whether a prefer is active for a particular
 * scope.
 *
 * @param {Object} state The store state.
 * @param {string} scope The scope of the feature (e.g. core/edit-post).
 * @param {string} name  The name of the feature.
 *
 * @return {*} Is the feature enabled?
 */
const get = withDeprecatedKeys((state, scope, name) => {
  const value = state.preferences[scope]?.[name];
  return value !== undefined ? value : state.defaults[scope]?.[name];
});
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+preferences@4.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_sgab4ar2tci4ud4kulkqwbhmly/node_modules/@wordpress/preferences/build-module/store/constants.js
/**
 * The identifier for the data store.
 *
 * @type {string}
 */
const constants_STORE_NAME = 'core/preferences';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+preferences@4.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_sgab4ar2tci4ud4kulkqwbhmly/node_modules/@wordpress/preferences/build-module/store/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





/**
 * Store definition for the preferences namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */
const build_module_store_store = (0,redux_store/* default */.A)(constants_STORE_NAME, {
  reducer: build_module_store_reducer,
  actions: build_module_store_actions_namespaceObject,
  selectors: build_module_store_selectors_namespaceObject
});
(0,data_build_module/* register */.kz)(build_module_store_store);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/keyboard-return.js
/**
 * WordPress dependencies
 */


const keyboardReturn = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m6.734 16.106 2.176-2.38-1.093-1.028-3.846 4.158 3.846 4.158 1.093-1.028-2.176-2.38h2.811c1.125 0 2.25.03 3.374 0 1.428-.001 3.362-.25 4.963-1.277 1.66-1.065 2.868-2.906 2.868-5.859 0-2.479-1.327-4.896-3.65-5.93-1.82-.813-3.044-.8-4.806-.788l-.567.002v1.5c.184 0 .368 0 .553-.002 1.82-.007 2.704-.014 4.21.657 1.854.827 2.76 2.657 2.76 4.561 0 2.472-.973 3.824-2.178 4.596-1.258.807-2.864 1.04-4.163 1.04h-.02c-1.115.03-2.229 0-3.344 0H6.734Z"
  })
});
/* harmony default export */ const keyboard_return = (keyboardReturn);
//# sourceMappingURL=keyboard-return.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs + 3 modules
var AnimatePresence = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-left-small.js
/**
 * WordPress dependencies
 */


const chevronLeftSmall = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m13.1 16-3.4-4 3.4-4 1.1 1-2.6 3 2.6 3-1.1 1z"
  })
});
/* harmony default export */ const chevron_left_small = (chevronLeftSmall);
//# sourceMappingURL=chevron-left-small.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/settings-drawer.js
/**
 * WordPress dependencies
 */








function LinkSettingsDrawer({
  children,
  settingsOpen,
  setSettingsOpen
}) {
  const prefersReducedMotion = (0,use_reduced_motion/* default */.A)();
  const MaybeAnimatePresence = prefersReducedMotion ? react.Fragment : AnimatePresence/* AnimatePresence */.N;
  const MaybeMotionDiv = prefersReducedMotion ? 'div' : motion/* motion */.P.div;
  const id = (0,use_instance_id/* default */.A)(LinkSettingsDrawer);
  const settingsDrawerId = `link-control-settings-drawer-${id}`;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      className: "block-editor-link-control__drawer-toggle",
      "aria-expanded": settingsOpen,
      onClick: () => setSettingsOpen(!settingsOpen),
      icon: (0,i18n_build_module/* isRTL */.V8)() ? chevron_left_small : chevron_right_small/* default */.A,
      "aria-controls": settingsDrawerId,
      children: (0,i18n_build_module._x)('Advanced', 'Additional link settings')
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(MaybeAnimatePresence, {
      children: settingsOpen && /*#__PURE__*/(0,jsx_runtime.jsx)(MaybeMotionDiv, {
        className: "block-editor-link-control__drawer",
        hidden: !settingsOpen,
        id: settingsDrawerId,
        initial: "collapsed",
        animate: "open",
        exit: "collapsed",
        variants: {
          open: {
            opacity: 1,
            height: 'auto'
          },
          collapsed: {
            opacity: 0,
            height: 0
          }
        },
        transition: {
          duration: 0.1
        },
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          className: "block-editor-link-control__drawer-inner",
          children: children
        })
      })
    })]
  });
}
/* harmony default export */ const settings_drawer = (LinkSettingsDrawer);
//# sourceMappingURL=settings-drawer.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/higher-order/with-spoken-messages/index.js
var with_spoken_messages = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/higher-order/with-spoken-messages/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/with-safe-timeout/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * We cannot use the `Window['setTimeout']` and `Window['clearTimeout']`
 * types here because those functions include functionality that is not handled
 * by this component, like the ability to pass extra arguments.
 *
 * In the case of this component, we only handle the simplest case where
 * `setTimeout` only accepts a function (not a string) and an optional delay.
 */

/**
 * A higher-order component used to provide and manage delayed function calls
 * that ought to be bound to a component's lifecycle.
 */
const withSafeTimeout = (0,create_higher_order_component/* createHigherOrderComponent */.f)(OriginalComponent => {
  return class WrappedComponent extends react.Component {
    constructor(props) {
      super(props);
      this.timeouts = [];
      this.setTimeout = this.setTimeout.bind(this);
      this.clearTimeout = this.clearTimeout.bind(this);
    }
    componentWillUnmount() {
      this.timeouts.forEach(clearTimeout);
    }
    setTimeout(fn, delay) {
      const id = setTimeout(() => {
        fn();
        this.clearTimeout(id);
      }, delay);
      this.timeouts.push(id);
      return id;
    }
    clearTimeout(id) {
      clearTimeout(id);
      this.timeouts = this.timeouts.filter(timeoutId => timeoutId !== id);
    }
    render() {
      return (
        /*#__PURE__*/
        // @ts-ignore
        (0,jsx_runtime.jsx)(OriginalComponent, {
          ...this.props,
          setTimeout: this.setTimeout,
          clearTimeout: this.clearTimeout
        })
      );
    }
  };
}, 'withSafeTimeout');
/* harmony default export */ const with_safe_timeout = (withSafeTimeout);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/with-instance-id/index.js
var with_instance_id = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/with-instance-id/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/pure/index.js
var pure = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/pure/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/with-select/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/** @typedef {import('react').ComponentType} ComponentType */

/**
 * Higher-order component used to inject state-derived props using registered
 * selectors.
 *
 * @param {Function} mapSelectToProps Function called on every state change,
 *                                    expected to return object of props to
 *                                    merge with the component's own props.
 *
 * @example
 * ```js
 * import { withSelect } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * function PriceDisplay( { price, currency } ) {
 * 	return new Intl.NumberFormat( 'en-US', {
 * 		style: 'currency',
 * 		currency,
 * 	} ).format( price );
 * }
 *
 * const HammerPriceDisplay = withSelect( ( select, ownProps ) => {
 * 	const { getPrice } = select( myCustomStore );
 * 	const { currency } = ownProps;
 *
 * 	return {
 * 		price: getPrice( 'hammer', currency ),
 * 	};
 * } )( PriceDisplay );
 *
 * // Rendered in the application:
 * //
 * //  <HammerPriceDisplay currency="USD" />
 * ```
 * In the above example, when `HammerPriceDisplay` is rendered into an
 * application, it will pass the price into the underlying `PriceDisplay`
 * component and update automatically if the price of a hammer ever changes in
 * the store.
 *
 * @return {ComponentType} Enhanced component with merged state data props.
 */

const withSelect = mapSelectToProps => (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => (0,pure/* default */.A)(ownProps => {
  const mapSelect = (select, registry) => mapSelectToProps(select, ownProps, registry);
  const mergeProps = (0,use_select/* default */.A)(mapSelect);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(WrappedComponent, {
    ...ownProps,
    ...mergeProps
  });
}), 'withSelect');
/* harmony default export */ const with_select = (withSelect);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/is-url.js
/**
 * Determines whether the given string looks like a URL.
 *
 * @param {string} url The string to scrutinise.
 *
 * @example
 * ```js
 * const isURL = isURL( 'https://wordpress.org' ); // true
 * ```
 *
 * @see https://url.spec.whatwg.org/
 * @see https://url.spec.whatwg.org/#valid-url-string
 *
 * @return {boolean} Whether or not it looks like a URL.
 */
function isURL(url) {
  // A URL can be considered value if the `URL` constructor is able to parse
  // it. The constructor throws an error for an invalid URL.
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}
//# sourceMappingURL=is-url.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/url-input/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */


/**
 * Whether the argument is a function.
 *
 * @param {*} maybeFunc The argument to check.
 * @return {boolean} True if the argument is a function, false otherwise.
 */




function isFunction(maybeFunc) {
  return typeof maybeFunc === 'function';
}
class URLInput extends react.Component {
  constructor(props) {
    super(props);
    this.onChange = this.onChange.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.selectLink = this.selectLink.bind(this);
    this.handleOnClick = this.handleOnClick.bind(this);
    this.bindSuggestionNode = this.bindSuggestionNode.bind(this);
    this.autocompleteRef = props.autocompleteRef || (0,react.createRef)();
    this.inputRef = (0,react.createRef)();
    this.updateSuggestions = (0,debounce/* debounce */.s)(this.updateSuggestions.bind(this), 200);
    this.suggestionNodes = [];
    this.suggestionsRequest = null;
    this.state = {
      suggestions: [],
      showSuggestions: false,
      suggestionsValue: null,
      selectedSuggestion: null,
      suggestionsListboxId: '',
      suggestionOptionIdPrefix: ''
    };
  }
  componentDidUpdate(prevProps) {
    const {
      showSuggestions,
      selectedSuggestion
    } = this.state;
    const {
      value,
      __experimentalShowInitialSuggestions = false
    } = this.props;

    // Only have to worry about scrolling selected suggestion into view
    // when already expanded.
    if (showSuggestions && selectedSuggestion !== null && this.suggestionNodes[selectedSuggestion]) {
      this.suggestionNodes[selectedSuggestion].scrollIntoView({
        behavior: 'instant',
        block: 'nearest',
        inline: 'nearest'
      });
    }

    // Update suggestions when the value changes.
    if (prevProps.value !== value && !this.props.disableSuggestions) {
      if (value?.length) {
        // If the new value is not empty we need to update with suggestions for it.
        this.updateSuggestions(value);
      } else if (__experimentalShowInitialSuggestions) {
        // If the new value is empty and we can show initial suggestions, then show initial suggestions.
        this.updateSuggestions();
      }
    }
  }
  componentDidMount() {
    if (this.shouldShowInitialSuggestions()) {
      this.updateSuggestions();
    }
  }
  componentWillUnmount() {
    this.suggestionsRequest?.cancel?.();
    this.suggestionsRequest = null;
  }
  bindSuggestionNode(index) {
    return ref => {
      this.suggestionNodes[index] = ref;
    };
  }
  shouldShowInitialSuggestions() {
    const {
      __experimentalShowInitialSuggestions = false,
      value
    } = this.props;
    return __experimentalShowInitialSuggestions && !(value && value.length);
  }
  updateSuggestions(value = '') {
    const {
      __experimentalFetchLinkSuggestions: fetchLinkSuggestions,
      __experimentalHandleURLSuggestions: handleURLSuggestions
    } = this.props;
    if (!fetchLinkSuggestions) {
      return;
    }

    // Initial suggestions may only show if there is no value
    // (note: this includes whitespace).
    const isInitialSuggestions = !value?.length;

    // Trim only now we've determined whether or not it originally had a "length"
    // (even if that value was all whitespace).
    value = value.trim();

    // Allow a suggestions request if:
    // - there are at least 2 characters in the search input (except manual searches where
    //   search input length is not required to trigger a fetch)
    // - this is a direct entry (eg: a URL)
    if (!isInitialSuggestions && (value.length < 2 || !handleURLSuggestions && isURL(value))) {
      this.suggestionsRequest?.cancel?.();
      this.suggestionsRequest = null;
      this.setState({
        suggestions: [],
        showSuggestions: false,
        suggestionsValue: value,
        selectedSuggestion: null,
        loading: false
      });
      return;
    }
    this.setState({
      selectedSuggestion: null,
      loading: true
    });
    const request = fetchLinkSuggestions(value, {
      isInitialSuggestions
    });
    request.then(suggestions => {
      // A fetch Promise doesn't have an abort option. It's mimicked by
      // comparing the request reference in on the instance, which is
      // reset or deleted on subsequent requests or unmounting.
      if (this.suggestionsRequest !== request) {
        return;
      }
      this.setState({
        suggestions,
        suggestionsValue: value,
        loading: false,
        showSuggestions: !!suggestions.length
      });
      if (!!suggestions.length) {
        this.props.debouncedSpeak((0,i18n_build_module/* sprintf */.nv)( /* translators: %s: number of results. */
        (0,i18n_build_module._n)('%d result found, use up and down arrow keys to navigate.', '%d results found, use up and down arrow keys to navigate.', suggestions.length), suggestions.length), 'assertive');
      } else {
        this.props.debouncedSpeak((0,i18n_build_module.__)('No results.'), 'assertive');
      }
    }).catch(() => {
      if (this.suggestionsRequest !== request) {
        return;
      }
      this.setState({
        loading: false
      });
    }).finally(() => {
      // If this is the current promise then reset the reference
      // to allow for checking if a new request is made.
      if (this.suggestionsRequest === request) {
        this.suggestionsRequest = null;
      }
    });

    // Note that this assignment is handled *before* the async search request
    // as a Promise always resolves on the next tick of the event loop.
    this.suggestionsRequest = request;
  }
  onChange(event) {
    this.props.onChange(event.target.value);
  }
  onFocus() {
    const {
      suggestions
    } = this.state;
    const {
      disableSuggestions,
      value
    } = this.props;

    // When opening the link editor, if there's a value present, we want to load the suggestions pane with the results for this input search value
    // Don't re-run the suggestions on focus if there are already suggestions present (prevents searching again when tabbing between the input and buttons)
    // or there is already a request in progress.
    if (value && !disableSuggestions && !(suggestions && suggestions.length) && this.suggestionsRequest === null) {
      // Ensure the suggestions are updated with the current input value.
      this.updateSuggestions(value);
    }
  }
  onKeyDown(event) {
    this.props.onKeyDown?.(event);
    const {
      showSuggestions,
      selectedSuggestion,
      suggestions,
      loading
    } = this.state;

    // If the suggestions are not shown or loading, we shouldn't handle the arrow keys
    // We shouldn't preventDefault to allow block arrow keys navigation.
    if (!showSuggestions || !suggestions.length || loading) {
      // In the Windows version of Firefox the up and down arrows don't move the caret
      // within an input field like they do for Mac Firefox/Chrome/Safari. This causes
      // a form of focus trapping that is disruptive to the user experience. This disruption
      // only happens if the caret is not in the first or last position in the text input.
      // See: https://github.com/WordPress/gutenberg/issues/5693#issuecomment-436684747
      switch (event.keyCode) {
        // When UP is pressed, if the caret is at the start of the text, move it to the 0
        // position.
        case keycodes_build_module.UP:
          {
            if (0 !== event.target.selectionStart) {
              event.preventDefault();

              // Set the input caret to position 0.
              event.target.setSelectionRange(0, 0);
            }
            break;
          }
        // When DOWN is pressed, if the caret is not at the end of the text, move it to the
        // last position.
        case keycodes_build_module/* DOWN */.PX:
          {
            if (this.props.value.length !== event.target.selectionStart) {
              event.preventDefault();

              // Set the input caret to the last position.
              event.target.setSelectionRange(this.props.value.length, this.props.value.length);
            }
            break;
          }

        // Submitting while loading should trigger onSubmit.
        case keycodes_build_module/* ENTER */.Fm:
          {
            if (this.props.onSubmit) {
              event.preventDefault();
              this.props.onSubmit(null, event);
            }
            break;
          }
      }
      return;
    }
    const suggestion = this.state.suggestions[this.state.selectedSuggestion];
    switch (event.keyCode) {
      case keycodes_build_module.UP:
        {
          event.preventDefault();
          const previousIndex = !selectedSuggestion ? suggestions.length - 1 : selectedSuggestion - 1;
          this.setState({
            selectedSuggestion: previousIndex
          });
          break;
        }
      case keycodes_build_module/* DOWN */.PX:
        {
          event.preventDefault();
          const nextIndex = selectedSuggestion === null || selectedSuggestion === suggestions.length - 1 ? 0 : selectedSuggestion + 1;
          this.setState({
            selectedSuggestion: nextIndex
          });
          break;
        }
      case keycodes_build_module/* TAB */.wn:
        {
          if (this.state.selectedSuggestion !== null) {
            this.selectLink(suggestion);
            // Announce a link has been selected when tabbing away from the input field.
            this.props.speak((0,i18n_build_module.__)('Link selected.'));
          }
          break;
        }
      case keycodes_build_module/* ENTER */.Fm:
        {
          event.preventDefault();
          if (this.state.selectedSuggestion !== null) {
            this.selectLink(suggestion);
            if (this.props.onSubmit) {
              this.props.onSubmit(suggestion, event);
            }
          } else if (this.props.onSubmit) {
            this.props.onSubmit(null, event);
          }
          break;
        }
    }
  }
  selectLink(suggestion) {
    this.props.onChange(suggestion.url, suggestion);
    this.setState({
      selectedSuggestion: null,
      showSuggestions: false
    });
  }
  handleOnClick(suggestion) {
    this.selectLink(suggestion);
    // Move focus to the input field when a link suggestion is clicked.
    this.inputRef.current.focus();
  }
  static getDerivedStateFromProps({
    value,
    instanceId,
    disableSuggestions,
    __experimentalShowInitialSuggestions = false
  }, {
    showSuggestions
  }) {
    let shouldShowSuggestions = showSuggestions;
    const hasValue = value && value.length;
    if (!__experimentalShowInitialSuggestions && !hasValue) {
      shouldShowSuggestions = false;
    }
    if (disableSuggestions === true) {
      shouldShowSuggestions = false;
    }
    return {
      showSuggestions: shouldShowSuggestions,
      suggestionsListboxId: `block-editor-url-input-suggestions-${instanceId}`,
      suggestionOptionIdPrefix: `block-editor-url-input-suggestion-${instanceId}`
    };
  }
  render() {
    return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [this.renderControl(), this.renderSuggestions()]
    });
  }
  renderControl() {
    const {
      /** Start opting into the new margin-free styles that will become the default in a future version. */
      __nextHasNoMarginBottom = false,
      label = null,
      className,
      isFullWidth,
      instanceId,
      placeholder = (0,i18n_build_module.__)('Paste URL or type to search'),
      __experimentalRenderControl: renderControl,
      value = '',
      hideLabelFromVision = false
    } = this.props;
    const {
      loading,
      showSuggestions,
      selectedSuggestion,
      suggestionsListboxId,
      suggestionOptionIdPrefix
    } = this.state;
    const inputId = `url-input-control-${instanceId}`;
    const controlProps = {
      id: inputId,
      // Passes attribute to label for the for attribute
      label,
      className: (0,dist_clsx/* default */.A)('block-editor-url-input', className, {
        'is-full-width': isFullWidth
      }),
      hideLabelFromVision
    };
    const inputProps = {
      id: inputId,
      value,
      required: true,
      className: 'block-editor-url-input__input',
      type: 'text',
      onChange: this.onChange,
      onFocus: this.onFocus,
      placeholder,
      onKeyDown: this.onKeyDown,
      role: 'combobox',
      'aria-label': label ? undefined : (0,i18n_build_module.__)('URL'),
      // Ensure input always has an accessible label
      'aria-expanded': showSuggestions,
      'aria-autocomplete': 'list',
      'aria-owns': suggestionsListboxId,
      'aria-activedescendant': selectedSuggestion !== null ? `${suggestionOptionIdPrefix}-${selectedSuggestion}` : undefined,
      ref: this.inputRef
    };
    if (renderControl) {
      return renderControl(controlProps, inputProps, loading);
    }
    if (!__nextHasNoMarginBottom) {
      (0,deprecated_build_module/* default */.A)('Bottom margin styles for wp.blockEditor.URLInput', {
        since: '6.2',
        version: '6.5',
        hint: 'Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version'
      });
    }
    return /*#__PURE__*/(0,jsx_runtime.jsxs)(base_control/* default */.Ay, {
      __nextHasNoMarginBottom: __nextHasNoMarginBottom,
      ...controlProps,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", {
        ...inputProps
      }), loading && /*#__PURE__*/(0,jsx_runtime.jsx)(spinner/* default */.Ay, {})]
    });
  }
  renderSuggestions() {
    const {
      className,
      __experimentalRenderSuggestions: renderSuggestions
    } = this.props;
    const {
      showSuggestions,
      suggestions,
      suggestionsValue,
      selectedSuggestion,
      suggestionsListboxId,
      suggestionOptionIdPrefix,
      loading
    } = this.state;
    if (!showSuggestions || suggestions.length === 0) {
      return null;
    }
    const suggestionsListProps = {
      id: suggestionsListboxId,
      ref: this.autocompleteRef,
      role: 'listbox'
    };
    const buildSuggestionItemProps = (suggestion, index) => {
      return {
        role: 'option',
        tabIndex: '-1',
        id: `${suggestionOptionIdPrefix}-${index}`,
        ref: this.bindSuggestionNode(index),
        'aria-selected': index === selectedSuggestion ? true : undefined
      };
    };
    if (isFunction(renderSuggestions)) {
      return renderSuggestions({
        suggestions,
        selectedSuggestion,
        suggestionsListProps,
        buildSuggestionItemProps,
        isLoading: loading,
        handleSuggestionClick: this.handleOnClick,
        isInitialSuggestions: !suggestionsValue?.length,
        currentInputValue: suggestionsValue
      });
    }
    return /*#__PURE__*/(0,jsx_runtime.jsx)(popover/* default */.Ay, {
      placement: "bottom",
      focusOnMount: false,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        ...suggestionsListProps,
        className: (0,dist_clsx/* default */.A)('block-editor-url-input__suggestions', `${className}__suggestions`),
        children: suggestions.map((suggestion, index) => /*#__PURE__*/(0,react.createElement)(build_module_button/* default */.Ay, {
          ...buildSuggestionItemProps(suggestion, index),
          key: suggestion.id,
          className: (0,dist_clsx/* default */.A)('block-editor-url-input__suggestion', {
            'is-selected': index === selectedSuggestion
          }),
          onClick: () => this.handleOnClick(suggestion)
        }, suggestion.title))
      })
    });
  }
}

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/url-input/README.md
 */
/* harmony default export */ const url_input = ((0,compose/* default */.A)(with_safe_timeout, with_spoken_messages/* default */.A, with_instance_id/* default */.A, with_select((select, props) => {
  // If a link suggestions handler is already provided then
  // bail.
  if (isFunction(props.__experimentalFetchLinkSuggestions)) {
    return;
  }
  const {
    getSettings
  } = select(store_store);
  return {
    __experimentalFetchLinkSuggestions: getSettings().__experimentalFetchLinkSuggestions
  };
}))(URLInput));
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/create-interpolate-element.js
var create_interpolate_element = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/create-interpolate-element.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/search-create-button.js
/**
 * WordPress dependencies
 */





const LinkControlSearchCreate = ({
  searchTerm,
  onClick,
  itemProps,
  buttonText
}) => {
  if (!searchTerm) {
    return null;
  }
  let text;
  if (buttonText) {
    text = typeof buttonText === 'function' ? buttonText(searchTerm) : buttonText;
  } else {
    text = (0,create_interpolate_element/* default */.A)((0,i18n_build_module/* sprintf */.nv)( /* translators: %s: search term. */
    (0,i18n_build_module.__)('Create: <mark>%s</mark>'), searchTerm), {
      mark: /*#__PURE__*/(0,jsx_runtime.jsx)("mark", {})
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
    ...itemProps,
    iconPosition: "left",
    icon: plus/* default */.A,
    className: "block-editor-link-control__search-item",
    onClick: onClick,
    children: text
  });
};
/* harmony default export */ const search_create_button = (LinkControlSearchCreate);
//# sourceMappingURL=search-create-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/text-highlight/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Highlights occurrences of a given string within another string of text. Wraps
 * each match with a `<mark>` tag which provides browser default styling.
 *
 * ```jsx
 * import { TextHighlight } from '@wordpress/components';
 *
 * const MyTextHighlight = () => (
 *   <TextHighlight
 *     text="Why do we like Gutenberg? Because Gutenberg is the best!"
 *     highlight="Gutenberg"
 *   />
 * );
 * ```
 */
const TextHighlight = props => {
  const {
    text = '',
    highlight = ''
  } = props;
  const trimmedHighlightText = highlight.trim();
  if (!trimmedHighlightText) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
      children: text
    });
  }
  const regex = new RegExp(`(${(0,strings/* escapeRegExp */.Nt)(trimmedHighlightText)})`, 'gi');
  return (0,create_interpolate_element/* default */.A)(text.replace(regex, '<mark>$&</mark>'), {
    mark: /*#__PURE__*/(0,jsx_runtime.jsx)("mark", {})
  });
};
/* harmony default export */ const text_highlight = (TextHighlight);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/post-list.js
/**
 * WordPress dependencies
 */


const postList = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M18 5.5H6a.5.5 0 0 0-.5.5v12a.5.5 0 0 0 .5.5h12a.5.5 0 0 0 .5-.5V6a.5.5 0 0 0-.5-.5ZM6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm1 5h1.5v1.5H7V9Zm1.5 4.5H7V15h1.5v-1.5ZM10 9h7v1.5h-7V9Zm7 4.5h-7V15h7v-1.5Z"
  })
});
/* harmony default export */ const post_list = (postList);
//# sourceMappingURL=post-list.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/page.js
/**
 * WordPress dependencies
 */


const page = /*#__PURE__*/(0,jsx_runtime.jsxs)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M15.5 7.5h-7V9h7V7.5Zm-7 3.5h7v1.5h-7V11Zm7 3.5h-7V16h7v-1.5Z"
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M17 4H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2ZM7 5.5h10a.5.5 0 0 1 .5.5v12a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V6a.5.5 0 0 1 .5-.5Z"
  })]
});
/* harmony default export */ const library_page = (page);
//# sourceMappingURL=page.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/tag.js
/**
 * WordPress dependencies
 */


const tag = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M4.75 4a.75.75 0 0 0-.75.75v7.826c0 .2.08.39.22.53l6.72 6.716a2.313 2.313 0 0 0 3.276-.001l5.61-5.611-.531-.53.532.528a2.315 2.315 0 0 0 0-3.264L13.104 4.22a.75.75 0 0 0-.53-.22H4.75ZM19 12.576a.815.815 0 0 1-.236.574l-5.61 5.611a.814.814 0 0 1-1.153 0L5.5 12.264V5.5h6.763l6.5 6.502a.816.816 0 0 1 .237.574ZM8.75 9.75a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
  })
});
/* harmony default export */ const library_tag = (tag);
//# sourceMappingURL=tag.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/category.js
var category = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/category.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/file.js
/**
 * WordPress dependencies
 */


const file = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12.848 8a1 1 0 0 1-.914-.594l-.723-1.63a.5.5 0 0 0-.447-.276H5a.5.5 0 0 0-.5.5v11.5a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5v-9A.5.5 0 0 0 19 8h-6.152Zm.612-1.5a.5.5 0 0 1-.462-.31l-.445-1.084A2 2 0 0 0 10.763 4H5a2 2 0 0 0-2 2v11.5a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-9a2 2 0 0 0-2-2h-5.54Z"
  })
});
/* harmony default export */ const library_file = (file);
//# sourceMappingURL=file.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/globe.js
/**
 * WordPress dependencies
 */


const globe = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M12 3.3c-4.8 0-8.8 3.9-8.8 8.8 0 4.8 3.9 8.8 8.8 8.8 4.8 0 8.8-3.9 8.8-8.8s-4-8.8-8.8-8.8zm6.5 5.5h-2.6C15.4 7.3 14.8 6 14 5c2 .6 3.6 2 4.5 3.8zm.7 3.2c0 .6-.1 1.2-.2 1.8h-2.9c.1-.6.1-1.2.1-1.8s-.1-1.2-.1-1.8H19c.2.6.2 1.2.2 1.8zM12 18.7c-1-.7-1.8-1.9-2.3-3.5h4.6c-.5 1.6-1.3 2.9-2.3 3.5zm-2.6-4.9c-.1-.6-.1-1.1-.1-1.8 0-.6.1-1.2.1-1.8h5.2c.1.6.1 1.1.1 1.8s-.1 1.2-.1 1.8H9.4zM4.8 12c0-.6.1-1.2.2-1.8h2.9c-.1.6-.1 1.2-.1 1.8 0 .6.1 1.2.1 1.8H5c-.2-.6-.2-1.2-.2-1.8zM12 5.3c1 .7 1.8 1.9 2.3 3.5H9.7c.5-1.6 1.3-2.9 2.3-3.5zM10 5c-.8 1-1.4 2.3-1.8 3.8H5.5C6.4 7 8 5.6 10 5zM5.5 15.3h2.6c.4 1.5 1 2.8 1.8 3.7-1.8-.6-3.5-2-4.4-3.7zM14 19c.8-1 1.4-2.2 1.8-3.7h2.6C17.6 17 16 18.4 14 19z"
  })
});
/* harmony default export */ const library_globe = (globe);
//# sourceMappingURL=globe.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/home.js
/**
 * WordPress dependencies
 */


const home = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M12 4L4 7.9V20h16V7.9L12 4zm6.5 14.5H14V13h-4v5.5H5.5V8.8L12 5.7l6.5 3.1v9.7z"
  })
});
/* harmony default export */ const library_home = (home);
//# sourceMappingURL=home.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/verse.js
/**
 * WordPress dependencies
 */


const verse = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M17.8 2l-.9.3c-.1 0-3.6 1-5.2 2.1C10 5.5 9.3 6.5 8.9 7.1c-.6.9-1.7 4.7-1.7 6.3l-.9 2.3c-.2.4 0 .8.4 1 .1 0 .2.1.3.1.3 0 .6-.2.7-.5l.6-1.5c.3 0 .7-.1 1.2-.2.7-.1 1.4-.3 2.2-.5.8-.2 1.6-.5 2.4-.8.7-.3 1.4-.7 1.9-1.2s.8-1.2 1-1.9c.2-.7.3-1.6.4-2.4.1-.8.1-1.7.2-2.5 0-.8.1-1.5.2-2.1V2zm-1.9 5.6c-.1.8-.2 1.5-.3 2.1-.2.6-.4 1-.6 1.3-.3.3-.8.6-1.4.9-.7.3-1.4.5-2.2.8-.6.2-1.3.3-1.8.4L15 7.5c.3-.3.6-.7 1-1.1 0 .4 0 .8-.1 1.2zM6 20h8v-1.5H6V20z"
  })
});
/* harmony default export */ const library_verse = (verse);
//# sourceMappingURL=verse.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/safe-decode-uri.js
/**
 * Safely decodes a URI with `decodeURI`. Returns the URI unmodified if
 * `decodeURI` throws an error.
 *
 * @param {string} uri URI to decode.
 *
 * @example
 * ```js
 * const badUri = safeDecodeURI( '%z' ); // does not throw an Error, simply returns '%z'
 * ```
 *
 * @return {string} Decoded URI if possible.
 */
function safe_decode_uri_safeDecodeURI(uri) {
  try {
    return decodeURI(uri);
  } catch (uriError) {
    return uri;
  }
}
//# sourceMappingURL=safe-decode-uri.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/get-path.js
/**
 * Returns the path part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const path1 = getPath( 'http://localhost:8080/this/is/a/test?query=true' ); // 'this/is/a/test'
 * const path2 = getPath( 'https://wordpress.org/help/faq/' ); // 'help/faq'
 * ```
 *
 * @return {string|void} The path part of the URL.
 */
function getPath(url) {
  const matches = /^[^\/\s:]+:(?:\/\/)?[^\/\s#?]+[\/]([^\s#?]+)[#?]{0,1}\S*$/.exec(url);
  if (matches) {
    return matches[1];
  }
}
//# sourceMappingURL=get-path.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/filter-url-for-display.js
/**
 * Returns a URL for display.
 *
 * @param {string}      url       Original URL.
 * @param {number|null} maxLength URL length.
 *
 * @example
 * ```js
 * const displayUrl = filterURLForDisplay( 'https://www.wordpress.org/gutenberg/' ); // wordpress.org/gutenberg
 * const imageUrl = filterURLForDisplay( 'https://www.wordpress.org/wp-content/uploads/img.png', 20 ); // …ent/uploads/img.png
 * ```
 *
 * @return {string} Displayed URL.
 */
function filterURLForDisplay(url, maxLength = null) {
  // Remove protocol and www prefixes.
  let filteredURL = url.replace(/^(?:https?:)\/\/(?:www\.)?/, '');

  // Ends with / and only has that single slash, strip it.
  if (filteredURL.match(/^[^\/]+\/$/)) {
    filteredURL = filteredURL.replace('/', '');
  }

  // capture file name from URL
  const fileRegexp = /\/([^\/?]+)\.(?:[\w]+)(?=\?|$)/;
  if (!maxLength || filteredURL.length <= maxLength || !filteredURL.match(fileRegexp)) {
    return filteredURL;
  }

  // If the file is not greater than max length, return last portion of URL.
  filteredURL = filteredURL.split('?')[0];
  const urlPieces = filteredURL.split('/');
  const file = urlPieces[urlPieces.length - 1];
  if (file.length <= maxLength) {
    return '…' + filteredURL.slice(-maxLength);
  }

  // If the file is greater than max length, truncate the file.
  const index = file.lastIndexOf('.');
  const [fileName, extension] = [file.slice(0, index), file.slice(index + 1)];
  const truncatedFile = fileName.slice(-3) + '.' + extension;
  return file.slice(0, maxLength - truncatedFile.length - 1) + '…' + truncatedFile;
}
//# sourceMappingURL=filter-url-for-display.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/search-item.js
/**
 * WordPress dependencies
 */







const ICONS_MAP = {
  post: post_list,
  page: library_page,
  post_tag: library_tag,
  category: category/* default */.A,
  attachment: library_file
};
function SearchItemIcon({
  isURL,
  suggestion
}) {
  let icon = null;
  if (isURL) {
    icon = library_globe;
  } else if (suggestion.type in ICONS_MAP) {
    icon = ICONS_MAP[suggestion.type];
    if (suggestion.type === 'page') {
      if (suggestion.isFrontPage) {
        icon = library_home;
      }
      if (suggestion.isBlogHome) {
        icon = library_verse;
      }
    }
  }
  if (icon) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
      className: "block-editor-link-control__search-item-icon",
      icon: icon
    });
  }
  return null;
}

/**
 * Adds a leading slash to a url if it doesn't already have one.
 * @param {string} url the url to add a leading slash to.
 * @return {string} the url with a leading slash.
 */
function addLeadingSlash(url) {
  const trimmedURL = url?.trim();
  if (!trimmedURL?.length) {
    return url;
  }
  return url?.replace(/^\/?/, '/');
}
function removeTrailingSlash(url) {
  const trimmedURL = url?.trim();
  if (!trimmedURL?.length) {
    return url;
  }
  return url?.replace(/\/$/, '');
}
const partialRight = (fn, ...partialArgs) => (...args) => fn(...args, ...partialArgs);
const defaultTo = d => v => {
  return v === null || v === undefined || v !== v ? d : v;
};

/**
 * Prepares a URL for display in the UI.
 * - decodes the URL.
 * - filters it (removes protocol, www, etc.).
 * - truncates it if necessary.
 * - adds a leading slash.
 * @param {string} url the url.
 * @return {string} the processed url to display.
 */
function getURLForDisplay(url) {
  if (!url) {
    return url;
  }
  return (0,pipe/* default */.h)(safe_decode_uri_safeDecodeURI, getPath, defaultTo(''), partialRight(filterURLForDisplay, 24), removeTrailingSlash, addLeadingSlash)(url);
}
const LinkControlSearchItem = ({
  itemProps,
  suggestion,
  searchTerm,
  onClick,
  isURL = false,
  shouldShowType = false
}) => {
  const info = isURL ? (0,i18n_build_module.__)('Press ENTER to add this link') : getURLForDisplay(suggestion.url);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
    ...itemProps,
    info: info,
    iconPosition: "left",
    icon: /*#__PURE__*/(0,jsx_runtime.jsx)(SearchItemIcon, {
      suggestion: suggestion,
      isURL: isURL
    }),
    onClick: onClick,
    shortcut: shouldShowType && getVisualTypeName(suggestion),
    className: "block-editor-link-control__search-item",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_highlight
    // The component expects a plain text string.
    , {
      text: (0,strip_html/* default */.A)(suggestion.title),
      highlight: searchTerm
    })
  });
};
function getVisualTypeName(suggestion) {
  if (suggestion.isFrontPage) {
    return 'front page';
  }
  if (suggestion.isBlogHome) {
    return 'blog home';
  }

  // Rename 'post_tag' to 'tag'. Ideally, the API would return the localised CPT or taxonomy label.
  return suggestion.type === 'post_tag' ? 'tag' : suggestion.type;
}
/* harmony default export */ const search_item = (LinkControlSearchItem);
//# sourceMappingURL=search-item.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/constants.js
/**
 * WordPress dependencies
 */


// Used as a unique identifier for the "Create" option within search results.
// Used to help distinguish the "Create" suggestion within the search results in
// order to handle it as a unique case.
const CREATE_TYPE = '__CREATE__';
const TEL_TYPE = 'tel';
const URL_TYPE = 'link';
const MAILTO_TYPE = 'mailto';
const INTERNAL_TYPE = 'internal';
const LINK_ENTRY_TYPES = [URL_TYPE, MAILTO_TYPE, TEL_TYPE, INTERNAL_TYPE];
const DEFAULT_LINK_SETTINGS = [{
  id: 'opensInNewTab',
  title: (0,i18n_build_module.__)('Open in new tab')
}];
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/search-results.js
/**
 * WordPress dependencies
 */



/**
 * External dependencies
 */


/**
 * Internal dependencies
 */





function LinkControlSearchResults({
  instanceId,
  withCreateSuggestion,
  currentInputValue,
  handleSuggestionClick,
  suggestionsListProps,
  buildSuggestionItemProps,
  suggestions,
  selectedSuggestion,
  isLoading,
  isInitialSuggestions,
  createSuggestionButtonText,
  suggestionsQuery
}) {
  const resultsListClasses = (0,dist_clsx/* default */.A)('block-editor-link-control__search-results', {
    'is-loading': isLoading
  });
  const isSingleDirectEntryResult = suggestions.length === 1 && LINK_ENTRY_TYPES.includes(suggestions[0].type);
  const shouldShowCreateSuggestion = withCreateSuggestion && !isSingleDirectEntryResult && !isInitialSuggestions;
  // If the query has a specified type, then we can skip showing them in the result. See #24839.
  const shouldShowSuggestionsTypes = !suggestionsQuery?.type;

  // According to guidelines aria-label should be added if the label
  // itself is not visible.
  // See: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/listbox_role
  const searchResultsLabelId = `block-editor-link-control-search-results-label-${instanceId}`;
  const labelText = isInitialSuggestions ? (0,i18n_build_module.__)('Suggestions') : (0,i18n_build_module/* sprintf */.nv)( /* translators: %s: search term. */
  (0,i18n_build_module.__)('Search results for "%s"'), currentInputValue);
  const searchResultsLabel = /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
    id: searchResultsLabelId,
    children: labelText
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "block-editor-link-control__search-results-wrapper",
    children: [searchResultsLabel, /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      ...suggestionsListProps,
      className: resultsListClasses,
      "aria-labelledby": searchResultsLabelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
        children: suggestions.map((suggestion, index) => {
          if (shouldShowCreateSuggestion && CREATE_TYPE === suggestion.type) {
            return /*#__PURE__*/(0,jsx_runtime.jsx)(search_create_button, {
              searchTerm: currentInputValue,
              buttonText: createSuggestionButtonText,
              onClick: () => handleSuggestionClick(suggestion)
              // Intentionally only using `type` here as
              // the constant is enough to uniquely
              // identify the single "CREATE" suggestion.
              ,

              itemProps: buildSuggestionItemProps(suggestion, index),
              isSelected: index === selectedSuggestion
            }, suggestion.type);
          }

          // If we're not handling "Create" suggestions above then
          // we don't want them in the main results so exit early.
          if (CREATE_TYPE === suggestion.type) {
            return null;
          }
          return /*#__PURE__*/(0,jsx_runtime.jsx)(search_item, {
            itemProps: buildSuggestionItemProps(suggestion, index),
            suggestion: suggestion,
            index: index,
            onClick: () => {
              handleSuggestionClick(suggestion);
            },
            isSelected: index === selectedSuggestion,
            isURL: LINK_ENTRY_TYPES.includes(suggestion.type),
            searchTerm: currentInputValue,
            shouldShowType: shouldShowSuggestionsTypes,
            isFrontPage: suggestion?.isFrontPage,
            isBlogHome: suggestion?.isBlogHome
          }, `${suggestion.id}-${suggestion.type}`);
        })
      })
    })]
  });
}
//# sourceMappingURL=search-results.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/get-protocol.js
/**
 * Returns the protocol part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const protocol1 = getProtocol( 'tel:012345678' ); // 'tel:'
 * const protocol2 = getProtocol( 'https://wordpress.org' ); // 'https:'
 * ```
 *
 * @return {string|void} The protocol part of the URL.
 */
function getProtocol(url) {
  const matches = /^([^\s:]+:)/.exec(url);
  if (matches) {
    return matches[1];
  }
}
//# sourceMappingURL=get-protocol.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/is-email.js
const EMAIL_REGEXP = /^(mailto:)?[a-z0-9._%+-]+@[a-z0-9][a-z0-9.-]*\.[a-z]{2,63}$/i;

/**
 * Determines whether the given string looks like an email.
 *
 * @param {string} email The string to scrutinise.
 *
 * @example
 * ```js
 * const isEmail = isEmail( 'hello@wordpress.org' ); // true
 * ```
 *
 * @return {boolean} Whether or not it looks like an email.
 */
function isEmail(email) {
  return EMAIL_REGEXP.test(email);
}
//# sourceMappingURL=is-email.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/prepend-http.js
/**
 * Internal dependencies
 */

const USABLE_HREF_REGEXP = /^(?:[a-z]+:|#|\?|\.|\/)/i;

/**
 * Prepends "http://" to a url, if it looks like something that is meant to be a TLD.
 *
 * @param {string} url The URL to test.
 *
 * @example
 * ```js
 * const actualURL = prependHTTP( 'wordpress.org' ); // http://wordpress.org
 * ```
 *
 * @return {string} The updated URL.
 */
function prependHTTP(url) {
  if (!url) {
    return url;
  }
  url = url.trim();
  if (!USABLE_HREF_REGEXP.test(url) && !isEmail(url)) {
    return 'http://' + url;
  }
  return url;
}
//# sourceMappingURL=prepend-http.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/is-valid-protocol.js
/**
 * Tests if a url protocol is valid.
 *
 * @param {string} protocol The url protocol.
 *
 * @example
 * ```js
 * const isValid = isValidProtocol( 'https:' ); // true
 * const isNotValid = isValidProtocol( 'https :' ); // false
 * ```
 *
 * @return {boolean} True if the argument is a valid protocol (e.g. http:, tel:).
 */
function isValidProtocol(protocol) {
  if (!protocol) {
    return false;
  }
  return /^[a-z\-.\+]+[0-9]*:$/i.test(protocol);
}
//# sourceMappingURL=is-valid-protocol.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@4.0.1/node_modules/@wordpress/url/build-module/is-valid-fragment.js
/**
 * Checks for invalid characters within the provided fragment.
 *
 * @param {string} fragment The url fragment.
 *
 * @example
 * ```js
 * const isValid = isValidFragment( '#valid-fragment' ); // true
 * const isNotValid = isValidFragment( '#invalid-#fragment' ); // false
 * ```
 *
 * @return {boolean} True if the argument contains a valid fragment.
 */
function isValidFragment(fragment) {
  if (!fragment) {
    return false;
  }
  return /^#[^\s#?\/]*$/.test(fragment);
}
//# sourceMappingURL=is-valid-fragment.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/is-url-like.js
/**
 * WordPress dependencies
 */


/**
 * Determines whether a given value could be a URL. Note this does not
 * guarantee the value is a URL only that it looks like it might be one. For
 * example, just because a string has `www.` in it doesn't make it a URL,
 * but it does make it highly likely that it will be so in the context of
 * creating a link it makes sense to treat it like one.
 *
 * @param {string} val the candidate for being URL-like (or not).
 *
 * @return {boolean} whether or not the value is potentially a URL.
 */
function isURLLike(val) {
  const hasSpaces = val.includes(' ');
  if (hasSpaces) {
    return false;
  }
  const protocol = getProtocol(val);
  const protocolIsValid = isValidProtocol(protocol);
  const mayBeTLD = hasPossibleTLD(val);
  const isWWW = val?.startsWith('www.');
  const isInternal = val?.startsWith('#') && isValidFragment(val);
  return protocolIsValid || isWWW || isInternal || mayBeTLD;
}

/**
 * Checks if a given URL has a valid Top-Level Domain (TLD).
 *
 * @param {string} url       - The URL to check.
 * @param {number} maxLength - The maximum length of the TLD.
 * @return {boolean} Returns true if the URL has a valid TLD, false otherwise.
 */
function hasPossibleTLD(url, maxLength = 6) {
  // Clean the URL by removing anything after the first occurrence of "?" or "#".
  const cleanedURL = url.split(/[?#]/)[0];

  // Regular expression explanation:
  // - (?<=\S)                  : Positive lookbehind assertion to ensure there is at least one non-whitespace character before the TLD
  // - \.                       : Matches a literal dot (.)
  // - [a-zA-Z_]{2,maxLength}   : Matches 2 to maxLength letters or underscores, representing the TLD
  // - (?:\/|$)                 : Non-capturing group that matches either a forward slash (/) or the end of the string
  const regex = new RegExp(`(?<=\\S)\\.(?:[a-zA-Z_]{2,${maxLength}})(?:\\/|$)`);
  return regex.test(cleanedURL);
}
//# sourceMappingURL=is-url-like.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/use-search-handler.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const handleNoop = () => Promise.resolve([]);
const handleDirectEntry = val => {
  let type = URL_TYPE;
  const protocol = getProtocol(val) || '';
  if (protocol.includes('mailto')) {
    type = MAILTO_TYPE;
  }
  if (protocol.includes('tel')) {
    type = TEL_TYPE;
  }
  if (val?.startsWith('#')) {
    type = INTERNAL_TYPE;
  }
  return Promise.resolve([{
    id: val,
    title: val,
    url: type === 'URL' ? prependHTTP(val) : val,
    type
  }]);
};
const handleEntitySearch = async (val, suggestionsQuery, fetchSearchSuggestions, withCreateSuggestion, pageOnFront, pageForPosts) => {
  const {
    isInitialSuggestions
  } = suggestionsQuery;
  const results = await fetchSearchSuggestions(val, suggestionsQuery);

  // Identify front page and update type to match.
  results.map(result => {
    if (Number(result.id) === pageOnFront) {
      result.isFrontPage = true;
      return result;
    } else if (Number(result.id) === pageForPosts) {
      result.isBlogHome = true;
      return result;
    }
    return result;
  });

  // If displaying initial suggestions just return plain results.
  if (isInitialSuggestions) {
    return results;
  }

  // Here we append a faux suggestion to represent a "CREATE" option. This
  // is detected in the rendering of the search results and handled as a
  // special case. This is currently necessary because the suggestions
  // dropdown will only appear if there are valid suggestions and
  // therefore unless the create option is a suggestion it will not
  // display in scenarios where there are no results returned from the
  // API. In addition promoting CREATE to a first class suggestion affords
  // the a11y benefits afforded by `URLInput` to all suggestions (eg:
  // keyboard handling, ARIA roles...etc).
  //
  // Note also that the value of the `title` and `url` properties must correspond
  // to the text value of the `<input>`. This is because `title` is used
  // when creating the suggestion. Similarly `url` is used when using keyboard to select
  // the suggestion (the <form> `onSubmit` handler falls-back to `url`).
  return isURLLike(val) || !withCreateSuggestion ? results : results.concat({
    // the `id` prop is intentionally ommitted here because it
    // is never exposed as part of the component's public API.
    // see: https://github.com/WordPress/gutenberg/pull/19775#discussion_r378931316.
    title: val,
    // Must match the existing `<input>`s text value.
    url: val,
    // Must match the existing `<input>`s text value.
    type: CREATE_TYPE
  });
};
function useSearchHandler(suggestionsQuery, allowDirectEntry, withCreateSuggestion) {
  const {
    fetchSearchSuggestions,
    pageOnFront,
    pageForPosts
  } = (0,use_select/* default */.A)(select => {
    const {
      getSettings
    } = select(store_store);
    return {
      pageOnFront: getSettings().pageOnFront,
      pageForPosts: getSettings().pageForPosts,
      fetchSearchSuggestions: getSettings().__experimentalFetchLinkSuggestions
    };
  }, []);
  const directEntryHandler = allowDirectEntry ? handleDirectEntry : handleNoop;
  return (0,react.useCallback)((val, {
    isInitialSuggestions
  }) => {
    return isURLLike(val) ? directEntryHandler(val, {
      isInitialSuggestions
    }) : handleEntitySearch(val, {
      ...suggestionsQuery,
      isInitialSuggestions
    }, fetchSearchSuggestions, withCreateSuggestion, pageOnFront, pageForPosts);
  }, [directEntryHandler, fetchSearchSuggestions, pageOnFront, pageForPosts, suggestionsQuery, withCreateSuggestion]);
}
//# sourceMappingURL=use-search-handler.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/search-input.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





// Must be a function as otherwise URLInput will default
// to the fetchLinkSuggestions passed in block editor settings
// which will cause an unintended http request.


const noopSearchHandler = () => Promise.resolve([]);
const search_input_noop = () => {};
const LinkControlSearchInput = (0,react.forwardRef)(({
  value,
  children,
  currentLink = {},
  className = null,
  placeholder = null,
  withCreateSuggestion = false,
  onCreateSuggestion = search_input_noop,
  onChange = search_input_noop,
  onSelect = search_input_noop,
  showSuggestions = true,
  renderSuggestions = props => /*#__PURE__*/(0,jsx_runtime.jsx)(LinkControlSearchResults, {
    ...props
  }),
  fetchSuggestions = null,
  allowDirectEntry = true,
  showInitialSuggestions = false,
  suggestionsQuery = {},
  withURLSuggestion = true,
  createSuggestionButtonText,
  hideLabelFromVision = false
}, ref) => {
  const genericSearchHandler = useSearchHandler(suggestionsQuery, allowDirectEntry, withCreateSuggestion, withURLSuggestion);
  const searchHandler = showSuggestions ? fetchSuggestions || genericSearchHandler : noopSearchHandler;
  const instanceId = (0,use_instance_id/* default */.A)(LinkControlSearchInput);
  const [focusedSuggestion, setFocusedSuggestion] = (0,react.useState)();

  /**
   * Handles the user moving between different suggestions. Does not handle
   * choosing an individual item.
   *
   * @param {string} selection  the url of the selected suggestion.
   * @param {Object} suggestion the suggestion object.
   */
  const onInputChange = (selection, suggestion) => {
    onChange(selection);
    setFocusedSuggestion(suggestion);
  };
  const handleRenderSuggestions = props => renderSuggestions({
    ...props,
    instanceId,
    withCreateSuggestion,
    createSuggestionButtonText,
    suggestionsQuery,
    handleSuggestionClick: suggestion => {
      if (props.handleSuggestionClick) {
        props.handleSuggestionClick(suggestion);
      }
      onSuggestionSelected(suggestion);
    }
  });
  const onSuggestionSelected = async selectedSuggestion => {
    let suggestion = selectedSuggestion;
    if (CREATE_TYPE === selectedSuggestion.type) {
      // Create a new page and call onSelect with the output from the onCreateSuggestion callback.
      try {
        suggestion = await onCreateSuggestion(selectedSuggestion.title);
        if (suggestion?.url) {
          onSelect(suggestion);
        }
      } catch (e) {}
      return;
    }
    if (allowDirectEntry || suggestion && Object.keys(suggestion).length >= 1) {
      const {
        id,
        url,
        ...restLinkProps
      } = currentLink !== null && currentLink !== void 0 ? currentLink : {};
      onSelect(
      // Some direct entries don't have types or IDs, and we still need to clear the previous ones.
      {
        ...restLinkProps,
        ...suggestion
      }, suggestion);
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "block-editor-link-control__search-input-container",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(url_input, {
      disableSuggestions: currentLink?.url === value,
      __nextHasNoMarginBottom: true,
      label: (0,i18n_build_module.__)('Link'),
      hideLabelFromVision: hideLabelFromVision,
      className: className,
      value: value,
      onChange: onInputChange,
      placeholder: placeholder !== null && placeholder !== void 0 ? placeholder : (0,i18n_build_module.__)('Search or type URL'),
      __experimentalRenderSuggestions: showSuggestions ? handleRenderSuggestions : null,
      __experimentalFetchLinkSuggestions: searchHandler,
      __experimentalHandleURLSuggestions: true,
      __experimentalShowInitialSuggestions: showInitialSuggestions,
      onSubmit: (suggestion, event) => {
        const hasSuggestion = suggestion || focusedSuggestion;

        // If there is no suggestion and the value (ie: any manually entered URL) is empty
        // then don't allow submission otherwise we get empty links.
        if (!hasSuggestion && !value?.trim()?.length) {
          event.preventDefault();
        } else {
          onSuggestionSelected(hasSuggestion || {
            url: value
          });
        }
      },
      ref: ref
    }), children]
  });
});
/* harmony default export */ const search_input = (LinkControlSearchInput);
//# sourceMappingURL=search-input.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/external-link/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function UnforwardedExternalLink(props, ref) {
  const {
    href,
    children,
    className,
    rel = '',
    ...additionalProps
  } = props;
  const optimizedRel = [...new Set([...rel.split(' '), 'external', 'noreferrer', 'noopener'].filter(Boolean))].join(' ');
  const classes = (0,dist_clsx/* default */.A)('components-external-link', className);
  /* Anchor links are perceived as external links.
  This constant helps check for on page anchor links,
  to prevent them from being opened in the editor. */
  const isInternalAnchor = !!href?.startsWith('#');
  const onClickHandler = event => {
    if (isInternalAnchor) {
      event.preventDefault();
    }
    if (props.onClick) {
      props.onClick(event);
    }
  };
  return (
    /*#__PURE__*/
    /* eslint-disable react/jsx-no-target-blank */
    (0,jsx_runtime.jsxs)("a", {
      ...additionalProps,
      className: classes,
      href: href,
      onClick: onClickHandler,
      target: "_blank",
      rel: optimizedRel,
      ref: ref,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        className: "components-external-link__contents",
        children: children
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        className: "components-external-link__icon",
        "aria-label": /* translators: accessibility text */
        (0,i18n_build_module.__)('(opens in a new tab)'),
        children: "\u2197"
      })]
    })
    /* eslint-enable react/jsx-no-target-blank */
  );
}

/**
 * Link to an external resource.
 *
 * ```jsx
 * import { ExternalLink } from '@wordpress/components';
 *
 * const MyExternalLink = () => (
 *   <ExternalLink href="https://wordpress.org">WordPress.org</ExternalLink>
 * );
 * ```
 */
const ExternalLink = (0,react.forwardRef)(UnforwardedExternalLink);
/* harmony default export */ const external_link = (ExternalLink);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/clipboard@2.0.11/node_modules/clipboard/dist/clipboard.js
var dist_clipboard = __webpack_require__("../../node_modules/.pnpm/clipboard@2.0.11/node_modules/clipboard/dist/clipboard.js");
var clipboard_default = /*#__PURE__*/__webpack_require__.n(dist_clipboard);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-copy-to-clipboard/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * @template T
 * @param {T} value
 * @return {import('react').RefObject<T>} The updated ref
 */
function useUpdatedRef(value) {
  const ref = (0,react.useRef)(value);
  ref.current = value;
  return ref;
}

/**
 * Copies the given text to the clipboard when the element is clicked.
 *
 * @template {HTMLElement} TElementType
 * @param {string | (() => string)} text      The text to copy. Use a function if not
 *                                            already available and expensive to compute.
 * @param {Function}                onSuccess Called when to text is copied.
 *
 * @return {import('react').Ref<TElementType>} A ref to assign to the target element.
 */
function useCopyToClipboard(text, onSuccess) {
  // Store the dependencies as refs and continuously update them so they're
  // fresh when the callback is called.
  const textRef = useUpdatedRef(text);
  const onSuccessRef = useUpdatedRef(onSuccess);
  return (0,use_ref_effect/* default */.A)(node => {
    // Clipboard listens to click events.
    const clipboard = new (clipboard_default())(node, {
      text() {
        return typeof textRef.current === 'function' ? textRef.current() : textRef.current || '';
      }
    });
    clipboard.on('success', ({
      clearSelection
    }) => {
      // Clearing selection will move focus back to the triggering
      // button, ensuring that it is not reset to the body, and
      // further that it is kept within the rendered node.
      clearSelection();
      if (onSuccessRef.current) {
        onSuccessRef.current();
      }
    });
    return () => {
      clipboard.destroy();
    };
  }, []);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/info.js
/**
 * WordPress dependencies
 */


const info = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M12 3.2c-4.8 0-8.8 3.9-8.8 8.8 0 4.8 3.9 8.8 8.8 8.8 4.8 0 8.8-3.9 8.8-8.8 0-4.8-4-8.8-8.8-8.8zm0 16c-4 0-7.2-3.3-7.2-7.2C4.8 8 8 4.8 12 4.8s7.2 3.3 7.2 7.2c0 4-3.2 7.2-7.2 7.2zM11 17h2v-6h-2v6zm0-8h2V7h-2v2z"
  })
});
/* harmony default export */ const library_info = (info);
//# sourceMappingURL=info.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/pencil.js
/**
 * WordPress dependencies
 */


const pencil = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m19 7-3-3-8.5 8.5-1 4 4-1L19 7Zm-7 11.5H5V20h7v-1.5Z"
  })
});
/* harmony default export */ const library_pencil = (pencil);
//# sourceMappingURL=pencil.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/edit.js
/**
 * Internal dependencies
 */


/* harmony default export */ const edit = (library_pencil);
//# sourceMappingURL=edit.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/link-off.js
/**
 * WordPress dependencies
 */


const linkOff = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M17.031 4.703 15.576 4l-1.56 3H14v.03l-2.324 4.47H9.5V13h1.396l-1.502 2.889h-.95a3.694 3.694 0 0 1 0-7.389H10V7H8.444a5.194 5.194 0 1 0 0 10.389h.17L7.5 19.53l1.416.719L15.049 8.5h.507a3.694 3.694 0 0 1 0 7.39H14v1.5h1.556a5.194 5.194 0 0 0 .273-10.383l1.202-2.304Z"
  })
});
/* harmony default export */ const link_off = (linkOff);
//# sourceMappingURL=link-off.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/copy-small.js
/**
 * WordPress dependencies
 */


const copySmall = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M5.625 5.5h9.75c.069 0 .125.056.125.125v9.75a.125.125 0 0 1-.125.125h-9.75a.125.125 0 0 1-.125-.125v-9.75c0-.069.056-.125.125-.125ZM4 5.625C4 4.728 4.728 4 5.625 4h9.75C16.273 4 17 4.728 17 5.625v9.75c0 .898-.727 1.625-1.625 1.625h-9.75A1.625 1.625 0 0 1 4 15.375v-9.75Zm14.5 11.656v-9H20v9C20 18.8 18.77 20 17.251 20H6.25v-1.5h11.001c.69 0 1.249-.528 1.249-1.219Z"
  })
});
/* harmony default export */ const copy_small = (copySmall);
//# sourceMappingURL=copy-small.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/viewer-slot.js
/**
 * WordPress dependencies
 */

const {
  Slot: ViewerSlot,
  Fill: ViewerFill
} = (0,slot_fill/* createSlotFill */.QJ)('BlockEditorLinkControlViewer');

/* harmony default export */ const viewer_slot = ((/* unused pure expression or super */ null && (ViewerSlot)));
//# sourceMappingURL=viewer-slot.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/use-rich-url-data.js
/**
 * Internal dependencies
 */


/**
 * WordPress dependencies
 */


function use_rich_url_data_reducer(state, action) {
  switch (action.type) {
    case 'RESOLVED':
      return {
        ...state,
        isFetching: false,
        richData: action.richData
      };
    case 'ERROR':
      return {
        ...state,
        isFetching: false,
        richData: null
      };
    case 'LOADING':
      return {
        ...state,
        isFetching: true
      };
    default:
      throw new Error(`Unexpected action type ${action.type}`);
  }
}
function useRemoteUrlData(url) {
  const [state, dispatch] = (0,react.useReducer)(use_rich_url_data_reducer, {
    richData: null,
    isFetching: false
  });
  const {
    fetchRichUrlData
  } = (0,use_select/* default */.A)(select => {
    const {
      getSettings
    } = select(store_store);
    return {
      fetchRichUrlData: getSettings().__experimentalFetchRichUrlData
    };
  }, []);
  (0,react.useEffect)(() => {
    // Only make the request if we have an actual URL
    // and the fetching util is available. In some editors
    // there may not be such a util.
    if (url?.length && fetchRichUrlData && typeof AbortController !== 'undefined') {
      dispatch({
        type: 'LOADING'
      });
      const controller = new window.AbortController();
      const signal = controller.signal;
      fetchRichUrlData(url, {
        signal
      }).then(urlData => {
        dispatch({
          type: 'RESOLVED',
          richData: urlData
        });
      }).catch(() => {
        // Avoid setting state on unmounted component
        if (!signal.aborted) {
          dispatch({
            type: 'ERROR'
          });
        }
      });
      // Cleanup: when the URL changes the abort the current request.
      return () => {
        controller.abort();
      };
    }
  }, [url]);
  return state;
}
/* harmony default export */ const use_rich_url_data = (useRemoteUrlData);
//# sourceMappingURL=use-rich-url-data.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/link-preview.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */










/**
 * Internal dependencies
 */





function LinkPreview({
  value,
  onEditClick,
  hasRichPreviews = false,
  hasUnlinkControl = false,
  onRemove
}) {
  const showIconLabels = (0,use_select/* default */.A)(select => select(build_module_store_store).get('core', 'showIconLabels'), []);

  // Avoid fetching if rich previews are not desired.
  const showRichPreviews = hasRichPreviews ? value?.url : null;
  const {
    richData,
    isFetching
  } = use_rich_url_data(showRichPreviews);

  // Rich data may be an empty object so test for that.
  const hasRichData = richData && Object.keys(richData).length;
  const displayURL = value && filterURLForDisplay(safe_decode_uri_safeDecodeURI(value.url), 24) || '';

  // url can be undefined if the href attribute is unset
  const isEmptyURL = !value?.url?.length;
  const displayTitle = !isEmptyURL && (0,strip_html/* default */.A)(richData?.title || value?.title || displayURL);
  let icon;
  if (richData?.icon) {
    icon = /*#__PURE__*/(0,jsx_runtime.jsx)("img", {
      src: richData?.icon,
      alt: ""
    });
  } else if (isEmptyURL) {
    icon = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
      icon: library_info,
      size: 32
    });
  } else {
    icon = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
      icon: library_globe
    });
  }
  const {
    createNotice
  } = (0,use_dispatch/* default */.A)(store);
  const ref = useCopyToClipboard(value.url, () => {
    createNotice('info', (0,i18n_build_module.__)('Link copied to clipboard.'), {
      isDismissible: true,
      type: 'snackbar'
    });
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    "aria-label": (0,i18n_build_module.__)('Currently selected'),
    className: (0,dist_clsx/* default */.A)('block-editor-link-control__search-item', {
      'is-current': true,
      'is-rich': hasRichData,
      'is-fetching': !!isFetching,
      'is-preview': true,
      'is-error': isEmptyURL,
      'is-url-title': displayTitle === displayURL
    }),
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "block-editor-link-control__search-item-top",
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("span", {
        className: "block-editor-link-control__search-item-header",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          className: (0,dist_clsx/* default */.A)('block-editor-link-control__search-item-icon', {
            'is-image': richData?.icon
          }),
          children: icon
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          className: "block-editor-link-control__search-item-details",
          children: !isEmptyURL ? /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(external_link, {
              className: "block-editor-link-control__search-item-title",
              href: value.url,
              children: /*#__PURE__*/(0,jsx_runtime.jsx)(truncate_component, {
                numberOfLines: 1,
                children: displayTitle
              })
            }), value?.url && displayTitle !== displayURL && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
              className: "block-editor-link-control__search-item-info",
              children: /*#__PURE__*/(0,jsx_runtime.jsx)(truncate_component, {
                numberOfLines: 1,
                children: displayURL
              })
            })]
          }) : /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            className: "block-editor-link-control__search-item-error-notice",
            children: (0,i18n_build_module.__)('Link is empty')
          })
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        icon: edit,
        label: (0,i18n_build_module.__)('Edit link'),
        onClick: onEditClick,
        size: "compact"
      }), hasUnlinkControl && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        icon: link_off,
        label: (0,i18n_build_module.__)('Remove link'),
        onClick: onRemove,
        size: "compact"
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        icon: copy_small,
        label: (0,i18n_build_module/* sprintf */.nv)(
        // Translators: %s is a placeholder for the link URL and an optional colon, (if a Link URL is present).
        (0,i18n_build_module.__)('Copy link%s'),
        // Ends up looking like "Copy link: https://example.com".
        isEmptyURL || showIconLabels ? '' : ': ' + value.url),
        ref: ref,
        __experimentalIsFocusable: true,
        disabled: isEmptyURL,
        size: "compact"
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(ViewerSlot, {
        fillProps: value
      })]
    })
  });
}
//# sourceMappingURL=link-preview.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/checkbox-control/index.js
var checkbox_control = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/checkbox-control/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/settings.js
/**
 * WordPress dependencies
 */




const settings_noop = () => {};
const LinkControlSettings = ({
  value,
  onChange = settings_noop,
  settings
}) => {
  if (!settings || !settings.length) {
    return null;
  }
  const handleSettingChange = setting => newValue => {
    onChange({
      ...value,
      [setting.id]: newValue
    });
  };
  const theSettings = settings.map(setting => /*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_control/* default */.A, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-link-control__setting",
    label: setting.title,
    onChange: handleSettingChange(setting),
    checked: value ? !!value[setting.id] : false,
    help: setting?.help
  }, setting.id));
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {
    className: "block-editor-link-control__settings",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
      as: "legend",
      children: (0,i18n_build_module.__)('Currently selected link settings')
    }), theSettings]
  });
};
/* harmony default export */ const link_control_settings = (LinkControlSettings);
//# sourceMappingURL=settings.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/use-create-page.js
/**
 * WordPress dependencies
 */


function useCreatePage(handleCreatePage) {
  const cancelableCreateSuggestion = (0,react.useRef)();
  const [isCreatingPage, setIsCreatingPage] = (0,react.useState)(false);
  const [errorMessage, setErrorMessage] = (0,react.useState)(null);
  const createPage = async function (suggestionTitle) {
    setIsCreatingPage(true);
    setErrorMessage(null);
    try {
      // Make cancellable in order that we can avoid setting State
      // if the component unmounts during the call to `createSuggestion`
      cancelableCreateSuggestion.current = makeCancelable(
      // Using Promise.resolve to allow createSuggestion to return a
      // non-Promise based value.
      Promise.resolve(handleCreatePage(suggestionTitle)));
      return await cancelableCreateSuggestion.current.promise;
    } catch (error) {
      if (error && error.isCanceled) {
        return; // bail if canceled to avoid setting state
      }
      setErrorMessage(error.message || (0,i18n_build_module.__)('An unknown error occurred during creation. Please try again.'));
      throw error;
    } finally {
      setIsCreatingPage(false);
    }
  };

  /**
   * Handles cancelling any pending Promises that have been made cancelable.
   */
  (0,react.useEffect)(() => {
    return () => {
      // componentDidUnmount
      if (cancelableCreateSuggestion.current) {
        cancelableCreateSuggestion.current.cancel();
      }
    };
  }, []);
  return {
    createPage,
    isCreatingPage,
    errorMessage
  };
}

/**
 * Creates a wrapper around a promise which allows it to be programmatically
 * cancelled.
 * See: https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html
 *
 * @param {Promise} promise the Promise to make cancelable
 */
const makeCancelable = promise => {
  let hasCanceled_ = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then(val => hasCanceled_ ? reject({
      isCanceled: true
    }) : resolve(val), error => hasCanceled_ ? reject({
      isCanceled: true
    }) : reject(error));
  });
  return {
    promise: wrappedPromise,
    cancel() {
      hasCanceled_ = true;
    }
  };
};
//# sourceMappingURL=use-create-page.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var fast_deep_equal = __webpack_require__("../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js");
var fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/use-internal-value.js
/**
 * WordPress dependencies
 */


/**
 * External dependencies
 */

function useInternalValue(value) {
  const [internalValue, setInternalValue] = (0,react.useState)(value || {});
  const [previousValue, setPreviousValue] = (0,react.useState)(value);

  // If the value prop changes, update the internal state.
  // See:
  // - https://github.com/WordPress/gutenberg/pull/51387#issuecomment-1722927384.
  // - https://react.dev/reference/react/useState#storing-information-from-previous-renders.
  if (!fast_deep_equal_default()(value, previousValue)) {
    setPreviousValue(value);
    setInternalValue(value);
  }
  const setInternalURLInputValue = nextValue => {
    setInternalValue({
      ...internalValue,
      url: nextValue
    });
  };
  const setInternalTextInputValue = nextValue => {
    setInternalValue({
      ...internalValue,
      title: nextValue
    });
  };
  const createSetInternalSettingValueHandler = settingsKeys => nextValue => {
    // Only apply settings values which are defined in the settings prop.
    const settingsUpdates = Object.keys(nextValue).reduce((acc, key) => {
      if (settingsKeys.includes(key)) {
        acc[key] = nextValue[key];
      }
      return acc;
    }, {});
    setInternalValue({
      ...internalValue,
      ...settingsUpdates
    });
  };
  return [internalValue, setInternalValue, setInternalURLInputValue, setInternalTextInputValue, createSetInternalSettingValueHandler];
}
//# sourceMappingURL=use-internal-value.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/link-control/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */










/**
 * Internal dependencies
 */









/**
 * Default properties associated with a link control value.
 *
 * @typedef WPLinkControlDefaultValue
 *
 * @property {string}   url           Link URL.
 * @property {string=}  title         Link title.
 * @property {boolean=} opensInNewTab Whether link should open in a new browser
 *                                    tab. This value is only assigned if not
 *                                    providing a custom `settings` prop.
 */

/* eslint-disable jsdoc/valid-types */
/**
 * Custom settings values associated with a link.
 *
 * @typedef {{[setting:string]:any}} WPLinkControlSettingsValue
 */
/* eslint-enable */

/**
 * Custom settings values associated with a link.
 *
 * @typedef WPLinkControlSetting
 *
 * @property {string} id    Identifier to use as property for setting value.
 * @property {string} title Human-readable label to show in user interface.
 */

/**
 * Properties associated with a link control value, composed as a union of the
 * default properties and any custom settings values.
 *
 * @typedef {WPLinkControlDefaultValue&WPLinkControlSettingsValue} WPLinkControlValue
 */

/** @typedef {(nextValue:WPLinkControlValue)=>void} WPLinkControlOnChangeProp */

/**
 * Properties associated with a search suggestion used within the LinkControl.
 *
 * @typedef WPLinkControlSuggestion
 *
 * @property {string} id    Identifier to use to uniquely identify the suggestion.
 * @property {string} type  Identifies the type of the suggestion (eg: `post`,
 *                          `page`, `url`...etc)
 * @property {string} title Human-readable label to show in user interface.
 * @property {string} url   A URL for the suggestion.
 */

/** @typedef {(title:string)=>WPLinkControlSuggestion} WPLinkControlCreateSuggestionProp */

/**
 * @typedef WPLinkControlProps
 *
 * @property {(WPLinkControlSetting[])=}  settings                   An array of settings objects. Each object will used to
 *                                                                   render a `ToggleControl` for that setting.
 * @property {boolean=}                   forceIsEditingLink         If passed as either `true` or `false`, controls the
 *                                                                   internal editing state of the component to respective
 *                                                                   show or not show the URL input field.
 * @property {WPLinkControlValue=}        value                      Current link value.
 * @property {WPLinkControlOnChangeProp=} onChange                   Value change handler, called with the updated value if
 *                                                                   the user selects a new link or updates settings.
 * @property {boolean=}                   noDirectEntry              Whether to allow turning a URL-like search query directly into a link.
 * @property {boolean=}                   showSuggestions            Whether to present suggestions when typing the URL.
 * @property {boolean=}                   showInitialSuggestions     Whether to present initial suggestions immediately.
 * @property {boolean=}                   withCreateSuggestion       Whether to allow creation of link value from suggestion.
 * @property {Object=}                    suggestionsQuery           Query parameters to pass along to wp.blockEditor.__experimentalFetchLinkSuggestions.
 * @property {boolean=}                   noURLSuggestion            Whether to add a fallback suggestion which treats the search query as a URL.
 * @property {boolean=}                   hasTextControl             Whether to add a text field to the UI to update the value.title.
 * @property {string|Function|undefined}  createSuggestionButtonText The text to use in the button that calls createSuggestion.
 * @property {Function}                   renderControlBottom        Optional controls to be rendered at the bottom of the component.
 */



const link_control_noop = () => {};
const PREFERENCE_SCOPE = 'core/block-editor';
const PREFERENCE_KEY = 'linkControlSettingsDrawer';

/**
 * Renders a link control. A link control is a controlled input which maintains
 * a value associated with a link (HTML anchor element) and relevant settings
 * for how that link is expected to behave.
 *
 * @param {WPLinkControlProps} props Component props.
 */
function LinkControl({
  searchInputPlaceholder,
  value,
  settings = DEFAULT_LINK_SETTINGS,
  onChange = link_control_noop,
  onRemove,
  onCancel,
  noDirectEntry = false,
  showSuggestions = true,
  showInitialSuggestions,
  forceIsEditingLink,
  createSuggestion,
  withCreateSuggestion,
  inputValue: propInputValue = '',
  suggestionsQuery = {},
  noURLSuggestion = false,
  createSuggestionButtonText,
  hasRichPreviews = false,
  hasTextControl = false,
  renderControlBottom = null
}) {
  if (withCreateSuggestion === undefined && createSuggestion) {
    withCreateSuggestion = true;
  }
  const [settingsOpen, setSettingsOpen] = (0,react.useState)(false);
  const {
    advancedSettingsPreference
  } = (0,use_select/* default */.A)(select => {
    var _prefsStore$get;
    const prefsStore = select(build_module_store_store);
    return {
      advancedSettingsPreference: (_prefsStore$get = prefsStore.get(PREFERENCE_SCOPE, PREFERENCE_KEY)) !== null && _prefsStore$get !== void 0 ? _prefsStore$get : false
    };
  }, []);
  const {
    set: setPreference
  } = (0,use_dispatch/* default */.A)(build_module_store_store);

  /**
   * Sets the open/closed state of the Advanced Settings Drawer,
   * optionlly persisting the state to the user's preferences.
   *
   * Note that Block Editor components can be consumed by non-WordPress
   * environments which may not have preferences setup.
   * Therefore a local state is also  used as a fallback.
   *
   * @param {boolean} prefVal the open/closed state of the Advanced Settings Drawer.
   */
  const setSettingsOpenWithPreference = prefVal => {
    if (setPreference) {
      setPreference(PREFERENCE_SCOPE, PREFERENCE_KEY, prefVal);
    }
    setSettingsOpen(prefVal);
  };

  // Block Editor components can be consumed by non-WordPress environments
  // which may not have these preferences setup.
  // Therefore a local state is used as a fallback.
  const isSettingsOpen = advancedSettingsPreference || settingsOpen;
  const isMounting = (0,react.useRef)(true);
  const wrapperNode = (0,react.useRef)();
  const textInputRef = (0,react.useRef)();
  const isEndingEditWithFocus = (0,react.useRef)(false);
  const settingsKeys = settings.map(({
    id
  }) => id);
  const [internalControlValue, setInternalControlValue, setInternalURLInputValue, setInternalTextInputValue, createSetInternalSettingValueHandler] = useInternalValue(value);
  const valueHasChanges = value && !(0,objects/* default */.A)(internalControlValue, value);
  const [isEditingLink, setIsEditingLink] = (0,react.useState)(forceIsEditingLink !== undefined ? forceIsEditingLink : !value || !value.url);
  const {
    createPage,
    isCreatingPage,
    errorMessage
  } = useCreatePage(createSuggestion);
  (0,react.useEffect)(() => {
    if (forceIsEditingLink === undefined) {
      return;
    }
    setIsEditingLink(forceIsEditingLink);
  }, [forceIsEditingLink]);
  (0,react.useEffect)(() => {
    // We don't auto focus into the Link UI on mount
    // because otherwise using the keyboard to select text
    // *within* the link format is not possible.
    if (isMounting.current) {
      return;
    }

    // Scenario - when:
    // - switching between editable and non editable LinkControl
    // - clicking on a link
    // ...then move focus to the *first* element to avoid focus loss
    // and to ensure focus is *within* the Link UI.
    const nextFocusTarget = dom_build_module/* focus */.XC.focusable.find(wrapperNode.current)[0] || wrapperNode.current;
    nextFocusTarget.focus();
    isEndingEditWithFocus.current = false;
  }, [isEditingLink, isCreatingPage]);

  // The component mounting reference is maintained separately
  // to correctly reset values in `StrictMode`.
  (0,react.useEffect)(() => {
    isMounting.current = false;
    return () => {
      isMounting.current = true;
    };
  }, []);
  const hasLinkValue = value?.url?.trim()?.length > 0;

  /**
   * Cancels editing state and marks that focus may need to be restored after
   * the next render, if focus was within the wrapper when editing finished.
   */
  const stopEditing = () => {
    isEndingEditWithFocus.current = !!wrapperNode.current?.contains(wrapperNode.current.ownerDocument.activeElement);
    setIsEditingLink(false);
  };
  const handleSelectSuggestion = updatedValue => {
    // Suggestions may contains "settings" values (e.g. `opensInNewTab`)
    // which should not overide any existing settings values set by the
    // user. This filters out any settings values from the suggestion.
    const nonSettingsChanges = Object.keys(updatedValue).reduce((acc, key) => {
      if (!settingsKeys.includes(key)) {
        acc[key] = updatedValue[key];
      }
      return acc;
    }, {});
    onChange({
      ...internalControlValue,
      ...nonSettingsChanges,
      // As title is not a setting, it must be manually applied
      // in such a way as to preserve the users changes over
      // any "title" value provided by the "suggestion".
      title: internalControlValue?.title || updatedValue?.title
    });
    stopEditing();
  };
  const handleSubmit = () => {
    if (valueHasChanges) {
      // Submit the original value with new stored values applied
      // on top. URL is a special case as it may also be a prop.
      onChange({
        ...value,
        ...internalControlValue,
        url: currentUrlInputValue
      });
    }
    stopEditing();
  };
  const handleSubmitWithEnter = event => {
    const {
      keyCode
    } = event;
    if (keyCode === keycodes_build_module/* ENTER */.Fm && !currentInputIsEmpty // Disallow submitting empty values.
    ) {
      event.preventDefault();
      handleSubmit();
    }
  };
  const resetInternalValues = () => {
    setInternalControlValue(value);
  };
  const handleCancel = event => {
    event.preventDefault();
    event.stopPropagation();

    // Ensure that any unsubmitted input changes are reset.
    resetInternalValues();
    if (hasLinkValue) {
      // If there is a link then exist editing mode and show preview.
      stopEditing();
    } else {
      // If there is no link value, then remove the link entirely.
      onRemove?.();
    }
    onCancel?.();
  };
  const currentUrlInputValue = propInputValue || internalControlValue?.url || '';
  const currentInputIsEmpty = !currentUrlInputValue?.trim()?.length;
  const shownUnlinkControl = onRemove && value && !isEditingLink && !isCreatingPage;
  const showActions = isEditingLink && hasLinkValue;

  // Only show text control once a URL value has been committed
  // and it isn't just empty whitespace.
  // See https://github.com/WordPress/gutenberg/pull/33849/#issuecomment-932194927.
  const showTextControl = hasLinkValue && hasTextControl;
  const isEditing = (isEditingLink || !value) && !isCreatingPage;
  const isDisabled = !valueHasChanges || currentInputIsEmpty;
  const showSettings = !!settings?.length && isEditingLink && hasLinkValue;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    tabIndex: -1,
    ref: wrapperNode,
    className: "block-editor-link-control",
    children: [isCreatingPage && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "block-editor-link-control__loading",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(spinner/* default */.Ay, {}), " ", (0,i18n_build_module.__)('Creating'), "\u2026"]
    }), isEditing && /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        className: (0,dist_clsx/* default */.A)({
          'block-editor-link-control__search-input-wrapper': true,
          'has-text-control': showTextControl,
          'has-actions': showActions
        }),
        children: [showTextControl && /*#__PURE__*/(0,jsx_runtime.jsx)(text_control/* default */.A, {
          __nextHasNoMarginBottom: true,
          ref: textInputRef,
          className: "block-editor-link-control__field block-editor-link-control__text-content",
          label: (0,i18n_build_module.__)('Text'),
          value: internalControlValue?.title,
          onChange: setInternalTextInputValue,
          onKeyDown: handleSubmitWithEnter,
          size: "__unstable-large"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(search_input, {
          currentLink: value,
          className: "block-editor-link-control__field block-editor-link-control__search-input",
          placeholder: searchInputPlaceholder,
          value: currentUrlInputValue,
          withCreateSuggestion: withCreateSuggestion,
          onCreateSuggestion: createPage,
          onChange: setInternalURLInputValue,
          onSelect: handleSelectSuggestion,
          showInitialSuggestions: showInitialSuggestions,
          allowDirectEntry: !noDirectEntry,
          showSuggestions: showSuggestions,
          suggestionsQuery: suggestionsQuery,
          withURLSuggestion: !noURLSuggestion,
          createSuggestionButtonText: createSuggestionButtonText,
          hideLabelFromVision: !showTextControl
        }), !showActions && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          className: "block-editor-link-control__search-enter",
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
            onClick: isDisabled ? link_control_noop : handleSubmit,
            label: (0,i18n_build_module.__)('Submit'),
            icon: keyboard_return,
            className: "block-editor-link-control__search-submit",
            "aria-disabled": isDisabled
          })
        })]
      }), errorMessage && /*#__PURE__*/(0,jsx_runtime.jsx)(notice/* default */.A, {
        className: "block-editor-link-control__search-error",
        status: "error",
        isDismissible: false,
        children: errorMessage
      })]
    }), value && !isEditingLink && !isCreatingPage && /*#__PURE__*/(0,jsx_runtime.jsx)(LinkPreview, {
      // force remount when URL changes to avoid race conditions for rich previews
      value: value,
      onEditClick: () => setIsEditingLink(true),
      hasRichPreviews: hasRichPreviews,
      hasUnlinkControl: shownUnlinkControl,
      onRemove: () => {
        onRemove();
        setIsEditingLink(true);
      }
    }, value?.url), showSettings && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-link-control__tools",
      children: !currentInputIsEmpty && /*#__PURE__*/(0,jsx_runtime.jsx)(settings_drawer, {
        settingsOpen: isSettingsOpen,
        setSettingsOpen: setSettingsOpenWithPreference,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(link_control_settings, {
          value: internalControlValue,
          settings: settings,
          onChange: createSetInternalSettingValueHandler(settingsKeys)
        })
      })
    }), showActions && /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
      justify: "right",
      className: "block-editor-link-control__search-actions",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        variant: "tertiary",
        onClick: handleCancel,
        children: (0,i18n_build_module.__)('Cancel')
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        variant: "primary",
        onClick: isDisabled ? link_control_noop : handleSubmit,
        className: "block-editor-link-control__search-submit",
        "aria-disabled": isDisabled,
        children: (0,i18n_build_module.__)('Save')
      })]
    }), !isCreatingPage && renderControlBottom && renderControlBottom()]
  });
}
LinkControl.ViewerFill = ViewerFill;
LinkControl.DEFAULT_LINK_SETTINGS = DEFAULT_LINK_SETTINGS;
/* harmony default export */ const link_control = (LinkControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/media-replace-flow/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */











/**
 * Internal dependencies
 */







const media_replace_flow_noop = () => {};
let media_replace_flow_uniqueId = 0;
const MediaReplaceFlow = ({
  mediaURL,
  mediaId,
  mediaIds,
  allowedTypes,
  accept,
  onError,
  onSelect,
  onSelectURL,
  onToggleFeaturedImage,
  useFeaturedImage,
  onFilesUpload = media_replace_flow_noop,
  name = (0,i18n_build_module.__)('Replace'),
  createNotice,
  removeNotice,
  children,
  multiple = false,
  addToGallery,
  handleUpload = true,
  popoverProps
}) => {
  const mediaUpload = (0,use_select/* default */.A)(select => {
    return select(store_store).getSettings().mediaUpload;
  }, []);
  const canUpload = !!mediaUpload;
  const editMediaButtonRef = (0,react.useRef)();
  const errorNoticeID = `block-editor/media-replace-flow/error-notice/${++media_replace_flow_uniqueId}`;
  const onUploadError = message => {
    const safeMessage = (0,strip_html/* default */.A)(message);
    if (onError) {
      onError(safeMessage);
      return;
    }
    // We need to set a timeout for showing the notice
    // so that VoiceOver and possibly other screen readers
    // can announce the error afer the toolbar button
    // regains focus once the upload dialog closes.
    // Otherwise VO simply skips over the notice and announces
    // the focused element and the open menu.
    setTimeout(() => {
      createNotice('error', safeMessage, {
        speak: true,
        id: errorNoticeID,
        isDismissible: true
      });
    }, 1000);
  };
  const selectMedia = (media, closeMenu) => {
    if (useFeaturedImage && onToggleFeaturedImage) {
      onToggleFeaturedImage();
    }
    closeMenu();
    // Calling `onSelect` after the state update since it might unmount the component.
    onSelect(media);
    (0,a11y_build_module/* speak */.L)((0,i18n_build_module.__)('The media file has been replaced'));
    removeNotice(errorNoticeID);
  };
  const uploadFiles = (event, closeMenu) => {
    const files = event.target.files;
    if (!handleUpload) {
      closeMenu();
      return onSelect(files);
    }
    onFilesUpload(files);
    mediaUpload({
      allowedTypes,
      filesList: files,
      onFileChange: ([media]) => {
        selectMedia(media, closeMenu);
      },
      onError: onUploadError
    });
  };
  const openOnArrowDown = event => {
    if (event.keyCode === keycodes_build_module/* DOWN */.PX) {
      event.preventDefault();
      event.target.click();
    }
  };
  const onlyAllowsImages = () => {
    if (!allowedTypes || allowedTypes.length === 0) {
      return false;
    }
    return allowedTypes.every(allowedType => allowedType === 'image' || allowedType.startsWith('image/'));
  };
  const gallery = multiple && onlyAllowsImages();
  return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown/* default */.A, {
    popoverProps: popoverProps,
    contentClassName: "block-editor-media-replace-flow__options",
    renderToggle: ({
      isOpen,
      onToggle
    }) => /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
      ref: editMediaButtonRef,
      "aria-expanded": isOpen,
      "aria-haspopup": "true",
      onClick: onToggle,
      onKeyDown: openOnArrowDown,
      children: name
    }),
    renderContent: ({
      onClose
    }) => /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(navigable_container_menu/* default */.Ay, {
        className: "block-editor-media-replace-flow__media-upload-menu",
        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(media_upload_check, {
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(media_upload, {
            gallery: gallery,
            addToGallery: addToGallery,
            multiple: multiple,
            value: multiple ? mediaIds : mediaId,
            onSelect: media => selectMedia(media, onClose),
            allowedTypes: allowedTypes,
            render: ({
              open
            }) => /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
              icon: library_media,
              onClick: open,
              children: (0,i18n_build_module.__)('Open Media Library')
            })
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(form_file_upload/* default */.A, {
            onChange: event => {
              uploadFiles(event, onClose);
            },
            accept: accept,
            multiple: !!multiple,
            render: ({
              openFileDialog
            }) => {
              return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
                icon: upload/* default */.A,
                onClick: () => {
                  openFileDialog();
                },
                children: (0,i18n_build_module.__)('Upload')
              });
            }
          })]
        }), onToggleFeaturedImage && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
          icon: post_featured_image,
          onClick: onToggleFeaturedImage,
          isPressed: useFeaturedImage,
          children: (0,i18n_build_module.__)('Use featured image')
        }), children]
      }), onSelectURL &&
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
      (0,jsx_runtime.jsxs)("form", {
        className: (0,dist_clsx/* default */.A)('block-editor-media-flow__url-input', {
          'has-siblings': canUpload || onToggleFeaturedImage
        }),
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          className: "block-editor-media-replace-flow__image-url-label",
          children: (0,i18n_build_module.__)('Current media URL:')
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(link_control, {
          value: {
            url: mediaURL
          },
          settings: [],
          showSuggestions: false,
          onChange: ({
            url
          }) => {
            onSelectURL(url);
            editMediaButtonRef.current.focus();
          }
        })]
      })]
    })
  });
};

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/media-replace-flow/README.md
 */
/* harmony default export */ const media_replace_flow = ((0,compose/* default */.A)([with_dispatch(dispatch => {
  const {
    createNotice,
    removeNotice
  } = dispatch(store);
  return {
    createNotice,
    removeNotice
  };
}), withFilters('editor.MediaReplaceFlow')])(MediaReplaceFlow));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/theme-file-uri-utils.js
/**
 * Internal dependencies
 */


/**
 * Looks up a theme file URI based on a relative path.
 *
 * @param {string}        file          A relative path.
 * @param {Array<Object>} themeFileURIs A collection of absolute theme file URIs and their corresponding file paths.
 * @return {string?} A resolved theme file URI, if one is found in the themeFileURIs collection.
 */
function getResolvedThemeFilePath(file, themeFileURIs = []) {
  const uri = themeFileURIs.find(themeFileUri => themeFileUri.name === file);
  if (!uri?.href) {
    return file;
  }
  return uri?.href;
}

/**
 * Mutates an object by settings a value at the provided path.
 *
 * @param {Object}              object Object to set a value in.
 * @param {number|string|Array} path   Path in the object to modify.
 * @param {*}                   value  New value to set.
 * @return {Object} Object with the new value set.
 */
function setMutably(object, path, value) {
  path = path.split('.');
  const finalValueKey = path.pop();
  let prev = object;
  for (const key of path) {
    const current = prev[key];
    prev = current;
  }
  prev[finalValueKey] = value;
  return object;
}

/**
 * Resolves any relative paths if a corresponding theme file URI is available.
 * Note: this function mutates the object and is specifically to be used in
 * an async styles build context in useGlobalStylesOutput
 *
 * @param {Object}        themeJson     Theme.json/Global styles tree.
 * @param {Array<Object>} themeFileURIs A collection of absolute theme file URIs and their corresponding file paths.
 * @return {Object} Returns mutated object.
 */
function theme_file_uri_utils_setThemeFileUris(themeJson, themeFileURIs) {
  if (!themeJson?.styles || !themeFileURIs) {
    return themeJson;
  }
  themeFileURIs.forEach(({
    name,
    href,
    target
  }) => {
    const value = getValueFromObjectPath(themeJson, target);
    if (value === name) {
      /*
       * The object must not be updated immutably here because the
       * themeJson is a reference to the global styles tree used as a dependency in the
       * useGlobalStylesOutputWithConfig() hook. If we don't mutate the object,
       * the hook will detect the change and re-render the component, resulting
       * in a maximum depth exceeded error.
       */
      themeJson = setMutably(themeJson, target, href);
    }
  });
  return themeJson;
}
//# sourceMappingURL=theme-file-uri-utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/background-panel.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */







const IMAGE_BACKGROUND_TYPE = 'image';
const background_panel_DEFAULT_CONTROLS = {
  backgroundImage: true,
  backgroundSize: false
};

/**
 * Checks site settings to see if the background panel may be used.
 * `settings.background.backgroundSize` exists also,
 * but can only be used if settings?.background?.backgroundImage is `true`.
 *
 * @param {Object} settings Site settings
 * @return {boolean}        Whether site settings has activated background panel.
 */
function useHasBackgroundPanel(settings) {
  return platform/* default */.A.OS === 'web' && settings?.background?.backgroundImage;
}

/**
 * Checks if there is a current value in the background size block support
 * attributes. Background size values include background size as well
 * as background position.
 *
 * @param {Object} style Style attribute.
 * @return {boolean}     Whether the block has a background size value set.
 */
function hasBackgroundSizeValue(style) {
  return style?.background?.backgroundPosition !== undefined || style?.background?.backgroundSize !== undefined;
}

/**
 * Checks if there is a current value in the background image block support
 * attributes.
 *
 * @param {Object} style Style attribute.
 * @return {boolean}     Whether the block has a background image value set.
 */
function hasBackgroundImageValue(style) {
  return !!style?.background?.backgroundImage?.id ||
  // Supports url() string values in theme.json.
  'string' === typeof style?.background?.backgroundImage || !!style?.background?.backgroundImage?.url;
}

/**
 * Get the help text for the background size control.
 *
 * @param {string} value backgroundSize value.
 * @return {string}      Translated help text.
 */
function backgroundSizeHelpText(value) {
  if (value === 'cover' || value === undefined) {
    return (0,i18n_build_module.__)('Image covers the space evenly.');
  }
  if (value === 'contain') {
    return (0,i18n_build_module.__)('Image is contained without distortion.');
  }
  return (0,i18n_build_module.__)('Image has a fixed width.');
}

/**
 * Converts decimal x and y coords from FocalPointPicker to percentage-based values
 * to use as backgroundPosition value.
 *
 * @param {{x?:number, y?:number}} value FocalPointPicker coords.
 * @return {string}      				 backgroundPosition value.
 */
const coordsToBackgroundPosition = value => {
  if (!value || isNaN(value.x) && isNaN(value.y)) {
    return undefined;
  }
  const x = isNaN(value.x) ? 0.5 : value.x;
  const y = isNaN(value.y) ? 0.5 : value.y;
  return `${x * 100}% ${y * 100}%`;
};

/**
 * Converts backgroundPosition value to x and y coords for FocalPointPicker.
 *
 * @param {string} value backgroundPosition value.
 * @return {{x?:number, y?:number}}       FocalPointPicker coords.
 */
const backgroundPositionToCoords = value => {
  if (!value) {
    return {
      x: undefined,
      y: undefined
    };
  }
  let [x, y] = value.split(' ').map(v => parseFloat(v) / 100);
  x = isNaN(x) ? undefined : x;
  y = isNaN(y) ? x : y;
  return {
    x,
    y
  };
};
function InspectorImagePreview({
  label,
  filename,
  url: imgUrl
}) {
  const imgLabel = label || getFilename(imgUrl) || (0,i18n_build_module.__)('Add background image');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(item_group_component, {
    as: "span",
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
      justify: imgUrl ? 'flex-start' : 'center',
      as: "span",
      children: [imgUrl && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        className: (0,dist_clsx/* default */.A)('block-editor-global-styles-background-panel__inspector-image-indicator-wrapper', {
          'has-image': imgUrl
        }),
        "aria-hidden": true,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          className: "block-editor-global-styles-background-panel__inspector-image-indicator",
          style: {
            backgroundImage: `url(${imgUrl})`
          }
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_item_component/* default */.A, {
        as: "span",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(truncate_component, {
          numberOfLines: 1,
          className: "block-editor-global-styles-background-panel__inspector-media-replace-title",
          children: imgLabel
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
          as: "span",
          children: imgUrl ? (0,i18n_build_module/* sprintf */.nv)( /* translators: %s: file name */
          (0,i18n_build_module.__)('Background image: %s'), filename || imgLabel) : (0,i18n_build_module.__)('No background image selected')
        })]
      })]
    })
  });
}
function BackgroundImageToolsPanelItem({
  panelId,
  isShownByDefault,
  onChange,
  style,
  inheritedValue,
  themeFileURIs
}) {
  const mediaUpload = (0,use_select/* default */.A)(select => select(store_store).getSettings().mediaUpload, []);
  const {
    id,
    title,
    url
  } = style?.background?.backgroundImage || {
    ...inheritedValue?.background?.backgroundImage
  };
  const replaceContainerRef = (0,react.useRef)();
  const {
    createErrorNotice
  } = (0,use_dispatch/* default */.A)(store);
  const onUploadError = message => {
    createErrorNotice(message, {
      type: 'snackbar'
    });
  };
  const resetBackgroundImage = () => onChange(object_setImmutably(style, ['background', 'backgroundImage'], undefined));
  const onSelectMedia = media => {
    if (!media || !media.url) {
      resetBackgroundImage();
      return;
    }
    if ((0,blob_build_module/* isBlobURL */.H8)(media.url)) {
      return;
    }

    // For media selections originated from a file upload.
    if (media.media_type && media.media_type !== IMAGE_BACKGROUND_TYPE || !media.media_type && media.type && media.type !== IMAGE_BACKGROUND_TYPE) {
      onUploadError((0,i18n_build_module.__)('Only images can be used as a background image.'));
      return;
    }
    const sizeValue = style?.background?.backgroundSize;
    const positionValue = style?.background?.backgroundPosition;
    onChange(object_setImmutably(style, ['background'], {
      ...style?.background,
      backgroundImage: {
        url: media.url,
        id: media.id,
        source: 'file',
        title: media.title || undefined
      },
      backgroundPosition: !positionValue && ('auto' === sizeValue || !sizeValue) ? '50% 0' : positionValue
    }));
  };
  const onFilesDrop = filesList => {
    mediaUpload({
      allowedTypes: [IMAGE_BACKGROUND_TYPE],
      filesList,
      onFileChange([image]) {
        if ((0,blob_build_module/* isBlobURL */.H8)(image?.url)) {
          return;
        }
        onSelectMedia(image);
      },
      onError: onUploadError
    });
  };
  const resetAllFilter = (0,react.useCallback)(previousValue => {
    return {
      ...previousValue,
      style: {
        ...previousValue.style,
        background: undefined
      }
    };
  }, []);
  const hasValue = hasBackgroundImageValue(style);
  const closeAndFocus = () => {
    const [toggleButton] = dom_build_module/* focus */.XC.tabbable.find(replaceContainerRef.current);
    // Focus the toggle button and close the dropdown menu.
    // This ensures similar behaviour as to selecting an image, where the dropdown is
    // closed and focus is redirected to the dropdown toggle button.
    toggleButton?.focus();
    toggleButton?.click();
  };
  const onRemove = () => onChange(object_setImmutably(style, ['background', 'backgroundImage'], 'none'));
  const canRemove = !hasValue && hasBackgroundImageValue(inheritedValue);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
    className: "single-column",
    hasValue: () => hasValue,
    label: (0,i18n_build_module.__)('Background image'),
    onDeselect: resetBackgroundImage,
    isShownByDefault: isShownByDefault,
    resetAllFilter: resetAllFilter,
    panelId: panelId,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "block-editor-global-styles-background-panel__inspector-media-replace-container",
      ref: replaceContainerRef,
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(media_replace_flow, {
        mediaId: id,
        mediaURL: url,
        allowedTypes: [IMAGE_BACKGROUND_TYPE],
        accept: "image/*",
        onSelect: onSelectMedia,
        name: /*#__PURE__*/(0,jsx_runtime.jsx)(InspectorImagePreview, {
          label: title,
          filename: title,
          url: getResolvedThemeFilePath(url, themeFileURIs)
        }),
        variant: "secondary",
        children: [canRemove && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
          onClick: () => {
            closeAndFocus();
            onRemove();
          },
          children: (0,i18n_build_module.__)('Remove')
        }), hasValue && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
          onClick: () => {
            closeAndFocus();
            resetBackgroundImage();
          },
          children: (0,i18n_build_module.__)('Reset ')
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(drop_zone/* default */.A, {
        onFilesDrop: onFilesDrop,
        label: (0,i18n_build_module.__)('Drop to upload')
      })]
    })
  });
}
function BackgroundSizeToolsPanelItem({
  panelId,
  isShownByDefault,
  onChange,
  style,
  inheritedValue,
  defaultValues,
  themeFileURIs
}) {
  const sizeValue = style?.background?.backgroundSize || inheritedValue?.background?.backgroundSize;
  const repeatValue = style?.background?.backgroundRepeat || inheritedValue?.background?.backgroundRepeat;
  const imageValue = style?.background?.backgroundImage?.url || inheritedValue?.background?.backgroundImage?.url;
  const positionValue = style?.background?.backgroundPosition || inheritedValue?.background?.backgroundPosition;

  /*
   * An `undefined` value is replaced with any supplied
   * default control value for the toggle group control.
   * An empty string is treated as `auto` - this allows a user
   * to select "Size" and then enter a custom value, with an
   * empty value being treated as `auto`.
   */
  const currentValueForToggle = sizeValue !== undefined && sizeValue !== 'cover' && sizeValue !== 'contain' || sizeValue === '' ? 'auto' : sizeValue || defaultValues?.backgroundSize;

  /*
   * If the current value is `cover` and the repeat value is `undefined`, then
   * the toggle should be unchecked as the default state. Otherwise, the toggle
   * should reflect the current repeat value.
   */
  const repeatCheckedValue = !(repeatValue === 'no-repeat' || currentValueForToggle === 'cover' && repeatValue === undefined);
  const hasValue = hasBackgroundSizeValue(style);
  const resetAllFilter = (0,react.useCallback)(previousValue => {
    return {
      ...previousValue,
      style: {
        ...previousValue.style,
        background: {
          ...previousValue.style?.background,
          backgroundRepeat: undefined,
          backgroundSize: undefined
        }
      }
    };
  }, []);
  const updateBackgroundSize = next => {
    // When switching to 'contain' toggle the repeat off.
    let nextRepeat = repeatValue;
    let nextPosition = positionValue;
    if (next === 'contain') {
      nextRepeat = 'no-repeat';
      nextPosition = undefined;
    }
    if (next === 'cover') {
      nextRepeat = undefined;
      nextPosition = undefined;
    }
    if ((currentValueForToggle === 'cover' || currentValueForToggle === 'contain') && next === 'auto') {
      nextRepeat = undefined;
      /*
       * A background image uploaded and set in the editor (an image with a record id),
       * receives a default background position of '50% 0',
       * when the toggle switches to "Tile". This is to increase the chance that
       * the image's focus point is visible.
       */
      if (!!style?.background?.backgroundImage?.id) {
        nextPosition = '50% 0';
      }
    }

    /*
     * Next will be null when the input is cleared,
     * in which case the value should be 'auto'.
     */
    if (!next && currentValueForToggle === 'auto') {
      next = 'auto';
    }
    onChange(object_setImmutably(style, ['background'], {
      ...style?.background,
      backgroundPosition: nextPosition,
      backgroundRepeat: nextRepeat,
      backgroundSize: next
    }));
  };
  const updateBackgroundPosition = next => {
    onChange(object_setImmutably(style, ['background', 'backgroundPosition'], coordsToBackgroundPosition(next)));
  };
  const toggleIsRepeated = () => onChange(object_setImmutably(style, ['background', 'backgroundRepeat'], repeatCheckedValue === true ? 'no-repeat' : 'repeat'));
  const resetBackgroundSize = () => onChange(object_setImmutably(style, ['background'], {
    ...style?.background,
    backgroundPosition: undefined,
    backgroundRepeat: undefined,
    backgroundSize: undefined
  }));
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
    as: tools_panel_item_component,
    spacing: 2,
    className: "single-column",
    hasValue: () => hasValue,
    label: (0,i18n_build_module.__)('Size'),
    onDeselect: resetBackgroundSize,
    isShownByDefault: isShownByDefault,
    resetAllFilter: resetAllFilter,
    panelId: panelId,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(focal_point_picker, {
      __next40pxDefaultSize: true,
      label: (0,i18n_build_module.__)('Position'),
      url: getResolvedThemeFilePath(imageValue, themeFileURIs),
      value: backgroundPositionToCoords(positionValue),
      onChange: updateBackgroundPosition
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(toggle_group_control_component, {
      size: "__unstable-large",
      label: (0,i18n_build_module.__)('Size'),
      value: currentValueForToggle,
      onChange: updateBackgroundSize,
      isBlock: true,
      help: backgroundSizeHelpText(sizeValue || defaultValues?.backgroundSize),
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_component, {
        value: "cover",
        label: (0,i18n_build_module._x)('Cover', 'Size option for background image control')
      }, "cover"), /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_component, {
        value: "contain",
        label: (0,i18n_build_module._x)('Contain', 'Size option for background image control')
      }, "contain"), /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_component, {
        value: "auto",
        label: (0,i18n_build_module._x)('Tile', 'Size option for background image control')
      }, "tile")]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
      justify: "flex-start",
      spacing: 2,
      as: "span",
      children: [currentValueForToggle !== undefined && currentValueForToggle !== 'cover' && currentValueForToggle !== 'contain' ? /*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
        "aria-label": (0,i18n_build_module.__)('Background image width'),
        onChange: updateBackgroundSize,
        value: sizeValue,
        size: "__unstable-large",
        __unstableInputWidth: "100px",
        min: 0,
        placeholder: (0,i18n_build_module.__)('Auto')
      }) : null, currentValueForToggle !== 'cover' && /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_control/* default */.A, {
        label: (0,i18n_build_module.__)('Repeat'),
        checked: repeatCheckedValue,
        onChange: toggleIsRepeated
      })]
    })]
  });
}
function BackgroundToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children,
  headerLabel
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(v_stack_component/* default */.A, {
    as: tools_panel_component,
    spacing: 4,
    label: headerLabel,
    resetAll: resetAll,
    panelId: panelId,
    dropdownMenuProps: dropdownMenuProps,
    children: children
  });
}
function BackgroundPanel({
  as: Wrapper = BackgroundToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = background_panel_DEFAULT_CONTROLS,
  defaultValues = {},
  headerLabel = (0,i18n_build_module.__)('Background image'),
  themeFileURIs
}) {
  const resetAllFilter = (0,react.useCallback)(previousValue => {
    return {
      ...previousValue,
      background: {}
    };
  }, []);
  const shouldShowBackgroundSizeControls = settings?.background?.backgroundSize;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId,
    headerLabel: headerLabel,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(BackgroundImageToolsPanelItem, {
      onChange: onChange,
      panelId: panelId,
      isShownByDefault: defaultControls.backgroundImage,
      style: value,
      inheritedValue: inheritedValue,
      themeFileURIs: themeFileURIs
    }), shouldShowBackgroundSizeControls && /*#__PURE__*/(0,jsx_runtime.jsx)(BackgroundSizeToolsPanelItem, {
      onChange: onChange,
      panelId: panelId,
      isShownByDefault: defaultControls.backgroundSize,
      style: value,
      inheritedValue: inheritedValue,
      defaultValues: defaultValues,
      themeFileURIs: themeFileURIs
    })]
  });
}
//# sourceMappingURL=background-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/background.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const BACKGROUND_SUPPORT_KEY = 'background';

// Initial control values where no block style is set.
const BACKGROUND_DEFAULT_VALUES = {
  backgroundSize: 'cover'
};

/**
 * Determine whether there is block support for background.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   Background image feature to check for.
 *
 * @return {boolean} Whether there is support.
 */
function hasBackgroundSupport(blockName, feature = 'any') {
  const support = (0,build_module/* getBlockSupport */.bI)(blockName, BACKGROUND_SUPPORT_KEY);
  if (support === true) {
    return true;
  }
  if (feature === 'any') {
    return !!support?.backgroundImage || !!support?.backgroundSize || !!support?.backgroundRepeat;
  }
  return !!support?.[feature];
}
function setBackgroundStyleDefaults(backgroundStyle) {
  if (!backgroundStyle) {
    return;
  }
  const backgroundImage = backgroundStyle?.backgroundImage;
  let backgroundStylesWithDefaults;

  // Set block background defaults.
  if (!!backgroundImage?.url) {
    if (!backgroundStyle?.backgroundSize) {
      backgroundStylesWithDefaults = {
        backgroundSize: 'cover'
      };
    }
    if ('contain' === backgroundStyle?.backgroundSize && !backgroundStyle?.backgroundPosition) {
      backgroundStylesWithDefaults = {
        backgroundPosition: 'center'
      };
    }
  }
  return backgroundStylesWithDefaults;
}
function background_useBlockProps({
  name,
  style
}) {
  if (!hasBackgroundSupport(name) || !style?.background?.backgroundImage) {
    return;
  }
  const backgroundStyles = setBackgroundStyleDefaults(style?.background);
  if (!backgroundStyles) {
    return;
  }
  return {
    style: {
      ...backgroundStyles
    }
  };
}

/**
 * Generates a CSS class name if an background image is set.
 *
 * @param {Object} style A block's style attribute.
 *
 * @return {string} CSS class name.
 */
function getBackgroundImageClasses(style) {
  return hasBackgroundImageValue(style) ? 'has-background' : '';
}
function BackgroundInspectorControl({
  children
}) {
  const resetAllFilter = (0,react.useCallback)(attributes => {
    return {
      ...attributes,
      style: {
        ...attributes.style,
        background: undefined
      }
    };
  }, []);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
    group: "background",
    resetAllFilter: resetAllFilter,
    children: children
  });
}
function BackgroundImagePanel({
  clientId,
  name,
  setAttributes,
  settings
}) {
  const style = (0,use_select/* default */.A)(select => select(store_store).getBlockAttributes(clientId)?.style, [clientId]);
  if (!useHasBackgroundPanel(settings) || !hasBackgroundSupport(name, 'backgroundImage')) {
    return null;
  }
  const defaultControls = (0,build_module/* getBlockSupport */.bI)(name, [BACKGROUND_SUPPORT_KEY, '__experimentalDefaultControls']);
  const onChange = newStyle => {
    setAttributes({
      style: utils_cleanEmptyObject(newStyle)
    });
  };
  const updatedSettings = {
    ...settings,
    background: {
      ...settings.background,
      backgroundSize: settings?.background?.backgroundSize && hasBackgroundSupport(name, 'backgroundSize')
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BackgroundPanel, {
    as: BackgroundInspectorControl,
    panelId: clientId,
    defaultControls: defaultControls,
    defaultValues: BACKGROUND_DEFAULT_VALUES,
    settings: updatedSettings,
    onChange: onChange,
    value: style
  });
}
/* harmony default export */ const hooks_background = ({
  useBlockProps: background_useBlockProps,
  attributeKeys: ['style'],
  hasSupport: hasBackgroundSupport
});
//# sourceMappingURL=background.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/lock.js
/**
 * WordPress dependencies
 */


/**
 * Filters registered block settings, extending attributes to include `lock`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function lock_addAttribute(settings) {
  var _settings$attributes$;
  // Allow blocks to specify their own attribute definition with default values if needed.
  if ('type' in ((_settings$attributes$ = settings.attributes?.lock) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  }
  // Gracefully handle if settings.attributes is undefined.
  settings.attributes = {
    ...settings.attributes,
    lock: {
      type: 'object'
    }
  };
  return settings;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/lock/addAttribute', lock_addAttribute);
//# sourceMappingURL=lock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/anchor.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



/**
 * Regular expression matching invalid anchor characters for replacement.
 *
 * @type {RegExp}
 */



const ANCHOR_REGEX = /[\s#]/g;
const ANCHOR_SCHEMA = {
  type: 'string',
  source: 'attribute',
  attribute: 'id',
  selector: '*'
};

/**
 * Filters registered block settings, extending attributes with anchor using ID
 * of the first node.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function anchor_addAttribute(settings) {
  var _settings$attributes$;
  // Allow blocks to specify their own attribute definition with default values if needed.
  if ('type' in ((_settings$attributes$ = settings.attributes?.anchor) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  }
  if ((0,build_module/* hasBlockSupport */.pN)(settings, 'anchor')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = {
      ...settings.attributes,
      anchor: ANCHOR_SCHEMA
    };
  }
  return settings;
}
function BlockEditAnchorControlPure({
  anchor,
  setAttributes
}) {
  const blockEditingMode = useBlockEditingMode();
  if (blockEditingMode !== 'default') {
    return null;
  }
  const isWeb = platform/* default */.A.OS === 'web';
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
    group: "advanced",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_control/* default */.A, {
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      className: "html-anchor-control",
      label: (0,i18n_build_module.__)('HTML anchor'),
      help: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [(0,i18n_build_module.__)('Enter a word or two — without spaces — to make a unique web address just for this block, called an “anchor”. Then, you’ll be able to link directly to this section of your page.'), isWeb && /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
          children: [' ', /*#__PURE__*/(0,jsx_runtime.jsx)(external_link, {
            href: (0,i18n_build_module.__)('https://wordpress.org/documentation/article/page-jumps/'),
            children: (0,i18n_build_module.__)('Learn more about anchors')
          })]
        })]
      }),
      value: anchor || '',
      placeholder: !isWeb ? (0,i18n_build_module.__)('Add an anchor') : null,
      onChange: nextValue => {
        nextValue = nextValue.replace(ANCHOR_REGEX, '-');
        setAttributes({
          anchor: nextValue
        });
      },
      autoCapitalize: "none",
      autoComplete: "off"
    })
  });
}
/* harmony default export */ const hooks_anchor = ({
  addSaveProps,
  edit: BlockEditAnchorControlPure,
  attributeKeys: ['anchor'],
  hasSupport(name) {
    return (0,build_module/* hasBlockSupport */.pN)(name, 'anchor');
  }
});

/**
 * Override props assigned to save component to inject anchor ID, if block
 * supports anchor. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */
function addSaveProps(extraProps, blockType, attributes) {
  if ((0,build_module/* hasBlockSupport */.pN)(blockType, 'anchor')) {
    extraProps.id = attributes.anchor === '' ? null : attributes.anchor;
  }
  return extraProps;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/anchor/attribute', anchor_addAttribute);
//# sourceMappingURL=anchor.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/aria-label.js
/**
 * WordPress dependencies
 */


const ARIA_LABEL_SCHEMA = {
  type: 'string',
  source: 'attribute',
  attribute: 'aria-label',
  selector: '*'
};

/**
 * Filters registered block settings, extending attributes with ariaLabel using aria-label
 * of the first node.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function aria_label_addAttribute(settings) {
  // Allow blocks to specify their own attribute definition with default values if needed.
  if (settings?.attributes?.ariaLabel?.type) {
    return settings;
  }
  if ((0,build_module/* hasBlockSupport */.pN)(settings, 'ariaLabel')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = {
      ...settings.attributes,
      ariaLabel: ARIA_LABEL_SCHEMA
    };
  }
  return settings;
}

/**
 * Override props assigned to save component to inject aria-label, if block
 * supports ariaLabel. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */
function aria_label_addSaveProps(extraProps, blockType, attributes) {
  if ((0,build_module/* hasBlockSupport */.pN)(blockType, 'ariaLabel')) {
    extraProps['aria-label'] = attributes.ariaLabel === '' ? null : attributes.ariaLabel;
  }
  return extraProps;
}
/* harmony default export */ const aria_label = ({
  addSaveProps: aria_label_addSaveProps,
  attributeKeys: ['ariaLabel'],
  hasSupport(name) {
    return (0,build_module/* hasBlockSupport */.pN)(name, 'ariaLabel');
  }
});
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/ariaLabel/attribute', aria_label_addAttribute);
//# sourceMappingURL=aria-label.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/custom-class-name.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/**
 * Filters registered block settings, extending attributes to include `className`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function custom_class_name_addAttribute(settings) {
  if ((0,build_module/* hasBlockSupport */.pN)(settings, 'customClassName', true)) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = {
      ...settings.attributes,
      className: {
        type: 'string'
      }
    };
  }
  return settings;
}
function CustomClassNameControlsPure({
  className,
  setAttributes
}) {
  const blockEditingMode = useBlockEditingMode();
  if (blockEditingMode !== 'default') {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
    group: "advanced",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_control/* default */.A, {
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      autoComplete: "off",
      label: (0,i18n_build_module.__)('Additional CSS class(es)'),
      value: className || '',
      onChange: nextValue => {
        setAttributes({
          className: nextValue !== '' ? nextValue : undefined
        });
      },
      help: (0,i18n_build_module.__)('Separate multiple classes with spaces.')
    })
  });
}
/* harmony default export */ const custom_class_name = ({
  edit: CustomClassNameControlsPure,
  addSaveProps: custom_class_name_addSaveProps,
  attributeKeys: ['className'],
  hasSupport(name) {
    return (0,build_module/* hasBlockSupport */.pN)(name, 'customClassName', true);
  }
});

/**
 * Override props assigned to save component to inject the className, if block
 * supports customClassName. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */
function custom_class_name_addSaveProps(extraProps, blockType, attributes) {
  if ((0,build_module/* hasBlockSupport */.pN)(blockType, 'customClassName', true) && attributes.className) {
    extraProps.className = (0,dist_clsx/* default */.A)(extraProps.className, attributes.className);
  }
  return extraProps;
}
function addTransforms(result, source, index, results) {
  if (!(0,build_module/* hasBlockSupport */.pN)(result.name, 'customClassName', true)) {
    return result;
  }

  // If the condition verifies we are probably in the presence of a wrapping transform
  // e.g: nesting paragraphs in a group or columns and in that case the class should not be kept.
  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  }

  // If we are transforming one block to multiple blocks or multiple blocks to one block,
  // we ignore the class during the transform.
  if (results.length === 1 && source.length > 1 || results.length > 1 && source.length === 1) {
    return result;
  }

  // If we are in presence of transform between one or more block in the source
  // that have one or more blocks in the result
  // we apply the class on source N to the result N,
  // if source N does not exists we do nothing.
  if (source[index]) {
    const originClassName = source[index]?.attributes.className;
    if (originClassName) {
      return {
        ...result,
        attributes: {
          ...result.attributes,
          className: originClassName
        }
      };
    }
  }
  return result;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/editor/custom-class-name/attribute', custom_class_name_addAttribute);
(0,hooks_build_module/* addFilter */.U2)('blocks.switchToBlockType.transformedBlock', 'core/color/addTransforms', addTransforms);
//# sourceMappingURL=custom-class-name.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/generated-class-name.js
/**
 * WordPress dependencies
 */



/**
 * Override props assigned to save component to inject generated className if
 * block supports it. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 *
 * @return {Object} Filtered props applied to save element.
 */
function addGeneratedClassName(extraProps, blockType) {
  // Adding the generated className.
  if ((0,build_module/* hasBlockSupport */.pN)(blockType, 'className', true)) {
    if (typeof extraProps.className === 'string') {
      // We have some extra classes and want to add the default classname
      // We use uniq to prevent duplicate classnames.

      extraProps.className = [...new Set([(0,build_module/* getBlockDefaultClassName */.KW)(blockType.name), ...extraProps.className.split(' ')])].join(' ').trim();
    } else {
      // There is no string in the className variable,
      // so we just dump the default name in there.
      extraProps.className = (0,build_module/* getBlockDefaultClassName */.KW)(blockType.name);
    }
  }
  return extraProps;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/generated-class-name/save-props', addGeneratedClassName);
//# sourceMappingURL=generated-class-name.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/unit-values.js
const UNITED_VALUE_REGEX = /^([\d.\-+]*)\s*(fr|cm|mm|Q|in|pc|pt|px|em|ex|ch|rem|lh|vw|vh|vmin|vmax|%|cap|ic|rlh|vi|vb|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx|svw|lvw|dvw|svh|lvh|dvh|svi|lvi|dvi|svb|lvb|dvb|svmin|lvmin|dvmin|svmax|lvmax|dvmax)?$/;

/**
 * Parses a number and unit from a value.
 *
 * @param toParse Value to parse
 *
 * @return  The extracted number and unit.
 */
function parseCSSUnitValue(toParse) {
  const value = toParse.trim();
  const matched = value.match(UNITED_VALUE_REGEX);
  if (!matched) {
    return [undefined, undefined];
  }
  const [, num, unit] = matched;
  let numParsed = parseFloat(num);
  numParsed = Number.isNaN(numParsed) ? undefined : numParsed;
  return [numParsed, unit];
}

/**
 * Combines a value and a unit into a unit value.
 *
 * @param value
 * @param unit
 *
 * @return The unit value.
 */
function createCSSUnitValue(value, unit) {
  return `${value}${unit}`;
}
//# sourceMappingURL=unit-values.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/utils.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const sides = ['top', 'right', 'bottom', 'left'];
const borderProps = ['color', 'style', 'width'];
const isEmptyBorder = border => {
  if (!border) {
    return true;
  }
  return !borderProps.some(prop => border[prop] !== undefined);
};
const isDefinedBorder = border => {
  // No border, no worries :)
  if (!border) {
    return false;
  }

  // If we have individual borders per side within the border object we
  // need to check whether any of those side borders have been set.
  if (hasSplitBorders(border)) {
    const allSidesEmpty = sides.every(side => isEmptyBorder(border[side]));
    return !allSidesEmpty;
  }

  // If we have a top-level border only, check if that is empty. e.g.
  // { color: undefined, style: undefined, width: undefined }
  // Border radius can still be set within the border object as it is
  // handled separately.
  return !isEmptyBorder(border);
};
const isCompleteBorder = border => {
  if (!border) {
    return false;
  }
  return borderProps.every(prop => border[prop] !== undefined);
};
const hasSplitBorders = (border = {}) => {
  return Object.keys(border).some(side => sides.indexOf(side) !== -1);
};
const hasMixedBorders = borders => {
  if (!hasSplitBorders(borders)) {
    return false;
  }
  const shorthandBorders = sides.map(side => getShorthandBorderStyle(borders?.[side]));
  return !shorthandBorders.every(border => border === shorthandBorders[0]);
};
const getSplitBorders = border => {
  if (!border || isEmptyBorder(border)) {
    return undefined;
  }
  return {
    top: border,
    right: border,
    bottom: border,
    left: border
  };
};
const getBorderDiff = (original, updated) => {
  const diff = {};
  if (original.color !== updated.color) {
    diff.color = updated.color;
  }
  if (original.style !== updated.style) {
    diff.style = updated.style;
  }
  if (original.width !== updated.width) {
    diff.width = updated.width;
  }
  return diff;
};
const getCommonBorder = borders => {
  if (!borders) {
    return undefined;
  }
  const colors = [];
  const styles = [];
  const widths = [];
  sides.forEach(side => {
    colors.push(borders[side]?.color);
    styles.push(borders[side]?.style);
    widths.push(borders[side]?.width);
  });
  const allColorsMatch = colors.every(value => value === colors[0]);
  const allStylesMatch = styles.every(value => value === styles[0]);
  const allWidthsMatch = widths.every(value => value === widths[0]);
  return {
    color: allColorsMatch ? colors[0] : undefined,
    style: allStylesMatch ? styles[0] : undefined,
    width: allWidthsMatch ? widths[0] : getMostCommonUnit(widths)
  };
};
const getShorthandBorderStyle = (border, fallbackBorder) => {
  if (isEmptyBorder(border)) {
    return fallbackBorder;
  }
  const {
    color: fallbackColor,
    style: fallbackStyle,
    width: fallbackWidth
  } = fallbackBorder || {};
  const {
    color = fallbackColor,
    style = fallbackStyle,
    width = fallbackWidth
  } = border;
  const hasVisibleBorder = !!width && width !== '0' || !!color;
  const borderStyle = hasVisibleBorder ? style || 'solid' : style;
  return [width, borderStyle, color].filter(Boolean).join(' ');
};
const getMostCommonUnit = values => {
  // Collect all the CSS units.
  const units = values.map(value => value === undefined ? undefined : parseCSSUnitValue(`${value}`)[1]);

  // Return the most common unit out of only the defined CSS units.
  const filteredUnits = units.filter(value => value !== undefined);
  return utils_mode(filteredUnits);
};

/**
 * Finds the mode value out of the array passed favouring the first value
 * as a tiebreaker.
 *
 * @param values Values to determine the mode from.
 *
 * @return The mode value.
 */
function utils_mode(values) {
  if (values.length === 0) {
    return undefined;
  }
  const map = {};
  let maxCount = 0;
  let currentMode;
  values.forEach(value => {
    map[value] = map[value] === undefined ? 1 : map[value] + 1;
    if (map[value] > maxCount) {
      currentMode = value;
      maxCount = map[value];
    }
  });
  return currentMode;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/colors/utils.js
/**
 * External dependencies
 */




/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);
const {
  kebabCase
} = lock_unlock_unlock(privateApis);

/**
 * Provided an array of color objects as set by the theme or by the editor defaults,
 * and the values of the defined color or custom color returns a color object describing the color.
 *
 * @param {Array}   colors       Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} definedColor A string containing the color slug.
 * @param {?string} customColor  A string containing the customColor value.
 *
 * @return {?Object} If definedColor is passed and the name is found in colors,
 *                   the color object exactly as set by the theme or editor defaults is returned.
 *                   Otherwise, an object that just sets the color is defined.
 */
const utils_getColorObjectByAttributeValues = (colors, definedColor, customColor) => {
  if (definedColor) {
    const colorObj = colors?.find(color => color.slug === definedColor);
    if (colorObj) {
      return colorObj;
    }
  }
  return {
    color: customColor
  };
};

/**
 * Provided an array of color objects as set by the theme or by the editor defaults, and a color value returns the color object matching that value or undefined.
 *
 * @param {Array}   colors     Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} colorValue A string containing the color value.
 *
 * @return {?Object} Color object included in the colors array whose color property equals colorValue.
 *                   Returns undefined if no color object matches this requirement.
 */
const getColorObjectByColorValue = (colors, colorValue) => {
  return colors?.find(color => color.color === colorValue);
};

/**
 * Returns a class based on the context a color is being used and its slug.
 *
 * @param {string} colorContextName Context/place where color is being used e.g: background, text etc...
 * @param {string} colorSlug        Slug of the color.
 *
 * @return {?string} String with the class corresponding to the color in the provided context.
 *                   Returns undefined if either colorContextName or colorSlug are not provided.
 */
function utils_getColorClassName(colorContextName, colorSlug) {
  if (!colorContextName || !colorSlug) {
    return undefined;
  }
  return `has-${kebabCase(colorSlug)}-${colorContextName}`;
}

/**
 * Given an array of color objects and a color value returns the color value of the most readable color in the array.
 *
 * @param {Array}   colors     Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} colorValue A string containing the color value.
 *
 * @return {string} String with the color value of the most readable color.
 */
function getMostReadableColor(colors, colorValue) {
  const colordColor = colord(colorValue);
  const getColorContrast = ({
    color
  }) => colordColor.contrast(color);
  const maxContrast = Math.max(...colors.map(getColorContrast));
  return colors.find(color => getColorContrast(color) === maxContrast).color;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/colors-gradients/use-multiple-origin-colors-and-gradients.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Retrieves color and gradient related settings.
 *
 * The arrays for colors and gradients are made up of color palettes from each
 * origin i.e. "Core", "Theme", and "User".
 *
 * @return {Object} Color and gradient related settings.
 */
function use_multiple_origin_colors_and_gradients_useMultipleOriginColorsAndGradients() {
  const [enableCustomColors, customColors, themeColors, defaultColors, shouldDisplayDefaultColors, enableCustomGradients, customGradients, themeGradients, defaultGradients, shouldDisplayDefaultGradients] = use_settings_useSettings('color.custom', 'color.palette.custom', 'color.palette.theme', 'color.palette.default', 'color.defaultPalette', 'color.customGradient', 'color.gradients.custom', 'color.gradients.theme', 'color.gradients.default', 'color.defaultGradients');
  const colorGradientSettings = {
    disableCustomColors: !enableCustomColors,
    disableCustomGradients: !enableCustomGradients
  };
  colorGradientSettings.colors = (0,react.useMemo)(() => {
    const result = [];
    if (themeColors && themeColors.length) {
      result.push({
        name: (0,i18n_build_module._x)('Theme', 'Indicates this palette comes from the theme.'),
        colors: themeColors
      });
    }
    if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
      result.push({
        name: (0,i18n_build_module._x)('Default', 'Indicates this palette comes from WordPress.'),
        colors: defaultColors
      });
    }
    if (customColors && customColors.length) {
      result.push({
        name: (0,i18n_build_module._x)('Custom', 'Indicates this palette comes from the theme.'),
        colors: customColors
      });
    }
    return result;
  }, [customColors, themeColors, defaultColors, shouldDisplayDefaultColors]);
  colorGradientSettings.gradients = (0,react.useMemo)(() => {
    const result = [];
    if (themeGradients && themeGradients.length) {
      result.push({
        name: (0,i18n_build_module._x)('Theme', 'Indicates this palette comes from the theme.'),
        gradients: themeGradients
      });
    }
    if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
      result.push({
        name: (0,i18n_build_module._x)('Default', 'Indicates this palette comes from WordPress.'),
        gradients: defaultGradients
      });
    }
    if (customGradients && customGradients.length) {
      result.push({
        name: (0,i18n_build_module._x)('Custom', 'Indicates this palette is created by the user.'),
        gradients: customGradients
      });
    }
    return result;
  }, [customGradients, themeGradients, defaultGradients, shouldDisplayDefaultGradients]);
  colorGradientSettings.hasColorsOrGradients = !!colorGradientSettings.colors.length || !!colorGradientSettings.gradients.length;
  return colorGradientSettings;
}
//# sourceMappingURL=use-multiple-origin-colors-and-gradients.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/link.js
/**
 * WordPress dependencies
 */


const link_link = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M10 17.389H8.444A5.194 5.194 0 1 1 8.444 7H10v1.5H8.444a3.694 3.694 0 0 0 0 7.389H10v1.5ZM14 7h1.556a5.194 5.194 0 0 1 0 10.39H14v-1.5h1.556a3.694 3.694 0 0 0 0-7.39H14V7Zm-4.5 6h5v-1.5h-5V13Z"
  })
});
/* harmony default export */ const library_link = (link_link);
//# sourceMappingURL=link.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/styles.js
function border_box_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */

const borderBoxControl = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)( true ? "" : 0,  true ? "" : 0);
const linkedBorderControl = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("flex:1;", (0,rtl/* rtl */.h)({
  marginRight: '24px'
})(), ";" + ( true ? "" : 0),  true ? "" : 0);
const wrapper =  true ? {
  name: "bjn8wh",
  styles: "position:relative"
} : 0;
const borderBoxControlLinkedButton = size => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("position:absolute;top:", size === '__unstable-large' ? '8px' : '3px', ";", (0,rtl/* rtl */.h)({
    right: 0
  })(), " line-height:0;" + ( true ? "" : 0),  true ? "" : 0);
};
const borderBoxStyleWithFallback = border => {
  const {
    color = colors_values/* COLORS */.l.gray[200],
    style = 'solid',
    width = config_values/* default */.A.borderWidth
  } = border || {};
  const clampedWidth = width !== config_values/* default */.A.borderWidth ? `clamp(1px, ${width}, 10px)` : width;
  const hasVisibleBorder = !!width && width !== '0' || !!color;
  const borderStyle = hasVisibleBorder ? style || 'solid' : style;
  return `${color} ${borderStyle} ${clampedWidth}`;
};
const borderBoxControlVisualizer = (borders, size) => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("position:absolute;top:", size === '__unstable-large' ? '20px' : '15px', ";right:", size === '__unstable-large' ? '39px' : '29px', ";bottom:", size === '__unstable-large' ? '20px' : '15px', ";left:", size === '__unstable-large' ? '39px' : '29px', ";border-top:", borderBoxStyleWithFallback(borders?.top), ";border-bottom:", borderBoxStyleWithFallback(borders?.bottom), ";", (0,rtl/* rtl */.h)({
    borderLeft: borderBoxStyleWithFallback(borders?.left)
  })(), " ", (0,rtl/* rtl */.h)({
    borderRight: borderBoxStyleWithFallback(borders?.right)
  })(), ";" + ( true ? "" : 0),  true ? "" : 0);
};
const borderBoxControlSplitControls = size => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("position:relative;flex:1;width:", size === '__unstable-large' ? undefined : '80%', ";" + ( true ? "" : 0),  true ? "" : 0);
const centeredBorderControl =  true ? {
  name: "1nwbfnf",
  styles: "grid-column:span 2;margin:0 auto"
} : 0;
const rightBorderControl = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)((0,rtl/* rtl */.h)({
  marginLeft: 'auto'
})(), ";" + ( true ? "" : 0),  true ? "" : 0);
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-linked-button/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function useBorderBoxControlLinkedButton(props) {
  const {
    className,
    size = 'default',
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'BorderBoxControlLinkedButton');

  // Generate class names.
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    return cx(borderBoxControlLinkedButton(size), className);
  }, [className, cx, size]);
  return {
    ...otherProps,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-linked-button/component.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






const BorderBoxControlLinkedButton = (props, forwardedRef) => {
  const {
    className,
    isLinked,
    ...buttonProps
  } = useBorderBoxControlLinkedButton(props);
  const label = isLinked ? (0,i18n_build_module.__)('Unlink sides') : (0,i18n_build_module.__)('Link sides');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
    text: label,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
      className: className,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        ...buttonProps,
        size: "small",
        icon: isLinked ? library_link : link_off,
        iconSize: 24,
        "aria-label": label,
        ref: forwardedRef
      })
    })
  });
};
const ConnectedBorderBoxControlLinkedButton = (0,context_connect/* contextConnect */.KZ)(BorderBoxControlLinkedButton, 'BorderBoxControlLinkedButton');
/* harmony default export */ const border_box_control_linked_button_component = (ConnectedBorderBoxControlLinkedButton);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-visualizer/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function useBorderBoxControlVisualizer(props) {
  const {
    className,
    value,
    size = 'default',
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'BorderBoxControlVisualizer');

  // Generate class names.
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    return cx(borderBoxControlVisualizer(value, size), className);
  }, [cx, className, value, size]);
  return {
    ...otherProps,
    className: classes,
    value
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-visualizer/component.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const BorderBoxControlVisualizer = (props, forwardedRef) => {
  const {
    value,
    ...otherProps
  } = useBorderBoxControlVisualizer(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
    ...otherProps,
    ref: forwardedRef
  });
};
const ConnectedBorderBoxControlVisualizer = (0,context_connect/* contextConnect */.KZ)(BorderBoxControlVisualizer, 'BorderBoxControlVisualizer');
/* harmony default export */ const border_box_control_visualizer_component = (ConnectedBorderBoxControlVisualizer);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/close-small.js
var close_small = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/close-small.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/line-solid.js
/**
 * WordPress dependencies
 */


const lineSolid = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M5 11.25h14v1.5H5z"
  })
});
/* harmony default export */ const line_solid = (lineSolid);
//# sourceMappingURL=line-solid.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/line-dashed.js
/**
 * WordPress dependencies
 */


const lineDashed = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    fillRule: "evenodd",
    d: "M5 11.25h3v1.5H5v-1.5zm5.5 0h3v1.5h-3v-1.5zm8.5 0h-3v1.5h3v-1.5z",
    clipRule: "evenodd"
  })
});
/* harmony default export */ const line_dashed = (lineDashed);
//# sourceMappingURL=line-dashed.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/line-dotted.js
/**
 * WordPress dependencies
 */


const lineDotted = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    fillRule: "evenodd",
    d: "M5.25 11.25h1.5v1.5h-1.5v-1.5zm3 0h1.5v1.5h-1.5v-1.5zm4.5 0h-1.5v1.5h1.5v-1.5zm1.5 0h1.5v1.5h-1.5v-1.5zm4.5 0h-1.5v1.5h1.5v-1.5z",
    clipRule: "evenodd"
  })
});
/* harmony default export */ const line_dotted = (lineDotted);
//# sourceMappingURL=line-dotted.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-control/border-control-style-picker/component.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const BORDER_STYLES = [{
  label: (0,i18n_build_module.__)('Solid'),
  icon: line_solid,
  value: 'solid'
}, {
  label: (0,i18n_build_module.__)('Dashed'),
  icon: line_dashed,
  value: 'dashed'
}, {
  label: (0,i18n_build_module.__)('Dotted'),
  icon: line_dotted,
  value: 'dotted'
}];
function UnconnectedBorderControlStylePicker({
  onChange,
  ...restProps
}, forwardedRef) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_component, {
    __nextHasNoMarginBottom: true,
    __next40pxDefaultSize: true,
    ref: forwardedRef,
    isDeselectable: true,
    onChange: value => {
      onChange?.(value);
    },
    ...restProps,
    children: BORDER_STYLES.map(borderStyle => /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_icon_component, {
      value: borderStyle.value,
      icon: borderStyle.icon,
      label: borderStyle.label
    }, borderStyle.value))
  });
}
const BorderControlStylePicker = (0,context_connect/* contextConnect */.KZ)(UnconnectedBorderControlStylePicker, 'BorderControlStylePicker');
/* harmony default export */ const border_control_style_picker_component = (BorderControlStylePicker);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-indicator/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

function UnforwardedColorIndicator(props, forwardedRef) {
  const {
    className,
    colorValue,
    ...additionalProps
  } = props;
  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
    className: (0,dist_clsx/* default */.A)('component-color-indicator', className),
    style: {
      background: colorValue
    },
    ref: forwardedRef,
    ...additionalProps
  });
}

/**
 * ColorIndicator is a React component that renders a specific color in a
 * circle. It's often used to summarize a collection of used colors in a child
 * component.
 *
 * ```jsx
 * import { ColorIndicator } from '@wordpress/components';
 *
 * const MyColorIndicator = () => <ColorIndicator colorValue="#0073aa" />;
 * ```
 */
const ColorIndicator = (0,react.forwardRef)(UnforwardedColorIndicator);
/* harmony default export */ const color_indicator = (ColorIndicator);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-debounce/index.js
var use_debounce = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-debounce/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/select-control/index.js
var select_control = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/select-control/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/box-sizing.js
var box_sizing = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/box-sizing.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/styles.js

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */









const NumberControlWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(number_control/* default */.A,  true ? {
  target: "ez9hsf47"
} : 0)("width:", (0,space/* space */.x)(24), ";" + ( true ? "" : 0));
const SelectControl = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(select_control/* default */.A,  true ? {
  target: "ez9hsf46"
} : 0)("margin-left:", (0,space/* space */.x)(-2), ";width:5em;" + ( true ? "" : 0));
const styles_RangeControl = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(range_control,  true ? {
  target: "ez9hsf45"
} : 0)("flex:1;margin-right:", (0,space/* space */.x)(2), ";" + ( true ? "" : 0));

// Make the Hue circle picker not go out of the bar.
const interactiveHueStyles = `
.react-colorful__interactive {
	width: calc( 100% - ${(0,space/* space */.x)(2)} );
	margin-left: ${(0,space/* space */.x)(1)};
}`;
const AuxiliaryColorArtefactWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "ez9hsf44"
} : 0)("padding-top:", (0,space/* space */.x)(2), ";padding-right:0;padding-left:0;padding-bottom:0;" + ( true ? "" : 0));
const AuxiliaryColorArtefactHStackHeader = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(h_stack_component/* default */.A,  true ? {
  target: "ez9hsf43"
} : 0)("padding-left:", (0,space/* space */.x)(4), ";padding-right:", (0,space/* space */.x)(4), ";" + ( true ? "" : 0));
const ColorInputWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_component/* default */.A,  true ? {
  target: "ez9hsf42"
} : 0)("padding-top:", (0,space/* space */.x)(4), ";padding-left:", (0,space/* space */.x)(4), ";padding-right:", (0,space/* space */.x)(3), ";padding-bottom:", (0,space/* space */.x)(5), ";" + ( true ? "" : 0));
const ColorfulWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "ez9hsf41"
} : 0)(box_sizing/* boxSizingReset */.r, ";width:216px;.react-colorful{display:flex;flex-direction:column;align-items:center;width:216px;height:auto;}.react-colorful__saturation{width:100%;border-radius:0;height:216px;margin-bottom:", (0,space/* space */.x)(4), ";border-bottom:none;}.react-colorful__hue,.react-colorful__alpha{width:184px;height:16px;border-radius:16px;margin-bottom:", (0,space/* space */.x)(2), ";}.react-colorful__pointer{height:16px;width:16px;border:none;box-shadow:0 0 2px 0 rgba( 0, 0, 0, 0.25 );outline:2px solid transparent;}.react-colorful__pointer-fill{box-shadow:inset 0 0 0 ", config_values/* default */.A.borderWidthFocus, " #fff;}", interactiveHueStyles, ";" + ( true ? "" : 0));
const CopyButton = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(build_module_button/* default */.Ay,  true ? {
  target: "ez9hsf40"
} : 0)("&&&&&{min-width:", (0,space/* space */.x)(6), ";padding:0;>svg{margin-right:0;}}" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/copy.js
/**
 * WordPress dependencies
 */


const copy = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M5 4.5h11a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5H5a.5.5 0 0 1-.5-.5V5a.5.5 0 0 1 .5-.5ZM3 5a2 2 0 0 1 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5Zm17 3v10.75c0 .69-.56 1.25-1.25 1.25H6v1.5h12.75a2.75 2.75 0 0 0 2.75-2.75V8H20Z"
  })
});
/* harmony default export */ const library_copy = (copy);
//# sourceMappingURL=copy.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/color-copy-button.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



const ColorCopyButton = props => {
  const {
    color,
    colorType
  } = props;
  const [copiedColor, setCopiedColor] = (0,react.useState)(null);
  const copyTimer = (0,react.useRef)();
  const copyRef = useCopyToClipboard(() => {
    switch (colorType) {
      case 'hsl':
        {
          return color.toHslString();
        }
      case 'rgb':
        {
          return color.toRgbString();
        }
      default:
      case 'hex':
        {
          return color.toHex();
        }
    }
  }, () => {
    if (copyTimer.current) {
      clearTimeout(copyTimer.current);
    }
    setCopiedColor(color.toHex());
    copyTimer.current = setTimeout(() => {
      setCopiedColor(null);
      copyTimer.current = undefined;
    }, 3000);
  });
  (0,react.useEffect)(() => {
    // Clear copyTimer on component unmount.
    return () => {
      if (copyTimer.current) {
        clearTimeout(copyTimer.current);
      }
    };
  }, []);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
    delay: 0,
    hideOnClick: false,
    text: copiedColor === color.toHex() ? (0,i18n_build_module.__)('Copied!') : (0,i18n_build_module.__)('Copy'),
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(CopyButton, {
      size: "small",
      ref: copyRef,
      icon: library_copy,
      showTooltip: false
    })
  });
};
//# sourceMappingURL=color-copy-button.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/text/component.js
var text_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/text/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/spacer/component.js + 1 modules
var spacer_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/spacer/component.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/input-with-slider.js
/**
 * Internal dependencies
 */








const InputWithSlider = ({
  min,
  max,
  label,
  abbreviation,
  onChange,
  value
}) => {
  const onNumberControlChange = newValue => {
    if (!newValue) {
      onChange(0);
      return;
    }
    if (typeof newValue === 'string') {
      onChange(parseInt(newValue, 10));
      return;
    }
    onChange(newValue);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
    spacing: 4,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(NumberControlWrapper, {
      min: min,
      max: max,
      label: label,
      hideLabelFromVision: true,
      value: value,
      onChange: onNumberControlChange,
      prefix: /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
        as: text_component/* default */.A,
        paddingLeft: (0,space/* space */.x)(4),
        color: colors_values/* COLORS */.l.theme.accent,
        lineHeight: 1,
        children: abbreviation
      }),
      spinControls: "none",
      size: "__unstable-large"
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(styles_RangeControl, {
      __nextHasNoMarginBottom: true,
      label: label,
      hideLabelFromVision: true,
      min: min,
      max: max,
      value: value
      // @ts-expect-error
      // See: https://github.com/WordPress/gutenberg/pull/40535#issuecomment-1172418185
      ,
      onChange: onChange,
      withInputField: false
    })]
  });
};
//# sourceMappingURL=input-with-slider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/rgb-input.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */




const RgbInput = ({
  color,
  onChange,
  enableAlpha
}) => {
  const {
    r,
    g,
    b,
    a
  } = color.toRgb();
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(InputWithSlider, {
      min: 0,
      max: 255,
      label: "Red",
      abbreviation: "R",
      value: r,
      onChange: nextR => onChange((0,node_modules_colord/* colord */.Mj)({
        r: nextR,
        g,
        b,
        a
      }))
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(InputWithSlider, {
      min: 0,
      max: 255,
      label: "Green",
      abbreviation: "G",
      value: g,
      onChange: nextG => onChange((0,node_modules_colord/* colord */.Mj)({
        r,
        g: nextG,
        b,
        a
      }))
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(InputWithSlider, {
      min: 0,
      max: 255,
      label: "Blue",
      abbreviation: "B",
      value: b,
      onChange: nextB => onChange((0,node_modules_colord/* colord */.Mj)({
        r,
        g,
        b: nextB,
        a
      }))
    }), enableAlpha && /*#__PURE__*/(0,jsx_runtime.jsx)(InputWithSlider, {
      min: 0,
      max: 100,
      label: "Alpha",
      abbreviation: "A",
      value: Math.trunc(a * 100),
      onChange: nextA => onChange((0,node_modules_colord/* colord */.Mj)({
        r,
        g,
        b,
        a: nextA / 100
      }))
    })]
  });
};
//# sourceMappingURL=rgb-input.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/hsl-input.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




const HslInput = ({
  color,
  onChange,
  enableAlpha
}) => {
  const colorPropHSLA = (0,react.useMemo)(() => color.toHsl(), [color]);
  const [internalHSLA, setInternalHSLA] = (0,react.useState)({
    ...colorPropHSLA
  });
  const isInternalColorSameAsReceivedColor = color.isEqual((0,node_modules_colord/* colord */.Mj)(internalHSLA));
  (0,react.useEffect)(() => {
    if (!isInternalColorSameAsReceivedColor) {
      // Keep internal HSLA color up to date with the received color prop
      setInternalHSLA(colorPropHSLA);
    }
  }, [colorPropHSLA, isInternalColorSameAsReceivedColor]);

  // If the internal color is equal to the received color prop, we can use the
  // HSLA values from the local state which, compared to the received color prop,
  // retain more details about the actual H and S values that the user selected,
  // and thus allow for better UX when interacting with the H and S sliders.
  const colorValue = isInternalColorSameAsReceivedColor ? internalHSLA : colorPropHSLA;
  const updateHSLAValue = partialNewValue => {
    const nextOnChangeValue = (0,node_modules_colord/* colord */.Mj)({
      ...colorValue,
      ...partialNewValue
    });

    // Fire `onChange` only if the resulting color is different from the
    // current one.
    // Otherwise, update the internal HSLA color to cause a re-render.
    if (!color.isEqual(nextOnChangeValue)) {
      onChange(nextOnChangeValue);
    } else {
      setInternalHSLA(prevHSLA => ({
        ...prevHSLA,
        ...partialNewValue
      }));
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(InputWithSlider, {
      min: 0,
      max: 359,
      label: "Hue",
      abbreviation: "H",
      value: colorValue.h,
      onChange: nextH => {
        updateHSLAValue({
          h: nextH
        });
      }
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(InputWithSlider, {
      min: 0,
      max: 100,
      label: "Saturation",
      abbreviation: "S",
      value: colorValue.s,
      onChange: nextS => {
        updateHSLAValue({
          s: nextS
        });
      }
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(InputWithSlider, {
      min: 0,
      max: 100,
      label: "Lightness",
      abbreviation: "L",
      value: colorValue.l,
      onChange: nextL => {
        updateHSLAValue({
          l: nextL
        });
      }
    }), enableAlpha && /*#__PURE__*/(0,jsx_runtime.jsx)(InputWithSlider, {
      min: 0,
      max: 100,
      label: "Alpha",
      abbreviation: "A",
      value: Math.trunc(100 * colorValue.a),
      onChange: nextA => {
        updateHSLAValue({
          a: nextA / 100
        });
      }
    })]
  });
};
//# sourceMappingURL=hsl-input.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/index.js + 4 modules
var input_control = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/hex-input.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






const HexInput = ({
  color,
  onChange,
  enableAlpha
}) => {
  const handleChange = nextValue => {
    if (!nextValue) {
      return;
    }
    const hexValue = nextValue.startsWith('#') ? nextValue : '#' + nextValue;
    onChange((0,node_modules_colord/* colord */.Mj)(hexValue));
  };
  const stateReducer = (state, action) => {
    const nativeEvent = action.payload?.event?.nativeEvent;
    if ('insertFromPaste' !== nativeEvent?.inputType) {
      return {
        ...state
      };
    }
    const value = state.value?.startsWith('#') ? state.value.slice(1).toUpperCase() : state.value?.toUpperCase();
    return {
      ...state,
      value
    };
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(input_control/* InputControl */.ey, {
    prefix: /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
      as: text_component/* default */.A,
      marginLeft: (0,space/* space */.x)(4),
      color: colors_values/* COLORS */.l.theme.accent,
      lineHeight: 1,
      children: "#"
    }),
    value: color.toHex().slice(1).toUpperCase(),
    onChange: handleChange,
    maxLength: enableAlpha ? 9 : 7,
    label: (0,i18n_build_module.__)('Hex color'),
    hideLabelFromVision: true,
    size: "__unstable-large",
    __unstableStateReducer: stateReducer,
    __unstableInputWidth: "9em"
  });
};
//# sourceMappingURL=hex-input.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/color-input.js
/**
 * Internal dependencies
 */




const ColorInput = ({
  colorType,
  color,
  onChange,
  enableAlpha
}) => {
  const props = {
    color,
    onChange,
    enableAlpha
  };
  switch (colorType) {
    case 'hsl':
      return /*#__PURE__*/(0,jsx_runtime.jsx)(HslInput, {
        ...props
      });
    case 'rgb':
      return /*#__PURE__*/(0,jsx_runtime.jsx)(RgbInput, {
        ...props
      });
    default:
    case 'hex':
      return /*#__PURE__*/(0,jsx_runtime.jsx)(HexInput, {
        ...props
      });
  }
};
//# sourceMappingURL=color-input.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react-colorful@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-colorful/dist/index.mjs
var dist = __webpack_require__("../../node_modules/.pnpm/react-colorful@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-colorful/dist/index.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/picker.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const Picker = ({
  color,
  enableAlpha,
  onChange
}) => {
  const Component = enableAlpha ? dist/* RgbaStringColorPicker */.p9 : dist/* RgbStringColorPicker */.gy;
  const rgbColor = (0,react.useMemo)(() => color.toRgbString(), [color]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Component, {
    color: rgbColor,
    onChange: nextColor => {
      onChange((0,node_modules_colord/* colord */.Mj)(nextColor));
    }
    // Pointer capture fortifies drag gestures so that they continue to
    // work while dragging outside the component over objects like
    // iframes. If a newer version of react-colorful begins to employ
    // pointer capture this will be redundant and should be removed.
    ,
    onPointerDown: ({
      currentTarget,
      pointerId
    }) => {
      currentTarget.setPointerCapture(pointerId);
    },
    onPointerUp: ({
      currentTarget,
      pointerId
    }) => {
      currentTarget.releasePointerCapture(pointerId);
    }
  });
};
//# sourceMappingURL=picker.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/component.js
/**
 * External dependencies
 */




/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */








(0,node_modules_colord/* extend */.X$)([names/* default */.A]);
const options = [{
  label: 'RGB',
  value: 'rgb'
}, {
  label: 'HSL',
  value: 'hsl'
}, {
  label: 'Hex',
  value: 'hex'
}];

// `isBorderless` is still experimental and not a public prop for InputControl yet.
const BORDERLESS_SELECT_CONTROL_CONTEXT = {
  InputBase: {
    isBorderless: true
  }
};
const UnconnectedColorPicker = (props, forwardedRef) => {
  const {
    enableAlpha = false,
    color: colorProp,
    onChange,
    defaultValue = '#fff',
    copyFormat,
    ...divProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'ColorPicker');

  // Use a safe default value for the color and remove the possibility of `undefined`.
  const [color, setColor] = (0,use_controlled_value/* useControlledValue */.j)({
    onChange,
    value: colorProp,
    defaultValue
  });
  const safeColordColor = (0,react.useMemo)(() => {
    return (0,node_modules_colord/* colord */.Mj)(color || '');
  }, [color]);
  const debouncedSetColor = (0,use_debounce/* default */.A)(setColor);
  const handleChange = (0,react.useCallback)(nextValue => {
    debouncedSetColor(nextValue.toHex());
  }, [debouncedSetColor]);
  const [colorType, setColorType] = (0,react.useState)(copyFormat || 'hex');
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(ColorfulWrapper, {
    ref: forwardedRef,
    ...divProps,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Picker, {
      onChange: handleChange,
      color: safeColordColor,
      enableAlpha: enableAlpha
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(AuxiliaryColorArtefactWrapper, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(AuxiliaryColorArtefactHStackHeader, {
        justify: "space-between",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(context_system_provider/* ContextSystemProvider */.c7, {
          value: BORDERLESS_SELECT_CONTROL_CONTEXT,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(SelectControl, {
            __nextHasNoMarginBottom: true,
            options: options,
            value: colorType,
            onChange: nextColorType => setColorType(nextColorType),
            label: (0,i18n_build_module.__)('Color format'),
            hideLabelFromVision: true
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(ColorCopyButton, {
          color: safeColordColor,
          colorType: copyFormat || colorType
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(ColorInputWrapper, {
        direction: "column",
        gap: 2,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(ColorInput, {
          colorType: colorType,
          color: safeColordColor,
          onChange: handleChange,
          enableAlpha: enableAlpha
        })
      })]
    })]
  });
};
const ColorPicker = (0,context_connect/* contextConnect */.KZ)(UnconnectedColorPicker, 'ColorPicker');
/* harmony default export */ const color_picker_component = (ColorPicker);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/memize@2.1.0/node_modules/memize/dist/index.js
var memize_dist = __webpack_require__("../../node_modules/.pnpm/memize@2.1.0/node_modules/memize/dist/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/use-deprecated-props.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

function isLegacyProps(props) {
  return typeof props.onChangeComplete !== 'undefined' || typeof props.disableAlpha !== 'undefined' || typeof props.color?.hex === 'string';
}
function getColorFromLegacyProps(color) {
  if (color === undefined) {
    return;
  }
  if (typeof color === 'string') {
    return color;
  }
  if (color.hex) {
    return color.hex;
  }
  return undefined;
}
const transformColorStringToLegacyColor = (0,memize_dist/* default */.A)(color => {
  const colordColor = (0,node_modules_colord/* colord */.Mj)(color);
  const hex = colordColor.toHex();
  const rgb = colordColor.toRgb();
  const hsv = colordColor.toHsv();
  const hsl = colordColor.toHsl();
  return {
    hex,
    rgb,
    hsv,
    hsl,
    source: 'hex',
    oldHue: hsl.h
  };
});
function useDeprecatedProps(props) {
  const {
    onChangeComplete
  } = props;
  const legacyChangeHandler = (0,react.useCallback)(color => {
    onChangeComplete(transformColorStringToLegacyColor(color));
  }, [onChangeComplete]);
  if (isLegacyProps(props)) {
    return {
      color: getColorFromLegacyProps(props.color),
      enableAlpha: !props.disableAlpha,
      onChange: legacyChangeHandler
    };
  }
  return {
    ...props,
    color: props.color,
    enableAlpha: props.enableAlpha,
    onChange: props.onChange
  };
}
//# sourceMappingURL=use-deprecated-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-picker/legacy-adapter.js
/**
 * Internal dependencies
 */



const LegacyAdapter = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(color_picker_component, {
    ...useDeprecatedProps(props)
  });
};
//# sourceMappingURL=legacy-adapter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/circular-option-picker/circular-option-picker-context.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

const CircularOptionPickerContext = (0,react.createContext)({});
//# sourceMappingURL=circular-option-picker-context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/circular-option-picker/circular-option-picker-option.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






function UnforwardedOptionAsButton(props, forwardedRef) {
  const {
    isPressed,
    ...additionalProps
  } = props;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
    ...additionalProps,
    "aria-pressed": isPressed,
    ref: forwardedRef
  });
}
const OptionAsButton = (0,react.forwardRef)(UnforwardedOptionAsButton);
function UnforwardedOptionAsOption(props, forwardedRef) {
  const {
    id,
    isSelected,
    compositeStore,
    ...additionalProps
  } = props;
  const activeId = compositeStore.useState('activeId');
  if (isSelected && !activeId) {
    compositeStore.setActiveId(id);
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(QZLXIDNP/* CompositeItem */.l, {
    render: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      ...additionalProps,
      role: "option",
      "aria-selected": !!isSelected,
      ref: forwardedRef
    }),
    store: compositeStore,
    id: id
  });
}
const OptionAsOption = (0,react.forwardRef)(UnforwardedOptionAsOption);
function Option({
  className,
  isSelected,
  selectedIconProps = {},
  tooltipText,
  ...additionalProps
}) {
  const {
    baseId,
    compositeStore
  } = (0,react.useContext)(CircularOptionPickerContext);
  const id = (0,use_instance_id/* default */.A)(Option, baseId || 'components-circular-option-picker__option');
  const commonProps = {
    id,
    className: 'components-circular-option-picker__option',
    ...additionalProps
  };
  const optionControl = compositeStore ? /*#__PURE__*/(0,jsx_runtime.jsx)(OptionAsOption, {
    ...commonProps,
    compositeStore: compositeStore,
    isSelected: isSelected
  }) : /*#__PURE__*/(0,jsx_runtime.jsx)(OptionAsButton, {
    ...commonProps,
    isPressed: isSelected
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: (0,dist_clsx/* default */.A)(className, 'components-circular-option-picker__option-wrapper'),
    children: [tooltipText ? /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
      text: tooltipText,
      children: optionControl
    }) : optionControl, isSelected && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
      icon: check/* default */.A,
      ...selectedIconProps
    })]
  });
}
//# sourceMappingURL=circular-option-picker-option.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/circular-option-picker/circular-option-picker-option-group.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */

function OptionGroup({
  className,
  options,
  ...additionalProps
}) {
  const role = 'aria-label' in additionalProps || 'aria-labelledby' in additionalProps ? 'group' : undefined;
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ...additionalProps,
    role: role,
    className: (0,dist_clsx/* default */.A)('components-circular-option-picker__option-group', 'components-circular-option-picker__swatches', className),
    children: options
  });
}
//# sourceMappingURL=circular-option-picker-option-group.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/circular-option-picker/circular-option-picker-actions.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */



function DropdownLinkAction({
  buttonProps,
  className,
  dropdownProps,
  linkText
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown/* default */.A, {
    className: (0,dist_clsx/* default */.A)('components-circular-option-picker__dropdown-link-action', className),
    renderToggle: ({
      isOpen,
      onToggle
    }) => /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      "aria-expanded": isOpen,
      "aria-haspopup": "true",
      onClick: onToggle,
      variant: "link",
      ...buttonProps,
      children: linkText
    }),
    ...dropdownProps
  });
}
function ButtonAction({
  className,
  children,
  ...additionalProps
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
    className: (0,dist_clsx/* default */.A)('components-circular-option-picker__clear', className),
    variant: "tertiary",
    ...additionalProps,
    children: children
  });
}
//# sourceMappingURL=circular-option-picker-actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/circular-option-picker/circular-option-picker.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






/**
 *`CircularOptionPicker` is a component that displays a set of options as circular buttons.
 *
 * ```jsx
 * import { CircularOptionPicker } from '../circular-option-picker';
 * import { useState } from '@wordpress/element';
 *
 * const Example = () => {
 * 	const [ currentColor, setCurrentColor ] = useState();
 * 	const colors = [
 * 		{ color: '#f00', name: 'Red' },
 * 		{ color: '#0f0', name: 'Green' },
 * 		{ color: '#00f', name: 'Blue' },
 * 	];
 * 	const colorOptions = (
 * 		<>
 * 			{ colors.map( ( { color, name }, index ) => {
 * 				return (
 * 					<CircularOptionPicker.Option
 * 						key={ `${ color }-${ index }` }
 * 						tooltipText={ name }
 * 						style={ { backgroundColor: color, color } }
 * 						isSelected={ index === currentColor }
 * 						onClick={ () => setCurrentColor( index ) }
 * 						aria-label={ name }
 * 					/>
 * 				);
 * 			} ) }
 * 		</>
 * 	);
 * 	return (
 * 		<CircularOptionPicker
 * 				options={ colorOptions }
 * 				actions={
 * 					<CircularOptionPicker.ButtonAction
 * 						onClick={ () => setCurrentColor( undefined ) }
 * 					>
 * 						{ 'Clear' }
 * 					</CircularOptionPicker.ButtonAction>
 * 				}
 * 			/>
 * 	);
 * };
 * ```
 */


function ListboxCircularOptionPicker(props) {
  const {
    actions,
    options,
    baseId,
    className,
    loop = true,
    children,
    ...additionalProps
  } = props;
  const compositeStore = (0,_7GBW5FLS/* useCompositeStore */.q)({
    focusLoop: loop,
    rtl: (0,i18n_build_module/* isRTL */.V8)()
  });
  const compositeContext = {
    baseId,
    compositeStore
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: className,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(CircularOptionPickerContext.Provider, {
      value: compositeContext,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(_7QTPYGNZ/* Composite */.e, {
        ...additionalProps,
        id: baseId,
        store: compositeStore,
        role: "listbox",
        children: options
      }), children, actions]
    })
  });
}
function ButtonsCircularOptionPicker(props) {
  const {
    actions,
    options,
    children,
    baseId,
    ...additionalProps
  } = props;
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ...additionalProps,
    id: baseId,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(CircularOptionPickerContext.Provider, {
      value: {
        baseId
      },
      children: [options, children, actions]
    })
  });
}
function CircularOptionPicker(props) {
  const {
    asButtons,
    actions: actionsProp,
    options: optionsProp,
    children,
    className,
    ...additionalProps
  } = props;
  const baseId = (0,use_instance_id/* default */.A)(CircularOptionPicker, 'components-circular-option-picker', additionalProps.id);
  const OptionPickerImplementation = asButtons ? ButtonsCircularOptionPicker : ListboxCircularOptionPicker;
  const actions = actionsProp ? /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "components-circular-option-picker__custom-clear-wrapper",
    children: actionsProp
  }) : undefined;
  const options = /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "components-circular-option-picker__swatches",
    children: optionsProp
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(OptionPickerImplementation, {
    ...additionalProps,
    baseId: baseId,
    className: (0,dist_clsx/* default */.A)('components-circular-option-picker', className),
    actions: actions,
    options: options,
    children: children
  });
}
CircularOptionPicker.Option = Option;
CircularOptionPicker.OptionGroup = OptionGroup;
CircularOptionPicker.ButtonAction = ButtonAction;
CircularOptionPicker.DropdownLinkAction = DropdownLinkAction;
/* harmony default export */ const circular_option_picker = (CircularOptionPicker);
//# sourceMappingURL=circular-option-picker.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/circular-option-picker/index.js
/**
 * Internal dependencies
 */




/* harmony default export */ const build_module_circular_option_picker = (circular_option_picker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-palette/styles.js

function color_palette_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const ColorHeading = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(heading_component/* default */.A,  true ? {
  target: "ev9wop70"
} : 0)( true ? {
  name: "13lxv2o",
  styles: "text-transform:uppercase;line-height:24px;font-weight:500;&&&{font-size:11px;margin-bottom:0;}"
} : 0);
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/dropdown/styles.js

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const styles_padding = ({
  paddingSize = 'small'
}) => {
  if (paddingSize === 'none') {
    return;
  }
  const paddingValues = {
    small: (0,space/* space */.x)(2),
    medium: (0,space/* space */.x)(4)
  };
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding:", paddingValues[paddingSize] || paddingValues.small, ";" + ( true ? "" : 0),  true ? "" : 0);
};
const DropdownContentWrapperDiv = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eovvns30"
} : 0)("margin-left:", (0,space/* space */.x)(-2), ";margin-right:", (0,space/* space */.x)(-2), ";&:first-of-type{margin-top:", (0,space/* space */.x)(-2), ";}&:last-of-type{margin-bottom:", (0,space/* space */.x)(-2), ";}", styles_padding, ";" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/dropdown/dropdown-content-wrapper.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function UnconnectedDropdownContentWrapper(props, forwardedRef) {
  const {
    paddingSize = 'small',
    ...derivedProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'DropdownContentWrapper');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(DropdownContentWrapperDiv, {
    ...derivedProps,
    paddingSize: paddingSize,
    ref: forwardedRef
  });
}

/**
 * A convenience wrapper for the `renderContent` when you want to apply
 * different padding. (Default is `paddingSize="small"`).
 *
 * ```jsx
 * import {
 *   Dropdown,
 *   __experimentalDropdownContentWrapper as DropdownContentWrapper,
 * } from '@wordpress/components';
 *
 * <Dropdown
 *   renderContent={ () => (
 *     <DropdownContentWrapper paddingSize="medium">
 *       My dropdown content
 *     </DropdownContentWrapper>
 * ) }
 * />
 * ```
 */
const DropdownContentWrapper = (0,context_connect/* contextConnect */.KZ)(UnconnectedDropdownContentWrapper, 'DropdownContentWrapper');
/* harmony default export */ const dropdown_content_wrapper = (DropdownContentWrapper);
//# sourceMappingURL=dropdown-content-wrapper.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-palette/utils.js
/**
 * External dependencies
 */




/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);
const extractColorNameFromCurrentValue = (currentValue, colors = [], showMultiplePalettes = false) => {
  if (!currentValue) {
    return '';
  }
  const currentValueIsCssVariable = /^var\(/.test(currentValue);
  const normalizedCurrentValue = currentValueIsCssVariable ? currentValue : (0,node_modules_colord/* colord */.Mj)(currentValue).toHex();

  // Normalize format of `colors` to simplify the following loop

  const colorPalettes = showMultiplePalettes ? colors : [{
    colors: colors
  }];
  for (const {
    colors: paletteColors
  } of colorPalettes) {
    for (const {
      name: colorName,
      color: colorValue
    } of paletteColors) {
      const normalizedColorValue = currentValueIsCssVariable ? colorValue : (0,node_modules_colord/* colord */.Mj)(colorValue).toHex();
      if (normalizedCurrentValue === normalizedColorValue) {
        return colorName;
      }
    }
  }

  // translators: shown when the user has picked a custom color (i.e not in the palette of colors).
  return (0,i18n_build_module.__)('Custom');
};

// The PaletteObject type has a `colors` property (an array of ColorObject),
// while the ColorObject type has a `color` property (the CSS color value).
const isMultiplePaletteObject = obj => Array.isArray(obj.colors) && !('color' in obj);
const isMultiplePaletteArray = arr => {
  return arr.length > 0 && arr.every(colorObj => isMultiplePaletteObject(colorObj));
};

/**
 * Transform a CSS variable used as background color into the color value itself.
 *
 * @param value   The color value that may be a CSS variable.
 * @param element The element for which to get the computed style.
 * @return The background color value computed from a element.
 */
const normalizeColorValue = (value, element) => {
  const currentValueIsCssVariable = /^var\(/.test(value !== null && value !== void 0 ? value : '');
  if (!currentValueIsCssVariable || element === null) {
    return value;
  }
  const {
    ownerDocument
  } = element;
  const {
    defaultView
  } = ownerDocument;
  const computedBackgroundColor = defaultView?.getComputedStyle(element).backgroundColor;
  return computedBackgroundColor ? (0,node_modules_colord/* colord */.Mj)(computedBackgroundColor).toHex() : value;
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/color-palette/index.js
/**
 * External dependencies
 */






/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */










(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);
function SinglePalette({
  className,
  clearColor,
  colors,
  onChange,
  value,
  ...additionalProps
}) {
  const colorOptions = (0,react.useMemo)(() => {
    return colors.map(({
      color,
      name
    }, index) => {
      const colordColor = (0,node_modules_colord/* colord */.Mj)(color);
      const isSelected = value === color;
      return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker.Option, {
        isSelected: isSelected,
        selectedIconProps: isSelected ? {
          fill: colordColor.contrast() > colordColor.contrast('#000') ? '#fff' : '#000'
        } : {},
        tooltipText: name ||
        // translators: %s: color hex code e.g: "#f00".
        (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Color code: %s'), color),
        style: {
          backgroundColor: color,
          color
        },
        onClick: isSelected ? clearColor : () => onChange(color, index),
        "aria-label": name ?
        // translators: %s: The name of the color e.g: "vivid red".
        (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Color: %s'), name) :
        // translators: %s: color hex code e.g: "#f00".
        (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Color code: %s'), color)
      }, `${color}-${index}`);
    });
  }, [colors, value, onChange, clearColor]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker.OptionGroup, {
    className: className,
    options: colorOptions,
    ...additionalProps
  });
}
function MultiplePalettes({
  className,
  clearColor,
  colors,
  onChange,
  value,
  headingLevel
}) {
  const instanceId = (0,use_instance_id/* default */.A)(MultiplePalettes, 'color-palette');
  if (colors.length === 0) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(v_stack_component/* default */.A, {
    spacing: 3,
    className: className,
    children: colors.map(({
      name,
      colors: colorPalette
    }, index) => {
      const id = `${instanceId}-${index}`;
      return /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
        spacing: 2,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(ColorHeading, {
          id: id,
          level: headingLevel,
          children: name
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(SinglePalette, {
          clearColor: clearColor,
          colors: colorPalette,
          onChange: newColor => onChange(newColor, index),
          value: value,
          "aria-labelledby": id
        })]
      }, index);
    })
  });
}
function CustomColorPickerDropdown({
  isRenderedInSidebar,
  popoverProps: receivedPopoverProps,
  ...props
}) {
  const popoverProps = (0,react.useMemo)(() => ({
    shift: true,
    // Disabling resize as it would otherwise cause the popover to show
    // scrollbars while dragging the color picker's handle close to the
    // popover edge.
    resize: false,
    ...(isRenderedInSidebar ? {
      // When in the sidebar: open to the left (stacking),
      // leaving the same gap as the parent popover.
      placement: 'left-start',
      offset: 34
    } : {
      // Default behavior: open below the anchor
      placement: 'bottom',
      offset: 8
    }),
    ...receivedPopoverProps
  }), [isRenderedInSidebar, receivedPopoverProps]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown/* default */.A, {
    contentClassName: "components-color-palette__custom-color-dropdown-content",
    popoverProps: popoverProps,
    ...props
  });
}
function UnforwardedColorPalette(props, forwardedRef) {
  const {
    asButtons,
    loop,
    clearable = true,
    colors = [],
    disableCustomColors = false,
    enableAlpha = false,
    onChange,
    value,
    __experimentalIsRenderedInSidebar = false,
    headingLevel = 2,
    'aria-label': ariaLabel,
    'aria-labelledby': ariaLabelledby,
    ...additionalProps
  } = props;
  const [normalizedColorValue, setNormalizedColorValue] = (0,react.useState)(value);
  const clearColor = (0,react.useCallback)(() => onChange(undefined), [onChange]);
  const customColorPaletteCallbackRef = (0,react.useCallback)(node => {
    setNormalizedColorValue(normalizeColorValue(value, node));
  }, [value]);
  const hasMultipleColorOrigins = isMultiplePaletteArray(colors);
  const buttonLabelName = (0,react.useMemo)(() => extractColorNameFromCurrentValue(value, colors, hasMultipleColorOrigins), [value, colors, hasMultipleColorOrigins]);
  const renderCustomColorPicker = () => /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_content_wrapper, {
    paddingSize: "none",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(LegacyAdapter, {
      color: normalizedColorValue,
      onChange: color => onChange(color),
      enableAlpha: enableAlpha
    })
  });
  const isHex = value?.startsWith('#');

  // Leave hex values as-is. Remove the `var()` wrapper from CSS vars.
  const displayValue = value?.replace(/^var\((.+)\)$/, '$1');
  const customColorAccessibleLabel = !!displayValue ? (0,i18n_build_module/* sprintf */.nv)(
  // translators: %1$s: The name of the color e.g: "vivid red". %2$s: The color's hex code e.g: "#f00".
  (0,i18n_build_module.__)('Custom color picker. The currently selected color is called "%1$s" and has a value of "%2$s".'), buttonLabelName, displayValue) : (0,i18n_build_module.__)('Custom color picker.');
  const paletteCommonProps = {
    clearColor,
    onChange,
    value
  };
  const actions = !!clearable && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker.ButtonAction, {
    onClick: clearColor,
    children: (0,i18n_build_module.__)('Clear')
  });
  let metaProps;
  if (asButtons) {
    metaProps = {
      asButtons: true
    };
  } else {
    const _metaProps = {
      asButtons: false,
      loop
    };
    if (ariaLabel) {
      metaProps = {
        ..._metaProps,
        'aria-label': ariaLabel
      };
    } else if (ariaLabelledby) {
      metaProps = {
        ..._metaProps,
        'aria-labelledby': ariaLabelledby
      };
    } else {
      metaProps = {
        ..._metaProps,
        'aria-label': (0,i18n_build_module.__)('Custom color picker.')
      };
    }
  }
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
    spacing: 3,
    ref: forwardedRef,
    ...additionalProps,
    children: [!disableCustomColors && /*#__PURE__*/(0,jsx_runtime.jsx)(CustomColorPickerDropdown, {
      isRenderedInSidebar: __experimentalIsRenderedInSidebar,
      renderContent: renderCustomColorPicker,
      renderToggle: ({
        isOpen,
        onToggle
      }) => /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
        className: "components-color-palette__custom-color-wrapper",
        spacing: 0,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("button", {
          ref: customColorPaletteCallbackRef,
          className: "components-color-palette__custom-color-button",
          "aria-expanded": isOpen,
          "aria-haspopup": "true",
          onClick: onToggle,
          "aria-label": customColorAccessibleLabel,
          style: {
            background: value
          },
          type: "button"
        }), /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
          className: "components-color-palette__custom-color-text-wrapper",
          spacing: 0.5,
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(truncate_component, {
            className: "components-color-palette__custom-color-name",
            children: value ? buttonLabelName : (0,i18n_build_module.__)('No color selected')
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(truncate_component, {
            className: (0,dist_clsx/* default */.A)('components-color-palette__custom-color-value', {
              'components-color-palette__custom-color-value--is-hex': isHex
            }),
            children: displayValue
          })]
        })]
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker, {
      ...metaProps,
      actions: actions,
      options: hasMultipleColorOrigins ? /*#__PURE__*/(0,jsx_runtime.jsx)(MultiplePalettes, {
        ...paletteCommonProps,
        headingLevel: headingLevel,
        colors: colors,
        value: value
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)(SinglePalette, {
        ...paletteCommonProps,
        colors: colors,
        value: value
      })
    })]
  });
}

/**
 * Allows the user to pick a color from a list of pre-defined color entries.
 *
 * ```jsx
 * import { ColorPalette } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyColorPalette = () => {
 *   const [ color, setColor ] = useState ( '#f00' )
 *   const colors = [
 *     { name: 'red', color: '#f00' },
 *     { name: 'white', color: '#fff' },
 *     { name: 'blue', color: '#00f' },
 *   ];
 *   return (
 *     <ColorPalette
 *       colors={ colors }
 *       value={ color }
 *       onChange={ ( color ) => setColor( color ) }
 *     />
 *   );
 * } );
 * ```
 */
const ColorPalette = (0,react.forwardRef)(UnforwardedColorPalette);
/* harmony default export */ const color_palette = (ColorPalette);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-control/styles.js
function border_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */




const labelStyles =  true ? {
  name: "f3vz0n",
  styles: "font-weight:500"
} : 0;
const focusBoxShadow = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("box-shadow:inset ", config_values/* default */.A.controlBoxShadowFocus, ";" + ( true ? "" : 0),  true ? "" : 0);
const borderControl = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border:0;padding:0;margin:0;", box_sizing/* boxSizingReset */.r, ";" + ( true ? "" : 0),  true ? "" : 0);
const innerWrapper = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(ValueInput, "{flex:1 1 40%;}&& ", UnitSelect, "{min-height:0;}" + ( true ? "" : 0),  true ? "" : 0);

/*
 * This style is only applied to the UnitControl wrapper when the border width
 * field should be a set width. Omitting this allows the UnitControl &
 * RangeControl to share the available width in a 40/60 split respectively.
 */
const styles_wrapperWidth = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(ValueInput, "{flex:0 0 auto;}" + ( true ? "" : 0),  true ? "" : 0);
const wrapperHeight = size => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("height:", size === '__unstable-large' ? '40px' : '30px', ";" + ( true ? "" : 0),  true ? "" : 0);
};
const borderControlDropdown = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("background:#fff;&&>button{aspect-ratio:1;padding:0;display:flex;align-items:center;justify-content:center;", (0,rtl/* rtl */.h)({
  borderRadius: `2px 0 0 2px`
}, {
  borderRadius: `0 2px 2px 0`
})(), " border:", config_values/* default */.A.borderWidth, " solid ", colors_values/* COLORS */.l.ui.border, ";&:focus,&:hover:not( :disabled ){", focusBoxShadow, " border-color:", colors_values/* COLORS */.l.ui.borderFocus, ";z-index:1;position:relative;}}" + ( true ? "" : 0),  true ? "" : 0);
const colorIndicatorBorder = border => {
  const {
    color,
    style
  } = border || {};
  const fallbackColor = !!style && style !== 'none' ? colors_values/* COLORS */.l.gray[300] : undefined;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border-style:", style === 'none' ? 'solid' : style, ";border-color:", color || fallbackColor, ";" + ( true ? "" : 0),  true ? "" : 0);
};
const colorIndicatorWrapper = (border, size) => {
  const {
    style
  } = border || {};
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border-radius:9999px;border:2px solid transparent;", style ? colorIndicatorBorder(border) : undefined, " width:", size === '__unstable-large' ? '24px' : '22px', ";height:", size === '__unstable-large' ? '24px' : '22px', ";padding:", size === '__unstable-large' ? '2px' : '1px', ";&>span{height:", (0,space/* space */.x)(4), ";width:", (0,space/* space */.x)(4), ";background:linear-gradient(\n\t\t\t\t-45deg,\n\t\t\t\ttransparent 48%,\n\t\t\t\trgb( 0 0 0 / 20% ) 48%,\n\t\t\t\trgb( 0 0 0 / 20% ) 52%,\n\t\t\t\ttransparent 52%\n\t\t\t);}" + ( true ? "" : 0),  true ? "" : 0);
};

// Must equal $color-palette-circle-size from:
// @wordpress/components/src/circular-option-picker/style.scss
const swatchSize = 28;
const swatchGap = 12;
const borderControlPopoverControls = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("width:", swatchSize * 6 + swatchGap * 5, "px;>div:first-of-type>", base_control_styles/* StyledLabel */.Gw, "{margin-bottom:0;", labelStyles, ";}&& ", base_control_styles/* StyledLabel */.Gw, "+button:not( .has-text ){min-width:24px;padding:0;}" + ( true ? "" : 0),  true ? "" : 0);
const borderControlPopoverContent = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)( true ? "" : 0,  true ? "" : 0);
const borderColorIndicator = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)( true ? "" : 0,  true ? "" : 0);
const resetButton = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("justify-content:center;width:100%;&&{border-top:", config_values/* default */.A.borderWidth, " solid ", colors_values/* COLORS */.l.gray[400], ";border-top-left-radius:0;border-top-right-radius:0;height:40px;}" + ( true ? "" : 0),  true ? "" : 0);
const borderSlider = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("flex:1 1 60%;", (0,rtl/* rtl */.h)({
  marginRight: (0,space/* space */.x)(3)
})(), ";" + ( true ? "" : 0),  true ? "" : 0);
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-control/border-control-dropdown/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function useBorderControlDropdown(props) {
  const {
    border,
    className,
    colors = [],
    enableAlpha = false,
    enableStyle = true,
    onChange,
    previousStyleSelection,
    size = 'default',
    __experimentalIsRenderedInSidebar = false,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'BorderControlDropdown');
  const [widthValue] = parseQuantityAndUnitFromRawValue(border?.width);
  const hasZeroWidth = widthValue === 0;
  const onColorChange = color => {
    const style = border?.style === 'none' ? previousStyleSelection : border?.style;
    const width = hasZeroWidth && !!color ? '1px' : border?.width;
    onChange({
      color,
      style,
      width
    });
  };
  const onStyleChange = style => {
    const width = hasZeroWidth && !!style ? '1px' : border?.width;
    onChange({
      ...border,
      style,
      width
    });
  };
  const onReset = () => {
    onChange({
      ...border,
      color: undefined,
      style: undefined
    });
  };

  // Generate class names.
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    return cx(borderControlDropdown, className);
  }, [className, cx]);
  const indicatorClassName = (0,react.useMemo)(() => {
    return cx(borderColorIndicator);
  }, [cx]);
  const indicatorWrapperClassName = (0,react.useMemo)(() => {
    return cx(colorIndicatorWrapper(border, size));
  }, [border, cx, size]);
  const popoverControlsClassName = (0,react.useMemo)(() => {
    return cx(borderControlPopoverControls);
  }, [cx]);
  const popoverContentClassName = (0,react.useMemo)(() => {
    return cx(borderControlPopoverContent);
  }, [cx]);
  const resetButtonClassName = (0,react.useMemo)(() => {
    return cx(resetButton);
  }, [cx]);
  return {
    ...otherProps,
    border,
    className: classes,
    colors,
    enableAlpha,
    enableStyle,
    indicatorClassName,
    indicatorWrapperClassName,
    onColorChange,
    onStyleChange,
    onReset,
    popoverContentClassName,
    popoverControlsClassName,
    resetButtonClassName,
    size,
    __experimentalIsRenderedInSidebar
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-control/border-control-dropdown/component.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */















const getAriaLabelColorValue = colorValue => {
  // Leave hex values as-is. Remove the `var()` wrapper from CSS vars.
  return colorValue.replace(/^var\((.+)\)$/, '$1');
};
const getColorObject = (colorValue, colors) => {
  if (!colorValue || !colors) {
    return;
  }
  if (isMultiplePaletteArray(colors)) {
    // Multiple origins
    let matchedColor;
    colors.some(origin => origin.colors.some(color => {
      if (color.color === colorValue) {
        matchedColor = color;
        return true;
      }
      return false;
    }));
    return matchedColor;
  }

  // Single origin
  return colors.find(color => color.color === colorValue);
};
const getToggleAriaLabel = (colorValue, colorObject, style, isStyleEnabled) => {
  if (isStyleEnabled) {
    if (colorObject) {
      const ariaLabelValue = getAriaLabelColorValue(colorObject.color);
      return style ? (0,i18n_build_module/* sprintf */.nv)(
      // translators: %1$s: The name of the color e.g. "vivid red". %2$s: The color's hex code e.g.: "#f00:". %3$s: The current border style selection e.g. "solid".
      'Border color and style picker. The currently selected color is called "%1$s" and has a value of "%2$s". The currently selected style is "%3$s".', colorObject.name, ariaLabelValue, style) : (0,i18n_build_module/* sprintf */.nv)(
      // translators: %1$s: The name of the color e.g. "vivid red". %2$s: The color's hex code e.g.: "#f00:".
      'Border color and style picker. The currently selected color is called "%1$s" and has a value of "%2$s".', colorObject.name, ariaLabelValue);
    }
    if (colorValue) {
      const ariaLabelValue = getAriaLabelColorValue(colorValue);
      return style ? (0,i18n_build_module/* sprintf */.nv)(
      // translators: %1$s: The color's hex code e.g.: "#f00:". %2$s: The current border style selection e.g. "solid".
      'Border color and style picker. The currently selected color has a value of "%1$s". The currently selected style is "%2$s".', ariaLabelValue, style) : (0,i18n_build_module/* sprintf */.nv)(
      // translators: %1$s: The color's hex code e.g: "#f00".
      'Border color and style picker. The currently selected color has a value of "%1$s".', ariaLabelValue);
    }
    return (0,i18n_build_module.__)('Border color and style picker.');
  }
  if (colorObject) {
    return (0,i18n_build_module/* sprintf */.nv)(
    // translators: %1$s: The name of the color e.g. "vivid red". %2$s: The color's hex code e.g: "#f00".
    'Border color picker. The currently selected color is called "%1$s" and has a value of "%2$s".', colorObject.name, getAriaLabelColorValue(colorObject.color));
  }
  if (colorValue) {
    return (0,i18n_build_module/* sprintf */.nv)(
    // translators: %1$s: The color's hex code e.g: "#f00".
    'Border color picker. The currently selected color has a value of "%1$s".', getAriaLabelColorValue(colorValue));
  }
  return (0,i18n_build_module.__)('Border color picker.');
};
const BorderControlDropdown = (props, forwardedRef) => {
  const {
    __experimentalIsRenderedInSidebar,
    border,
    colors,
    disableCustomColors,
    enableAlpha,
    enableStyle,
    indicatorClassName,
    indicatorWrapperClassName,
    isStyleSettable,
    onReset,
    onColorChange,
    onStyleChange,
    popoverContentClassName,
    popoverControlsClassName,
    resetButtonClassName,
    showDropdownHeader,
    size,
    __unstablePopoverProps,
    ...otherProps
  } = useBorderControlDropdown(props);
  const {
    color,
    style
  } = border || {};
  const colorObject = getColorObject(color, colors);
  const toggleAriaLabel = getToggleAriaLabel(color, colorObject, style, enableStyle);
  const showResetButton = color || style && style !== 'none';
  const dropdownPosition = __experimentalIsRenderedInSidebar ? 'bottom left' : undefined;
  const renderToggle = ({
    onToggle
  }) => /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
    onClick: onToggle,
    variant: "tertiary",
    "aria-label": toggleAriaLabel,
    tooltipPosition: dropdownPosition,
    label: (0,i18n_build_module.__)('Border color and style picker'),
    showTooltip: true,
    __next40pxDefaultSize: size === '__unstable-large' ? true : false,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
      className: indicatorWrapperClassName,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(color_indicator, {
        className: indicatorClassName,
        colorValue: color
      })
    })
  });
  const renderContent = ({
    onClose
  }) => /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_content_wrapper, {
      paddingSize: "medium",
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
        className: popoverControlsClassName,
        spacing: 6,
        children: [showDropdownHeader ? /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(base_control_styles/* StyledLabel */.Gw, {
            children: (0,i18n_build_module.__)('Border color')
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
            size: "small",
            label: (0,i18n_build_module.__)('Close border color'),
            icon: close_small/* default */.A,
            onClick: onClose
          })]
        }) : undefined, /*#__PURE__*/(0,jsx_runtime.jsx)(color_palette, {
          className: popoverContentClassName,
          value: color,
          onChange: onColorChange,
          colors,
          disableCustomColors,
          __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
          clearable: false,
          enableAlpha: enableAlpha
        }), enableStyle && isStyleSettable && /*#__PURE__*/(0,jsx_runtime.jsx)(border_control_style_picker_component, {
          label: (0,i18n_build_module.__)('Style'),
          value: style,
          onChange: onStyleChange
        })]
      })
    }), showResetButton && /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_content_wrapper, {
      paddingSize: "none",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        className: resetButtonClassName,
        variant: "tertiary",
        onClick: () => {
          onReset();
          onClose();
        },
        children: (0,i18n_build_module.__)('Reset')
      })
    })]
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown/* default */.A, {
    renderToggle: renderToggle,
    renderContent: renderContent,
    popoverProps: {
      ...__unstablePopoverProps
    },
    ...otherProps,
    ref: forwardedRef
  });
};
const ConnectedBorderControlDropdown = (0,context_connect/* contextConnect */.KZ)(BorderControlDropdown, 'BorderControlDropdown');
/* harmony default export */ const border_control_dropdown_component = (ConnectedBorderControlDropdown);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-control/border-control/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




// If either width or color are defined, the border is considered valid
// and a border style can be set as well.
const isValidBorder = border => {
  const hasWidth = border?.width !== undefined && border.width !== '';
  const hasColor = border?.color !== undefined;
  return hasWidth || hasColor;
};
function useBorderControl(props) {
  const {
    className,
    colors = [],
    isCompact,
    onChange,
    enableAlpha = true,
    enableStyle = true,
    shouldSanitizeBorder = true,
    size = 'default',
    value: border,
    width,
    __experimentalIsRenderedInSidebar = false,
    __next40pxDefaultSize,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'BorderControl');
  const computedSize = size === 'default' && __next40pxDefaultSize ? '__unstable-large' : size;
  const [widthValue, originalWidthUnit] = parseQuantityAndUnitFromRawValue(border?.width);
  const widthUnit = originalWidthUnit || 'px';
  const hadPreviousZeroWidth = widthValue === 0;
  const [colorSelection, setColorSelection] = (0,react.useState)();
  const [styleSelection, setStyleSelection] = (0,react.useState)();
  const isStyleSettable = shouldSanitizeBorder ? isValidBorder(border) : true;
  const onBorderChange = (0,react.useCallback)(newBorder => {
    if (shouldSanitizeBorder && !isValidBorder(newBorder)) {
      onChange(undefined);
      return;
    }
    onChange(newBorder);
  }, [onChange, shouldSanitizeBorder]);
  const onWidthChange = (0,react.useCallback)(newWidth => {
    const newWidthValue = newWidth === '' ? undefined : newWidth;
    const [parsedValue] = parseQuantityAndUnitFromRawValue(newWidth);
    const hasZeroWidth = parsedValue === 0;
    const updatedBorder = {
      ...border,
      width: newWidthValue
    };

    // Setting the border width explicitly to zero will also set the
    // border style to `none` and clear the border color.
    if (hasZeroWidth && !hadPreviousZeroWidth) {
      // Before clearing the color and style selections, keep track of
      // the current selections so they can be restored when the width
      // changes to a non-zero value.
      setColorSelection(border?.color);
      setStyleSelection(border?.style);

      // Clear the color and style border properties.
      updatedBorder.color = undefined;
      updatedBorder.style = 'none';
    }

    // Selection has changed from zero border width to non-zero width.
    if (!hasZeroWidth && hadPreviousZeroWidth) {
      // Restore previous border color and style selections if width
      // is now not zero.
      if (updatedBorder.color === undefined) {
        updatedBorder.color = colorSelection;
      }
      if (updatedBorder.style === 'none') {
        updatedBorder.style = styleSelection;
      }
    }
    onBorderChange(updatedBorder);
  }, [border, hadPreviousZeroWidth, colorSelection, styleSelection, onBorderChange]);
  const onSliderChange = (0,react.useCallback)(value => {
    onWidthChange(`${value}${widthUnit}`);
  }, [onWidthChange, widthUnit]);

  // Generate class names.
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    return cx(borderControl, className);
  }, [className, cx]);
  let wrapperWidth = width;
  if (isCompact) {
    // Widths below represent the minimum usable width for compact controls.
    // Taller controls contain greater internal padding, thus greater width.
    wrapperWidth = size === '__unstable-large' ? '116px' : '90px';
  }
  const innerWrapperClassName = (0,react.useMemo)(() => {
    const widthStyle = !!wrapperWidth && styles_wrapperWidth;
    const heightStyle = wrapperHeight(computedSize);
    return cx(innerWrapper(), widthStyle, heightStyle);
  }, [wrapperWidth, cx, computedSize]);
  const sliderClassName = (0,react.useMemo)(() => {
    return cx(borderSlider());
  }, [cx]);
  return {
    ...otherProps,
    className: classes,
    colors,
    enableAlpha,
    enableStyle,
    innerWrapperClassName,
    inputWidth: wrapperWidth,
    isStyleSettable,
    onBorderChange,
    onSliderChange,
    onWidthChange,
    previousStyleSelection: styleSelection,
    sliderClassName,
    value: border,
    widthUnit,
    widthValue,
    size: computedSize,
    __experimentalIsRenderedInSidebar,
    __next40pxDefaultSize
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-control/border-control/component.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */











const BorderLabel = props => {
  const {
    label,
    hideLabelFromVision
  } = props;
  if (!label) {
    return null;
  }
  return hideLabelFromVision ? /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
    as: "legend",
    children: label
  }) : /*#__PURE__*/(0,jsx_runtime.jsx)(base_control_styles/* StyledLabel */.Gw, {
    as: "legend",
    children: label
  });
};
const UnconnectedBorderControl = (props, forwardedRef) => {
  const {
    __next40pxDefaultSize = false,
    colors,
    disableCustomColors,
    disableUnits,
    enableAlpha,
    enableStyle,
    hideLabelFromVision,
    innerWrapperClassName,
    inputWidth,
    isStyleSettable,
    label,
    onBorderChange,
    onSliderChange,
    onWidthChange,
    placeholder,
    __unstablePopoverProps,
    previousStyleSelection,
    showDropdownHeader,
    size,
    sliderClassName,
    value: border,
    widthUnit,
    widthValue,
    withSlider,
    __experimentalIsRenderedInSidebar,
    ...otherProps
  } = useBorderControl(props);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(view_component/* default */.A, {
    as: "fieldset",
    ...otherProps,
    ref: forwardedRef,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(BorderLabel, {
      label: label,
      hideLabelFromVision: hideLabelFromVision
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
      spacing: 4,
      className: innerWrapperClassName,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
        prefix: /*#__PURE__*/(0,jsx_runtime.jsx)(border_control_dropdown_component, {
          border: border,
          colors: colors,
          __unstablePopoverProps: __unstablePopoverProps,
          disableCustomColors: disableCustomColors,
          enableAlpha: enableAlpha,
          enableStyle: enableStyle,
          isStyleSettable: isStyleSettable,
          onChange: onBorderChange,
          previousStyleSelection: previousStyleSelection,
          showDropdownHeader: showDropdownHeader,
          __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
          size: size
        }),
        label: (0,i18n_build_module.__)('Border width'),
        hideLabelFromVision: true,
        min: 0,
        onChange: onWidthChange,
        value: border?.width || '',
        placeholder: placeholder,
        disableUnits: disableUnits,
        __unstableInputWidth: inputWidth,
        size: size
      }), withSlider && /*#__PURE__*/(0,jsx_runtime.jsx)(range_control, {
        __nextHasNoMarginBottom: true,
        label: (0,i18n_build_module.__)('Border width'),
        hideLabelFromVision: true,
        className: sliderClassName,
        initialPosition: 0,
        max: 100,
        min: 0,
        onChange: onSliderChange,
        step: ['px', '%'].includes(widthUnit) ? 1 : 0.1,
        value: widthValue || undefined,
        withInputField: false,
        __next40pxDefaultSize: __next40pxDefaultSize
      })]
    })]
  });
};

/**
 * The `BorderControl` brings together internal sub-components which allow users to
 * set the various properties of a border. The first sub-component, a
 * `BorderDropdown` contains options representing border color and style. The
 * border width is controlled via a `UnitControl` and an optional `RangeControl`.
 *
 * Border radius is not covered by this control as it may be desired separate to
 * color, style, and width. For example, the border radius may be absorbed under
 * a "shape" abstraction.
 *
 * ```jsx
 * import { __experimentalBorderControl as BorderControl } from '@wordpress/components';
 * import { __ } from '@wordpress/i18n';
 *
 * const colors = [
 * 	{ name: 'Blue 20', color: '#72aee6' },
 * 	// ...
 * ];
 *
 * const MyBorderControl = () => {
 * 	const [ border, setBorder ] = useState();
 * 	const onChange = ( newBorder ) => setBorder( newBorder );
 *
 * 	return (
 * 		<BorderControl
 * 			colors={ colors }
 * 			label={ __( 'Border' ) }
 * 			onChange={ onChange }
 * 			value={ border }
 * 		/>
 * 	);
 * };
 * ```
 */
const BorderControl = (0,context_connect/* contextConnect */.KZ)(UnconnectedBorderControl, 'BorderControl');
/* harmony default export */ const border_control_component = (BorderControl);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-split-controls/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function useBorderBoxControlSplitControls(props) {
  const {
    className,
    colors = [],
    enableAlpha = false,
    enableStyle = true,
    size = 'default',
    __experimentalIsRenderedInSidebar = false,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'BorderBoxControlSplitControls');

  // Generate class names.
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    return cx(borderBoxControlSplitControls(size), className);
  }, [cx, className, size]);
  const centeredClassName = (0,react.useMemo)(() => {
    return cx(centeredBorderControl, className);
  }, [cx, className]);
  const rightAlignedClassName = (0,react.useMemo)(() => {
    return cx(rightBorderControl(), className);
  }, [cx, className]);
  return {
    ...otherProps,
    centeredClassName,
    className: classes,
    colors,
    enableAlpha,
    enableStyle,
    rightAlignedClassName,
    size,
    __experimentalIsRenderedInSidebar
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-split-controls/component.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







const BorderBoxControlSplitControls = (props, forwardedRef) => {
  const {
    centeredClassName,
    colors,
    disableCustomColors,
    enableAlpha,
    enableStyle,
    onChange,
    popoverPlacement,
    popoverOffset,
    rightAlignedClassName,
    size = 'default',
    value,
    __experimentalIsRenderedInSidebar,
    ...otherProps
  } = useBorderBoxControlSplitControls(props);

  // Use internal state instead of a ref to make sure that the component
  // re-renders when the popover's anchor updates.
  const [popoverAnchor, setPopoverAnchor] = (0,react.useState)(null);

  // Memoize popoverProps to avoid returning a new object every time.
  const popoverProps = (0,react.useMemo)(() => popoverPlacement ? {
    placement: popoverPlacement,
    offset: popoverOffset,
    anchor: popoverAnchor,
    shift: true
  } : undefined, [popoverPlacement, popoverOffset, popoverAnchor]);
  const sharedBorderControlProps = {
    colors,
    disableCustomColors,
    enableAlpha,
    enableStyle,
    isCompact: true,
    __experimentalIsRenderedInSidebar,
    size
  };
  const mergedRef = (0,use_merge_refs/* default */.A)([setPopoverAnchor, forwardedRef]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(grid_component, {
    ...otherProps,
    ref: mergedRef,
    gap: 4,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(border_box_control_visualizer_component, {
      value: value,
      size: size
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(border_control_component, {
      className: centeredClassName,
      hideLabelFromVision: true,
      label: (0,i18n_build_module.__)('Top border'),
      onChange: newBorder => onChange(newBorder, 'top'),
      __unstablePopoverProps: popoverProps,
      value: value?.top,
      ...sharedBorderControlProps
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(border_control_component, {
      hideLabelFromVision: true,
      label: (0,i18n_build_module.__)('Left border'),
      onChange: newBorder => onChange(newBorder, 'left'),
      __unstablePopoverProps: popoverProps,
      value: value?.left,
      ...sharedBorderControlProps
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(border_control_component, {
      className: rightAlignedClassName,
      hideLabelFromVision: true,
      label: (0,i18n_build_module.__)('Right border'),
      onChange: newBorder => onChange(newBorder, 'right'),
      __unstablePopoverProps: popoverProps,
      value: value?.right,
      ...sharedBorderControlProps
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(border_control_component, {
      className: centeredClassName,
      hideLabelFromVision: true,
      label: (0,i18n_build_module.__)('Bottom border'),
      onChange: newBorder => onChange(newBorder, 'bottom'),
      __unstablePopoverProps: popoverProps,
      value: value?.bottom,
      ...sharedBorderControlProps
    })]
  });
};
const ConnectedBorderBoxControlSplitControls = (0,context_connect/* contextConnect */.KZ)(BorderBoxControlSplitControls, 'BorderBoxControlSplitControls');
/* harmony default export */ const border_box_control_split_controls_component = (ConnectedBorderBoxControlSplitControls);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/border-box-control/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function useBorderBoxControl(props) {
  const {
    className,
    colors = [],
    onChange,
    enableAlpha = false,
    enableStyle = true,
    size = 'default',
    value,
    __experimentalIsRenderedInSidebar = false,
    __next40pxDefaultSize,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'BorderBoxControl');
  const computedSize = size === 'default' && __next40pxDefaultSize ? '__unstable-large' : size;
  const mixedBorders = hasMixedBorders(value);
  const splitBorders = hasSplitBorders(value);
  const linkedValue = splitBorders ? getCommonBorder(value) : value;
  const splitValue = splitBorders ? value : getSplitBorders(value);

  // If no numeric width value is set, the unit select will be disabled.
  const hasWidthValue = !isNaN(parseFloat(`${linkedValue?.width}`));
  const [isLinked, setIsLinked] = (0,react.useState)(!mixedBorders);
  const toggleLinked = () => setIsLinked(!isLinked);
  const onLinkedChange = newBorder => {
    if (!newBorder) {
      return onChange(undefined);
    }

    // If we have all props defined on the new border apply it.
    if (!mixedBorders || isCompleteBorder(newBorder)) {
      return onChange(isEmptyBorder(newBorder) ? undefined : newBorder);
    }

    // If we had mixed borders we might have had some shared border props
    // that we need to maintain. For example; we could have mixed borders
    // with all the same color but different widths. Then from the linked
    // control we change the color. We should keep the separate  widths.
    const changes = getBorderDiff(linkedValue, newBorder);
    const updatedBorders = {
      top: {
        ...value?.top,
        ...changes
      },
      right: {
        ...value?.right,
        ...changes
      },
      bottom: {
        ...value?.bottom,
        ...changes
      },
      left: {
        ...value?.left,
        ...changes
      }
    };
    if (hasMixedBorders(updatedBorders)) {
      return onChange(updatedBorders);
    }
    const filteredResult = isEmptyBorder(updatedBorders.top) ? undefined : updatedBorders.top;
    onChange(filteredResult);
  };
  const onSplitChange = (newBorder, side) => {
    const updatedBorders = {
      ...splitValue,
      [side]: newBorder
    };
    if (hasMixedBorders(updatedBorders)) {
      onChange(updatedBorders);
    } else {
      onChange(newBorder);
    }
  };
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => {
    return cx(borderBoxControl, className);
  }, [cx, className]);
  const linkedControlClassName = (0,react.useMemo)(() => {
    return cx(linkedBorderControl());
  }, [cx]);
  const wrapperClassName = (0,react.useMemo)(() => {
    return cx(wrapper);
  }, [cx]);
  return {
    ...otherProps,
    className: classes,
    colors,
    disableUnits: mixedBorders && !hasWidthValue,
    enableAlpha,
    enableStyle,
    hasMixedBorders: mixedBorders,
    isLinked,
    linkedControlClassName,
    onLinkedChange,
    onSplitChange,
    toggleLinked,
    linkedValue,
    size: computedSize,
    splitValue,
    wrapperClassName,
    __experimentalIsRenderedInSidebar
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/border-box-control/border-box-control/component.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */










const component_BorderLabel = props => {
  const {
    label,
    hideLabelFromVision
  } = props;
  if (!label) {
    return null;
  }
  return hideLabelFromVision ? /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
    as: "label",
    children: label
  }) : /*#__PURE__*/(0,jsx_runtime.jsx)(base_control_styles/* StyledLabel */.Gw, {
    children: label
  });
};
const UnconnectedBorderBoxControl = (props, forwardedRef) => {
  const {
    className,
    colors,
    disableCustomColors,
    disableUnits,
    enableAlpha,
    enableStyle,
    hasMixedBorders,
    hideLabelFromVision,
    isLinked,
    label,
    linkedControlClassName,
    linkedValue,
    onLinkedChange,
    onSplitChange,
    popoverPlacement,
    popoverOffset,
    size,
    splitValue,
    toggleLinked,
    wrapperClassName,
    __experimentalIsRenderedInSidebar,
    ...otherProps
  } = useBorderBoxControl(props);

  // Use internal state instead of a ref to make sure that the component
  // re-renders when the popover's anchor updates.
  const [popoverAnchor, setPopoverAnchor] = (0,react.useState)(null);

  // Memoize popoverProps to avoid returning a new object every time.
  const popoverProps = (0,react.useMemo)(() => popoverPlacement ? {
    placement: popoverPlacement,
    offset: popoverOffset,
    anchor: popoverAnchor,
    shift: true
  } : undefined, [popoverPlacement, popoverOffset, popoverAnchor]);
  const mergedRef = (0,use_merge_refs/* default */.A)([setPopoverAnchor, forwardedRef]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(view_component/* default */.A, {
    className: className,
    ...otherProps,
    ref: mergedRef,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(component_BorderLabel, {
      label: label,
      hideLabelFromVision: hideLabelFromVision
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(view_component/* default */.A, {
      className: wrapperClassName,
      children: [isLinked ? /*#__PURE__*/(0,jsx_runtime.jsx)(border_control_component, {
        className: linkedControlClassName,
        colors: colors,
        disableUnits: disableUnits,
        disableCustomColors: disableCustomColors,
        enableAlpha: enableAlpha,
        enableStyle: enableStyle,
        onChange: onLinkedChange,
        placeholder: hasMixedBorders ? (0,i18n_build_module.__)('Mixed') : undefined,
        __unstablePopoverProps: popoverProps,
        shouldSanitizeBorder: false // This component will handle that.
        ,
        value: linkedValue,
        withSlider: true,
        width: size === '__unstable-large' ? '116px' : '110px',
        __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
        size: size
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)(border_box_control_split_controls_component, {
        colors: colors,
        disableCustomColors: disableCustomColors,
        enableAlpha: enableAlpha,
        enableStyle: enableStyle,
        onChange: onSplitChange,
        popoverPlacement: popoverPlacement,
        popoverOffset: popoverOffset,
        value: splitValue,
        __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
        size: size
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(border_box_control_linked_button_component, {
        onClick: toggleLinked,
        isLinked: isLinked,
        size: size
      })]
    })]
  });
};

/**
 * The `BorderBoxControl` effectively has two view states. The first, a "linked"
 * view, allows configuration of a flat border via a single `BorderControl`.
 * The second, a "split" view, contains a `BorderControl` for each side
 * as well as a visualizer for the currently selected borders. Each view also
 * contains a button to toggle between the two.
 *
 * When switching from the "split" view to "linked", if the individual side
 * borders are not consistent, the "linked" view will display any border
 * properties selections that are consistent while showing a mixed state for
 * those that aren't. For example, if all borders had the same color and style
 * but different widths, then the border dropdown in the "linked" view's
 * `BorderControl` would show that consistent color and style but the "linked"
 * view's width input would show "Mixed" placeholder text.
 *
 * ```jsx
 * import { __experimentalBorderBoxControl as BorderBoxControl } from '@wordpress/components';
 * import { __ } from '@wordpress/i18n';
 *
 * const colors = [
 * 	{ name: 'Blue 20', color: '#72aee6' },
 * 	// ...
 * ];
 *
 * const MyBorderBoxControl = () => {
 * 	const defaultBorder = {
 * 		color: '#72aee6',
 * 		style: 'dashed',
 * 		width: '1px',
 * 	};
 * 	const [ borders, setBorders ] = useState( {
 * 		top: defaultBorder,
 * 		right: defaultBorder,
 * 		bottom: defaultBorder,
 * 		left: defaultBorder,
 * 	} );
 * 	const onChange = ( newBorders ) => setBorders( newBorders );
 *
 * 	return (
 * 		<BorderBoxControl
 * 			colors={ colors }
 * 			label={ __( 'Borders' ) }
 * 			onChange={ onChange }
 * 			value={ borders }
 * 		/>
 * 	);
 * };
 * ```
 */
const BorderBoxControl = (0,context_connect/* contextConnect */.KZ)(UnconnectedBorderBoxControl, 'BorderBoxControl');
/* harmony default export */ const border_box_control_component = (BorderBoxControl);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/utils.js
/**
 * WordPress dependencies
 */


/**
 * Gets the (non-undefined) item with the highest occurrence within an array
 * Based in part on: https://stackoverflow.com/a/20762713
 *
 * Undefined values are always sorted to the end by `sort`, so this function
 * returns the first element, to always prioritize real values over undefined
 * values.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description
 *
 * @param {Array<any>} inputArray Array of items to check.
 * @return {any}                  The item with the most occurrences.
 */
function border_radius_control_utils_mode(inputArray) {
  const arr = [...inputArray];
  return arr.sort((a, b) => inputArray.filter(v => v === b).length - inputArray.filter(v => v === a).length).shift();
}

/**
 * Returns the most common CSS unit from the current CSS unit selections.
 *
 * - If a single flat border radius is set, its unit will be used
 * - If individual corner selections, the most common of those will be used
 * - Failing any unit selections a default of 'px' is returned.
 *
 * @param {Object} selectedUnits Unit selections for flat radius & each corner.
 * @return {string} Most common CSS unit from current selections. Default: `px`.
 */
function getAllUnit(selectedUnits = {}) {
  const {
    flat,
    ...cornerUnits
  } = selectedUnits;
  return flat || border_radius_control_utils_mode(Object.values(cornerUnits).filter(Boolean)) || 'px';
}

/**
 * Gets the 'all' input value and unit from values data.
 *
 * @param {Object|string} values Radius values.
 * @return {string}              A value + unit for the 'all' input.
 */
function getAllValue(values = {}) {
  /**
   * Border radius support was originally a single pixel value.
   *
   * To maintain backwards compatibility treat this case as the all value.
   */
  if (typeof values === 'string') {
    return values;
  }
  const parsedQuantitiesAndUnits = Object.values(values).map(value => parseQuantityAndUnitFromRawValue(value));
  const allValues = parsedQuantitiesAndUnits.map(value => {
    var _value$;
    return (_value$ = value[0]) !== null && _value$ !== void 0 ? _value$ : '';
  });
  const allUnits = parsedQuantitiesAndUnits.map(value => value[1]);
  const value = allValues.every(v => v === allValues[0]) ? allValues[0] : '';
  const unit = border_radius_control_utils_mode(allUnits);
  const allValue = value === 0 || value ? `${value}${unit}` : undefined;
  return allValue;
}

/**
 * Checks to determine if values are mixed.
 *
 * @param {Object} values Radius values.
 * @return {boolean}      Whether values are mixed.
 */
function hasMixedValues(values = {}) {
  const allValue = getAllValue(values);
  const isMixed = typeof values === 'string' ? false : isNaN(parseFloat(allValue));
  return isMixed;
}

/**
 * Checks to determine if values are defined.
 *
 * @param {Object} values Radius values.
 * @return {boolean}      Whether values are mixed.
 */
function hasDefinedValues(values) {
  if (!values) {
    return false;
  }

  // A string value represents a shorthand value.
  if (typeof values === 'string') {
    return true;
  }

  // An object represents longhand border radius values, if any are set
  // flag values as being defined.
  const filteredValues = Object.values(values).filter(value => {
    return !!value || value === 0;
  });
  return !!filteredValues.length;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/all-input-control.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function AllInputControl({
  onChange,
  selectedUnits,
  setSelectedUnits,
  values,
  ...props
}) {
  let allValue = getAllValue(values);
  if (allValue === undefined) {
    // If we don't have any value set the unit to any current selection
    // or the most common unit from the individual radii values.
    allValue = getAllUnit(selectedUnits);
  }
  const hasValues = hasDefinedValues(values);
  const isMixed = hasValues && hasMixedValues(values);
  const allPlaceholder = isMixed ? (0,i18n_build_module.__)('Mixed') : null;

  // Filter out CSS-unit-only values to prevent invalid styles.
  const handleOnChange = next => {
    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    onChange(nextValue);
  };

  // Store current unit selection for use as fallback for individual
  // radii controls.
  const handleOnUnitChange = unit => {
    setSelectedUnits({
      topLeft: unit,
      topRight: unit,
      bottomLeft: unit,
      bottomRight: unit
    });
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
    ...props,
    "aria-label": (0,i18n_build_module.__)('Border radius'),
    disableUnits: isMixed,
    isOnly: true,
    value: allValue,
    onChange: handleOnChange,
    onUnitChange: handleOnUnitChange,
    placeholder: allPlaceholder,
    size: "__unstable-large"
  });
}
//# sourceMappingURL=all-input-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/input-controls.js
/**
 * WordPress dependencies
 */



const CORNERS = {
  topLeft: (0,i18n_build_module.__)('Top left'),
  topRight: (0,i18n_build_module.__)('Top right'),
  bottomLeft: (0,i18n_build_module.__)('Bottom left'),
  bottomRight: (0,i18n_build_module.__)('Bottom right')
};
function BoxInputControls({
  onChange,
  selectedUnits,
  setSelectedUnits,
  values: valuesProp,
  ...props
}) {
  const createHandleOnChange = corner => next => {
    if (!onChange) {
      return;
    }

    // Filter out CSS-unit-only values to prevent invalid styles.
    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    onChange({
      ...values,
      [corner]: nextValue
    });
  };
  const createHandleOnUnitChange = side => next => {
    const newUnits = {
      ...selectedUnits
    };
    newUnits[side] = next;
    setSelectedUnits(newUnits);
  };

  // For shorthand style & backwards compatibility, handle flat string value.
  const values = typeof valuesProp !== 'string' ? valuesProp : {
    topLeft: valuesProp,
    topRight: valuesProp,
    bottomLeft: valuesProp,
    bottomRight: valuesProp
  };

  // Controls are wrapped in tooltips as visible labels aren't desired here.
  // Tooltip rendering also requires the UnitControl to be wrapped. See:
  // https://github.com/WordPress/gutenberg/pull/24966#issuecomment-685875026
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "components-border-radius-control__input-controls-wrapper",
    children: Object.entries(CORNERS).map(([corner, label]) => {
      const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(values[corner]);
      const computedUnit = values[corner] ? parsedUnit : selectedUnits[corner] || selectedUnits.flat;
      return /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
        text: label,
        placement: "top",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          className: "components-border-radius-control__tooltip-wrapper",
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
            ...props,
            "aria-label": label,
            value: [parsedQuantity, computedUnit].join(''),
            onChange: createHandleOnChange(corner),
            onUnitChange: createHandleOnUnitChange(corner),
            size: "__unstable-large"
          })
        })
      }, corner);
    })
  });
}
//# sourceMappingURL=input-controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/linked-button.js
/**
 * WordPress dependencies
 */




function LinkedButton({
  isLinked,
  ...props
}) {
  const label = isLinked ? (0,i18n_build_module.__)('Unlink radii') : (0,i18n_build_module.__)('Link radii');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
    text: label,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      ...props,
      className: "component-border-radius-control__linked-button",
      size: "small",
      icon: isLinked ? library_link : link_off,
      iconSize: 24,
      "aria-label": label
    })
  });
}
//# sourceMappingURL=linked-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */








const border_radius_control_DEFAULT_VALUES = {
  topLeft: undefined,
  topRight: undefined,
  bottomLeft: undefined,
  bottomRight: undefined
};
const MIN_BORDER_RADIUS_VALUE = 0;
const MAX_BORDER_RADIUS_VALUES = {
  px: 100,
  em: 20,
  rem: 20
};

/**
 * Control to display border radius options.
 *
 * @param {Object}   props          Component props.
 * @param {Function} props.onChange Callback to handle onChange.
 * @param {Object}   props.values   Border radius values.
 *
 * @return {Element}              Custom border radius control.
 */
function BorderRadiusControl({
  onChange,
  values
}) {
  const [isLinked, setIsLinked] = (0,react.useState)(!hasDefinedValues(values) || !hasMixedValues(values));

  // Tracking selected units via internal state allows filtering of CSS unit
  // only values from being saved while maintaining preexisting unit selection
  // behaviour. Filtering CSS unit only values prevents invalid style values.
  const [selectedUnits, setSelectedUnits] = (0,react.useState)({
    flat: typeof values === 'string' ? parseQuantityAndUnitFromRawValue(values)[1] : undefined,
    topLeft: parseQuantityAndUnitFromRawValue(values?.topLeft)[1],
    topRight: parseQuantityAndUnitFromRawValue(values?.topRight)[1],
    bottomLeft: parseQuantityAndUnitFromRawValue(values?.bottomLeft)[1],
    bottomRight: parseQuantityAndUnitFromRawValue(values?.bottomRight)[1]
  });
  const [availableUnits] = use_settings_useSettings('spacing.units');
  const units = useCustomUnits({
    availableUnits: availableUnits || ['px', 'em', 'rem']
  });
  const unit = getAllUnit(selectedUnits);
  const unitConfig = units && units.find(item => item.value === unit);
  const step = unitConfig?.step || 1;
  const [allValue] = parseQuantityAndUnitFromRawValue(getAllValue(values));
  const toggleLinked = () => setIsLinked(!isLinked);
  const handleSliderChange = next => {
    onChange(next !== undefined ? `${next}${unit}` : undefined);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {
    className: "components-border-radius-control",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
      as: "legend",
      children: (0,i18n_build_module.__)('Radius')
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "components-border-radius-control__wrapper",
      children: [isLinked ? /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(AllInputControl, {
          className: "components-border-radius-control__unit-control",
          values: values,
          min: MIN_BORDER_RADIUS_VALUE,
          onChange: onChange,
          selectedUnits: selectedUnits,
          setSelectedUnits: setSelectedUnits,
          units: units
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(range_control, {
          label: (0,i18n_build_module.__)('Border radius'),
          hideLabelFromVision: true,
          className: "components-border-radius-control__range-control",
          value: allValue !== null && allValue !== void 0 ? allValue : '',
          min: MIN_BORDER_RADIUS_VALUE,
          max: MAX_BORDER_RADIUS_VALUES[unit],
          initialPosition: 0,
          withInputField: false,
          onChange: handleSliderChange,
          step: step,
          __nextHasNoMarginBottom: true
        })]
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)(BoxInputControls, {
        min: MIN_BORDER_RADIUS_VALUE,
        onChange: onChange,
        selectedUnits: selectedUnits,
        setSelectedUnits: setSelectedUnits,
        values: values || border_radius_control_DEFAULT_VALUES,
        units: units
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(LinkedButton, {
        onClick: toggleLinked,
        isLinked: isLinked
      })]
    })]
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/shadow.js
/**
 * WordPress dependencies
 */


const shadow_shadow = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M12 8c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0 6.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5zM12.8 3h-1.5v3h1.5V3zm-1.6 18h1.5v-3h-1.5v3zm6.8-9.8v1.5h3v-1.5h-3zm-12 0H3v1.5h3v-1.5zm9.7 5.6 2.1 2.1 1.1-1.1-2.1-2.1-1.1 1.1zM8.3 7.2 6.2 5.1 5.1 6.2l2.1 2.1 1.1-1.1zM5.1 17.8l1.1 1.1 2.1-2.1-1.1-1.1-2.1 2.1zM18.9 6.2l-1.1-1.1-2.1 2.1 1.1 1.1 2.1-2.1z"
  })
});
/* harmony default export */ const library_shadow = (shadow_shadow);
//# sourceMappingURL=shadow.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/shadow-panel-components.js
/**
 * WordPress dependencies
 */





/**
 * External dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation.
 *
 * @type {Array}
 */


const shadow_panel_components_EMPTY_ARRAY = [];
const {
  CompositeItemV2: CompositeItem,
  CompositeV2: Composite,
  useCompositeStoreV2: useCompositeStore
} = lock_unlock_unlock(privateApis);
function ShadowPopoverContainer({
  shadow,
  onShadowChange,
  settings
}) {
  const shadows = useShadowPresets(settings);
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-global-styles__shadow-popover-container",
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
      spacing: 4,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(heading_component/* default */.A, {
        level: 5,
        children: (0,i18n_build_module.__)('Drop shadow')
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(ShadowPresets, {
        presets: shadows,
        activeShadow: shadow,
        onSelect: onShadowChange
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "block-editor-global-styles__clear-shadow",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          variant: "tertiary",
          onClick: () => onShadowChange(undefined),
          children: (0,i18n_build_module.__)('Clear')
        })
      })]
    })
  });
}
function ShadowPresets({
  presets,
  activeShadow,
  onSelect
}) {
  const compositeStore = useCompositeStore();
  return !presets ? null : /*#__PURE__*/(0,jsx_runtime.jsx)(Composite, {
    store: compositeStore,
    role: "listbox",
    className: "block-editor-global-styles__shadow__list",
    "aria-label": (0,i18n_build_module.__)('Drop shadows'),
    children: presets.map(({
      name,
      slug,
      shadow
    }) => /*#__PURE__*/(0,jsx_runtime.jsx)(ShadowIndicator, {
      label: name,
      isActive: shadow === activeShadow,
      type: slug === 'unset' ? 'unset' : 'preset',
      onSelect: () => onSelect(shadow === activeShadow ? undefined : shadow),
      shadow: shadow
    }, slug))
  });
}
function ShadowIndicator({
  type,
  label,
  isActive,
  onSelect,
  shadow
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(CompositeItem, {
    role: "option",
    "aria-label": label,
    "aria-selected": isActive,
    className: (0,dist_clsx/* default */.A)('block-editor-global-styles__shadow__item', {
      'is-active': isActive
    }),
    render: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      className: (0,dist_clsx/* default */.A)('block-editor-global-styles__shadow-indicator', {
        unset: type === 'unset'
      }),
      onClick: onSelect,
      label: label,
      style: {
        boxShadow: shadow
      },
      showTooltip: true,
      children: isActive && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
        icon: check/* default */.A
      })
    })
  });
}
function ShadowPopover({
  shadow,
  onShadowChange,
  settings
}) {
  const popoverProps = {
    placement: 'left-start',
    offset: 36,
    shift: true
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown/* default */.A, {
    popoverProps: popoverProps,
    className: "block-editor-global-styles__shadow-dropdown",
    renderToggle: renderShadowToggle(),
    renderContent: () => /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_content_wrapper, {
      paddingSize: "medium",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(ShadowPopoverContainer, {
        shadow: shadow,
        onShadowChange: onShadowChange,
        settings: settings
      })
    })
  });
}
function renderShadowToggle() {
  return ({
    onToggle,
    isOpen
  }) => {
    const toggleProps = {
      onClick: onToggle,
      className: (0,dist_clsx/* default */.A)({
        'is-open': isOpen
      }),
      'aria-expanded': isOpen
    };
    return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      ...toggleProps,
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
        justify: "flex-start",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
          className: "block-editor-global-styles__toggle-icon",
          icon: library_shadow,
          size: 24
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          children: (0,i18n_build_module.__)('Drop shadow')
        })]
      })
    });
  };
}
function useShadowPresets(settings) {
  return (0,react.useMemo)(() => {
    var _settings$shadow$pres;
    if (!settings?.shadow) {
      return shadow_panel_components_EMPTY_ARRAY;
    }
    const defaultPresetsEnabled = settings?.shadow?.defaultPresets;
    const {
      default: defaultShadows,
      theme: themeShadows,
      custom: customShadows
    } = (_settings$shadow$pres = settings?.shadow?.presets) !== null && _settings$shadow$pres !== void 0 ? _settings$shadow$pres : {};
    const unsetShadow = {
      name: (0,i18n_build_module.__)('Unset'),
      slug: 'unset',
      shadow: 'none'
    };
    const shadowPresets = [...(defaultPresetsEnabled && defaultShadows || shadow_panel_components_EMPTY_ARRAY), ...(themeShadows || shadow_panel_components_EMPTY_ARRAY), ...(customShadows || shadow_panel_components_EMPTY_ARRAY)];
    if (shadowPresets.length) {
      shadowPresets.unshift(unsetShadow);
    }
    return shadowPresets;
  }, [settings]);
}
//# sourceMappingURL=shadow-panel-components.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/border-panel.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */








function useHasBorderPanel(settings) {
  const controls = Object.values(useHasBorderPanelControls(settings));
  return controls.some(Boolean);
}
function useHasBorderPanelControls(settings) {
  const controls = {
    hasBorderColor: useHasBorderColorControl(settings),
    hasBorderRadius: useHasBorderRadiusControl(settings),
    hasBorderStyle: useHasBorderStyleControl(settings),
    hasBorderWidth: useHasBorderWidthControl(settings),
    hasShadow: useHasShadowControl(settings)
  };
  return controls;
}
function useHasBorderColorControl(settings) {
  return settings?.border?.color;
}
function useHasBorderRadiusControl(settings) {
  return settings?.border?.radius;
}
function useHasBorderStyleControl(settings) {
  return settings?.border?.style;
}
function useHasBorderWidthControl(settings) {
  return settings?.border?.width;
}
function useHasShadowControl(settings) {
  const shadows = useShadowPresets(settings);
  return !!settings?.shadow && shadows.length > 0;
}
function BorderToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children,
  label
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_component, {
    label: label,
    resetAll: resetAll,
    panelId: panelId,
    dropdownMenuProps: dropdownMenuProps,
    children: children
  });
}
const border_panel_DEFAULT_CONTROLS = {
  radius: true,
  color: true,
  width: true,
  shadow: true
};
function BorderPanel({
  as: Wrapper = BorderToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  name,
  defaultControls = border_panel_DEFAULT_CONTROLS
}) {
  var _settings$shadow$pres, _ref, _ref2, _shadowPresets$custom;
  const colors = useColorsPerOrigin(settings);
  const decodeValue = (0,react.useCallback)(rawValue => utils_getValueFromVariable({
    settings
  }, '', rawValue), [settings]);
  const encodeColorValue = colorValue => {
    const allColors = colors.flatMap(({
      colors: originColors
    }) => originColors);
    const colorObject = allColors.find(({
      color
    }) => color === colorValue);
    return colorObject ? 'var:preset|color|' + colorObject.slug : colorValue;
  };
  const border = (0,react.useMemo)(() => {
    if (hasSplitBorders(inheritedValue?.border)) {
      const borderValue = {
        ...inheritedValue?.border
      };
      ['top', 'right', 'bottom', 'left'].forEach(side => {
        borderValue[side] = {
          ...borderValue[side],
          color: decodeValue(borderValue[side]?.color)
        };
      });
      return borderValue;
    }
    return {
      ...inheritedValue?.border,
      color: inheritedValue?.border?.color ? decodeValue(inheritedValue?.border?.color) : undefined
    };
  }, [inheritedValue?.border, decodeValue]);
  const setBorder = newBorder => onChange({
    ...value,
    border: newBorder
  });
  const showBorderColor = useHasBorderColorControl(settings);
  const showBorderStyle = useHasBorderStyleControl(settings);
  const showBorderWidth = useHasBorderWidthControl(settings);

  // Border radius.
  const showBorderRadius = useHasBorderRadiusControl(settings);
  const borderRadiusValues = decodeValue(border?.radius);
  const setBorderRadius = newBorderRadius => setBorder({
    ...border,
    radius: newBorderRadius
  });
  const hasBorderRadius = () => {
    const borderValues = value?.border?.radius;
    if (typeof borderValues === 'object') {
      return Object.entries(borderValues).some(Boolean);
    }
    return !!borderValues;
  };
  const hasShadowControl = useHasShadowControl(settings);

  // Shadow
  const shadow = decodeValue(inheritedValue?.shadow);
  const shadowPresets = (_settings$shadow$pres = settings?.shadow?.presets) !== null && _settings$shadow$pres !== void 0 ? _settings$shadow$pres : {};
  const mergedShadowPresets = (_ref = (_ref2 = (_shadowPresets$custom = shadowPresets.custom) !== null && _shadowPresets$custom !== void 0 ? _shadowPresets$custom : shadowPresets.theme) !== null && _ref2 !== void 0 ? _ref2 : shadowPresets.default) !== null && _ref !== void 0 ? _ref : [];
  const setShadow = newValue => {
    const slug = mergedShadowPresets?.find(({
      shadow: shadowName
    }) => shadowName === newValue)?.slug;
    onChange(object_setImmutably(value, ['shadow'], slug ? `var:preset|shadow|${slug}` : newValue || undefined));
  };
  const hasShadow = () => !!value?.shadow;
  const resetShadow = () => setShadow(undefined);
  const resetBorder = () => {
    if (hasBorderRadius()) {
      return setBorder({
        radius: value?.border?.radius
      });
    }
    setBorder(undefined);
  };
  const onBorderChange = newBorder => {
    // Ensure we have a visible border style when a border width or
    // color is being selected.
    const updatedBorder = {
      ...newBorder
    };
    if (hasSplitBorders(updatedBorder)) {
      ['top', 'right', 'bottom', 'left'].forEach(side => {
        if (updatedBorder[side]) {
          updatedBorder[side] = {
            ...updatedBorder[side],
            color: encodeColorValue(updatedBorder[side]?.color)
          };
        }
      });
    } else if (updatedBorder) {
      updatedBorder.color = encodeColorValue(updatedBorder.color);
    }

    // As radius is maintained separately to color, style, and width
    // maintain its value. Undefined values here will be cleaned when
    // global styles are saved.
    setBorder({
      radius: border?.radius,
      ...updatedBorder
    });
  };
  const resetAllFilter = (0,react.useCallback)(previousValue => {
    return {
      ...previousValue,
      border: undefined,
      shadow: undefined
    };
  }, []);
  const showBorderByDefault = defaultControls?.color || defaultControls?.width;
  const hasBorderControl = showBorderColor || showBorderStyle || showBorderWidth || showBorderRadius;
  const label = useBorderPanelLabel({
    blockName: name,
    hasShadowControl,
    hasBorderControl
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId,
    label: label,
    children: [(showBorderWidth || showBorderColor) && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      hasValue: () => isDefinedBorder(value?.border),
      label: (0,i18n_build_module.__)('Border'),
      onDeselect: () => resetBorder(),
      isShownByDefault: showBorderByDefault,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(border_box_control_component, {
        colors: colors,
        enableAlpha: true,
        enableStyle: showBorderStyle,
        onChange: onBorderChange,
        popoverOffset: 40,
        popoverPlacement: "left-start",
        value: border,
        __experimentalIsRenderedInSidebar: true,
        size: "__unstable-large",
        hideLabelFromVision: !hasShadowControl,
        label: (0,i18n_build_module.__)('Border')
      })
    }), showBorderRadius && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      hasValue: hasBorderRadius,
      label: (0,i18n_build_module.__)('Radius'),
      onDeselect: () => setBorderRadius(undefined),
      isShownByDefault: defaultControls.radius,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(BorderRadiusControl, {
        values: borderRadiusValues,
        onChange: newValue => {
          setBorderRadius(newValue || undefined);
        }
      })
    }), hasShadowControl && /*#__PURE__*/(0,jsx_runtime.jsxs)(tools_panel_item_component, {
      label: (0,i18n_build_module.__)('Shadow'),
      hasValue: hasShadow,
      onDeselect: resetShadow,
      isShownByDefault: defaultControls.shadow,
      panelId: panelId,
      children: [hasBorderControl ? /*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
        as: "legend",
        children: (0,i18n_build_module.__)('Shadow')
      }) : null, /*#__PURE__*/(0,jsx_runtime.jsx)(item_group_component, {
        isBordered: true,
        isSeparated: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(ShadowPopover, {
          shadow: shadow,
          onShadowChange: setShadow,
          settings: settings
        })
      })]
    })]
  });
}
//# sourceMappingURL=border-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/border.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */








const BORDER_SUPPORT_KEY = '__experimentalBorder';
const SHADOW_SUPPORT_KEY = 'shadow';
const getColorByProperty = (colors, property, value) => {
  let matchedColor;
  colors.some(origin => origin.colors.some(color => {
    if (color[property] === value) {
      matchedColor = color;
      return true;
    }
    return false;
  }));
  return matchedColor;
};
const border_getMultiOriginColor = ({
  colors,
  namedColor,
  customColor
}) => {
  // Search each origin (default, theme, or user) for matching color by name.
  if (namedColor) {
    const colorObject = getColorByProperty(colors, 'slug', namedColor);
    if (colorObject) {
      return colorObject;
    }
  }

  // Skip if no custom color or matching named color.
  if (!customColor) {
    return {
      color: undefined
    };
  }

  // Attempt to find color via custom color value or build new object.
  const colorObject = getColorByProperty(colors, 'color', customColor);
  return colorObject ? colorObject : {
    color: customColor
  };
};
function getColorSlugFromVariable(value) {
  const namedColor = /var:preset\|color\|(.+)/.exec(value);
  if (namedColor && namedColor[1]) {
    return namedColor[1];
  }
  return null;
}
function styleToAttributes(style) {
  if (hasSplitBorders(style?.border)) {
    return {
      style,
      borderColor: undefined
    };
  }
  const borderColorValue = style?.border?.color;
  const borderColorSlug = borderColorValue?.startsWith('var:preset|color|') ? borderColorValue.substring('var:preset|color|'.length) : undefined;
  const updatedStyle = {
    ...style
  };
  updatedStyle.border = {
    ...updatedStyle.border,
    color: borderColorSlug ? undefined : borderColorValue
  };
  return {
    style: utils_cleanEmptyObject(updatedStyle),
    borderColor: borderColorSlug
  };
}
function attributesToStyle(attributes) {
  if (hasSplitBorders(attributes.style?.border)) {
    return attributes.style;
  }
  return {
    ...attributes.style,
    border: {
      ...attributes.style?.border,
      color: attributes.borderColor ? 'var:preset|color|' + attributes.borderColor : attributes.style?.border?.color
    }
  };
}
function BordersInspectorControl({
  label,
  children,
  resetAllFilter
}) {
  const attributesResetAllFilter = (0,react.useCallback)(attributes => {
    const existingStyle = attributesToStyle(attributes);
    const updatedStyle = resetAllFilter(existingStyle);
    return {
      ...attributes,
      ...styleToAttributes(updatedStyle)
    };
  }, [resetAllFilter]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
    group: "border",
    resetAllFilter: attributesResetAllFilter,
    label: label,
    children: children
  });
}
function border_BorderPanel({
  clientId,
  name,
  setAttributes,
  settings
}) {
  const isEnabled = useHasBorderPanel(settings);
  function selector(select) {
    const {
      style,
      borderColor
    } = select(store_store).getBlockAttributes(clientId) || {};
    return {
      style,
      borderColor
    };
  }
  const {
    style,
    borderColor
  } = (0,use_select/* default */.A)(selector, [clientId]);
  const value = (0,react.useMemo)(() => {
    return attributesToStyle({
      style,
      borderColor
    });
  }, [style, borderColor]);
  const onChange = newStyle => {
    setAttributes(styleToAttributes(newStyle));
  };
  if (!isEnabled) {
    return null;
  }
  const defaultControls = {
    ...(0,build_module/* getBlockSupport */.bI)(name, [BORDER_SUPPORT_KEY, '__experimentalDefaultControls']),
    ...(0,build_module/* getBlockSupport */.bI)(name, [SHADOW_SUPPORT_KEY, '__experimentalDefaultControls'])
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BorderPanel, {
    as: BordersInspectorControl,
    panelId: clientId,
    settings: settings,
    value: value,
    onChange: onChange,
    defaultControls: defaultControls
  });
}

/**
 * Determine whether there is block support for border properties.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   Border feature to check support for.
 *
 * @return {boolean} Whether there is support.
 */
function hasBorderSupport(blockName, feature = 'any') {
  if (platform/* default */.A.OS !== 'web') {
    return false;
  }
  const support = (0,build_module/* getBlockSupport */.bI)(blockName, BORDER_SUPPORT_KEY);
  if (support === true) {
    return true;
  }
  if (feature === 'any') {
    return !!(support?.color || support?.radius || support?.width || support?.style);
  }
  return !!support?.[feature];
}

/**
 * Determine whether there is block support for shadow properties.
 *
 * @param {string} blockName Block name.
 *
 * @return {boolean} Whether there is support.
 */
function hasShadowSupport(blockName) {
  return hasBlockSupport(blockName, SHADOW_SUPPORT_KEY);
}
function useBorderPanelLabel({
  blockName,
  hasBorderControl,
  hasShadowControl
} = {}) {
  const settings = useBlockSettings(blockName);
  const controls = useHasBorderPanelControls(settings);
  if (!hasBorderControl && !hasShadowControl && blockName) {
    hasBorderControl = controls?.hasBorderColor || controls?.hasBorderStyle || controls?.hasBorderWidth || controls?.hasBorderRadius;
    hasShadowControl = controls?.hasShadow;
  }
  if (hasBorderControl && hasShadowControl) {
    return (0,i18n_build_module.__)('Border & Shadow');
  }
  if (hasShadowControl) {
    return (0,i18n_build_module.__)('Shadow');
  }
  return (0,i18n_build_module.__)('Border');
}

/**
 * Returns a new style object where the specified border attribute has been
 * removed.
 *
 * @param {Object} style     Styles from block attributes.
 * @param {string} attribute The border style attribute to clear.
 *
 * @return {Object} Style object with the specified attribute removed.
 */
function removeBorderAttribute(style, attribute) {
  return cleanEmptyObject({
    ...style,
    border: {
      ...style?.border,
      [attribute]: undefined
    }
  });
}

/**
 * Filters registered block settings, extending attributes to include
 * `borderColor` if needed.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Updated block settings.
 */
function addAttributes(settings) {
  if (!hasBorderSupport(settings, 'color')) {
    return settings;
  }

  // Allow blocks to specify default value if needed.
  if (settings.attributes.borderColor) {
    return settings;
  }

  // Add new borderColor attribute to block settings.
  return {
    ...settings,
    attributes: {
      ...settings.attributes,
      borderColor: {
        type: 'string'
      }
    }
  };
}

/**
 * Override props assigned to save component to inject border color.
 *
 * @param {Object}        props           Additional props applied to save element.
 * @param {Object|string} blockNameOrType Block type definition.
 * @param {Object}        attributes      Block's attributes.
 *
 * @return {Object} Filtered props to apply to save element.
 */
function border_addSaveProps(props, blockNameOrType, attributes) {
  if (!hasBorderSupport(blockNameOrType, 'color') || shouldSkipSerialization(blockNameOrType, BORDER_SUPPORT_KEY, 'color')) {
    return props;
  }
  const borderClasses = border_getBorderClasses(attributes);
  const newClassName = (0,dist_clsx/* default */.A)(props.className, borderClasses);

  // If we are clearing the last of the previous classes in `className`
  // set it to `undefined` to avoid rendering empty DOM attributes.
  props.className = newClassName ? newClassName : undefined;
  return props;
}

/**
 * Generates a CSS class name consisting of all the applicable border color
 * classes given the current block attributes.
 *
 * @param {Object} attributes Block's attributes.
 *
 * @return {string} CSS class name.
 */
function border_getBorderClasses(attributes) {
  const {
    borderColor,
    style
  } = attributes;
  const borderColorClass = utils_getColorClassName('border-color', borderColor);
  return (0,dist_clsx/* default */.A)({
    'has-border-color': borderColor || style?.border?.color,
    [borderColorClass]: !!borderColorClass
  });
}
function border_useBlockProps({
  name,
  borderColor,
  style
}) {
  const {
    colors
  } = use_multiple_origin_colors_and_gradients_useMultipleOriginColorsAndGradients();
  if (!hasBorderSupport(name, 'color') || shouldSkipSerialization(name, BORDER_SUPPORT_KEY, 'color')) {
    return {};
  }
  const {
    color: borderColorValue
  } = border_getMultiOriginColor({
    colors,
    namedColor: borderColor
  });
  const {
    color: borderTopColor
  } = border_getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.top?.color)
  });
  const {
    color: borderRightColor
  } = border_getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.right?.color)
  });
  const {
    color: borderBottomColor
  } = border_getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.bottom?.color)
  });
  const {
    color: borderLeftColor
  } = border_getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.left?.color)
  });
  const extraStyles = {
    borderTopColor: borderTopColor || borderColorValue,
    borderRightColor: borderRightColor || borderColorValue,
    borderBottomColor: borderBottomColor || borderColorValue,
    borderLeftColor: borderLeftColor || borderColorValue
  };
  return border_addSaveProps({
    style: utils_cleanEmptyObject(extraStyles) || {}
  }, name, {
    borderColor,
    style
  });
}
/* harmony default export */ const hooks_border = ({
  useBlockProps: border_useBlockProps,
  addSaveProps: border_addSaveProps,
  attributeKeys: ['borderColor', 'style'],
  hasSupport(name) {
    return hasBorderSupport(name, 'color');
  }
});
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/border/addAttributes', addAttributes);
//# sourceMappingURL=border.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/gradients/use-gradient.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function use_gradient_experimentalGetGradientClass(gradientSlug) {
  if (!gradientSlug) {
    return undefined;
  }
  return `has-${gradientSlug}-gradient-background`;
}

/**
 * Retrieves the gradient value per slug.
 *
 * @param {Array}  gradients Gradient Palette
 * @param {string} slug      Gradient slug
 *
 * @return {string} Gradient value.
 */
function use_gradient_getGradientValueBySlug(gradients, slug) {
  const gradient = gradients?.find(g => g.slug === slug);
  return gradient && gradient.gradient;
}
function __experimentalGetGradientObjectByGradientValue(gradients, value) {
  const gradient = gradients?.find(g => g.gradient === value);
  return gradient;
}

/**
 * Retrieves the gradient slug per slug.
 *
 * @param {Array}  gradients Gradient Palette
 * @param {string} value     Gradient value
 * @return {string} Gradient slug.
 */
function getGradientSlugByValue(gradients, value) {
  const gradient = __experimentalGetGradientObjectByGradientValue(gradients, value);
  return gradient && gradient.slug;
}
function __experimentalUseGradient({
  gradientAttribute = 'gradient',
  customGradientAttribute = 'customGradient'
} = {}) {
  const {
    clientId
  } = useBlockEditContext();
  const [userGradientPalette, themeGradientPalette, defaultGradientPalette] = useSettings('color.gradients.custom', 'color.gradients.theme', 'color.gradients.default');
  const allGradients = useMemo(() => [...(userGradientPalette || []), ...(themeGradientPalette || []), ...(defaultGradientPalette || [])], [userGradientPalette, themeGradientPalette, defaultGradientPalette]);
  const {
    gradient,
    customGradient
  } = useSelect(select => {
    const {
      getBlockAttributes
    } = select(blockEditorStore);
    const attributes = getBlockAttributes(clientId) || {};
    return {
      customGradient: attributes[customGradientAttribute],
      gradient: attributes[gradientAttribute]
    };
  }, [clientId, gradientAttribute, customGradientAttribute]);
  const {
    updateBlockAttributes
  } = useDispatch(blockEditorStore);
  const setGradient = useCallback(newGradientValue => {
    const slug = getGradientSlugByValue(allGradients, newGradientValue);
    if (slug) {
      updateBlockAttributes(clientId, {
        [gradientAttribute]: slug,
        [customGradientAttribute]: undefined
      });
      return;
    }
    updateBlockAttributes(clientId, {
      [gradientAttribute]: undefined,
      [customGradientAttribute]: newGradientValue
    });
  }, [allGradients, clientId, updateBlockAttributes]);
  const gradientClass = use_gradient_experimentalGetGradientClass(gradient);
  let gradientValue;
  if (gradient) {
    gradientValue = use_gradient_getGradientValueBySlug(allGradients, gradient);
  } else {
    gradientValue = customGradient;
  }
  return {
    gradientClass,
    gradientValue,
    setGradient
  };
}
//# sourceMappingURL=use-gradient.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/get-valid-children.js
var get_valid_children = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/get-valid-children.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/z-stack/styles.js

function z_stack_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

const ZStackChildView = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "ebn2ljm1"
} : 0)("&:not( :first-of-type ){", ({
  offsetAmount
}) => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
  marginInlineStart: offsetAmount
},  true ? "" : 0,  true ? "" : 0), ";}", ({
  zIndex
}) => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
  zIndex
},  true ? "" : 0,  true ? "" : 0), ";" + ( true ? "" : 0));
var styles_ref =  true ? {
  name: "rs0gp6",
  styles: "grid-row-start:1;grid-column-start:1"
} : 0;
const ZStackView = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "ebn2ljm0"
} : 0)("display:inline-grid;grid-auto-flow:column;position:relative;&>", ZStackChildView, "{position:relative;justify-self:start;", ({
  isLayered
}) => isLayered ? // When `isLayered` is true, all items overlap in the same grid cell
styles_ref : undefined, ";}" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/z-stack/component.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function UnconnectedZStack(props, forwardedRef) {
  const {
    children,
    className,
    isLayered = true,
    isReversed = false,
    offset = 0,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'ZStack');
  const validChildren = (0,get_valid_children/* getValidChildren */.a)(children);
  const childrenLastIndex = validChildren.length - 1;
  const clonedChildren = validChildren.map((child, index) => {
    const zIndex = isReversed ? childrenLastIndex - index : index;
    // Only when the component is layered, the offset needs to be multiplied by
    // the item's index, so that items can correctly stack at the right distance
    const offsetAmount = isLayered ? offset * index : offset;
    const key = (0,react.isValidElement)(child) ? child.key : index;
    return /*#__PURE__*/(0,jsx_runtime.jsx)(ZStackChildView, {
      offsetAmount: offsetAmount,
      zIndex: zIndex,
      children: child
    }, key);
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(ZStackView, {
    ...otherProps,
    className: className,
    isLayered: isLayered,
    ref: forwardedRef,
    children: clonedChildren
  });
}

/**
 * `ZStack` allows you to stack things along the Z-axis.
 *
 * ```jsx
 * import { __experimentalZStack as ZStack } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ZStack offset={ 20 } isLayered>
 *       <ExampleImage />
 *       <ExampleImage />
 *       <ExampleImage />
 *     </ZStack>
 *   );
 * }
 * ```
 */
const ZStack = (0,context_connect/* contextConnect */.KZ)(UnconnectedZStack, 'ZStack');
/* harmony default export */ const z_stack_component = (ZStack);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-block/component.js + 1 modules
var flex_block_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-block/component.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/angle-picker-control/styles/angle-picker-control-styles.js

function angle_picker_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




const CIRCLE_SIZE = 32;
const INNER_CIRCLE_SIZE = 6;
const CircleRoot = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eln3bjz3"
} : 0)("border-radius:50%;border:", config_values/* default */.A.borderWidth, " solid ", colors_values/* COLORS */.l.ui.border, ";box-sizing:border-box;cursor:grab;height:", CIRCLE_SIZE, "px;overflow:hidden;width:", CIRCLE_SIZE, "px;:active{cursor:grabbing;}" + ( true ? "" : 0));
const CircleIndicatorWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eln3bjz2"
} : 0)( true ? {
  name: "1r307gh",
  styles: "box-sizing:border-box;position:relative;width:100%;height:100%;:focus-visible{outline:none;}"
} : 0);
const CircleIndicator = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eln3bjz1"
} : 0)("background:", colors_values/* COLORS */.l.theme.accent, ";border-radius:50%;box-sizing:border-box;display:block;left:50%;top:4px;transform:translateX( -50% );position:absolute;width:", INNER_CIRCLE_SIZE, "px;height:", INNER_CIRCLE_SIZE, "px;" + ( true ? "" : 0));
const UnitText = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(text_component/* default */.A,  true ? {
  target: "eln3bjz0"
} : 0)("color:", colors_values/* COLORS */.l.theme.accent, ";margin-right:", (0,space/* space */.x)(3), ";" + ( true ? "" : 0));
//# sourceMappingURL=angle-picker-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/angle-picker-control/angle-circle.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function AngleCircle({
  value,
  onChange,
  ...props
}) {
  const angleCircleRef = (0,react.useRef)(null);
  const angleCircleCenter = (0,react.useRef)();
  const previousCursorValue = (0,react.useRef)();
  const setAngleCircleCenter = () => {
    if (angleCircleRef.current === null) {
      return;
    }
    const rect = angleCircleRef.current.getBoundingClientRect();
    angleCircleCenter.current = {
      x: rect.x + rect.width / 2,
      y: rect.y + rect.height / 2
    };
  };
  const changeAngleToPosition = event => {
    if (event === undefined) {
      return;
    }

    // Prevent (drag) mouse events from selecting and accidentally
    // triggering actions from other elements.
    event.preventDefault();
    // Input control needs to lose focus and by preventDefault above, it doesn't.
    event.target?.focus();
    if (angleCircleCenter.current !== undefined && onChange !== undefined) {
      const {
        x: centerX,
        y: centerY
      } = angleCircleCenter.current;
      onChange(getAngle(centerX, centerY, event.clientX, event.clientY));
    }
  };
  const {
    startDrag,
    isDragging
  } = useDragging({
    onDragStart: event => {
      setAngleCircleCenter();
      changeAngleToPosition(event);
    },
    onDragMove: changeAngleToPosition,
    onDragEnd: changeAngleToPosition
  });
  (0,react.useEffect)(() => {
    if (isDragging) {
      if (previousCursorValue.current === undefined) {
        previousCursorValue.current = document.body.style.cursor;
      }
      document.body.style.cursor = 'grabbing';
    } else {
      document.body.style.cursor = previousCursorValue.current || '';
      previousCursorValue.current = undefined;
    }
  }, [isDragging]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(CircleRoot, {
    ref: angleCircleRef,
    onMouseDown: startDrag,
    className: "components-angle-picker-control__angle-circle",
    ...props,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(CircleIndicatorWrapper, {
      style: value ? {
        transform: `rotate(${value}deg)`
      } : undefined,
      className: "components-angle-picker-control__angle-circle-indicator-wrapper",
      tabIndex: -1,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(CircleIndicator, {
        className: "components-angle-picker-control__angle-circle-indicator"
      })
    })
  });
}
function getAngle(centerX, centerY, pointX, pointY) {
  const y = pointY - centerY;
  const x = pointX - centerX;
  const angleInRadians = Math.atan2(y, x);
  const angleInDeg = Math.round(angleInRadians * (180 / Math.PI)) + 90;
  if (angleInDeg < 0) {
    return 360 + angleInDeg;
  }
  return angleInDeg;
}
/* harmony default export */ const angle_circle = (AngleCircle);
//# sourceMappingURL=angle-circle.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/angle-picker-control/index.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







function UnforwardedAnglePickerControl(props, ref) {
  const {
    className,
    label = (0,i18n_build_module.__)('Angle'),
    onChange,
    value,
    ...restProps
  } = props;
  const handleOnNumberChange = unprocessedValue => {
    if (onChange === undefined) {
      return;
    }
    const inputValue = unprocessedValue !== undefined && unprocessedValue !== '' ? parseInt(unprocessedValue, 10) : 0;
    onChange(inputValue);
  };
  const classes = (0,dist_clsx/* default */.A)('components-angle-picker-control', className);
  const unitText = /*#__PURE__*/(0,jsx_runtime.jsx)(UnitText, {
    children: "\xB0"
  });
  const [prefixedUnitText, suffixedUnitText] = (0,i18n_build_module/* isRTL */.V8)() ? [unitText, null] : [null, unitText];
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
    ...restProps,
    ref: ref,
    className: classes,
    gap: 2,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_block_component/* default */.A, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(number_control/* default */.A, {
        label: label,
        className: "components-angle-picker-control__input-field",
        max: 360,
        min: 0,
        onChange: handleOnNumberChange,
        size: "__unstable-large",
        step: "1",
        value: value,
        spinControls: "none",
        prefix: prefixedUnitText,
        suffix: suffixedUnitText
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
      marginBottom: "1",
      marginTop: "auto",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(angle_circle, {
        "aria-hidden": "true",
        value: value,
        onChange: onChange
      })
    })]
  });
}

/**
 * `AnglePickerControl` is a React component to render a UI that allows users to
 * pick an angle. Users can choose an angle in a visual UI with the mouse by
 * dragging an angle indicator inside a circle or by directly inserting the
 * desired angle in a text field.
 *
 * ```jsx
 * import { useState } from '@wordpress/element';
 * import { AnglePickerControl } from '@wordpress/components';
 *
 * function Example() {
 *   const [ angle, setAngle ] = useState( 0 );
 *   return (
 *     <AnglePickerControl
 *       value={ angle }
 *       onChange={ setAngle }
 *     </>
 *   );
 * }
 * ```
 */
const AnglePickerControl = (0,react.forwardRef)(UnforwardedAnglePickerControl);
/* harmony default export */ const angle_picker_control = (AnglePickerControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-gradient-picker/gradient-bar/constants.js
const GRADIENT_MARKERS_WIDTH = 16;
const INSERT_POINT_WIDTH = 16;
const MINIMUM_DISTANCE_BETWEEN_INSERTER_AND_POINT = 10;
const MINIMUM_DISTANCE_BETWEEN_POINTS = 0;
const MINIMUM_SIGNIFICANT_MOVE = 5;
const KEYBOARD_CONTROL_POINT_VARIATION = MINIMUM_DISTANCE_BETWEEN_INSERTER_AND_POINT;
const MINIMUM_DISTANCE_BETWEEN_INSERTER_AND_MARKER = (INSERT_POINT_WIDTH + GRADIENT_MARKERS_WIDTH) / 2;
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-gradient-picker/gradient-bar/utils.js
/**
 * Internal dependencies
 */

/**
 * Clamps a number between 0 and 100.
 *
 * @param value Value to clamp.
 *
 * @return Value clamped between 0 and 100.
 */
function clampPercent(value) {
  return Math.max(0, Math.min(100, value));
}

/**
 * Check if a control point is overlapping with another.
 *
 * @param value        Array of control points.
 * @param initialIndex Index of the position to test.
 * @param newPosition  New position of the control point.
 * @param minDistance  Distance considered to be overlapping.
 *
 * @return True if the point is overlapping.
 */
function isOverlapping(value, initialIndex, newPosition, minDistance = MINIMUM_DISTANCE_BETWEEN_POINTS) {
  const initialPosition = value[initialIndex].position;
  const minPosition = Math.min(initialPosition, newPosition);
  const maxPosition = Math.max(initialPosition, newPosition);
  return value.some(({
    position
  }, index) => {
    return index !== initialIndex && (Math.abs(position - newPosition) < minDistance || minPosition < position && position < maxPosition);
  });
}

/**
 * Adds a control point from an array and returns the new array.
 *
 * @param points   Array of control points.
 * @param position Position to insert the new point.
 * @param color    Color to update the control point at index.
 *
 * @return New array of control points.
 */
function addControlPoint(points, position, color) {
  const nextIndex = points.findIndex(point => point.position > position);
  const newPoint = {
    color,
    position
  };
  const newPoints = points.slice();
  newPoints.splice(nextIndex - 1, 0, newPoint);
  return newPoints;
}

/**
 * Removes a control point from an array and returns the new array.
 *
 * @param points Array of control points.
 * @param index  Index to remove.
 *
 * @return New array of control points.
 */
function removeControlPoint(points, index) {
  return points.filter((_point, pointIndex) => {
    return pointIndex !== index;
  });
}
/**
 * Updates a control point from an array and returns the new array.
 *
 * @param points   Array of control points.
 * @param index    Index to update.
 * @param newPoint New control point to replace the index.
 *
 * @return New array of control points.
 */
function updateControlPoint(points, index, newPoint) {
  const newValue = points.slice();
  newValue[index] = newPoint;
  return newValue;
}

/**
 * Updates the position of a control point from an array and returns the new array.
 *
 * @param points      Array of control points.
 * @param index       Index to update.
 * @param newPosition Position to move the control point at index.
 *
 * @return New array of control points.
 */
function updateControlPointPosition(points, index, newPosition) {
  if (isOverlapping(points, index, newPosition)) {
    return points;
  }
  const newPoint = {
    ...points[index],
    position: newPosition
  };
  return updateControlPoint(points, index, newPoint);
}

/**
 * Updates the position of a control point from an array and returns the new array.
 *
 * @param points   Array of control points.
 * @param index    Index to update.
 * @param newColor Color to update the control point at index.
 *
 * @return New array of control points.
 */
function updateControlPointColor(points, index, newColor) {
  const newPoint = {
    ...points[index],
    color: newColor
  };
  return updateControlPoint(points, index, newPoint);
}

/**
 * Updates the position of a control point from an array and returns the new array.
 *
 * @param points   Array of control points.
 * @param position Position of the color stop.
 * @param newColor Color to update the control point at index.
 *
 * @return New array of control points.
 */
function updateControlPointColorByPosition(points, position, newColor) {
  const index = points.findIndex(point => point.position === position);
  return updateControlPointColor(points, index, newColor);
}

/**
 * Gets the horizontal coordinate when dragging a control point with the mouse.
 *
 * @param mouseXcoordinate Horizontal coordinate of the mouse position.
 * @param containerElement Container for the gradient picker.
 *
 * @return Whole number percentage from the left.
 */

function getHorizontalRelativeGradientPosition(mouseXCoordinate, containerElement) {
  if (!containerElement) {
    return;
  }
  const {
    x,
    width
  } = containerElement.getBoundingClientRect();
  const absolutePositionValue = mouseXCoordinate - x;
  return Math.round(clampPercent(absolutePositionValue * 100 / width));
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-gradient-picker/gradient-bar/control-points.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */











function ControlPointButton({
  isOpen,
  position,
  color,
  ...additionalProps
}) {
  const instanceId = (0,use_instance_id/* default */.A)(ControlPointButton);
  const descriptionId = `components-custom-gradient-picker__control-point-button-description-${instanceId}`;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      "aria-label": (0,i18n_build_module/* sprintf */.nv)(
      // translators: %1$s: gradient position e.g: 70, %2$s: gradient color code e.g: rgb(52,121,151).
      (0,i18n_build_module.__)('Gradient control point at position %1$s%% with color code %2$s.'), position, color),
      "aria-describedby": descriptionId,
      "aria-haspopup": "true",
      "aria-expanded": isOpen,
      className: (0,dist_clsx/* default */.A)('components-custom-gradient-picker__control-point-button', {
        'is-active': isOpen
      }),
      ...additionalProps
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
      id: descriptionId,
      children: (0,i18n_build_module.__)('Use your left or right arrow keys or drag and drop with the mouse to change the gradient position. Press the button to change the color or remove the control point.')
    })]
  });
}
function GradientColorPickerDropdown({
  isRenderedInSidebar,
  className,
  ...props
}) {
  // Open the popover below the gradient control/insertion point
  const popoverProps = (0,react.useMemo)(() => ({
    placement: 'bottom',
    offset: 8,
    // Disabling resize as it would otherwise cause the popover to show
    // scrollbars while dragging the color picker's handle close to the
    // popover edge.
    resize: false
  }), []);
  const mergedClassName = (0,dist_clsx/* default */.A)('components-custom-gradient-picker__control-point-dropdown', className);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(CustomColorPickerDropdown, {
    isRenderedInSidebar: isRenderedInSidebar,
    popoverProps: popoverProps,
    className: mergedClassName,
    ...props
  });
}
function ControlPoints({
  disableRemove,
  disableAlpha,
  gradientPickerDomRef,
  ignoreMarkerPosition,
  value: controlPoints,
  onChange,
  onStartControlPointChange,
  onStopControlPointChange,
  __experimentalIsRenderedInSidebar
}) {
  const controlPointMoveState = (0,react.useRef)();
  const onMouseMove = event => {
    if (controlPointMoveState.current === undefined || gradientPickerDomRef.current === null) {
      return;
    }
    const relativePosition = getHorizontalRelativeGradientPosition(event.clientX, gradientPickerDomRef.current);
    const {
      initialPosition,
      index,
      significantMoveHappened
    } = controlPointMoveState.current;
    if (!significantMoveHappened && Math.abs(initialPosition - relativePosition) >= MINIMUM_SIGNIFICANT_MOVE) {
      controlPointMoveState.current.significantMoveHappened = true;
    }
    onChange(updateControlPointPosition(controlPoints, index, relativePosition));
  };
  const cleanEventListeners = () => {
    if (window && window.removeEventListener && controlPointMoveState.current && controlPointMoveState.current.listenersActivated) {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', cleanEventListeners);
      onStopControlPointChange();
      controlPointMoveState.current.listenersActivated = false;
    }
  };

  // Adding `cleanEventListeners` to the dependency array below requires the function itself to be wrapped in a `useCallback`
  // This memoization would prevent the event listeners from being properly cleaned.
  // Instead, we'll pass a ref to the function in our `useEffect` so `cleanEventListeners` itself is no longer a dependency.
  const cleanEventListenersRef = (0,react.useRef)();
  cleanEventListenersRef.current = cleanEventListeners;
  (0,react.useEffect)(() => {
    return () => {
      cleanEventListenersRef.current?.();
    };
  }, []);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: controlPoints.map((point, index) => {
      const initialPosition = point?.position;
      return ignoreMarkerPosition !== initialPosition && /*#__PURE__*/(0,jsx_runtime.jsx)(GradientColorPickerDropdown, {
        isRenderedInSidebar: __experimentalIsRenderedInSidebar,
        onClose: onStopControlPointChange,
        renderToggle: ({
          isOpen,
          onToggle
        }) => /*#__PURE__*/(0,jsx_runtime.jsx)(ControlPointButton, {
          onClick: () => {
            if (controlPointMoveState.current && controlPointMoveState.current.significantMoveHappened) {
              return;
            }
            if (isOpen) {
              onStopControlPointChange();
            } else {
              onStartControlPointChange();
            }
            onToggle();
          },
          onMouseDown: () => {
            if (window && window.addEventListener) {
              controlPointMoveState.current = {
                initialPosition,
                index,
                significantMoveHappened: false,
                listenersActivated: true
              };
              onStartControlPointChange();
              window.addEventListener('mousemove', onMouseMove);
              window.addEventListener('mouseup', cleanEventListeners);
            }
          },
          onKeyDown: event => {
            if (event.code === 'ArrowLeft') {
              // Stop propagation of the key press event to avoid focus moving
              // to another editor area.
              event.stopPropagation();
              onChange(updateControlPointPosition(controlPoints, index, clampPercent(point.position - KEYBOARD_CONTROL_POINT_VARIATION)));
            } else if (event.code === 'ArrowRight') {
              // Stop propagation of the key press event to avoid focus moving
              // to another editor area.
              event.stopPropagation();
              onChange(updateControlPointPosition(controlPoints, index, clampPercent(point.position + KEYBOARD_CONTROL_POINT_VARIATION)));
            }
          },
          isOpen: isOpen,
          position: point.position,
          color: point.color
        }, index),
        renderContent: ({
          onClose
        }) => /*#__PURE__*/(0,jsx_runtime.jsxs)(dropdown_content_wrapper, {
          paddingSize: "none",
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(LegacyAdapter, {
            enableAlpha: !disableAlpha,
            color: point.color,
            onChange: color => {
              onChange(updateControlPointColor(controlPoints, index, (0,node_modules_colord/* colord */.Mj)(color).toRgbString()));
            }
          }), !disableRemove && controlPoints.length > 2 && /*#__PURE__*/(0,jsx_runtime.jsx)(h_stack_component/* default */.A, {
            className: "components-custom-gradient-picker__remove-control-point-wrapper",
            alignment: "center",
            children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
              onClick: () => {
                onChange(removeControlPoint(controlPoints, index));
                onClose();
              },
              variant: "link",
              children: (0,i18n_build_module.__)('Remove Control Point')
            })
          })]
        }),
        style: {
          left: `${point.position}%`,
          transform: 'translateX( -50% )'
        }
      }, index);
    })
  });
}
function InsertPoint({
  value: controlPoints,
  onChange,
  onOpenInserter,
  onCloseInserter,
  insertPosition,
  disableAlpha,
  __experimentalIsRenderedInSidebar
}) {
  const [alreadyInsertedPoint, setAlreadyInsertedPoint] = (0,react.useState)(false);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(GradientColorPickerDropdown, {
    isRenderedInSidebar: __experimentalIsRenderedInSidebar,
    className: "components-custom-gradient-picker__inserter",
    onClose: () => {
      onCloseInserter();
    },
    renderToggle: ({
      isOpen,
      onToggle
    }) => /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      "aria-expanded": isOpen,
      "aria-haspopup": "true",
      onClick: () => {
        if (isOpen) {
          onCloseInserter();
        } else {
          setAlreadyInsertedPoint(false);
          onOpenInserter();
        }
        onToggle();
      },
      className: "components-custom-gradient-picker__insert-point-dropdown",
      icon: plus/* default */.A
    }),
    renderContent: () => /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_content_wrapper, {
      paddingSize: "none",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(LegacyAdapter, {
        enableAlpha: !disableAlpha,
        onChange: color => {
          if (!alreadyInsertedPoint) {
            onChange(addControlPoint(controlPoints, insertPosition, (0,node_modules_colord/* colord */.Mj)(color).toRgbString()));
            setAlreadyInsertedPoint(true);
          } else {
            onChange(updateControlPointColorByPosition(controlPoints, insertPosition, (0,node_modules_colord/* colord */.Mj)(color).toRgbString()));
          }
        }
      })
    }),
    style: insertPosition !== null ? {
      left: `${insertPosition}%`,
      transform: 'translateX( -50% )'
    } : undefined
  });
}
ControlPoints.InsertPoint = InsertPoint;
/* harmony default export */ const control_points = (ControlPoints);
//# sourceMappingURL=control-points.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-gradient-picker/gradient-bar/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





const customGradientBarReducer = (state, action) => {
  switch (action.type) {
    case 'MOVE_INSERTER':
      if (state.id === 'IDLE' || state.id === 'MOVING_INSERTER') {
        return {
          id: 'MOVING_INSERTER',
          insertPosition: action.insertPosition
        };
      }
      break;
    case 'STOP_INSERTER_MOVE':
      if (state.id === 'MOVING_INSERTER') {
        return {
          id: 'IDLE'
        };
      }
      break;
    case 'OPEN_INSERTER':
      if (state.id === 'MOVING_INSERTER') {
        return {
          id: 'INSERTING_CONTROL_POINT',
          insertPosition: state.insertPosition
        };
      }
      break;
    case 'CLOSE_INSERTER':
      if (state.id === 'INSERTING_CONTROL_POINT') {
        return {
          id: 'IDLE'
        };
      }
      break;
    case 'START_CONTROL_CHANGE':
      if (state.id === 'IDLE') {
        return {
          id: 'MOVING_CONTROL_POINT'
        };
      }
      break;
    case 'STOP_CONTROL_CHANGE':
      if (state.id === 'MOVING_CONTROL_POINT') {
        return {
          id: 'IDLE'
        };
      }
      break;
  }
  return state;
};
const customGradientBarReducerInitialState = {
  id: 'IDLE'
};
function CustomGradientBar({
  background,
  hasGradient,
  value: controlPoints,
  onChange,
  disableInserter = false,
  disableAlpha = false,
  __experimentalIsRenderedInSidebar = false
}) {
  const gradientMarkersContainerDomRef = (0,react.useRef)(null);
  const [gradientBarState, gradientBarStateDispatch] = (0,react.useReducer)(customGradientBarReducer, customGradientBarReducerInitialState);
  const onMouseEnterAndMove = event => {
    if (!gradientMarkersContainerDomRef.current) {
      return;
    }
    const insertPosition = getHorizontalRelativeGradientPosition(event.clientX, gradientMarkersContainerDomRef.current);

    // If the insert point is close to an existing control point don't show it.
    if (controlPoints.some(({
      position
    }) => {
      return Math.abs(insertPosition - position) < MINIMUM_DISTANCE_BETWEEN_INSERTER_AND_POINT;
    })) {
      if (gradientBarState.id === 'MOVING_INSERTER') {
        gradientBarStateDispatch({
          type: 'STOP_INSERTER_MOVE'
        });
      }
      return;
    }
    gradientBarStateDispatch({
      type: 'MOVE_INSERTER',
      insertPosition
    });
  };
  const onMouseLeave = () => {
    gradientBarStateDispatch({
      type: 'STOP_INSERTER_MOVE'
    });
  };
  const isMovingInserter = gradientBarState.id === 'MOVING_INSERTER';
  const isInsertingControlPoint = gradientBarState.id === 'INSERTING_CONTROL_POINT';
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: (0,dist_clsx/* default */.A)('components-custom-gradient-picker__gradient-bar', {
      'has-gradient': hasGradient
    }),
    onMouseEnter: onMouseEnterAndMove,
    onMouseMove: onMouseEnterAndMove,
    onMouseLeave: onMouseLeave,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "components-custom-gradient-picker__gradient-bar-background",
      style: {
        background,
        opacity: hasGradient ? 1 : 0.4
      }
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      ref: gradientMarkersContainerDomRef,
      className: "components-custom-gradient-picker__markers-container",
      children: [!disableInserter && (isMovingInserter || isInsertingControlPoint) && /*#__PURE__*/(0,jsx_runtime.jsx)(control_points.InsertPoint, {
        __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
        disableAlpha: disableAlpha,
        insertPosition: gradientBarState.insertPosition,
        value: controlPoints,
        onChange: onChange,
        onOpenInserter: () => {
          gradientBarStateDispatch({
            type: 'OPEN_INSERTER'
          });
        },
        onCloseInserter: () => {
          gradientBarStateDispatch({
            type: 'CLOSE_INSERTER'
          });
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(control_points, {
        __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
        disableAlpha: disableAlpha,
        disableRemove: disableInserter,
        gradientPickerDomRef: gradientMarkersContainerDomRef,
        ignoreMarkerPosition: isInsertingControlPoint ? gradientBarState.insertPosition : undefined,
        value: controlPoints,
        onChange: onChange,
        onStartControlPointChange: () => {
          gradientBarStateDispatch({
            type: 'START_CONTROL_CHANGE'
          });
        },
        onStopControlPointChange: () => {
          gradientBarStateDispatch({
            type: 'STOP_CONTROL_CHANGE'
          });
        }
      })]
    })]
  });
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/gradient-parser@0.1.5/node_modules/gradient-parser/build/node.js
var node = __webpack_require__("../../node_modules/.pnpm/gradient-parser@0.1.5/node_modules/gradient-parser/build/node.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-gradient-picker/constants.js
/**
 * WordPress dependencies
 */

const DEFAULT_GRADIENT = 'linear-gradient(135deg, rgba(6, 147, 227, 1) 0%, rgb(155, 81, 224) 100%)';
const DEFAULT_LINEAR_GRADIENT_ANGLE = 180;
const HORIZONTAL_GRADIENT_ORIENTATION = {
  type: 'angular',
  value: '90'
};
const GRADIENT_OPTIONS = [{
  value: 'linear-gradient',
  label: (0,i18n_build_module.__)('Linear')
}, {
  value: 'radial-gradient',
  label: (0,i18n_build_module.__)('Radial')
}];
const DIRECTIONAL_ORIENTATION_ANGLE_MAP = {
  top: 0,
  'top right': 45,
  'right top': 45,
  right: 90,
  'right bottom': 135,
  'bottom right': 135,
  bottom: 180,
  'bottom left': 225,
  'left bottom': 225,
  left: 270,
  'top left': 315,
  'left top': 315
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-gradient-picker/serializer.js
/**
 * External dependencies
 */

function serializeGradientColor({
  type,
  value
}) {
  if (type === 'literal') {
    return value;
  }
  if (type === 'hex') {
    return `#${value}`;
  }
  return `${type}(${value.join(',')})`;
}
function serializeGradientPosition(position) {
  if (!position) {
    return '';
  }
  const {
    value,
    type
  } = position;
  return `${value}${type}`;
}
function serializeGradientColorStop({
  type,
  value,
  length
}) {
  return `${serializeGradientColor({
    type,
    value
  })} ${serializeGradientPosition(length)}`;
}
function serializeGradientOrientation(orientation) {
  if (Array.isArray(orientation) || !orientation || orientation.type !== 'angular') {
    return;
  }
  return `${orientation.value}deg`;
}
function serializeGradient({
  type,
  orientation,
  colorStops
}) {
  const serializedOrientation = serializeGradientOrientation(orientation);
  const serializedColorStops = colorStops.sort((colorStop1, colorStop2) => {
    const getNumericStopValue = colorStop => {
      return colorStop?.length?.value === undefined ? 0 : parseInt(colorStop.length.value);
    };
    return getNumericStopValue(colorStop1) - getNumericStopValue(colorStop2);
  }).map(serializeGradientColorStop);
  return `${type}(${[serializedOrientation, ...serializedColorStops].filter(Boolean).join(',')})`;
}
//# sourceMappingURL=serializer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-gradient-picker/utils.js
/**
 * External dependencies
 */




/**
 * Internal dependencies
 */


(0,node_modules_colord/* extend */.X$)([names/* default */.A]);
function getLinearGradientRepresentation(gradientAST) {
  return serializeGradient({
    type: 'linear-gradient',
    orientation: HORIZONTAL_GRADIENT_ORIENTATION,
    colorStops: gradientAST.colorStops
  });
}
function hasUnsupportedLength(item) {
  return item.length === undefined || item.length.type !== '%';
}
function getGradientAstWithDefault(value) {
  // gradientAST will contain the gradient AST as parsed by gradient-parser npm module.
  // More information of its structure available at https://www.npmjs.com/package/gradient-parser#ast.
  let gradientAST;
  let hasGradient = !!value;
  const valueToParse = value !== null && value !== void 0 ? value : DEFAULT_GRADIENT;
  try {
    gradientAST = node.parse(valueToParse)[0];
  } catch (error) {
    // eslint-disable-next-line no-console
    console.warn('wp.components.CustomGradientPicker failed to parse the gradient with error', error);
    gradientAST = node.parse(DEFAULT_GRADIENT)[0];
    hasGradient = false;
  }
  if (!Array.isArray(gradientAST.orientation) && gradientAST.orientation?.type === 'directional') {
    gradientAST.orientation = {
      type: 'angular',
      value: DIRECTIONAL_ORIENTATION_ANGLE_MAP[gradientAST.orientation.value].toString()
    };
  }
  if (gradientAST.colorStops.some(hasUnsupportedLength)) {
    const {
      colorStops
    } = gradientAST;
    const step = 100 / (colorStops.length - 1);
    colorStops.forEach((stop, index) => {
      stop.length = {
        value: `${step * index}`,
        type: '%'
      };
    });
  }
  return {
    gradientAST,
    hasGradient
  };
}
function getGradientAstWithControlPoints(gradientAST, newControlPoints) {
  return {
    ...gradientAST,
    colorStops: newControlPoints.map(({
      position,
      color
    }) => {
      const {
        r,
        g,
        b,
        a
      } = (0,node_modules_colord/* colord */.Mj)(color).toRgb();
      return {
        length: {
          type: '%',
          value: position?.toString()
        },
        type: a < 1 ? 'rgba' : 'rgb',
        value: a < 1 ? [`${r}`, `${g}`, `${b}`, `${a}`] : [`${r}`, `${g}`, `${b}`]
      };
    })
  };
}
function getStopCssColor(colorStop) {
  switch (colorStop.type) {
    case 'hex':
      return `#${colorStop.value}`;
    case 'literal':
      return colorStop.value;
    case 'rgb':
    case 'rgba':
      return `${colorStop.type}(${colorStop.value.join(',')})`;
    default:
      // Should be unreachable if passing an AST from gradient-parser.
      // See https://github.com/rafaelcaricio/gradient-parser#ast.
      return 'transparent';
  }
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-gradient-picker/styles/custom-gradient-picker-styles.js

function custom_gradient_picker_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const SelectWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_block_component/* default */.A,  true ? {
  target: "e10bzpgi1"
} : 0)( true ? {
  name: "1gvx10y",
  styles: "flex-grow:5"
} : 0);
const AccessoryWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_block_component/* default */.A,  true ? {
  target: "e10bzpgi0"
} : 0)( true ? {
  name: "1gvx10y",
  styles: "flex-grow:5"
} : 0);
//# sourceMappingURL=custom-gradient-picker-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/custom-gradient-picker/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */











const GradientAnglePicker = ({
  gradientAST,
  hasGradient,
  onChange
}) => {
  var _gradientAST$orientat;
  const angle = (_gradientAST$orientat = gradientAST?.orientation?.value) !== null && _gradientAST$orientat !== void 0 ? _gradientAST$orientat : DEFAULT_LINEAR_GRADIENT_ANGLE;
  const onAngleChange = newAngle => {
    onChange(serializeGradient({
      ...gradientAST,
      orientation: {
        type: 'angular',
        value: `${newAngle}`
      }
    }));
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(angle_picker_control, {
    onChange: onAngleChange,
    value: hasGradient ? angle : ''
  });
};
const GradientTypePicker = ({
  gradientAST,
  hasGradient,
  onChange
}) => {
  const {
    type
  } = gradientAST;
  const onSetLinearGradient = () => {
    onChange(serializeGradient({
      ...gradientAST,
      orientation: gradientAST.orientation ? undefined : HORIZONTAL_GRADIENT_ORIENTATION,
      type: 'linear-gradient'
    }));
  };
  const onSetRadialGradient = () => {
    const {
      orientation,
      ...restGradientAST
    } = gradientAST;
    onChange(serializeGradient({
      ...restGradientAST,
      type: 'radial-gradient'
    }));
  };
  const handleOnChange = next => {
    if (next === 'linear-gradient') {
      onSetLinearGradient();
    }
    if (next === 'radial-gradient') {
      onSetRadialGradient();
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(select_control/* default */.A, {
    __nextHasNoMarginBottom: true,
    className: "components-custom-gradient-picker__type-picker",
    label: (0,i18n_build_module.__)('Type'),
    labelPosition: "top",
    onChange: handleOnChange,
    options: GRADIENT_OPTIONS,
    size: "__unstable-large",
    value: hasGradient ? type : undefined
  });
};

/**
 * CustomGradientPicker is a React component that renders a UI for specifying
 * linear or radial gradients. Radial gradients are displayed in the picker as
 * a slice of the gradient from the center to the outside.
 *
 * ```jsx
 * import { CustomGradientPicker } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyCustomGradientPicker = () => {
 *   const [ gradient, setGradient ] = useState();
 *
 *   return (
 *     <CustomGradientPicker
 *			value={ gradient }
 *			onChange={ setGradient }
 *     />
 *   );
 * };
 * ```
 */
function CustomGradientPicker({
  value,
  onChange,
  __experimentalIsRenderedInSidebar = false
}) {
  const {
    gradientAST,
    hasGradient
  } = getGradientAstWithDefault(value);

  // On radial gradients the bar should display a linear gradient.
  // On radial gradients the bar represents a slice of the gradient from the center until the outside.
  // On liner gradients the bar represents the color stops from left to right independently of the angle.
  const background = getLinearGradientRepresentation(gradientAST);

  // Control points color option may be hex from presets, custom colors will be rgb.
  // The position should always be a percentage.
  const controlPoints = gradientAST.colorStops.map(colorStop => {
    return {
      color: getStopCssColor(colorStop),
      // Although it's already been checked by `hasUnsupportedLength` in `getGradientAstWithDefault`,
      // TypeScript doesn't know that `colorStop.length` is not undefined here.
      // @ts-expect-error
      position: parseInt(colorStop.length.value)
    };
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
    spacing: 4,
    className: "components-custom-gradient-picker",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(CustomGradientBar, {
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      background: background,
      hasGradient: hasGradient,
      value: controlPoints,
      onChange: newControlPoints => {
        onChange(serializeGradient(getGradientAstWithControlPoints(gradientAST, newControlPoints)));
      }
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
      gap: 3,
      className: "components-custom-gradient-picker__ui-line",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(SelectWrapper, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(GradientTypePicker, {
          gradientAST: gradientAST,
          hasGradient: hasGradient,
          onChange: onChange
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(AccessoryWrapper, {
        children: gradientAST.type === 'linear-gradient' && /*#__PURE__*/(0,jsx_runtime.jsx)(GradientAnglePicker, {
          gradientAST: gradientAST,
          hasGradient: hasGradient,
          onChange: onChange
        })
      })]
    })]
  });
}
/* harmony default export */ const custom_gradient_picker = (CustomGradientPicker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/gradient-picker/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






// The Multiple Origin Gradients have a `gradients` property (an array of
// gradient objects), while Single Origin ones have a `gradient` property.
const isMultipleOriginObject = obj => Array.isArray(obj.gradients) && !('gradient' in obj);
const isMultipleOriginArray = arr => {
  return arr.length > 0 && arr.every(gradientObj => isMultipleOriginObject(gradientObj));
};
function SingleOrigin({
  className,
  clearGradient,
  gradients,
  onChange,
  value,
  ...additionalProps
}) {
  const gradientOptions = (0,react.useMemo)(() => {
    return gradients.map(({
      gradient,
      name,
      slug
    }, index) => /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker.Option, {
      value: gradient,
      isSelected: value === gradient,
      tooltipText: name ||
      // translators: %s: gradient code e.g: "linear-gradient(90deg, rgba(98,16,153,1) 0%, rgba(172,110,22,1) 100%);".
      (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Gradient code: %s'), gradient),
      style: {
        color: 'rgba( 0,0,0,0 )',
        background: gradient
      },
      onClick: value === gradient ? clearGradient : () => onChange(gradient, index),
      "aria-label": name ?
      // translators: %s: The name of the gradient e.g: "Angular red to blue".
      (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Gradient: %s'), name) :
      // translators: %s: gradient code e.g: "linear-gradient(90deg, rgba(98,16,153,1) 0%, rgba(172,110,22,1) 100%);".
      (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Gradient code: %s'), gradient)
    }, slug));
  }, [gradients, value, onChange, clearGradient]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker.OptionGroup, {
    className: className,
    options: gradientOptions,
    ...additionalProps
  });
}
function MultipleOrigin({
  className,
  clearGradient,
  gradients,
  onChange,
  value,
  headingLevel
}) {
  const instanceId = (0,use_instance_id/* default */.A)(MultipleOrigin);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(v_stack_component/* default */.A, {
    spacing: 3,
    className: className,
    children: gradients.map(({
      name,
      gradients: gradientSet
    }, index) => {
      const id = `color-palette-${instanceId}-${index}`;
      return /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
        spacing: 2,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(ColorHeading, {
          level: headingLevel,
          id: id,
          children: name
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(SingleOrigin, {
          clearGradient: clearGradient,
          gradients: gradientSet,
          onChange: gradient => onChange(gradient, index),
          value: value,
          "aria-labelledby": id
        })]
      }, index);
    })
  });
}
function Component(props) {
  const {
    asButtons,
    loop,
    actions,
    headingLevel,
    'aria-label': ariaLabel,
    'aria-labelledby': ariaLabelledby,
    ...additionalProps
  } = props;
  const options = isMultipleOriginArray(props.gradients) ? /*#__PURE__*/(0,jsx_runtime.jsx)(MultipleOrigin, {
    headingLevel: headingLevel,
    ...additionalProps
  }) : /*#__PURE__*/(0,jsx_runtime.jsx)(SingleOrigin, {
    ...additionalProps
  });
  let metaProps;
  if (asButtons) {
    metaProps = {
      asButtons: true
    };
  } else {
    const _metaProps = {
      asButtons: false,
      loop
    };
    if (ariaLabel) {
      metaProps = {
        ..._metaProps,
        'aria-label': ariaLabel
      };
    } else if (ariaLabelledby) {
      metaProps = {
        ..._metaProps,
        'aria-labelledby': ariaLabelledby
      };
    } else {
      metaProps = {
        ..._metaProps,
        'aria-label': (0,i18n_build_module.__)('Custom color picker.')
      };
    }
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker, {
    ...metaProps,
    actions: actions,
    options: options
  });
}

/**
 *  GradientPicker is a React component that renders a color gradient picker to
 * define a multi step gradient. There's either a _linear_ or a _radial_ type
 * available.
 *
 * ```jsx
 *import { GradientPicker } from '@wordpress/components';
 *import { useState } from '@wordpress/element';
 *
 *const myGradientPicker = () => {
 *	const [ gradient, setGradient ] = useState( null );
 *
 *	return (
 *		<GradientPicker
 *			value={ gradient }
 *			onChange={ ( currentGradient ) => setGradient( currentGradient ) }
 *			gradients={ [
 *				{
 *					name: 'JShine',
 *					gradient:
 *						'linear-gradient(135deg,#12c2e9 0%,#c471ed 50%,#f64f59 100%)',
 *					slug: 'jshine',
 *				},
 *				{
 *					name: 'Moonlit Asteroid',
 *					gradient:
 *						'linear-gradient(135deg,#0F2027 0%, #203A43 0%, #2c5364 100%)',
 *					slug: 'moonlit-asteroid',
 *				},
 *				{
 *					name: 'Rastafarie',
 *					gradient:
 *						'linear-gradient(135deg,#1E9600 0%, #FFF200 0%, #FF0000 100%)',
 *					slug: 'rastafari',
 *				},
 *			] }
 *		/>
 *	);
 *};
 *```
 *
 */
function GradientPicker({
  className,
  gradients = [],
  onChange,
  value,
  clearable = true,
  disableCustomGradients = false,
  __experimentalIsRenderedInSidebar,
  headingLevel = 2,
  ...additionalProps
}) {
  const clearGradient = (0,react.useCallback)(() => onChange(undefined), [onChange]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
    spacing: gradients.length ? 4 : 0,
    children: [!disableCustomGradients && /*#__PURE__*/(0,jsx_runtime.jsx)(custom_gradient_picker, {
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      value: value,
      onChange: onChange
    }), (gradients.length > 0 || clearable) && /*#__PURE__*/(0,jsx_runtime.jsx)(Component, {
      ...additionalProps,
      className: className,
      clearGradient: clearGradient,
      gradients: gradients,
      onChange: onChange,
      value: value,
      actions: clearable && !disableCustomGradients && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker.ButtonAction, {
        onClick: clearGradient,
        children: (0,i18n_build_module.__)('Clear')
      }),
      headingLevel: headingLevel
    })]
  });
}
/* harmony default export */ const gradient_picker = (GradientPicker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/colors-gradients/control.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const {
  Tabs: control_Tabs
} = lock_unlock_unlock(privateApis);
const colorsAndGradientKeys = ['colors', 'disableCustomColors', 'gradients', 'disableCustomGradients'];
const TAB_IDS = {
  color: 'color',
  gradient: 'gradient'
};
function ColorGradientControlInner({
  colors,
  gradients,
  disableCustomColors,
  disableCustomGradients,
  __experimentalIsRenderedInSidebar,
  className,
  label,
  onColorChange,
  onGradientChange,
  colorValue,
  gradientValue,
  clearable,
  showTitle = true,
  enableAlpha,
  headingLevel
}) {
  const canChooseAColor = onColorChange && (colors && colors.length > 0 || !disableCustomColors);
  const canChooseAGradient = onGradientChange && (gradients && gradients.length > 0 || !disableCustomGradients);
  if (!canChooseAColor && !canChooseAGradient) {
    return null;
  }
  const tabPanels = {
    [TAB_IDS.color]: /*#__PURE__*/(0,jsx_runtime.jsx)(color_palette, {
      value: colorValue,
      onChange: canChooseAGradient ? newColor => {
        onColorChange(newColor);
        onGradientChange();
      } : onColorChange,
      colors,
      disableCustomColors,
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      clearable: clearable,
      enableAlpha: enableAlpha,
      headingLevel: headingLevel
    }),
    [TAB_IDS.gradient]: /*#__PURE__*/(0,jsx_runtime.jsx)(gradient_picker, {
      value: gradientValue,
      onChange: canChooseAColor ? newGradient => {
        onGradientChange(newGradient);
        onColorChange();
      } : onGradientChange,
      gradients,
      disableCustomGradients,
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      clearable: clearable,
      headingLevel: headingLevel
    })
  };
  const renderPanelType = type => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-color-gradient-control__panel",
    children: tabPanels[type]
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default */.Ay, {
    __nextHasNoMarginBottom: true,
    className: (0,dist_clsx/* default */.A)('block-editor-color-gradient-control', className),
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("fieldset", {
      className: "block-editor-color-gradient-control__fieldset",
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
        spacing: 1,
        children: [showTitle && /*#__PURE__*/(0,jsx_runtime.jsx)("legend", {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
            className: "block-editor-color-gradient-control__color-indicator",
            children: /*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
              children: label
            })
          })
        }), canChooseAColor && canChooseAGradient && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          children: /*#__PURE__*/(0,jsx_runtime.jsxs)(control_Tabs, {
            defaultTabId: gradientValue ? TAB_IDS.gradient : !!canChooseAColor && TAB_IDS.color,
            children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(control_Tabs.TabList, {
              children: [/*#__PURE__*/(0,jsx_runtime.jsx)(control_Tabs.Tab, {
                tabId: TAB_IDS.color,
                children: (0,i18n_build_module.__)('Color')
              }), /*#__PURE__*/(0,jsx_runtime.jsx)(control_Tabs.Tab, {
                tabId: TAB_IDS.gradient,
                children: (0,i18n_build_module.__)('Gradient')
              })]
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(control_Tabs.TabPanel, {
              tabId: TAB_IDS.color,
              className: "block-editor-color-gradient-control__panel",
              focusable: false,
              children: tabPanels.color
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(control_Tabs.TabPanel, {
              tabId: TAB_IDS.gradient,
              className: "block-editor-color-gradient-control__panel",
              focusable: false,
              children: tabPanels.gradient
            })]
          })
        }), !canChooseAGradient && renderPanelType(TAB_IDS.color), !canChooseAColor && renderPanelType(TAB_IDS.gradient)]
      })
    })
  });
}
function ColorGradientControlSelect(props) {
  const [colors, gradients, customColors, customGradients] = use_settings_useSettings('color.palette', 'color.gradients', 'color.custom', 'color.customGradient');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(ColorGradientControlInner, {
    colors: colors,
    gradients: gradients,
    disableCustomColors: !customColors,
    disableCustomGradients: !customGradients,
    ...props
  });
}
function ColorGradientControl(props) {
  if (colorsAndGradientKeys.every(key => props.hasOwnProperty(key))) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(ColorGradientControlInner, {
      ...props
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(ColorGradientControlSelect, {
    ...props
  });
}
/* harmony default export */ const control = (ColorGradientControl);
//# sourceMappingURL=control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/color-panel.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







function useHasColorPanel(settings) {
  const hasTextPanel = useHasTextPanel(settings);
  const hasBackgroundPanel = color_panel_useHasBackgroundPanel(settings);
  const hasLinkPanel = useHasLinkPanel(settings);
  const hasHeadingPanel = useHasHeadingPanel(settings);
  const hasButtonPanel = useHasButtonPanel(settings);
  const hasCaptionPanel = useHasCaptionPanel(settings);
  return hasTextPanel || hasBackgroundPanel || hasLinkPanel || hasHeadingPanel || hasButtonPanel || hasCaptionPanel;
}
function useHasTextPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  return settings?.color?.text && (colors?.length > 0 || settings?.color?.custom);
}
function useHasLinkPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  return settings?.color?.link && (colors?.length > 0 || settings?.color?.custom);
}
function useHasCaptionPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  return settings?.color?.caption && (colors?.length > 0 || settings?.color?.custom);
}
function useHasHeadingPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  return settings?.color?.heading && (colors?.length > 0 || settings?.color?.custom || gradients?.length > 0 || settings?.color?.customGradient);
}
function useHasButtonPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  return settings?.color?.button && (colors?.length > 0 || settings?.color?.custom || gradients?.length > 0 || settings?.color?.customGradient);
}
function color_panel_useHasBackgroundPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  return settings?.color?.background && (colors?.length > 0 || settings?.color?.custom || gradients?.length > 0 || settings?.color?.customGradient);
}
function ColorToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_component, {
    label: (0,i18n_build_module.__)('Elements'),
    resetAll: resetAll,
    panelId: panelId,
    hasInnerWrapper: true,
    headingLevel: 3,
    className: "color-block-support-panel",
    __experimentalFirstVisibleItemClass: "first",
    __experimentalLastVisibleItemClass: "last",
    dropdownMenuProps: dropdownMenuProps,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "color-block-support-panel__inner-wrapper",
      children: children
    })
  });
}
const color_panel_DEFAULT_CONTROLS = {
  text: true,
  background: true,
  link: true,
  heading: true,
  button: true,
  caption: true
};
const popoverProps = {
  placement: 'left-start',
  offset: 36,
  shift: true
};
const {
  Tabs: color_panel_Tabs
} = lock_unlock_unlock(privateApis);
const LabeledColorIndicators = ({
  indicators,
  label
}) => /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
  justify: "flex-start",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(z_stack_component, {
    isLayered: false,
    offset: -8,
    children: indicators.map((indicator, index) => /*#__PURE__*/(0,jsx_runtime.jsx)(flex_component/* default */.A, {
      expanded: false,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(color_indicator, {
        colorValue: indicator
      })
    }, index))
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
    className: "block-editor-panel-color-gradient-settings__color-name",
    title: label,
    children: label
  })]
});
function ColorPanelTab({
  isGradient,
  inheritedValue,
  userValue,
  setValue,
  colorGradientControlSettings
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(control, {
    ...colorGradientControlSettings,
    showTitle: false,
    enableAlpha: true,
    __experimentalIsRenderedInSidebar: true,
    colorValue: isGradient ? undefined : inheritedValue,
    gradientValue: isGradient ? inheritedValue : undefined,
    onColorChange: isGradient ? undefined : setValue,
    onGradientChange: isGradient ? setValue : undefined,
    clearable: inheritedValue === userValue,
    headingLevel: 3
  });
}
function ColorPanelDropdown({
  label,
  hasValue,
  resetValue,
  isShownByDefault,
  indicators,
  tabs,
  colorGradientControlSettings,
  panelId
}) {
  var _tabs$;
  const currentTab = tabs.find(tab => tab.userValue !== undefined);
  const {
    key: firstTabKey,
    ...firstTab
  } = (_tabs$ = tabs[0]) !== null && _tabs$ !== void 0 ? _tabs$ : {};
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
    className: "block-editor-tools-panel-color-gradient-settings__item",
    hasValue: hasValue,
    label: label,
    onDeselect: resetValue,
    isShownByDefault: isShownByDefault,
    panelId: panelId,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown/* default */.A, {
      popoverProps: popoverProps,
      className: "block-editor-tools-panel-color-gradient-settings__dropdown",
      renderToggle: ({
        onToggle,
        isOpen
      }) => {
        const toggleProps = {
          onClick: onToggle,
          className: (0,dist_clsx/* default */.A)('block-editor-panel-color-gradient-settings__dropdown', {
            'is-open': isOpen
          }),
          'aria-expanded': isOpen,
          'aria-label': (0,i18n_build_module/* sprintf */.nv)( /* translators: %s is the type of color property, e.g., "background" */
          (0,i18n_build_module.__)('Color %s styles'), label)
        };
        return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          ...toggleProps,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(LabeledColorIndicators, {
            indicators: indicators,
            label: label
          })
        });
      },
      renderContent: () => /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_content_wrapper, {
        paddingSize: "none",
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          className: "block-editor-panel-color-gradient-settings__dropdown-content",
          children: [tabs.length === 1 && /*#__PURE__*/(0,jsx_runtime.jsx)(ColorPanelTab, {
            ...firstTab,
            colorGradientControlSettings: colorGradientControlSettings
          }, firstTabKey), tabs.length > 1 && /*#__PURE__*/(0,jsx_runtime.jsxs)(color_panel_Tabs, {
            defaultTabId: currentTab?.key,
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(color_panel_Tabs.TabList, {
              children: tabs.map(tab => /*#__PURE__*/(0,jsx_runtime.jsx)(color_panel_Tabs.Tab, {
                tabId: tab.key,
                children: tab.label
              }, tab.key))
            }), tabs.map(tab => {
              const {
                key: tabKey,
                ...restTabProps
              } = tab;
              return /*#__PURE__*/(0,jsx_runtime.jsx)(color_panel_Tabs.TabPanel, {
                tabId: tabKey,
                focusable: false,
                children: /*#__PURE__*/(0,jsx_runtime.jsx)(ColorPanelTab, {
                  ...restTabProps,
                  colorGradientControlSettings: colorGradientControlSettings
                }, tabKey)
              }, tabKey);
            })]
          })]
        })
      })
    })
  });
}
function ColorPanel({
  as: Wrapper = ColorToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = color_panel_DEFAULT_CONTROLS,
  children
}) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  const areCustomSolidsEnabled = settings?.color?.custom;
  const areCustomGradientsEnabled = settings?.color?.customGradient;
  const hasSolidColors = colors.length > 0 || areCustomSolidsEnabled;
  const hasGradientColors = gradients.length > 0 || areCustomGradientsEnabled;
  const decodeValue = rawValue => utils_getValueFromVariable({
    settings
  }, '', rawValue);
  const encodeColorValue = colorValue => {
    const allColors = colors.flatMap(({
      colors: originColors
    }) => originColors);
    const colorObject = allColors.find(({
      color
    }) => color === colorValue);
    return colorObject ? 'var:preset|color|' + colorObject.slug : colorValue;
  };
  const encodeGradientValue = gradientValue => {
    const allGradients = gradients.flatMap(({
      gradients: originGradients
    }) => originGradients);
    const gradientObject = allGradients.find(({
      gradient
    }) => gradient === gradientValue);
    return gradientObject ? 'var:preset|gradient|' + gradientObject.slug : gradientValue;
  };

  // BackgroundColor
  const showBackgroundPanel = color_panel_useHasBackgroundPanel(settings);
  const backgroundColor = decodeValue(inheritedValue?.color?.background);
  const userBackgroundColor = decodeValue(value?.color?.background);
  const gradient = decodeValue(inheritedValue?.color?.gradient);
  const userGradient = decodeValue(value?.color?.gradient);
  const hasBackground = () => !!userBackgroundColor || !!userGradient;
  const setBackgroundColor = newColor => {
    const newValue = object_setImmutably(value, ['color', 'background'], encodeColorValue(newColor));
    newValue.color.gradient = undefined;
    onChange(newValue);
  };
  const setGradient = newGradient => {
    const newValue = object_setImmutably(value, ['color', 'gradient'], encodeGradientValue(newGradient));
    newValue.color.background = undefined;
    onChange(newValue);
  };
  const resetBackground = () => {
    const newValue = object_setImmutably(value, ['color', 'background'], undefined);
    newValue.color.gradient = undefined;
    onChange(newValue);
  };

  // Links
  const showLinkPanel = useHasLinkPanel(settings);
  const linkColor = decodeValue(inheritedValue?.elements?.link?.color?.text);
  const userLinkColor = decodeValue(value?.elements?.link?.color?.text);
  const setLinkColor = newColor => {
    onChange(object_setImmutably(value, ['elements', 'link', 'color', 'text'], encodeColorValue(newColor)));
  };
  const hoverLinkColor = decodeValue(inheritedValue?.elements?.link?.[':hover']?.color?.text);
  const userHoverLinkColor = decodeValue(value?.elements?.link?.[':hover']?.color?.text);
  const setHoverLinkColor = newColor => {
    onChange(object_setImmutably(value, ['elements', 'link', ':hover', 'color', 'text'], encodeColorValue(newColor)));
  };
  const hasLink = () => !!userLinkColor || !!userHoverLinkColor;
  const resetLink = () => {
    let newValue = object_setImmutably(value, ['elements', 'link', ':hover', 'color', 'text'], undefined);
    newValue = object_setImmutably(newValue, ['elements', 'link', 'color', 'text'], undefined);
    onChange(newValue);
  };

  // Text Color
  const showTextPanel = useHasTextPanel(settings);
  const textColor = decodeValue(inheritedValue?.color?.text);
  const userTextColor = decodeValue(value?.color?.text);
  const hasTextColor = () => !!userTextColor;
  const setTextColor = newColor => {
    let changedObject = object_setImmutably(value, ['color', 'text'], encodeColorValue(newColor));
    if (textColor === linkColor) {
      changedObject = object_setImmutably(changedObject, ['elements', 'link', 'color', 'text'], encodeColorValue(newColor));
    }
    onChange(changedObject);
  };
  const resetTextColor = () => setTextColor(undefined);

  // Elements
  const elements = [{
    name: 'caption',
    label: (0,i18n_build_module.__)('Captions'),
    showPanel: useHasCaptionPanel(settings)
  }, {
    name: 'button',
    label: (0,i18n_build_module.__)('Button'),
    showPanel: useHasButtonPanel(settings)
  }, {
    name: 'heading',
    label: (0,i18n_build_module.__)('Heading'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h1',
    label: (0,i18n_build_module.__)('H1'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h2',
    label: (0,i18n_build_module.__)('H2'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h3',
    label: (0,i18n_build_module.__)('H3'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h4',
    label: (0,i18n_build_module.__)('H4'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h5',
    label: (0,i18n_build_module.__)('H5'),
    showPanel: useHasHeadingPanel(settings)
  }, {
    name: 'h6',
    label: (0,i18n_build_module.__)('H6'),
    showPanel: useHasHeadingPanel(settings)
  }];
  const resetAllFilter = (0,react.useCallback)(previousValue => {
    return {
      ...previousValue,
      color: undefined,
      elements: {
        ...previousValue?.elements,
        link: {
          ...previousValue?.elements?.link,
          color: undefined,
          ':hover': {
            color: undefined
          }
        },
        ...elements.reduce((acc, element) => {
          return {
            ...acc,
            [element.name]: {
              ...previousValue?.elements?.[element.name],
              color: undefined
            }
          };
        }, {})
      }
    };
  }, []);
  const items = [showTextPanel && {
    key: 'text',
    label: (0,i18n_build_module.__)('Text'),
    hasValue: hasTextColor,
    resetValue: resetTextColor,
    isShownByDefault: defaultControls.text,
    indicators: [textColor],
    tabs: [{
      key: 'text',
      label: (0,i18n_build_module.__)('Text'),
      inheritedValue: textColor,
      setValue: setTextColor,
      userValue: userTextColor
    }]
  }, showBackgroundPanel && {
    key: 'background',
    label: (0,i18n_build_module.__)('Background'),
    hasValue: hasBackground,
    resetValue: resetBackground,
    isShownByDefault: defaultControls.background,
    indicators: [gradient !== null && gradient !== void 0 ? gradient : backgroundColor],
    tabs: [hasSolidColors && {
      key: 'background',
      label: (0,i18n_build_module.__)('Color'),
      inheritedValue: backgroundColor,
      setValue: setBackgroundColor,
      userValue: userBackgroundColor
    }, hasGradientColors && {
      key: 'gradient',
      label: (0,i18n_build_module.__)('Gradient'),
      inheritedValue: gradient,
      setValue: setGradient,
      userValue: userGradient,
      isGradient: true
    }].filter(Boolean)
  }, showLinkPanel && {
    key: 'link',
    label: (0,i18n_build_module.__)('Link'),
    hasValue: hasLink,
    resetValue: resetLink,
    isShownByDefault: defaultControls.link,
    indicators: [linkColor, hoverLinkColor],
    tabs: [{
      key: 'link',
      label: (0,i18n_build_module.__)('Default'),
      inheritedValue: linkColor,
      setValue: setLinkColor,
      userValue: userLinkColor
    }, {
      key: 'hover',
      label: (0,i18n_build_module.__)('Hover'),
      inheritedValue: hoverLinkColor,
      setValue: setHoverLinkColor,
      userValue: userHoverLinkColor
    }]
  }].filter(Boolean);
  elements.forEach(({
    name,
    label,
    showPanel
  }) => {
    if (!showPanel) {
      return;
    }
    const elementBackgroundColor = decodeValue(inheritedValue?.elements?.[name]?.color?.background);
    const elementGradient = decodeValue(inheritedValue?.elements?.[name]?.color?.gradient);
    const elementTextColor = decodeValue(inheritedValue?.elements?.[name]?.color?.text);
    const elementBackgroundUserColor = decodeValue(value?.elements?.[name]?.color?.background);
    const elementGradientUserColor = decodeValue(value?.elements?.[name]?.color?.gradient);
    const elementTextUserColor = decodeValue(value?.elements?.[name]?.color?.text);
    const hasElement = () => !!(elementTextUserColor || elementBackgroundUserColor || elementGradientUserColor);
    const resetElement = () => {
      const newValue = object_setImmutably(value, ['elements', name, 'color', 'background'], undefined);
      newValue.elements[name].color.gradient = undefined;
      newValue.elements[name].color.text = undefined;
      onChange(newValue);
    };
    const setElementTextColor = newTextColor => {
      onChange(object_setImmutably(value, ['elements', name, 'color', 'text'], encodeColorValue(newTextColor)));
    };
    const setElementBackgroundColor = newBackgroundColor => {
      const newValue = object_setImmutably(value, ['elements', name, 'color', 'background'], encodeColorValue(newBackgroundColor));
      newValue.elements[name].color.gradient = undefined;
      onChange(newValue);
    };
    const setElementGradient = newGradient => {
      const newValue = object_setImmutably(value, ['elements', name, 'color', 'gradient'], encodeGradientValue(newGradient));
      newValue.elements[name].color.background = undefined;
      onChange(newValue);
    };
    const supportsTextColor = true;
    // Background color is not supported for `caption`
    // as there isn't yet a way to set padding for the element.
    const supportsBackground = name !== 'caption';
    items.push({
      key: name,
      label,
      hasValue: hasElement,
      resetValue: resetElement,
      isShownByDefault: defaultControls[name],
      indicators: supportsTextColor && supportsBackground ? [elementTextColor, elementGradient !== null && elementGradient !== void 0 ? elementGradient : elementBackgroundColor] : [supportsTextColor ? elementTextColor : elementGradient !== null && elementGradient !== void 0 ? elementGradient : elementBackgroundColor],
      tabs: [hasSolidColors && supportsTextColor && {
        key: 'text',
        label: (0,i18n_build_module.__)('Text'),
        inheritedValue: elementTextColor,
        setValue: setElementTextColor,
        userValue: elementTextUserColor
      }, hasSolidColors && supportsBackground && {
        key: 'background',
        label: (0,i18n_build_module.__)('Background'),
        inheritedValue: elementBackgroundColor,
        setValue: setElementBackgroundColor,
        userValue: elementBackgroundUserColor
      }, hasGradientColors && supportsBackground && {
        key: 'gradient',
        label: (0,i18n_build_module.__)('Gradient'),
        inheritedValue: elementGradient,
        setValue: setElementGradient,
        userValue: elementGradientUserColor,
        isGradient: true
      }].filter(Boolean)
    });
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId,
    children: [items.map(item => {
      const {
        key,
        ...restItem
      } = item;
      return /*#__PURE__*/(0,jsx_runtime.jsx)(ColorPanelDropdown, {
        ...restItem,
        colorGradientControlSettings: {
          colors,
          disableCustomColors: !areCustomSolidsEnabled,
          gradients,
          disableCustomGradients: !areCustomGradientsEnabled
        },
        panelId: panelId
      }, key);
    }), children]
  });
}
//# sourceMappingURL=color-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/contrast-checker/index.js
/**
 * External dependencies
 */




/**
 * WordPress dependencies
 */




(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);
function ContrastChecker({
  backgroundColor,
  fallbackBackgroundColor,
  fallbackTextColor,
  fallbackLinkColor,
  fontSize,
  // Font size value in pixels.
  isLargeText,
  textColor,
  linkColor,
  enableAlphaChecker = false
}) {
  const currentBackgroundColor = backgroundColor || fallbackBackgroundColor;

  // Must have a background color.
  if (!currentBackgroundColor) {
    return null;
  }
  const currentTextColor = textColor || fallbackTextColor;
  const currentLinkColor = linkColor || fallbackLinkColor;

  // Must have at least one text color.
  if (!currentTextColor && !currentLinkColor) {
    return null;
  }
  const textColors = [{
    color: currentTextColor,
    description: (0,i18n_build_module.__)('text color')
  }, {
    color: currentLinkColor,
    description: (0,i18n_build_module.__)('link color')
  }];
  const colordBackgroundColor = (0,node_modules_colord/* colord */.Mj)(currentBackgroundColor);
  const backgroundColorHasTransparency = colordBackgroundColor.alpha() < 1;
  const backgroundColorBrightness = colordBackgroundColor.brightness();
  const isReadableOptions = {
    level: 'AA',
    size: isLargeText || isLargeText !== false && fontSize >= 24 ? 'large' : 'small'
  };
  let message = '';
  let speakMessage = '';
  for (const item of textColors) {
    // If there is no color, go no further.
    if (!item.color) {
      continue;
    }
    const colordTextColor = (0,node_modules_colord/* colord */.Mj)(item.color);
    const isColordTextReadable = colordTextColor.isReadable(colordBackgroundColor, isReadableOptions);
    const textHasTransparency = colordTextColor.alpha() < 1;

    // If the contrast is not readable.
    if (!isColordTextReadable) {
      // Don't show the message if the background or text is transparent.
      if (backgroundColorHasTransparency || textHasTransparency) {
        continue;
      }
      message = backgroundColorBrightness < colordTextColor.brightness() ? (0,i18n_build_module/* sprintf */.nv)(
      // translators: %s is a type of text color, e.g., "text color" or "link color".
      (0,i18n_build_module.__)('This color combination may be hard for people to read. Try using a darker background color and/or a brighter %s.'), item.description) : (0,i18n_build_module/* sprintf */.nv)(
      // translators: %s is a type of text color, e.g., "text color" or "link color".
      (0,i18n_build_module.__)('This color combination may be hard for people to read. Try using a brighter background color and/or a darker %s.'), item.description);
      speakMessage = (0,i18n_build_module.__)('This color combination may be hard for people to read.');
      // Break from the loop when we have a contrast warning.
      // These messages take priority over the transparency warning.
      break;
    }

    // If there is no contrast warning and the text is transparent,
    // show the transparent warning if alpha check is enabled.
    if (textHasTransparency && enableAlphaChecker) {
      message = (0,i18n_build_module.__)('Transparent text may be hard for people to read.');
      speakMessage = (0,i18n_build_module.__)('Transparent text may be hard for people to read.');
    }
  }
  if (!message) {
    return null;
  }

  // Note: The `Notice` component can speak messages via its `spokenMessage`
  // prop, but the contrast checker requires granular control over when the
  // announcements are made. Notably, the message will be re-announced if a
  // new color combination is selected and the contrast is still insufficient.
  (0,a11y_build_module/* speak */.L)(speakMessage);
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-contrast-checker",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(notice/* default */.A, {
      spokenMessage: null,
      status: "warning",
      isDismissible: false,
      children: message
    })
  });
}

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/contrast-checker/README.md
 */
/* harmony default export */ const contrast_checker = (ContrastChecker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/contrast-checker.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function contrast_checker_getComputedStyle(node) {
  return node.ownerDocument.defaultView.getComputedStyle(node);
}
function BlockColorContrastChecker({
  clientId
}) {
  const [detectedBackgroundColor, setDetectedBackgroundColor] = (0,react.useState)();
  const [detectedColor, setDetectedColor] = (0,react.useState)();
  const [detectedLinkColor, setDetectedLinkColor] = (0,react.useState)();
  const ref = useBlockRef(clientId);

  // There are so many things that can change the color of a block
  // So we perform this check on every render.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  (0,react.useEffect)(() => {
    if (!ref.current) {
      return;
    }
    setDetectedColor(contrast_checker_getComputedStyle(ref.current).color);
    const firstLinkElement = ref.current?.querySelector('a');
    if (firstLinkElement && !!firstLinkElement.innerText) {
      setDetectedLinkColor(contrast_checker_getComputedStyle(firstLinkElement).color);
    }
    let backgroundColorNode = ref.current;
    let backgroundColor = contrast_checker_getComputedStyle(backgroundColorNode).backgroundColor;
    while (backgroundColor === 'rgba(0, 0, 0, 0)' && backgroundColorNode.parentNode && backgroundColorNode.parentNode.nodeType === backgroundColorNode.parentNode.ELEMENT_NODE) {
      backgroundColorNode = backgroundColorNode.parentNode;
      backgroundColor = contrast_checker_getComputedStyle(backgroundColorNode).backgroundColor;
    }
    setDetectedBackgroundColor(backgroundColor);
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(contrast_checker, {
    backgroundColor: detectedBackgroundColor,
    textColor: detectedColor,
    enableAlphaChecker: true,
    linkColor: detectedLinkColor
  });
}
//# sourceMappingURL=contrast-checker.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/color.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */










const COLOR_SUPPORT_KEY = 'color';
const hasColorSupport = blockNameOrType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockNameOrType, COLOR_SUPPORT_KEY);
  return colorSupport && (colorSupport.link === true || colorSupport.gradient === true || colorSupport.background !== false || colorSupport.text !== false);
};
const hasLinkColorSupport = blockType => {
  if (platform/* default */.A.OS !== 'web') {
    return false;
  }
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.link;
};
const hasGradientSupport = blockNameOrType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockNameOrType, COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.gradients;
};
const hasBackgroundColorSupport = blockType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.background !== false;
};
const hasTextColorSupport = blockType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.text !== false;
};

/**
 * Filters registered block settings, extending attributes to include
 * `backgroundColor` and `textColor` attribute.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function color_addAttributes(settings) {
  if (!hasColorSupport(settings)) {
    return settings;
  }

  // Allow blocks to specify their own attribute definition with default values if needed.
  if (!settings.attributes.backgroundColor) {
    Object.assign(settings.attributes, {
      backgroundColor: {
        type: 'string'
      }
    });
  }
  if (!settings.attributes.textColor) {
    Object.assign(settings.attributes, {
      textColor: {
        type: 'string'
      }
    });
  }
  if (hasGradientSupport(settings) && !settings.attributes.gradient) {
    Object.assign(settings.attributes, {
      gradient: {
        type: 'string'
      }
    });
  }
  return settings;
}

/**
 * Override props assigned to save component to inject colors classnames.
 *
 * @param {Object}        props           Additional props applied to save element.
 * @param {Object|string} blockNameOrType Block type.
 * @param {Object}        attributes      Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */
function color_addSaveProps(props, blockNameOrType, attributes) {
  if (!hasColorSupport(blockNameOrType) || shouldSkipSerialization(blockNameOrType, COLOR_SUPPORT_KEY)) {
    return props;
  }
  const hasGradient = hasGradientSupport(blockNameOrType);

  // I'd have preferred to avoid the "style" attribute usage here
  const {
    backgroundColor,
    textColor,
    gradient,
    style
  } = attributes;
  const shouldSerialize = feature => !shouldSkipSerialization(blockNameOrType, COLOR_SUPPORT_KEY, feature);

  // Primary color classes must come before the `has-text-color`,
  // `has-background` and `has-link-color` classes to maintain backwards
  // compatibility and avoid block invalidations.
  const textClass = shouldSerialize('text') ? utils_getColorClassName('color', textColor) : undefined;
  const gradientClass = shouldSerialize('gradients') ? use_gradient_experimentalGetGradientClass(gradient) : undefined;
  const backgroundClass = shouldSerialize('background') ? utils_getColorClassName('background-color', backgroundColor) : undefined;
  const serializeHasBackground = shouldSerialize('background') || shouldSerialize('gradients');
  const hasBackground = backgroundColor || style?.color?.background || hasGradient && (gradient || style?.color?.gradient);
  const newClassName = (0,dist_clsx/* default */.A)(props.className, textClass, gradientClass, {
    // Don't apply the background class if there's a custom gradient.
    [backgroundClass]: (!hasGradient || !style?.color?.gradient) && !!backgroundClass,
    'has-text-color': shouldSerialize('text') && (textColor || style?.color?.text),
    'has-background': serializeHasBackground && hasBackground,
    'has-link-color': shouldSerialize('link') && style?.elements?.link?.color
  });
  props.className = newClassName ? newClassName : undefined;
  return props;
}
function color_styleToAttributes(style) {
  const textColorValue = style?.color?.text;
  const textColorSlug = textColorValue?.startsWith('var:preset|color|') ? textColorValue.substring('var:preset|color|'.length) : undefined;
  const backgroundColorValue = style?.color?.background;
  const backgroundColorSlug = backgroundColorValue?.startsWith('var:preset|color|') ? backgroundColorValue.substring('var:preset|color|'.length) : undefined;
  const gradientValue = style?.color?.gradient;
  const gradientSlug = gradientValue?.startsWith('var:preset|gradient|') ? gradientValue.substring('var:preset|gradient|'.length) : undefined;
  const updatedStyle = {
    ...style
  };
  updatedStyle.color = {
    ...updatedStyle.color,
    text: textColorSlug ? undefined : textColorValue,
    background: backgroundColorSlug ? undefined : backgroundColorValue,
    gradient: gradientSlug ? undefined : gradientValue
  };
  return {
    style: utils_cleanEmptyObject(updatedStyle),
    textColor: textColorSlug,
    backgroundColor: backgroundColorSlug,
    gradient: gradientSlug
  };
}
function color_attributesToStyle(attributes) {
  return {
    ...attributes.style,
    color: {
      ...attributes.style?.color,
      text: attributes.textColor ? 'var:preset|color|' + attributes.textColor : attributes.style?.color?.text,
      background: attributes.backgroundColor ? 'var:preset|color|' + attributes.backgroundColor : attributes.style?.color?.background,
      gradient: attributes.gradient ? 'var:preset|gradient|' + attributes.gradient : attributes.style?.color?.gradient
    }
  };
}
function ColorInspectorControl({
  children,
  resetAllFilter
}) {
  const attributesResetAllFilter = (0,react.useCallback)(attributes => {
    const existingStyle = color_attributesToStyle(attributes);
    const updatedStyle = resetAllFilter(existingStyle);
    return {
      ...attributes,
      ...color_styleToAttributes(updatedStyle)
    };
  }, [resetAllFilter]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
    group: "color",
    resetAllFilter: attributesResetAllFilter,
    children: children
  });
}
function ColorEdit({
  clientId,
  name,
  setAttributes,
  settings
}) {
  const isEnabled = useHasColorPanel(settings);
  function selector(select) {
    const {
      style,
      textColor,
      backgroundColor,
      gradient
    } = select(store_store).getBlockAttributes(clientId) || {};
    return {
      style,
      textColor,
      backgroundColor,
      gradient
    };
  }
  const {
    style,
    textColor,
    backgroundColor,
    gradient
  } = (0,use_select/* default */.A)(selector, [clientId]);
  const value = (0,react.useMemo)(() => {
    return color_attributesToStyle({
      style,
      textColor,
      backgroundColor,
      gradient
    });
  }, [style, textColor, backgroundColor, gradient]);
  const onChange = newStyle => {
    setAttributes(color_styleToAttributes(newStyle));
  };
  if (!isEnabled) {
    return null;
  }
  const defaultControls = (0,build_module/* getBlockSupport */.bI)(name, [COLOR_SUPPORT_KEY, '__experimentalDefaultControls']);
  const enableContrastChecking = platform/* default */.A.OS === 'web' && !value?.color?.gradient && (settings?.color?.text || settings?.color?.link) &&
  // Contrast checking is enabled by default.
  // Deactivating it requires `enableContrastChecker` to have
  // an explicit value of `false`.
  false !== (0,build_module/* getBlockSupport */.bI)(name, [COLOR_SUPPORT_KEY, 'enableContrastChecker']);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(ColorPanel, {
    as: ColorInspectorControl,
    panelId: clientId,
    settings: settings,
    value: value,
    onChange: onChange,
    defaultControls: defaultControls,
    enableContrastChecker: false !== (0,build_module/* getBlockSupport */.bI)(name, [COLOR_SUPPORT_KEY, 'enableContrastChecker']),
    children: enableContrastChecking && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockColorContrastChecker, {
      clientId: clientId
    })
  });
}
function color_useBlockProps({
  name,
  backgroundColor,
  textColor,
  gradient,
  style
}) {
  const [userPalette, themePalette, defaultPalette] = use_settings_useSettings('color.palette.custom', 'color.palette.theme', 'color.palette.default');
  const colors = (0,react.useMemo)(() => [...(userPalette || []), ...(themePalette || []), ...(defaultPalette || [])], [userPalette, themePalette, defaultPalette]);
  if (!hasColorSupport(name) || shouldSkipSerialization(name, COLOR_SUPPORT_KEY)) {
    return {};
  }
  const extraStyles = {};
  if (textColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY, 'text')) {
    extraStyles.color = utils_getColorObjectByAttributeValues(colors, textColor)?.color;
  }
  if (backgroundColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY, 'background')) {
    extraStyles.backgroundColor = utils_getColorObjectByAttributeValues(colors, backgroundColor)?.color;
  }
  const saveProps = color_addSaveProps({
    style: extraStyles
  }, name, {
    textColor,
    backgroundColor,
    gradient,
    style
  });
  const hasBackgroundValue = backgroundColor || style?.color?.background || gradient || style?.color?.gradient;
  return {
    ...saveProps,
    className: (0,dist_clsx/* default */.A)(saveProps.className,
    // Add background image classes in the editor, if not already handled by background color values.
    !hasBackgroundValue && getBackgroundImageClasses(style))
  };
}
/* harmony default export */ const hooks_color = ({
  useBlockProps: color_useBlockProps,
  addSaveProps: color_addSaveProps,
  attributeKeys: ['backgroundColor', 'textColor', 'gradient', 'style'],
  hasSupport: hasColorSupport
});
const MIGRATION_PATHS = {
  linkColor: [['style', 'elements', 'link', 'color', 'text']],
  textColor: [['textColor'], ['style', 'color', 'text']],
  backgroundColor: [['backgroundColor'], ['style', 'color', 'background']],
  gradient: [['gradient'], ['style', 'color', 'gradient']]
};
function color_addTransforms(result, source, index, results) {
  const destinationBlockType = result.name;
  const activeSupports = {
    linkColor: hasLinkColorSupport(destinationBlockType),
    textColor: hasTextColorSupport(destinationBlockType),
    backgroundColor: hasBackgroundColorSupport(destinationBlockType),
    gradient: hasGradientSupport(destinationBlockType)
  };
  return transformStyles(activeSupports, MIGRATION_PATHS, result, source, index, results);
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/color/addAttribute', color_addAttributes);
(0,hooks_build_module/* addFilter */.U2)('blocks.switchToBlockType.transformedBlock', 'core/color/addTransforms', color_addTransforms);
//# sourceMappingURL=color.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/settings.js
/**
 * WordPress dependencies
 */


const settings_settings = /*#__PURE__*/(0,jsx_runtime.jsxs)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m19 7.5h-7.628c-.3089-.87389-1.1423-1.5-2.122-1.5-.97966 0-1.81309.62611-2.12197 1.5h-2.12803v1.5h2.12803c.30888.87389 1.14231 1.5 2.12197 1.5.9797 0 1.8131-.62611 2.122-1.5h7.628z"
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m19 15h-2.128c-.3089-.8739-1.1423-1.5-2.122-1.5s-1.8131.6261-2.122 1.5h-7.628v1.5h7.628c.3089.8739 1.1423 1.5 2.122 1.5s1.8131-.6261 2.122-1.5h2.128z"
  })]
});
/* harmony default export */ const library_settings = (settings_settings);
//# sourceMappingURL=settings.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/font-size-picker/utils.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



/**
 * Some themes use css vars for their font sizes, so until we
 * have the way of calculating them don't display them.
 *
 * @param value The value that is checked.
 * @return Whether the value is a simple css value.
 */
function isSimpleCssValue(value) {
  const sizeRegex = /^[\d\.]+(px|em|rem|vw|vh|%|svw|lvw|dvw|svh|lvh|dvh|vi|svi|lvi|dvi|vb|svb|lvb|dvb|vmin|svmin|lvmin|dvmin|vmax|svmax|lvmax|dvmax)?$/i;
  return sizeRegex.test(String(value));
}

/**
 * If all of the given font sizes have the same unit (e.g. 'px'), return that
 * unit. Otherwise return null.
 *
 * @param fontSizes List of font sizes.
 * @return The common unit, or null.
 */
function getCommonSizeUnit(fontSizes) {
  const [firstFontSize, ...otherFontSizes] = fontSizes;
  if (!firstFontSize) {
    return null;
  }
  const [, firstUnit] = parseQuantityAndUnitFromRawValue(firstFontSize.size);
  const areAllSizesSameUnit = otherFontSizes.every(fontSize => {
    const [, unit] = parseQuantityAndUnitFromRawValue(fontSize.size);
    return unit === firstUnit;
  });
  return areAllSizesSameUnit ? firstUnit : null;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/font-size-picker/styles.js

function font_size_picker_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





const Container = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("fieldset",  true ? {
  target: "e8tqeku4"
} : 0)( true ? {
  name: "1t1ytme",
  styles: "border:0;margin:0;padding:0"
} : 0);
const Header = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(h_stack_component/* default */.A,  true ? {
  target: "e8tqeku3"
} : 0)("height:", (0,space/* space */.x)(4), ";" + ( true ? "" : 0));
const HeaderToggle = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(build_module_button/* default */.Ay,  true ? {
  target: "e8tqeku2"
} : 0)("margin-top:", (0,space/* space */.x)(-1), ";" + ( true ? "" : 0));
const HeaderLabel = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(base_control/* default.VisualLabel */.Ay.VisualLabel,  true ? {
  target: "e8tqeku1"
} : 0)("display:flex;gap:", (0,space/* space */.x)(1), ";justify-content:flex-start;margin-bottom:0;" + ( true ? "" : 0));
const HeaderHint = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e8tqeku0"
} : 0)("color:", colors_values/* COLORS */.l.gray[700], ";" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/font-size-picker/font-size-picker-select.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




const DEFAULT_OPTION = {
  key: 'default',
  name: (0,i18n_build_module.__)('Default'),
  value: undefined
};
const CUSTOM_OPTION = {
  key: 'custom',
  name: (0,i18n_build_module.__)('Custom')
};
const FontSizePickerSelect = props => {
  var _options$find;
  const {
    __next40pxDefaultSize,
    fontSizes,
    value,
    disableCustomFontSizes,
    size,
    onChange,
    onSelectCustom
  } = props;
  const areAllSizesSameUnit = !!getCommonSizeUnit(fontSizes);
  const options = [DEFAULT_OPTION, ...fontSizes.map(fontSize => {
    let hint;
    if (areAllSizesSameUnit) {
      const [quantity] = parseQuantityAndUnitFromRawValue(fontSize.size);
      if (quantity !== undefined) {
        hint = String(quantity);
      }
    } else if (isSimpleCssValue(fontSize.size)) {
      hint = String(fontSize.size);
    }
    return {
      key: fontSize.slug,
      name: fontSize.name || fontSize.slug,
      value: fontSize.size,
      __experimentalHint: hint
    };
  }), ...(disableCustomFontSizes ? [] : [CUSTOM_OPTION])];
  const selectedOption = value ? (_options$find = options.find(option => option.value === value)) !== null && _options$find !== void 0 ? _options$find : CUSTOM_OPTION : DEFAULT_OPTION;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(CustomSelectControl, {
    __next40pxDefaultSize: __next40pxDefaultSize,
    className: "components-font-size-picker__select",
    label: (0,i18n_build_module.__)('Font size'),
    hideLabelFromVision: true,
    describedBy: (0,i18n_build_module/* sprintf */.nv)(
    // translators: %s: Currently selected font size.
    (0,i18n_build_module.__)('Currently selected font size: %s'), selectedOption.name),
    options: options,
    value: selectedOption,
    __experimentalShowSelectedHint: true,
    onChange: ({
      selectedItem
    }) => {
      if (selectedItem === CUSTOM_OPTION) {
        onSelectCustom();
      } else {
        onChange(selectedItem.value);
      }
    },
    size: size
  });
};
/* harmony default export */ const font_size_picker_select = (FontSizePickerSelect);
//# sourceMappingURL=font-size-picker-select.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/font-size-picker/constants.js
/**
 * WordPress dependencies
 */


/**
 * List of T-shirt abbreviations.
 *
 * When there are 5 font sizes or fewer, we assume that the font sizes are
 * ordered by size and show T-shirt labels.
 */
const T_SHIRT_ABBREVIATIONS = [/* translators: S stands for 'small' and is a size label. */
(0,i18n_build_module.__)('S'), /* translators: M stands for 'medium' and is a size label. */
(0,i18n_build_module.__)('M'), /* translators: L stands for 'large' and is a size label. */
(0,i18n_build_module.__)('L'), /* translators: XL stands for 'extra large' and is a size label. */
(0,i18n_build_module.__)('XL'), /* translators: XXL stands for 'extra extra large' and is a size label. */
(0,i18n_build_module.__)('XXL')];

/**
 * List of T-shirt names.
 *
 * When there are 5 font sizes or fewer, we assume that the font sizes are
 * ordered by size and show T-shirt labels.
 */
const T_SHIRT_NAMES = [(0,i18n_build_module.__)('Small'), (0,i18n_build_module.__)('Medium'), (0,i18n_build_module.__)('Large'), (0,i18n_build_module.__)('Extra Large'), (0,i18n_build_module.__)('Extra Extra Large')];
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/font-size-picker/font-size-picker-toggle-group.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const FontSizePickerToggleGroup = props => {
  const {
    fontSizes,
    value,
    __next40pxDefaultSize,
    size,
    onChange
  } = props;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_component, {
    __nextHasNoMarginBottom: true,
    __next40pxDefaultSize: __next40pxDefaultSize,
    label: (0,i18n_build_module.__)('Font size'),
    hideLabelFromVision: true,
    value: value,
    onChange: onChange,
    isBlock: true,
    size: size,
    children: fontSizes.map((fontSize, index) => /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_component, {
      value: fontSize.size,
      label: T_SHIRT_ABBREVIATIONS[index],
      "aria-label": fontSize.name || T_SHIRT_NAMES[index],
      showTooltip: true
    }, fontSize.slug))
  });
};
/* harmony default export */ const font_size_picker_toggle_group = (FontSizePickerToggleGroup);
//# sourceMappingURL=font-size-picker-toggle-group.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/font-size-picker/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */













const DEFAULT_UNITS = ['px', 'em', 'rem', 'vw', 'vh'];
const UnforwardedFontSizePicker = (props, ref) => {
  const {
    __next40pxDefaultSize = false,
    fallbackFontSize,
    fontSizes = [],
    disableCustomFontSizes = false,
    onChange,
    size = 'default',
    units: unitsProp = DEFAULT_UNITS,
    value,
    withSlider = false,
    withReset = true
  } = props;
  const units = useCustomUnits({
    availableUnits: unitsProp
  });
  const shouldUseSelectControl = fontSizes.length > 5;
  const selectedFontSize = fontSizes.find(fontSize => fontSize.size === value);
  const isCustomValue = !!value && !selectedFontSize;
  const [showCustomValueControl, setShowCustomValueControl] = (0,react.useState)(!disableCustomFontSizes && isCustomValue);
  const headerHint = (0,react.useMemo)(() => {
    if (showCustomValueControl) {
      return (0,i18n_build_module.__)('Custom');
    }
    if (!shouldUseSelectControl) {
      if (selectedFontSize) {
        return selectedFontSize.name || T_SHIRT_NAMES[fontSizes.indexOf(selectedFontSize)];
      }
      return '';
    }
    const commonUnit = getCommonSizeUnit(fontSizes);
    if (commonUnit) {
      return `(${commonUnit})`;
    }
    return '';
  }, [showCustomValueControl, shouldUseSelectControl, selectedFontSize, fontSizes]);
  if (fontSizes.length === 0 && disableCustomFontSizes) {
    return null;
  }

  // If neither the value or first font size is a string, then FontSizePicker
  // operates in a legacy "unitless" mode where UnitControl can only be used
  // to select px values and onChange() is always called with number values.
  const hasUnits = typeof value === 'string' || typeof fontSizes[0]?.size === 'string';
  const [valueQuantity, valueUnit] = parseQuantityAndUnitFromRawValue(value, units);
  const isValueUnitRelative = !!valueUnit && ['em', 'rem', 'vw', 'vh'].includes(valueUnit);
  const isDisabled = value === undefined;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Container, {
    ref: ref,
    className: "components-font-size-picker",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
      as: "legend",
      children: (0,i18n_build_module.__)('Font size')
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Header, {
        className: "components-font-size-picker__header",
        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(HeaderLabel, {
          "aria-label": `${(0,i18n_build_module.__)('Size')} ${headerHint || ''}`,
          children: [(0,i18n_build_module.__)('Size'), headerHint && /*#__PURE__*/(0,jsx_runtime.jsx)(HeaderHint, {
            className: "components-font-size-picker__header__hint",
            children: headerHint
          })]
        }), !disableCustomFontSizes && /*#__PURE__*/(0,jsx_runtime.jsx)(HeaderToggle, {
          label: showCustomValueControl ? (0,i18n_build_module.__)('Use size preset') : (0,i18n_build_module.__)('Set custom size'),
          icon: library_settings,
          onClick: () => {
            setShowCustomValueControl(!showCustomValueControl);
          },
          isPressed: showCustomValueControl,
          size: "small"
        })]
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      children: [!!fontSizes.length && shouldUseSelectControl && !showCustomValueControl && /*#__PURE__*/(0,jsx_runtime.jsx)(font_size_picker_select, {
        __next40pxDefaultSize: __next40pxDefaultSize,
        fontSizes: fontSizes,
        value: value,
        disableCustomFontSizes: disableCustomFontSizes,
        size: size,
        onChange: newValue => {
          if (newValue === undefined) {
            onChange?.(undefined);
          } else {
            onChange?.(hasUnits ? newValue : Number(newValue), fontSizes.find(fontSize => fontSize.size === newValue));
          }
        },
        onSelectCustom: () => setShowCustomValueControl(true)
      }), !shouldUseSelectControl && !showCustomValueControl && /*#__PURE__*/(0,jsx_runtime.jsx)(font_size_picker_toggle_group, {
        fontSizes: fontSizes,
        value: value,
        __next40pxDefaultSize: __next40pxDefaultSize,
        size: size,
        onChange: newValue => {
          if (newValue === undefined) {
            onChange?.(undefined);
          } else {
            onChange?.(hasUnits ? newValue : Number(newValue), fontSizes.find(fontSize => fontSize.size === newValue));
          }
        }
      }), !disableCustomFontSizes && showCustomValueControl && /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
        className: "components-font-size-picker__custom-size-control",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          isBlock: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
            __next40pxDefaultSize: __next40pxDefaultSize,
            label: (0,i18n_build_module.__)('Custom'),
            labelPosition: "top",
            hideLabelFromVision: true,
            value: value,
            onChange: newValue => {
              if (newValue === undefined) {
                onChange?.(undefined);
              } else {
                onChange?.(hasUnits ? newValue : parseInt(newValue, 10));
              }
            },
            size: size,
            units: hasUnits ? units : [],
            min: 0
          })
        }), withSlider && /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          isBlock: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
            marginX: 2,
            marginBottom: 0,
            children: /*#__PURE__*/(0,jsx_runtime.jsx)(range_control, {
              __nextHasNoMarginBottom: true,
              __next40pxDefaultSize: __next40pxDefaultSize,
              className: "components-font-size-picker__custom-input",
              label: (0,i18n_build_module.__)('Custom Size'),
              hideLabelFromVision: true,
              value: valueQuantity,
              initialPosition: fallbackFontSize,
              withInputField: false,
              onChange: newValue => {
                if (newValue === undefined) {
                  onChange?.(undefined);
                } else if (hasUnits) {
                  onChange?.(newValue + (valueUnit !== null && valueUnit !== void 0 ? valueUnit : 'px'));
                } else {
                  onChange?.(newValue);
                }
              },
              min: 0,
              max: isValueUnitRelative ? 10 : 100,
              step: isValueUnitRelative ? 0.1 : 1
            })
          })
        }), withReset && /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* Button */.$n, {
            disabled: isDisabled,
            __experimentalIsFocusable: true,
            onClick: () => {
              onChange?.(undefined);
            },
            variant: "secondary",
            __next40pxDefaultSize: true,
            size: size === '__unstable-large' || props.__next40pxDefaultSize ? 'default' : 'small',
            children: (0,i18n_build_module.__)('Reset')
          })
        })]
      })]
    })]
  });
};
const font_size_picker_FontSizePicker = (0,react.forwardRef)(UnforwardedFontSizePicker);
/* harmony default export */ const font_size_picker = (font_size_picker_FontSizePicker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/font-family/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function FontFamilyControl({
  value = '',
  onChange,
  fontFamilies,
  ...props
}) {
  const [blockLevelFontFamilies] = use_settings_useSettings('typography.fontFamilies');
  if (!fontFamilies) {
    fontFamilies = blockLevelFontFamilies;
  }
  if (!fontFamilies || fontFamilies.length === 0) {
    return null;
  }
  const options = [{
    value: '',
    label: (0,i18n_build_module.__)('Default')
  }, ...fontFamilies.map(({
    fontFamily,
    name
  }) => {
    return {
      value: fontFamily,
      label: name || fontFamily
    };
  })];
  return /*#__PURE__*/(0,jsx_runtime.jsx)(select_control/* default */.A, {
    label: (0,i18n_build_module.__)('Font'),
    options: options,
    value: value,
    onChange: onChange,
    labelPosition: "top",
    ...props
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/font-appearance-control/index.js
/**
 * WordPress dependencies
 */




const FONT_STYLES = [{
  name: (0,i18n_build_module._x)('Regular', 'font style'),
  value: 'normal'
}, {
  name: (0,i18n_build_module._x)('Italic', 'font style'),
  value: 'italic'
}];
const FONT_WEIGHTS = [{
  name: (0,i18n_build_module._x)('Thin', 'font weight'),
  value: '100'
}, {
  name: (0,i18n_build_module._x)('Extra Light', 'font weight'),
  value: '200'
}, {
  name: (0,i18n_build_module._x)('Light', 'font weight'),
  value: '300'
}, {
  name: (0,i18n_build_module._x)('Regular', 'font weight'),
  value: '400'
}, {
  name: (0,i18n_build_module._x)('Medium', 'font weight'),
  value: '500'
}, {
  name: (0,i18n_build_module._x)('Semi Bold', 'font weight'),
  value: '600'
}, {
  name: (0,i18n_build_module._x)('Bold', 'font weight'),
  value: '700'
}, {
  name: (0,i18n_build_module._x)('Extra Bold', 'font weight'),
  value: '800'
}, {
  name: (0,i18n_build_module._x)('Black', 'font weight'),
  value: '900'
}];

/**
 * Adjusts font appearance field label in case either font styles or weights
 * are disabled.
 *
 * @param {boolean} hasFontStyles  Whether font styles are enabled and present.
 * @param {boolean} hasFontWeights Whether font weights are enabled and present.
 * @return {string} A label representing what font appearance is being edited.
 */
const getFontAppearanceLabel = (hasFontStyles, hasFontWeights) => {
  if (!hasFontStyles) {
    return (0,i18n_build_module.__)('Font weight');
  }
  if (!hasFontWeights) {
    return (0,i18n_build_module.__)('Font style');
  }
  return (0,i18n_build_module.__)('Appearance');
};

/**
 * Control to display unified font style and weight options.
 *
 * @param {Object} props Component props.
 *
 * @return {Element} Font appearance control.
 */
function FontAppearanceControl(props) {
  const {
    onChange,
    hasFontStyles = true,
    hasFontWeights = true,
    value: {
      fontStyle,
      fontWeight
    },
    ...otherProps
  } = props;
  const hasStylesOrWeights = hasFontStyles || hasFontWeights;
  const label = getFontAppearanceLabel(hasFontStyles, hasFontWeights);
  const defaultOption = {
    key: 'default',
    name: (0,i18n_build_module.__)('Default'),
    style: {
      fontStyle: undefined,
      fontWeight: undefined
    }
  };

  // Combines both font style and weight options into a single dropdown.
  const combineOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_STYLES.forEach(({
      name: styleName,
      value: styleValue
    }) => {
      FONT_WEIGHTS.forEach(({
        name: weightName,
        value: weightValue
      }) => {
        const optionName = styleValue === 'normal' ? weightName : (0,i18n_build_module/* sprintf */.nv)( /* translators: 1: Font weight name. 2: Font style name. */
        (0,i18n_build_module.__)('%1$s %2$s'), weightName, styleName);
        combinedOptions.push({
          key: `${styleValue}-${weightValue}`,
          name: optionName,
          style: {
            fontStyle: styleValue,
            fontWeight: weightValue
          }
        });
      });
    });
    return combinedOptions;
  };

  // Generates select options for font styles only.
  const styleOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_STYLES.forEach(({
      name,
      value
    }) => {
      combinedOptions.push({
        key: value,
        name,
        style: {
          fontStyle: value,
          fontWeight: undefined
        }
      });
    });
    return combinedOptions;
  };

  // Generates select options for font weights only.
  const weightOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_WEIGHTS.forEach(({
      name,
      value
    }) => {
      combinedOptions.push({
        key: value,
        name,
        style: {
          fontStyle: undefined,
          fontWeight: value
        }
      });
    });
    return combinedOptions;
  };

  // Map font styles and weights to select options.
  const selectOptions = (0,react.useMemo)(() => {
    if (hasFontStyles && hasFontWeights) {
      return combineOptions();
    }
    return hasFontStyles ? styleOptions() : weightOptions();
  }, [props.options]);

  // Find current selection by comparing font style & weight against options,
  // and fall back to the Default option if there is no matching option.
  const currentSelection = selectOptions.find(option => option.style.fontStyle === fontStyle && option.style.fontWeight === fontWeight) || selectOptions[0];

  // Adjusts screen reader description based on styles or weights.
  const getDescribedBy = () => {
    if (!currentSelection) {
      return (0,i18n_build_module.__)('No selected font appearance');
    }
    if (!hasFontStyles) {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: %s: Currently selected font weight.
      (0,i18n_build_module.__)('Currently selected font weight: %s'), currentSelection.name);
    }
    if (!hasFontWeights) {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: %s: Currently selected font style.
      (0,i18n_build_module.__)('Currently selected font style: %s'), currentSelection.name);
    }
    return (0,i18n_build_module/* sprintf */.nv)(
    // translators: %s: Currently selected font appearance.
    (0,i18n_build_module.__)('Currently selected font appearance: %s'), currentSelection.name);
  };
  return hasStylesOrWeights && /*#__PURE__*/(0,jsx_runtime.jsx)(StableCustomSelectControl, {
    ...otherProps,
    className: "components-font-appearance-control",
    label: label,
    describedBy: getDescribedBy(),
    options: selectOptions,
    value: currentSelection,
    onChange: ({
      selectedItem
    }) => onChange(selectedItem.style)
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/line-height-control/utils.js
const BASE_DEFAULT_VALUE = 1.5;
const STEP = 0.01;
/**
 * A spin factor of 10 allows the spin controls to increment/decrement by 0.1.
 * e.g. A line-height value of 1.55 will increment to 1.65.
 */
const SPIN_FACTOR = 10;
/**
 * There are varying value types within LineHeightControl:
 *
 * {undefined} Initial value. No changes from the user.
 * {string} Input value. Value consumed/outputted by the input. Empty would be ''.
 * {number} Block attribute type. Input value needs to be converted for attribute setting.
 *
 * Note: If the value is undefined, the input requires it to be an empty string ('')
 * in order to be considered "controlled" by props (rather than internal state).
 */
const RESET_VALUE = '';

/**
 * Determines if the lineHeight attribute has been properly defined.
 *
 * @param {any} lineHeight The value to check.
 *
 * @return {boolean} Whether the lineHeight attribute is valid.
 */
function isLineHeightDefined(lineHeight) {
  return lineHeight !== undefined && lineHeight !== RESET_VALUE;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/line-height-control/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const line_height_control_LineHeightControl = ({
  value: lineHeight,
  onChange,
  /** Start opting into the new margin-free styles that will become the default in a future version. */
  __nextHasNoMarginBottom = false,
  __unstableInputWidth = '60px',
  ...otherProps
}) => {
  const isDefined = isLineHeightDefined(lineHeight);
  const adjustNextValue = (nextValue, wasTypedOrPasted) => {
    // Set the next value without modification if lineHeight has been defined.
    if (isDefined) {
      return nextValue;
    }

    /**
     * The following logic handles the initial spin up/down action
     * (from an undefined value state) so that the next values are better suited for
     * line-height rendering. For example, the first spin up should immediately
     * go to 1.6, rather than the normally expected 0.1.
     *
     * Spin up/down actions can be triggered by keydowns of the up/down arrow keys,
     * dragging the input or by clicking the spin buttons.
     */
    const spin = STEP * SPIN_FACTOR;
    switch (`${nextValue}`) {
      case `${spin}`:
        // Increment by spin value.
        return BASE_DEFAULT_VALUE + spin;
      case '0':
        {
          // This means the user explicitly input '0', rather than using the
          // spin down action from an undefined value state.
          if (wasTypedOrPasted) {
            return nextValue;
          }
          // Decrement by spin value.
          return BASE_DEFAULT_VALUE - spin;
        }
      case '':
        return BASE_DEFAULT_VALUE;
      default:
        return nextValue;
    }
  };
  const stateReducer = (state, action) => {
    // Be careful when changing this — cross-browser behavior of the
    // `inputType` field in `input` events are inconsistent.
    // For example, Firefox emits an input event with inputType="insertReplacementText"
    // on spin button clicks, while other browsers do not even emit an input event.
    const wasTypedOrPasted = ['insertText', 'insertFromPaste'].includes(action.payload.event.nativeEvent?.inputType);
    const value = adjustNextValue(state.value, wasTypedOrPasted);
    return {
      ...state,
      value
    };
  };
  const value = isDefined ? lineHeight : RESET_VALUE;
  if (!__nextHasNoMarginBottom) {
    (0,deprecated_build_module/* default */.A)('Bottom margin styles for wp.blockEditor.LineHeightControl', {
      since: '6.0',
      version: '6.4',
      hint: 'Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version'
    });
  }
  const deprecatedStyles = __nextHasNoMarginBottom ? undefined : {
    marginBottom: 24
  };
  const handleOnChange = (nextValue, {
    event
  }) => {
    if (nextValue === '') {
      onChange();
      return;
    }
    if (event.type === 'click') {
      onChange(adjustNextValue(`${nextValue}`, false));
      return;
    }
    onChange(`${nextValue}`);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-line-height-control",
    style: deprecatedStyles,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(number_control/* default */.A, {
      ...otherProps,
      __unstableInputWidth: __unstableInputWidth,
      __unstableStateReducer: stateReducer,
      onChange: handleOnChange,
      label: (0,i18n_build_module.__)('Line height'),
      placeholder: BASE_DEFAULT_VALUE,
      step: STEP,
      spinFactor: SPIN_FACTOR,
      value: value,
      min: 0,
      spinControls: "custom"
    })
  });
};

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/line-height-control/README.md
 */
/* harmony default export */ const line_height_control = (line_height_control_LineHeightControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/letter-spacing-control/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Control for letter-spacing.
 *
 * @param {Object}                  props                      Component props.
 * @param {string}                  props.value                Currently selected letter-spacing.
 * @param {Function}                props.onChange             Handles change in letter-spacing selection.
 * @param {string|number|undefined} props.__unstableInputWidth Input width to pass through to inner UnitControl. Should be a valid CSS value.
 *
 * @return {Element} Letter-spacing control.
 */

function LetterSpacingControl({
  value,
  onChange,
  __unstableInputWidth = '60px',
  ...otherProps
}) {
  const [availableUnits] = use_settings_useSettings('spacing.units');
  const units = useCustomUnits({
    availableUnits: availableUnits || ['px', 'em', 'rem'],
    defaultValues: {
      px: 2,
      em: 0.2,
      rem: 0.2
    }
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
    ...otherProps,
    label: (0,i18n_build_module.__)('Letter spacing'),
    value: value,
    __unstableInputWidth: __unstableInputWidth,
    units: units,
    onChange: onChange
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/align-left.js
/**
 * WordPress dependencies
 */


const alignLeft = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M13 5.5H4V4h9v1.5Zm7 7H4V11h16v1.5Zm-7 7H4V18h9v1.5Z"
  })
});
/* harmony default export */ const align_left = (alignLeft);
//# sourceMappingURL=align-left.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/align-center.js
/**
 * WordPress dependencies
 */


const align_center_alignCenter = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M7.5 5.5h9V4h-9v1.5Zm-3.5 7h16V11H4v1.5Zm3.5 7h9V18h-9v1.5Z"
  })
});
/* harmony default export */ const align_center = (align_center_alignCenter);
//# sourceMappingURL=align-center.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/align-right.js
/**
 * WordPress dependencies
 */


const alignRight = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M11.111 5.5H20V4h-8.889v1.5ZM4 12.5h16V11H4v1.5Zm7.111 7H20V18h-8.889v1.5Z"
  })
});
/* harmony default export */ const align_right = (alignRight);
//# sourceMappingURL=align-right.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/align-justify.js
/**
 * WordPress dependencies
 */


const alignJustify = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M4 12.8h16v-1.5H4v1.5zm0 7h12.4v-1.5H4v1.5zM4 4.3v1.5h16V4.3H4z"
  })
});
/* harmony default export */ const align_justify = (alignJustify);
//# sourceMappingURL=align-justify.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/segmented-text-control/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * @typedef {Object} Option
 * @property {string} label The label of the option.
 * @property {string} value The value of the option.
 * @property {string} icon  The icon of the option.
 */

/**
 * Control to facilitate selecting a text style from a set of options.
 *
 * @param {Object}   props           Component props.
 * @param {string}   props.label     A label for the option.
 * @param {string}   props.value     Currently selected value.
 * @param {Function} props.onChange  Callback to handle onChange.
 * @param {Option[]} props.options   Array of options to display.
 * @param {string}   props.className Additional class name to apply.
 *
 * @return {Element} Element to render.
 */


function SegmentedTextControl({
  label,
  value,
  options,
  onChange,
  className
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {
    className: (0,dist_clsx/* default */.A)('block-editor-segmented-text-control', className),
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
      as: "legend",
      children: label
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-segmented-text-control__buttons",
      children: options.map(option => {
        return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          size: "compact",
          icon: option.icon,
          label: option.label,
          isPressed: option.value === value,
          onClick: () => onChange(option.value)
        }, option.value);
      })
    })]
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/text-alignment-control/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const TEXT_ALIGNMENT_OPTIONS = [{
  label: (0,i18n_build_module.__)('Align text left'),
  value: 'left',
  icon: align_left
}, {
  label: (0,i18n_build_module.__)('Align text center'),
  value: 'center',
  icon: align_center
}, {
  label: (0,i18n_build_module.__)('Align text right'),
  value: 'right',
  icon: align_right
}, {
  label: (0,i18n_build_module.__)('Justify text'),
  value: 'justify',
  icon: align_justify
}];
const DEFAULT_OPTIONS = ['left', 'center', 'right'];

/**
 * Control to facilitate text alignment selections.
 *
 * @param {Object}   props           Component props.
 * @param {string}   props.className Class name to add to the control.
 * @param {string}   props.value     Currently selected text alignment.
 * @param {Function} props.onChange  Handles change in text alignment selection.
 * @param {string[]} props.options   Array of text alignment options to display.
 *
 * @return {Element} Text alignment control.
 */
function TextAlignmentControl({
  className,
  value,
  onChange,
  options = DEFAULT_OPTIONS
}) {
  const validOptions = (0,react.useMemo)(() => TEXT_ALIGNMENT_OPTIONS.filter(option => options.includes(option.value)), [options]);
  if (!validOptions.length) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(SegmentedTextControl, {
    label: (0,i18n_build_module.__)('Text alignment'),
    options: validOptions,
    className: (0,dist_clsx/* default */.A)('block-editor-text-alignment-control', className),
    value: value,
    onChange: newValue => {
      onChange(newValue === value ? undefined : newValue);
    }
  });
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/reset.js
var library_reset = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/reset.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/format-uppercase.js
/**
 * WordPress dependencies
 */


const formatUppercase = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M6.1 6.8L2.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H6.1zm-.8 6.8L7 8.9l1.7 4.7H5.3zm15.1-.7c-.4-.5-.9-.8-1.6-1 .4-.2.7-.5.8-.9.2-.4.3-.9.3-1.4 0-.9-.3-1.6-.8-2-.6-.5-1.3-.7-2.4-.7h-3.5V18h4.2c1.1 0 2-.3 2.6-.8.6-.6 1-1.4 1-2.4-.1-.8-.3-1.4-.6-1.9zm-5.7-4.7h1.8c.6 0 1.1.1 1.4.4.3.2.5.7.5 1.3 0 .6-.2 1.1-.5 1.3-.3.2-.8.4-1.4.4h-1.8V8.2zm4 8c-.4.3-.9.5-1.5.5h-2.6v-3.8h2.6c1.4 0 2 .6 2 1.9.1.6-.1 1-.5 1.4z"
  })
});
/* harmony default export */ const format_uppercase = (formatUppercase);
//# sourceMappingURL=format-uppercase.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/format-lowercase.js
/**
 * WordPress dependencies
 */


const formatLowercase = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M11 16.8c-.1-.1-.2-.3-.3-.5v-2.6c0-.9-.1-1.7-.3-2.2-.2-.5-.5-.9-.9-1.2-.4-.2-.9-.3-1.6-.3-.5 0-1 .1-1.5.2s-.9.3-1.2.6l.2 1.2c.4-.3.7-.4 1.1-.5.3-.1.7-.2 1-.2.6 0 1 .1 1.3.4.3.2.4.7.4 1.4-1.2 0-2.3.2-3.3.7s-1.4 1.1-1.4 2.1c0 .7.2 1.2.7 1.6.4.4 1 .6 1.8.6.9 0 1.7-.4 2.4-1.2.1.3.2.5.4.7.1.2.3.3.6.4.3.1.6.1 1.1.1h.1l.2-1.2h-.1c-.4.1-.6 0-.7-.1zM9.2 16c-.2.3-.5.6-.9.8-.3.1-.7.2-1.1.2-.4 0-.7-.1-.9-.3-.2-.2-.3-.5-.3-.9 0-.6.2-1 .7-1.3.5-.3 1.3-.4 2.5-.5v2zm10.6-3.9c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2s-.2 1.4-.6 2z"
  })
});
/* harmony default export */ const format_lowercase = (formatLowercase);
//# sourceMappingURL=format-lowercase.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/format-capitalize.js
/**
 * WordPress dependencies
 */


const formatCapitalize = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M7.1 6.8L3.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H7.1zm-.8 6.8L8 8.9l1.7 4.7H6.3zm14.5-1.5c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2 .1.8-.2 1.4-.6 2z"
  })
});
/* harmony default export */ const format_capitalize = (formatCapitalize);
//# sourceMappingURL=format-capitalize.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/text-transform-control/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const TEXT_TRANSFORMS = [{
  label: (0,i18n_build_module.__)('None'),
  value: 'none',
  icon: library_reset/* default */.A
}, {
  label: (0,i18n_build_module.__)('Uppercase'),
  value: 'uppercase',
  icon: format_uppercase
}, {
  label: (0,i18n_build_module.__)('Lowercase'),
  value: 'lowercase',
  icon: format_lowercase
}, {
  label: (0,i18n_build_module.__)('Capitalize'),
  value: 'capitalize',
  icon: format_capitalize
}];

/**
 * Control to facilitate text transform selections.
 *
 * @param {Object}   props           Component props.
 * @param {string}   props.className Class name to add to the control.
 * @param {string}   props.value     Currently selected text transform.
 * @param {Function} props.onChange  Handles change in text transform selection.
 *
 * @return {Element} Text transform control.
 */
function TextTransformControl({
  className,
  value,
  onChange
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(SegmentedTextControl, {
    label: (0,i18n_build_module.__)('Letter case'),
    options: TEXT_TRANSFORMS,
    className: (0,dist_clsx/* default */.A)('block-editor-text-transform-control', className),
    value: value,
    onChange: newValue => {
      onChange(newValue === value ? undefined : newValue);
    }
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/format-underline.js
/**
 * WordPress dependencies
 */


const formatUnderline = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M7 18v1h10v-1H7zm5-2c1.5 0 2.6-.4 3.4-1.2.8-.8 1.1-2 1.1-3.5V5H15v5.8c0 1.2-.2 2.1-.6 2.8-.4.7-1.2 1-2.4 1s-2-.3-2.4-1c-.4-.7-.6-1.6-.6-2.8V5H7.5v6.2c0 1.5.4 2.7 1.1 3.5.8.9 1.9 1.3 3.4 1.3z"
  })
});
/* harmony default export */ const format_underline = (formatUnderline);
//# sourceMappingURL=format-underline.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/format-strikethrough.js
/**
 * WordPress dependencies
 */


const formatStrikethrough = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M9.1 9v-.5c0-.6.2-1.1.7-1.4.5-.3 1.2-.5 2-.5.7 0 1.4.1 2.1.3.7.2 1.4.5 2.1.9l.2-1.9c-.6-.3-1.2-.5-1.9-.7-.8-.1-1.6-.2-2.4-.2-1.5 0-2.7.3-3.6 1-.8.7-1.2 1.5-1.2 2.6V9h2zM20 12H4v1h8.3c.3.1.6.2.8.3.5.2.9.5 1.1.8.3.3.4.7.4 1.2 0 .7-.2 1.1-.8 1.5-.5.3-1.2.5-2.1.5-.8 0-1.6-.1-2.4-.3-.8-.2-1.5-.5-2.2-.8L7 18.1c.5.2 1.2.4 2 .6.8.2 1.6.3 2.4.3 1.7 0 3-.3 3.9-1 .9-.7 1.3-1.6 1.3-2.8 0-.9-.2-1.7-.7-2.2H20v-1z"
  })
});
/* harmony default export */ const format_strikethrough = (formatStrikethrough);
//# sourceMappingURL=format-strikethrough.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/text-decoration-control/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const TEXT_DECORATIONS = [{
  label: (0,i18n_build_module.__)('None'),
  value: 'none',
  icon: library_reset/* default */.A
}, {
  label: (0,i18n_build_module.__)('Underline'),
  value: 'underline',
  icon: format_underline
}, {
  label: (0,i18n_build_module.__)('Strikethrough'),
  value: 'line-through',
  icon: format_strikethrough
}];

/**
 * Control to facilitate text decoration selections.
 *
 * @param {Object}   props           Component props.
 * @param {string}   props.value     Currently selected text decoration.
 * @param {Function} props.onChange  Handles change in text decoration selection.
 * @param {string}   props.className Additional class name to apply.
 *
 * @return {Element} Text decoration control.
 */
function TextDecorationControl({
  value,
  onChange,
  className
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(SegmentedTextControl, {
    label: (0,i18n_build_module.__)('Decoration'),
    options: TEXT_DECORATIONS,
    className: (0,dist_clsx/* default */.A)('block-editor-text-decoration-control', className),
    value: value,
    onChange: newValue => {
      onChange(newValue === value ? undefined : newValue);
    }
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/text-horizontal.js
/**
 * WordPress dependencies
 */


const textHorizontal = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M8.2 14.4h3.9L13 17h1.7L11 6.5H9.3L5.6 17h1.7l.9-2.6zm2-5.5 1.4 4H8.8l1.4-4zm7.4 7.5-1.3.8.8 1.4H5.5V20h14.3l-2.2-3.6z"
  })
});
/* harmony default export */ const text_horizontal = (textHorizontal);
//# sourceMappingURL=text-horizontal.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/text-vertical.js
/**
 * WordPress dependencies
 */


const textVertical = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M7 5.6v1.7l2.6.9v3.9L7 13v1.7L17.5 11V9.3L7 5.6zm4.2 6V8.8l4 1.4-4 1.4zm-5.7 5.6V5.5H4v14.3l3.6-2.2-.8-1.3-1.3.9z"
  })
});
/* harmony default export */ const text_vertical = (textVertical);
//# sourceMappingURL=text-vertical.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-mode-control/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const WRITING_MODES = [{
  label: (0,i18n_build_module.__)('Horizontal'),
  value: 'horizontal-tb',
  icon: text_horizontal
}, {
  label: (0,i18n_build_module.__)('Vertical'),
  value: (0,i18n_build_module/* isRTL */.V8)() ? 'vertical-lr' : 'vertical-rl',
  icon: text_vertical
}];

/**
 * Control to facilitate writing mode selections.
 *
 * @param {Object}   props           Component props.
 * @param {string}   props.className Class name to add to the control.
 * @param {string}   props.value     Currently selected writing mode.
 * @param {Function} props.onChange  Handles change in the writing mode selection.
 *
 * @return {Element} Writing Mode control.
 */
function WritingModeControl({
  className,
  value,
  onChange
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(SegmentedTextControl, {
    label: (0,i18n_build_module.__)('Orientation'),
    options: WRITING_MODES,
    className: (0,dist_clsx/* default */.A)('block-editor-writing-mode-control', className),
    value: value,
    onChange: newValue => {
      onChange(newValue === value ? undefined : newValue);
    }
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/typography-panel.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */












const MIN_TEXT_COLUMNS = 1;
const MAX_TEXT_COLUMNS = 6;
function useHasTypographyPanel(settings) {
  const hasFontFamily = useHasFontFamilyControl(settings);
  const hasLineHeight = useHasLineHeightControl(settings);
  const hasFontAppearance = useHasAppearanceControl(settings);
  const hasLetterSpacing = useHasLetterSpacingControl(settings);
  const hasTextAlign = useHasTextAlignmentControl(settings);
  const hasTextTransform = useHasTextTransformControl(settings);
  const hasTextDecoration = useHasTextDecorationControl(settings);
  const hasWritingMode = useHasWritingModeControl(settings);
  const hasTextColumns = useHasTextColumnsControl(settings);
  const hasFontSize = useHasFontSizeControl(settings);
  return hasFontFamily || hasLineHeight || hasFontAppearance || hasLetterSpacing || hasTextAlign || hasTextTransform || hasFontSize || hasTextDecoration || hasWritingMode || hasTextColumns;
}
function useHasFontSizeControl(settings) {
  return settings?.typography?.defaultFontSizes !== false && settings?.typography?.fontSizes?.default?.length || settings?.typography?.fontSizes?.theme?.length || settings?.typography?.fontSizes?.custom?.length || settings?.typography?.customFontSize;
}
function useHasFontFamilyControl(settings) {
  return ['default', 'theme', 'custom'].some(key => settings?.typography?.fontFamilies?.[key]?.length);
}
function useHasLineHeightControl(settings) {
  return settings?.typography?.lineHeight;
}
function useHasAppearanceControl(settings) {
  return settings?.typography?.fontStyle || settings?.typography?.fontWeight;
}
function useAppearanceControlLabel(settings) {
  if (!settings?.typography?.fontStyle) {
    return (0,i18n_build_module.__)('Font weight');
  }
  if (!settings?.typography?.fontWeight) {
    return (0,i18n_build_module.__)('Font style');
  }
  return (0,i18n_build_module.__)('Appearance');
}
function useHasLetterSpacingControl(settings) {
  return settings?.typography?.letterSpacing;
}
function useHasTextTransformControl(settings) {
  return settings?.typography?.textTransform;
}
function useHasTextAlignmentControl(settings) {
  return settings?.typography?.textAlign;
}
function useHasTextDecorationControl(settings) {
  return settings?.typography?.textDecoration;
}
function useHasWritingModeControl(settings) {
  return settings?.typography?.writingMode;
}
function useHasTextColumnsControl(settings) {
  return settings?.typography?.textColumns;
}

/**
 * Concatenate all the font sizes into a single list for the font size picker.
 *
 * @param {Object} settings The global styles settings.
 *
 * @return {Array} The merged font sizes.
 */
function getMergedFontSizes(settings) {
  var _fontSizes$custom, _fontSizes$theme, _fontSizes$default;
  const fontSizes = settings?.typography?.fontSizes;
  const defaultFontSizesEnabled = !!settings?.typography?.defaultFontSizes;
  return [...((_fontSizes$custom = fontSizes?.custom) !== null && _fontSizes$custom !== void 0 ? _fontSizes$custom : []), ...((_fontSizes$theme = fontSizes?.theme) !== null && _fontSizes$theme !== void 0 ? _fontSizes$theme : []), ...(defaultFontSizesEnabled ? (_fontSizes$default = fontSizes?.default) !== null && _fontSizes$default !== void 0 ? _fontSizes$default : [] : [])];
}
function TypographyToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_component, {
    label: (0,i18n_build_module.__)('Typography'),
    resetAll: resetAll,
    panelId: panelId,
    dropdownMenuProps: dropdownMenuProps,
    children: children
  });
}
const typography_panel_DEFAULT_CONTROLS = {
  fontFamily: true,
  fontSize: true,
  fontAppearance: true,
  lineHeight: true,
  letterSpacing: true,
  textAlign: true,
  textTransform: true,
  textDecoration: true,
  writingMode: true,
  textColumns: true
};
function TypographyPanel({
  as: Wrapper = TypographyToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = typography_panel_DEFAULT_CONTROLS
}) {
  const decodeValue = rawValue => utils_getValueFromVariable({
    settings
  }, '', rawValue);

  // Font Family
  const hasFontFamilyEnabled = useHasFontFamilyControl(settings);
  const fontFamilies = settings?.typography?.fontFamilies;
  const mergedFontFamilies = (0,react.useMemo)(() => {
    return ['default', 'theme', 'custom'].flatMap(key => {
      var _fontFamilies$key;
      return (_fontFamilies$key = fontFamilies?.[key]) !== null && _fontFamilies$key !== void 0 ? _fontFamilies$key : [];
    });
  }, [fontFamilies]);
  const fontFamily = decodeValue(inheritedValue?.typography?.fontFamily);
  const setFontFamily = newValue => {
    const slug = mergedFontFamilies?.find(({
      fontFamily: f
    }) => f === newValue)?.slug;
    onChange(object_setImmutably(value, ['typography', 'fontFamily'], slug ? `var:preset|font-family|${slug}` : newValue || undefined));
  };
  const hasFontFamily = () => !!value?.typography?.fontFamily;
  const resetFontFamily = () => setFontFamily(undefined);

  // Font Size
  const hasFontSizeEnabled = useHasFontSizeControl(settings);
  const disableCustomFontSizes = !settings?.typography?.customFontSize;
  const mergedFontSizes = getMergedFontSizes(settings);
  const fontSize = decodeValue(inheritedValue?.typography?.fontSize);
  const setFontSize = (newValue, metadata) => {
    const actualValue = !!metadata?.slug ? `var:preset|font-size|${metadata?.slug}` : newValue;
    onChange(object_setImmutably(value, ['typography', 'fontSize'], actualValue || undefined));
  };
  const hasFontSize = () => !!value?.typography?.fontSize;
  const resetFontSize = () => setFontSize(undefined);

  // Appearance
  const hasAppearanceControl = useHasAppearanceControl(settings);
  const appearanceControlLabel = useAppearanceControlLabel(settings);
  const hasFontStyles = settings?.typography?.fontStyle;
  const hasFontWeights = settings?.typography?.fontWeight;
  const fontStyle = decodeValue(inheritedValue?.typography?.fontStyle);
  const fontWeight = decodeValue(inheritedValue?.typography?.fontWeight);
  const setFontAppearance = ({
    fontStyle: newFontStyle,
    fontWeight: newFontWeight
  }) => {
    onChange({
      ...value,
      typography: {
        ...value?.typography,
        fontStyle: newFontStyle || undefined,
        fontWeight: newFontWeight || undefined
      }
    });
  };
  const hasFontAppearance = () => !!value?.typography?.fontStyle || !!value?.typography?.fontWeight;
  const resetFontAppearance = () => {
    setFontAppearance({});
  };

  // Line Height
  const hasLineHeightEnabled = useHasLineHeightControl(settings);
  const lineHeight = decodeValue(inheritedValue?.typography?.lineHeight);
  const setLineHeight = newValue => {
    onChange(object_setImmutably(value, ['typography', 'lineHeight'], newValue || undefined));
  };
  const hasLineHeight = () => value?.typography?.lineHeight !== undefined;
  const resetLineHeight = () => setLineHeight(undefined);

  // Letter Spacing
  const hasLetterSpacingControl = useHasLetterSpacingControl(settings);
  const letterSpacing = decodeValue(inheritedValue?.typography?.letterSpacing);
  const setLetterSpacing = newValue => {
    onChange(object_setImmutably(value, ['typography', 'letterSpacing'], newValue || undefined));
  };
  const hasLetterSpacing = () => !!value?.typography?.letterSpacing;
  const resetLetterSpacing = () => setLetterSpacing(undefined);

  // Text Columns
  const hasTextColumnsControl = useHasTextColumnsControl(settings);
  const textColumns = decodeValue(inheritedValue?.typography?.textColumns);
  const setTextColumns = newValue => {
    onChange(object_setImmutably(value, ['typography', 'textColumns'], newValue || undefined));
  };
  const hasTextColumns = () => !!value?.typography?.textColumns;
  const resetTextColumns = () => setTextColumns(undefined);

  // Text Transform
  const hasTextTransformControl = useHasTextTransformControl(settings);
  const textTransform = decodeValue(inheritedValue?.typography?.textTransform);
  const setTextTransform = newValue => {
    onChange(object_setImmutably(value, ['typography', 'textTransform'], newValue || undefined));
  };
  const hasTextTransform = () => !!value?.typography?.textTransform;
  const resetTextTransform = () => setTextTransform(undefined);

  // Text Decoration
  const hasTextDecorationControl = useHasTextDecorationControl(settings);
  const textDecoration = decodeValue(inheritedValue?.typography?.textDecoration);
  const setTextDecoration = newValue => {
    onChange(object_setImmutably(value, ['typography', 'textDecoration'], newValue || undefined));
  };
  const hasTextDecoration = () => !!value?.typography?.textDecoration;
  const resetTextDecoration = () => setTextDecoration(undefined);

  // Text Orientation
  const hasWritingModeControl = useHasWritingModeControl(settings);
  const writingMode = decodeValue(inheritedValue?.typography?.writingMode);
  const setWritingMode = newValue => {
    onChange(object_setImmutably(value, ['typography', 'writingMode'], newValue || undefined));
  };
  const hasWritingMode = () => !!value?.typography?.writingMode;
  const resetWritingMode = () => setWritingMode(undefined);

  // Text Alignment
  const hasTextAlignmentControl = useHasTextAlignmentControl(settings);
  const textAlign = decodeValue(inheritedValue?.typography?.textAlign);
  const setTextAlign = newValue => {
    onChange(object_setImmutably(value, ['typography', 'textAlign'], newValue || undefined));
  };
  const hasTextAlign = () => !!value?.typography?.textAlign;
  const resetTextAlign = () => setTextAlign(undefined);
  const resetAllFilter = (0,react.useCallback)(previousValue => {
    return {
      ...previousValue,
      typography: {}
    };
  }, []);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId,
    children: [hasFontFamilyEnabled && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      label: (0,i18n_build_module.__)('Font'),
      hasValue: hasFontFamily,
      onDeselect: resetFontFamily,
      isShownByDefault: defaultControls.fontFamily,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(FontFamilyControl, {
        fontFamilies: mergedFontFamilies,
        value: fontFamily,
        onChange: setFontFamily,
        size: "__unstable-large",
        __nextHasNoMarginBottom: true
      })
    }), hasFontSizeEnabled && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      label: (0,i18n_build_module.__)('Size'),
      hasValue: hasFontSize,
      onDeselect: resetFontSize,
      isShownByDefault: defaultControls.fontSize,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(font_size_picker, {
        value: fontSize,
        onChange: setFontSize,
        fontSizes: mergedFontSizes,
        disableCustomFontSizes: disableCustomFontSizes,
        withReset: false,
        withSlider: true,
        size: "__unstable-large"
      })
    }), hasAppearanceControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      className: "single-column",
      label: appearanceControlLabel,
      hasValue: hasFontAppearance,
      onDeselect: resetFontAppearance,
      isShownByDefault: defaultControls.fontAppearance,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(FontAppearanceControl, {
        value: {
          fontStyle,
          fontWeight
        },
        onChange: setFontAppearance,
        hasFontStyles: hasFontStyles,
        hasFontWeights: hasFontWeights,
        size: "__unstable-large",
        __nextHasNoMarginBottom: true
      })
    }), hasLineHeightEnabled && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      className: "single-column",
      label: (0,i18n_build_module.__)('Line height'),
      hasValue: hasLineHeight,
      onDeselect: resetLineHeight,
      isShownByDefault: defaultControls.lineHeight,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(line_height_control, {
        __nextHasNoMarginBottom: true,
        __unstableInputWidth: "auto",
        value: lineHeight,
        onChange: setLineHeight,
        size: "__unstable-large"
      })
    }), hasLetterSpacingControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      className: "single-column",
      label: (0,i18n_build_module.__)('Letter spacing'),
      hasValue: hasLetterSpacing,
      onDeselect: resetLetterSpacing,
      isShownByDefault: defaultControls.letterSpacing,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(LetterSpacingControl, {
        value: letterSpacing,
        onChange: setLetterSpacing,
        size: "__unstable-large",
        __unstableInputWidth: "auto"
      })
    }), hasTextColumnsControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      className: "single-column",
      label: (0,i18n_build_module.__)('Columns'),
      hasValue: hasTextColumns,
      onDeselect: resetTextColumns,
      isShownByDefault: defaultControls.textColumns,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(number_control/* default */.A, {
        label: (0,i18n_build_module.__)('Columns'),
        max: MAX_TEXT_COLUMNS,
        min: MIN_TEXT_COLUMNS,
        onChange: setTextColumns,
        size: "__unstable-large",
        spinControls: "custom",
        value: textColumns,
        initialPosition: 1
      })
    }), hasTextDecorationControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      className: "single-column",
      label: (0,i18n_build_module.__)('Decoration'),
      hasValue: hasTextDecoration,
      onDeselect: resetTextDecoration,
      isShownByDefault: defaultControls.textDecoration,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(TextDecorationControl, {
        value: textDecoration,
        onChange: setTextDecoration,
        size: "__unstable-large",
        __unstableInputWidth: "auto"
      })
    }), hasWritingModeControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      className: "single-column",
      label: (0,i18n_build_module.__)('Orientation'),
      hasValue: hasWritingMode,
      onDeselect: resetWritingMode,
      isShownByDefault: defaultControls.writingMode,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(WritingModeControl, {
        value: writingMode,
        onChange: setWritingMode,
        size: "__unstable-large",
        __nextHasNoMarginBottom: true
      })
    }), hasTextTransformControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      label: (0,i18n_build_module.__)('Letter case'),
      hasValue: hasTextTransform,
      onDeselect: resetTextTransform,
      isShownByDefault: defaultControls.textTransform,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(TextTransformControl, {
        value: textTransform,
        onChange: setTextTransform,
        showNone: true,
        isBlock: true,
        size: "__unstable-large",
        __nextHasNoMarginBottom: true
      })
    }), hasTextAlignmentControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      label: (0,i18n_build_module.__)('Text alignment'),
      hasValue: hasTextAlign,
      onDeselect: resetTextAlign,
      isShownByDefault: defaultControls.textAlign,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(TextAlignmentControl, {
        value: textAlign,
        onChange: setTextAlign,
        size: "__unstable-large",
        __nextHasNoMarginBottom: true
      })
    })]
  });
}
//# sourceMappingURL=typography-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/line-height.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




const LINE_HEIGHT_SUPPORT_KEY = 'typography.lineHeight';

/**
 * Inspector control panel containing the line height related configuration
 *
 * @param {Object} props
 *
 * @return {Element} Line height edit element.
 */
function LineHeightEdit(props) {
  const {
    attributes: {
      style
    },
    setAttributes
  } = props;
  const onChange = newLineHeightValue => {
    const newStyle = {
      ...style,
      typography: {
        ...style?.typography,
        lineHeight: newLineHeightValue
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };
  return /*#__PURE__*/_jsx(LineHeightControl, {
    __unstableInputWidth: "100%",
    __nextHasNoMarginBottom: true,
    value: style?.typography?.lineHeight,
    onChange: onChange,
    size: "__unstable-large"
  });
}

/**
 * Custom hook that checks if line-height settings have been disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */
function useIsLineHeightDisabled({
  name: blockName
} = {}) {
  const [isEnabled] = useSettings('typography.lineHeight');
  return !isEnabled || !hasBlockSupport(blockName, LINE_HEIGHT_SUPPORT_KEY);
}
//# sourceMappingURL=line-height.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+token-list@3.10.0/node_modules/@wordpress/token-list/build-module/index.js
/* wp:polyfill */
/**
 * A set of tokens.
 *
 * @see https://dom.spec.whatwg.org/#domtokenlist
 */
class TokenList {
  /**
   * Constructs a new instance of TokenList.
   *
   * @param initialValue Initial value to assign.
   */
  constructor(initialValue = '') {
    this._currentValue = '';
    this._valueAsArray = [];
    this.value = initialValue;
  }
  entries(...args) {
    return this._valueAsArray.entries(...args);
  }
  forEach(...args) {
    return this._valueAsArray.forEach(...args);
  }
  keys(...args) {
    return this._valueAsArray.keys(...args);
  }
  values(...args) {
    return this._valueAsArray.values(...args);
  }

  /**
   * Returns the associated set as string.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-value
   *
   * @return Token set as string.
   */
  get value() {
    return this._currentValue;
  }

  /**
   * Replaces the associated set with a new string value.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-value
   *
   * @param value New token set as string.
   */
  set value(value) {
    value = String(value);
    this._valueAsArray = [...new Set(value.split(/\s+/g).filter(Boolean))];
    this._currentValue = this._valueAsArray.join(' ');
  }

  /**
   * Returns the number of tokens.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-length
   *
   * @return Number of tokens.
   */
  get length() {
    return this._valueAsArray.length;
  }

  /**
   * Returns the stringified form of the TokenList.
   *
   * @see https://dom.spec.whatwg.org/#DOMTokenList-stringification-behavior
   * @see https://www.ecma-international.org/ecma-262/9.0/index.html#sec-tostring
   *
   * @return Token set as string.
   */
  toString() {
    return this.value;
  }

  /**
   * Returns an iterator for the TokenList, iterating items of the set.
   *
   * @see https://dom.spec.whatwg.org/#domtokenlist
   *
   * @return TokenList iterator.
   */
  *[Symbol.iterator]() {
    return yield* this._valueAsArray;
  }

  /**
   * Returns the token with index `index`.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-item
   *
   * @param index Index at which to return token.
   *
   * @return Token at index.
   */
  item(index) {
    return this._valueAsArray[index];
  }

  /**
   * Returns true if `token` is present, and false otherwise.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-contains
   *
   * @param item Token to test.
   *
   * @return Whether token is present.
   */
  contains(item) {
    return this._valueAsArray.indexOf(item) !== -1;
  }

  /**
   * Adds all arguments passed, except those already present.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-add
   *
   * @param items Items to add.
   */
  add(...items) {
    this.value += ' ' + items.join(' ');
  }

  /**
   * Removes arguments passed, if they are present.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-remove
   *
   * @param items Items to remove.
   */
  remove(...items) {
    this.value = this._valueAsArray.filter(val => !items.includes(val)).join(' ');
  }

  /**
   * If `force` is not given, "toggles" `token`, removing it if it’s present
   * and adding it if it’s not present. If `force` is true, adds token (same
   * as add()). If force is false, removes token (same as remove()). Returns
   * true if `token` is now present, and false otherwise.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-toggle
   *
   * @param token   Token to toggle.
   * @param [force] Presence to force.
   *
   * @return Whether token is present after toggle.
   */
  toggle(token, force) {
    if (undefined === force) {
      force = !this.contains(token);
    }
    if (force) {
      this.add(token);
    } else {
      this.remove(token);
    }
    return force;
  }

  /**
   * Replaces `token` with `newToken`. Returns true if `token` was replaced
   * with `newToken`, and false otherwise.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-replace
   *
   * @param token    Token to replace with `newToken`.
   * @param newToken Token to use in place of `token`.
   *
   * @return Whether replacement occurred.
   */
  replace(token, newToken) {
    if (!this.contains(token)) {
      return false;
    }
    this.remove(token);
    this.add(newToken);
    return true;
  }

  /* eslint-disable @typescript-eslint/no-unused-vars */
  /**
   * Returns true if `token` is in the associated attribute’s supported
   * tokens. Returns false otherwise.
   *
   * Always returns `true` in this implementation.
   *
   * @param _token
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-supports
   *
   * @return Whether token is supported.
   */
  supports(_token) {
    return true;
  }
  /* eslint-enable @typescript-eslint/no-unused-vars */
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/font-family.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



const FONT_FAMILY_SUPPORT_KEY = 'typography.__experimentalFontFamily';
const {
  kebabCase: font_family_kebabCase
} = lock_unlock_unlock(privateApis);

/**
 * Filters registered block settings, extending attributes to include
 * the `fontFamily` attribute.
 *
 * @param {Object} settings Original block settings
 * @return {Object}         Filtered block settings
 */
function font_family_addAttributes(settings) {
  if (!(0,build_module/* hasBlockSupport */.pN)(settings, FONT_FAMILY_SUPPORT_KEY)) {
    return settings;
  }

  // Allow blocks to specify a default value if needed.
  if (!settings.attributes.fontFamily) {
    Object.assign(settings.attributes, {
      fontFamily: {
        type: 'string'
      }
    });
  }
  return settings;
}

/**
 * Override props assigned to save component to inject font family.
 *
 * @param {Object} props      Additional props applied to save element
 * @param {Object} blockType  Block type
 * @param {Object} attributes Block attributes
 * @return {Object}           Filtered props applied to save element
 */
function font_family_addSaveProps(props, blockType, attributes) {
  if (!(0,build_module/* hasBlockSupport */.pN)(blockType, FONT_FAMILY_SUPPORT_KEY)) {
    return props;
  }
  if (shouldSkipSerialization(blockType, TYPOGRAPHY_SUPPORT_KEY, 'fontFamily')) {
    return props;
  }
  if (!attributes?.fontFamily) {
    return props;
  }

  // Use TokenList to dedupe classes.
  const classes = new TokenList(props.className);
  classes.add(`has-${font_family_kebabCase(attributes?.fontFamily)}-font-family`);
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : undefined;
  return props;
}
function font_family_useBlockProps({
  name,
  fontFamily
}) {
  return font_family_addSaveProps({}, name, {
    fontFamily
  });
}
/* harmony default export */ const font_family = ({
  useBlockProps: font_family_useBlockProps,
  addSaveProps: font_family_addSaveProps,
  attributeKeys: ['fontFamily'],
  hasSupport(name) {
    return (0,build_module/* hasBlockSupport */.pN)(name, FONT_FAMILY_SUPPORT_KEY);
  }
});

/**
 * Resets the font family block support attribute. This can be used when
 * disabling the font family support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */
function resetFontFamily({
  setAttributes
}) {
  setAttributes({
    fontFamily: undefined
  });
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/fontFamily/addAttribute', font_family_addAttributes);
//# sourceMappingURL=font-family.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/font-sizes/utils.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

const {
  kebabCase: utils_kebabCase
} = lock_unlock_unlock(privateApis);

/**
 *  Returns the font size object based on an array of named font sizes and the namedFontSize and customFontSize values.
 * 	If namedFontSize is undefined or not found in fontSizes an object with just the size value based on customFontSize is returned.
 *
 * @param {Array}   fontSizes               Array of font size objects containing at least the "name" and "size" values as properties.
 * @param {?string} fontSizeAttribute       Content of the font size attribute (slug).
 * @param {?number} customFontSizeAttribute Contents of the custom font size attribute (value).
 *
 * @return {?Object} If fontSizeAttribute is set and an equal slug is found in fontSizes it returns the font size object for that slug.
 * 					 Otherwise, an object with just the size value based on customFontSize is returned.
 */
const utils_getFontSize = (fontSizes, fontSizeAttribute, customFontSizeAttribute) => {
  if (fontSizeAttribute) {
    const fontSizeObject = fontSizes?.find(({
      slug
    }) => slug === fontSizeAttribute);
    if (fontSizeObject) {
      return fontSizeObject;
    }
  }
  return {
    size: customFontSizeAttribute
  };
};

/**
 * Returns the corresponding font size object for a given value.
 *
 * @param {Array}  fontSizes Array of font size objects.
 * @param {number} value     Font size value.
 *
 * @return {Object} Font size object.
 */
function utils_getFontSizeObjectByValue(fontSizes, value) {
  const fontSizeObject = fontSizes?.find(({
    size
  }) => size === value);
  if (fontSizeObject) {
    return fontSizeObject;
  }
  return {
    size: value
  };
}

/**
 * Returns a class based on fontSizeName.
 *
 * @param {string} fontSizeSlug Slug of the fontSize.
 *
 * @return {string | undefined} String with the class corresponding to the fontSize passed.
 *                  The class is generated by appending 'has-' followed by fontSizeSlug in kebabCase and ending with '-font-size'.
 */
function utils_getFontSizeClass(fontSizeSlug) {
  if (!fontSizeSlug) {
    return;
  }
  return `has-${utils_kebabCase(fontSizeSlug)}-font-size`;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/font-size.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






const FONT_SIZE_SUPPORT_KEY = 'typography.fontSize';

/**
 * Filters registered block settings, extending attributes to include
 * `fontSize` and `fontWeight` attributes.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function font_size_addAttributes(settings) {
  if (!(0,build_module/* hasBlockSupport */.pN)(settings, FONT_SIZE_SUPPORT_KEY)) {
    return settings;
  }

  // Allow blocks to specify a default value if needed.
  if (!settings.attributes.fontSize) {
    Object.assign(settings.attributes, {
      fontSize: {
        type: 'string'
      }
    });
  }
  return settings;
}

/**
 * Override props assigned to save component to inject font size.
 *
 * @param {Object} props           Additional props applied to save element.
 * @param {Object} blockNameOrType Block type.
 * @param {Object} attributes      Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */
function font_size_addSaveProps(props, blockNameOrType, attributes) {
  if (!(0,build_module/* hasBlockSupport */.pN)(blockNameOrType, FONT_SIZE_SUPPORT_KEY)) {
    return props;
  }
  if (shouldSkipSerialization(blockNameOrType, TYPOGRAPHY_SUPPORT_KEY, 'fontSize')) {
    return props;
  }

  // Use TokenList to dedupe classes.
  const classes = new TokenList(props.className);
  classes.add(utils_getFontSizeClass(attributes.fontSize));
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : undefined;
  return props;
}

/**
 * Inspector control panel containing the font size related configuration
 *
 * @param {Object} props
 *
 * @return {Element} Font size edit element.
 */
function FontSizeEdit(props) {
  const {
    attributes: {
      fontSize,
      style
    },
    setAttributes
  } = props;
  const [fontSizes] = useSettings('typography.fontSizes');
  const onChange = value => {
    const fontSizeSlug = getFontSizeObjectByValue(fontSizes, value).slug;
    setAttributes({
      style: cleanEmptyObject({
        ...style,
        typography: {
          ...style?.typography,
          fontSize: fontSizeSlug ? undefined : value
        }
      }),
      fontSize: fontSizeSlug
    });
  };
  const fontSizeObject = getFontSize(fontSizes, fontSize, style?.typography?.fontSize);
  const fontSizeValue = fontSizeObject?.size || style?.typography?.fontSize || fontSize;
  return /*#__PURE__*/_jsx(FontSizePicker, {
    onChange: onChange,
    value: fontSizeValue,
    withReset: false,
    withSlider: true,
    size: "__unstable-large"
  });
}

/**
 * Custom hook that checks if font-size settings have been disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */
function useIsFontSizeDisabled({
  name: blockName
} = {}) {
  const [fontSizes] = useSettings('typography.fontSizes');
  const hasFontSizes = !!fontSizes?.length;
  return !hasBlockSupport(blockName, FONT_SIZE_SUPPORT_KEY) || !hasFontSizes;
}
function font_size_useBlockProps({
  name,
  fontSize,
  style
}) {
  const [fontSizes, fluidTypographySettings, layoutSettings] = use_settings_useSettings('typography.fontSizes', 'typography.fluid', 'layout');

  /*
   * Only add inline styles if the block supports font sizes,
   * doesn't skip serialization of font sizes,
   * and has either a custom font size or a preset font size.
   */
  if (!(0,build_module/* hasBlockSupport */.pN)(name, FONT_SIZE_SUPPORT_KEY) || shouldSkipSerialization(name, TYPOGRAPHY_SUPPORT_KEY, 'fontSize') || !fontSize && !style?.typography?.fontSize) {
    return;
  }
  let props;
  if (style?.typography?.fontSize) {
    props = {
      style: {
        fontSize: typography_utils_getTypographyFontSizeValue({
          size: style.typography.fontSize
        }, {
          typography: {
            fluid: fluidTypographySettings
          },
          layout: layoutSettings
        })
      }
    };
  }
  if (fontSize) {
    props = {
      style: {
        fontSize: utils_getFontSize(fontSizes, fontSize, style?.typography?.fontSize).size
      }
    };
  }
  if (!props) {
    return;
  }
  return font_size_addSaveProps(props, name, {
    fontSize
  });
}
/* harmony default export */ const font_size = ({
  useBlockProps: font_size_useBlockProps,
  addSaveProps: font_size_addSaveProps,
  attributeKeys: ['fontSize', 'style'],
  hasSupport(name) {
    return (0,build_module/* hasBlockSupport */.pN)(name, FONT_SIZE_SUPPORT_KEY);
  }
});
const font_size_MIGRATION_PATHS = {
  fontSize: [['fontSize'], ['style', 'typography', 'fontSize']]
};
function font_size_addTransforms(result, source, index, results) {
  const destinationBlockType = result.name;
  const activeSupports = {
    fontSize: (0,build_module/* hasBlockSupport */.pN)(destinationBlockType, FONT_SIZE_SUPPORT_KEY)
  };
  return transformStyles(activeSupports, font_size_MIGRATION_PATHS, result, source, index, results);
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/font/addAttribute', font_size_addAttributes);
(0,hooks_build_module/* addFilter */.U2)('blocks.switchToBlockType.transformedBlock', 'core/font-size/addTransforms', font_size_addTransforms);
//# sourceMappingURL=font-size.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/alignment-control/ui.js
/**
 * WordPress dependencies
 */




const DEFAULT_ALIGNMENT_CONTROLS = [{
  icon: align_left,
  title: (0,i18n_build_module.__)('Align text left'),
  align: 'left'
}, {
  icon: align_center,
  title: (0,i18n_build_module.__)('Align text center'),
  align: 'center'
}, {
  icon: align_right,
  title: (0,i18n_build_module.__)('Align text right'),
  align: 'right'
}];
const ui_POPOVER_PROPS = {
  placement: 'bottom-start'
};
function ui_AlignmentUI({
  value,
  onChange,
  alignmentControls = DEFAULT_ALIGNMENT_CONTROLS,
  label = (0,i18n_build_module.__)('Align text'),
  describedBy = (0,i18n_build_module.__)('Change text alignment'),
  isCollapsed = true,
  isToolbar
}) {
  function applyOrUnset(align) {
    return () => onChange(value === align ? undefined : align);
  }
  const activeAlignment = alignmentControls.find(control => control.align === value);
  function setIcon() {
    if (activeAlignment) {
      return activeAlignment.icon;
    }
    return (0,i18n_build_module/* isRTL */.V8)() ? align_right : align_left;
  }
  const UIComponent = isToolbar ? toolbar_group/* default */.A : toolbar_dropdown_menu;
  const extraProps = isToolbar ? {
    isCollapsed
  } : {
    toggleProps: {
      describedBy
    },
    popoverProps: ui_POPOVER_PROPS
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(UIComponent, {
    icon: setIcon(),
    label: label,
    controls: alignmentControls.map(control => {
      const {
        align
      } = control;
      const isActive = value === align;
      return {
        ...control,
        isActive,
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: applyOrUnset(align)
      };
    }),
    ...extraProps
  });
}
/* harmony default export */ const alignment_control_ui = (ui_AlignmentUI);
//# sourceMappingURL=ui.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/alignment-control/index.js
/**
 * Internal dependencies
 */


const AlignmentControl = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(alignment_control_ui, {
    ...props,
    isToolbar: false
  });
};
const AlignmentToolbar = props => {
  return /*#__PURE__*/_jsx(AlignmentUI, {
    ...props,
    isToolbar: true
  });
};

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/alignment-control/README.md
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/text-align.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const TEXT_ALIGN_SUPPORT_KEY = 'typography.textAlign';
const text_align_TEXT_ALIGNMENT_OPTIONS = [{
  icon: align_left,
  title: (0,i18n_build_module.__)('Align text left'),
  align: 'left'
}, {
  icon: align_center,
  title: (0,i18n_build_module.__)('Align text center'),
  align: 'center'
}, {
  icon: align_right,
  title: (0,i18n_build_module.__)('Align text right'),
  align: 'right'
}];
const VALID_TEXT_ALIGNMENTS = ['left', 'center', 'right'];
const NO_TEXT_ALIGNMENTS = [];

/**
 * Returns the valid text alignments.
 * Takes into consideration the text aligns supported by a block.
 * Exported just for testing purposes, not exported outside the module.
 *
 * @param {?boolean|string[]} blockTextAlign Text aligns supported by the block.
 *
 * @return {string[]} Valid text alignments.
 */
function getValidTextAlignments(blockTextAlign) {
  if (Array.isArray(blockTextAlign)) {
    return VALID_TEXT_ALIGNMENTS.filter(textAlign => blockTextAlign.includes(textAlign));
  }
  return blockTextAlign === true ? VALID_TEXT_ALIGNMENTS : NO_TEXT_ALIGNMENTS;
}
function BlockEditTextAlignmentToolbarControlsPure({
  style,
  name: blockName,
  setAttributes
}) {
  const settings = useBlockSettings(blockName);
  const hasTextAlignControl = settings?.typography?.textAlign;
  const blockEditingMode = useBlockEditingMode();
  if (!hasTextAlignControl || blockEditingMode !== 'default') {
    return null;
  }
  const validTextAlignments = getValidTextAlignments((0,build_module/* getBlockSupport */.bI)(blockName, TEXT_ALIGN_SUPPORT_KEY));
  if (!validTextAlignments.length) {
    return null;
  }
  const textAlignmentControls = text_align_TEXT_ALIGNMENT_OPTIONS.filter(control => validTextAlignments.includes(control.align));
  const onChange = newTextAlignValue => {
    const newStyle = {
      ...style,
      typography: {
        ...style?.typography,
        textAlign: newTextAlignValue
      }
    };
    setAttributes({
      style: utils_cleanEmptyObject(newStyle)
    });
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(block_controls, {
    group: "block",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(AlignmentControl, {
      value: style?.typography?.textAlign,
      onChange: onChange,
      alignmentControls: textAlignmentControls
    })
  });
}
/* harmony default export */ const text_align = ({
  edit: BlockEditTextAlignmentToolbarControlsPure,
  useBlockProps: text_align_useBlockProps,
  addSaveProps: addAssignedTextAlign,
  attributeKeys: ['style'],
  hasSupport(name) {
    return (0,build_module/* hasBlockSupport */.pN)(name, TEXT_ALIGN_SUPPORT_KEY, false);
  }
});
function text_align_useBlockProps({
  name,
  style
}) {
  if (!style?.typography?.textAlign) {
    return null;
  }
  const validTextAlignments = getValidTextAlignments((0,build_module/* getBlockSupport */.bI)(name, TEXT_ALIGN_SUPPORT_KEY));
  if (!validTextAlignments.length) {
    return null;
  }
  if (shouldSkipSerialization(name, TYPOGRAPHY_SUPPORT_KEY, 'textAlign')) {
    return null;
  }
  const textAlign = style.typography.textAlign;
  const className = (0,dist_clsx/* default */.A)({
    [`has-text-align-${textAlign}`]: textAlign
  });
  return {
    className
  };
}

/**
 * Override props assigned to save component to inject text alignment class
 * name if block supports it.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */
function addAssignedTextAlign(props, blockType, attributes) {
  if (!attributes?.style?.typography?.textAlign) {
    return props;
  }
  const {
    textAlign
  } = attributes.style.typography;
  const blockTextAlign = (0,build_module/* getBlockSupport */.bI)(blockType, TEXT_ALIGN_SUPPORT_KEY);
  const isTextAlignValid = getValidTextAlignments(blockTextAlign).includes(textAlign);
  if (isTextAlignValid && !shouldSkipSerialization(blockType, TYPOGRAPHY_SUPPORT_KEY, 'textAlign')) {
    props.className = (0,dist_clsx/* default */.A)(`has-text-align-${textAlign}`, props.className);
  }
  return props;
}
//# sourceMappingURL=text-align.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/typography.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */









function omit(object, keys) {
  return Object.fromEntries(Object.entries(object).filter(([key]) => !keys.includes(key)));
}
const LETTER_SPACING_SUPPORT_KEY = 'typography.__experimentalLetterSpacing';
const TEXT_TRANSFORM_SUPPORT_KEY = 'typography.__experimentalTextTransform';
const TEXT_DECORATION_SUPPORT_KEY = 'typography.__experimentalTextDecoration';
const TEXT_COLUMNS_SUPPORT_KEY = 'typography.textColumns';
const FONT_STYLE_SUPPORT_KEY = 'typography.__experimentalFontStyle';
const FONT_WEIGHT_SUPPORT_KEY = 'typography.__experimentalFontWeight';
const WRITING_MODE_SUPPORT_KEY = 'typography.__experimentalWritingMode';
const TYPOGRAPHY_SUPPORT_KEY = 'typography';
const TYPOGRAPHY_SUPPORT_KEYS = [LINE_HEIGHT_SUPPORT_KEY, FONT_SIZE_SUPPORT_KEY, FONT_STYLE_SUPPORT_KEY, FONT_WEIGHT_SUPPORT_KEY, FONT_FAMILY_SUPPORT_KEY, TEXT_ALIGN_SUPPORT_KEY, TEXT_COLUMNS_SUPPORT_KEY, TEXT_DECORATION_SUPPORT_KEY, WRITING_MODE_SUPPORT_KEY, TEXT_TRANSFORM_SUPPORT_KEY, LETTER_SPACING_SUPPORT_KEY];
function typography_styleToAttributes(style) {
  const updatedStyle = {
    ...omit(style, ['fontFamily'])
  };
  const fontSizeValue = style?.typography?.fontSize;
  const fontFamilyValue = style?.typography?.fontFamily;
  const fontSizeSlug = fontSizeValue?.startsWith('var:preset|font-size|') ? fontSizeValue.substring('var:preset|font-size|'.length) : undefined;
  const fontFamilySlug = fontFamilyValue?.startsWith('var:preset|font-family|') ? fontFamilyValue.substring('var:preset|font-family|'.length) : undefined;
  updatedStyle.typography = {
    ...omit(updatedStyle.typography, ['fontFamily']),
    fontSize: fontSizeSlug ? undefined : fontSizeValue
  };
  return {
    style: utils_cleanEmptyObject(updatedStyle),
    fontFamily: fontFamilySlug,
    fontSize: fontSizeSlug
  };
}
function typography_attributesToStyle(attributes) {
  return {
    ...attributes.style,
    typography: {
      ...attributes.style?.typography,
      fontFamily: attributes.fontFamily ? 'var:preset|font-family|' + attributes.fontFamily : undefined,
      fontSize: attributes.fontSize ? 'var:preset|font-size|' + attributes.fontSize : attributes.style?.typography?.fontSize
    }
  };
}
function TypographyInspectorControl({
  children,
  resetAllFilter
}) {
  const attributesResetAllFilter = (0,react.useCallback)(attributes => {
    const existingStyle = typography_attributesToStyle(attributes);
    const updatedStyle = resetAllFilter(existingStyle);
    return {
      ...attributes,
      ...typography_styleToAttributes(updatedStyle)
    };
  }, [resetAllFilter]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
    group: "typography",
    resetAllFilter: attributesResetAllFilter,
    children: children
  });
}
function typography_TypographyPanel({
  clientId,
  name,
  setAttributes,
  settings
}) {
  function selector(select) {
    const {
      style,
      fontFamily,
      fontSize
    } = select(store_store).getBlockAttributes(clientId) || {};
    return {
      style,
      fontFamily,
      fontSize
    };
  }
  const {
    style,
    fontFamily,
    fontSize
  } = (0,use_select/* default */.A)(selector, [clientId]);
  const isEnabled = useHasTypographyPanel(settings);
  const value = (0,react.useMemo)(() => typography_attributesToStyle({
    style,
    fontFamily,
    fontSize
  }), [style, fontSize, fontFamily]);
  const onChange = newStyle => {
    setAttributes(typography_styleToAttributes(newStyle));
  };
  if (!isEnabled) {
    return null;
  }
  const defaultControls = (0,build_module/* getBlockSupport */.bI)(name, [TYPOGRAPHY_SUPPORT_KEY, '__experimentalDefaultControls']);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(TypographyPanel, {
    as: TypographyInspectorControl,
    panelId: clientId,
    settings: settings,
    value: value,
    onChange: onChange,
    defaultControls: defaultControls
  });
}
const hasTypographySupport = blockName => {
  return TYPOGRAPHY_SUPPORT_KEYS.some(key => hasBlockSupport(blockName, key));
};
//# sourceMappingURL=typography.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/box-control/styles/box-control-icon-styles.js

function box_control_icon_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

const box_control_icon_styles_Root = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1j5nr4z8"
} : 0)( true ? {
  name: "1w884gc",
  styles: "box-sizing:border-box;display:block;width:24px;height:24px;position:relative;padding:4px"
} : 0);
const Viewbox = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1j5nr4z7"
} : 0)( true ? {
  name: "i6vjox",
  styles: "box-sizing:border-box;display:block;position:relative;width:100%;height:100%"
} : 0);
const strokeFocus = ({
  isFocused
}) => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    backgroundColor: 'currentColor',
    opacity: isFocused ? 1 : 0.3
  },  true ? "" : 0,  true ? "" : 0);
};
const Stroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1j5nr4z6"
} : 0)("box-sizing:border-box;display:block;pointer-events:none;position:absolute;", strokeFocus, ";" + ( true ? "" : 0));
const VerticalStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(Stroke,  true ? {
  target: "e1j5nr4z5"
} : 0)( true ? {
  name: "1k2w39q",
  styles: "bottom:3px;top:3px;width:2px"
} : 0);
const HorizontalStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(Stroke,  true ? {
  target: "e1j5nr4z4"
} : 0)( true ? {
  name: "1q9b07k",
  styles: "height:2px;left:3px;right:3px"
} : 0);
const TopStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(HorizontalStroke,  true ? {
  target: "e1j5nr4z3"
} : 0)( true ? {
  name: "abcix4",
  styles: "top:0"
} : 0);
const RightStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(VerticalStroke,  true ? {
  target: "e1j5nr4z2"
} : 0)( true ? {
  name: "1wf8jf",
  styles: "right:0"
} : 0);
const BottomStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(HorizontalStroke,  true ? {
  target: "e1j5nr4z1"
} : 0)( true ? {
  name: "8tapst",
  styles: "bottom:0"
} : 0);
const LeftStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(VerticalStroke,  true ? {
  target: "e1j5nr4z0"
} : 0)( true ? {
  name: "1ode3cm",
  styles: "left:0"
} : 0);
//# sourceMappingURL=box-control-icon-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/box-control/icon.js
/**
 * Internal dependencies
 */




const BASE_ICON_SIZE = 24;
function BoxControlIcon({
  size = 24,
  side = 'all',
  sides,
  ...props
}) {
  const isSideDisabled = value => sides?.length && !sides.includes(value);
  const hasSide = value => {
    if (isSideDisabled(value)) {
      return false;
    }
    return side === 'all' || side === value;
  };
  const top = hasSide('top') || hasSide('vertical');
  const right = hasSide('right') || hasSide('horizontal');
  const bottom = hasSide('bottom') || hasSide('vertical');
  const left = hasSide('left') || hasSide('horizontal');

  // Simulates SVG Icon scaling.
  const scale = size / BASE_ICON_SIZE;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(box_control_icon_styles_Root, {
    style: {
      transform: `scale(${scale})`
    },
    ...props,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(Viewbox, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(TopStroke, {
        isFocused: top
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(RightStroke, {
        isFocused: right
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(BottomStroke, {
        isFocused: bottom
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(LeftStroke, {
        isFocused: left
      })]
    })
  });
}
//# sourceMappingURL=icon.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/box-control/styles/box-control-styles.js

function box_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */






const box_control_styles_StyledUnitControl = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(unit_control,  true ? {
  target: "e1jovhle5"
} : 0)( true ? {
  name: "1ejyr19",
  styles: "max-width:90px"
} : 0);
const InputWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(h_stack_component/* default */.A,  true ? {
  target: "e1jovhle4"
} : 0)( true ? {
  name: "1j1lmoi",
  styles: "grid-column:1/span 3"
} : 0);
const ResetButton = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(build_module_button/* default */.Ay,  true ? {
  target: "e1jovhle3"
} : 0)( true ? {
  name: "tkya7b",
  styles: "grid-area:1/2;justify-self:end"
} : 0);
const LinkedButtonWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1jovhle2"
} : 0)( true ? {
  name: "1dfa8al",
  styles: "grid-area:1/3;justify-self:end"
} : 0);
const FlexedBoxControlIcon = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(BoxControlIcon,  true ? {
  target: "e1jovhle1"
} : 0)( true ? {
  name: "ou8xsw",
  styles: "flex:0 0 auto"
} : 0);
const FlexedRangeControl = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(range_control,  true ? {
  target: "e1jovhle0"
} : 0)("width:100%;margin-inline-end:", (0,space/* space */.x)(2), ";" + ( true ? "" : 0));
//# sourceMappingURL=box-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/box-control/utils.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

const CUSTOM_VALUE_SETTINGS = {
  px: {
    max: 300,
    step: 1
  },
  '%': {
    max: 100,
    step: 1
  },
  vw: {
    max: 100,
    step: 1
  },
  vh: {
    max: 100,
    step: 1
  },
  em: {
    max: 10,
    step: 0.1
  },
  rm: {
    max: 10,
    step: 0.1
  },
  svw: {
    max: 100,
    step: 1
  },
  lvw: {
    max: 100,
    step: 1
  },
  dvw: {
    max: 100,
    step: 1
  },
  svh: {
    max: 100,
    step: 1
  },
  lvh: {
    max: 100,
    step: 1
  },
  dvh: {
    max: 100,
    step: 1
  },
  vi: {
    max: 100,
    step: 1
  },
  svi: {
    max: 100,
    step: 1
  },
  lvi: {
    max: 100,
    step: 1
  },
  dvi: {
    max: 100,
    step: 1
  },
  vb: {
    max: 100,
    step: 1
  },
  svb: {
    max: 100,
    step: 1
  },
  lvb: {
    max: 100,
    step: 1
  },
  dvb: {
    max: 100,
    step: 1
  },
  vmin: {
    max: 100,
    step: 1
  },
  svmin: {
    max: 100,
    step: 1
  },
  lvmin: {
    max: 100,
    step: 1
  },
  dvmin: {
    max: 100,
    step: 1
  },
  vmax: {
    max: 100,
    step: 1
  },
  svmax: {
    max: 100,
    step: 1
  },
  lvmax: {
    max: 100,
    step: 1
  },
  dvmax: {
    max: 100,
    step: 1
  }
};
const utils_LABELS = {
  all: (0,i18n_build_module.__)('All sides'),
  top: (0,i18n_build_module.__)('Top side'),
  bottom: (0,i18n_build_module.__)('Bottom side'),
  left: (0,i18n_build_module.__)('Left side'),
  right: (0,i18n_build_module.__)('Right side'),
  mixed: (0,i18n_build_module.__)('Mixed'),
  vertical: (0,i18n_build_module.__)('Top and bottom sides'),
  horizontal: (0,i18n_build_module.__)('Left and right sides')
};
const utils_DEFAULT_VALUES = {
  top: undefined,
  right: undefined,
  bottom: undefined,
  left: undefined
};
const utils_ALL_SIDES = ['top', 'right', 'bottom', 'left'];

/**
 * Gets an items with the most occurrence within an array
 * https://stackoverflow.com/a/20762713
 *
 * @param arr Array of items to check.
 * @return The item with the most occurrences.
 */
function box_control_utils_mode(arr) {
  return arr.sort((a, b) => arr.filter(v => v === a).length - arr.filter(v => v === b).length).pop();
}

/**
 * Gets the 'all' input value and unit from values data.
 *
 * @param values         Box values.
 * @param selectedUnits  Box units.
 * @param availableSides Available box sides to evaluate.
 *
 * @return A value + unit for the 'all' input.
 */
function utils_getAllValue(values = {}, selectedUnits, availableSides = utils_ALL_SIDES) {
  const sides = normalizeSides(availableSides);
  const parsedQuantitiesAndUnits = sides.map(side => parseQuantityAndUnitFromRawValue(values[side]));
  const allParsedQuantities = parsedQuantitiesAndUnits.map(value => {
    var _value$;
    return (_value$ = value[0]) !== null && _value$ !== void 0 ? _value$ : '';
  });
  const allParsedUnits = parsedQuantitiesAndUnits.map(value => value[1]);
  const commonQuantity = allParsedQuantities.every(v => v === allParsedQuantities[0]) ? allParsedQuantities[0] : '';

  /**
   * The typeof === 'number' check is important. On reset actions, the incoming value
   * may be null or an empty string.
   *
   * Also, the value may also be zero (0), which is considered a valid unit value.
   *
   * typeof === 'number' is more specific for these cases, rather than relying on a
   * simple truthy check.
   */
  let commonUnit;
  if (typeof commonQuantity === 'number') {
    commonUnit = box_control_utils_mode(allParsedUnits);
  } else {
    var _getAllUnitFallback;
    // Set meaningful unit selection if no commonQuantity and user has previously
    // selected units without assigning values while controls were unlinked.
    commonUnit = (_getAllUnitFallback = getAllUnitFallback(selectedUnits)) !== null && _getAllUnitFallback !== void 0 ? _getAllUnitFallback : box_control_utils_mode(allParsedUnits);
  }
  return [commonQuantity, commonUnit].join('');
}

/**
 * Determine the most common unit selection to use as a fallback option.
 *
 * @param selectedUnits Current unit selections for individual sides.
 * @return  Most common unit selection.
 */
function getAllUnitFallback(selectedUnits) {
  if (!selectedUnits || typeof selectedUnits !== 'object') {
    return undefined;
  }
  const filteredUnits = Object.values(selectedUnits).filter(Boolean);
  return box_control_utils_mode(filteredUnits);
}

/**
 * Checks to determine if values are mixed.
 *
 * @param values        Box values.
 * @param selectedUnits Box units.
 * @param sides         Available box sides to evaluate.
 *
 * @return Whether values are mixed.
 */
function utils_isValuesMixed(values = {}, selectedUnits, sides = utils_ALL_SIDES) {
  const allValue = utils_getAllValue(values, selectedUnits, sides);
  const isMixed = isNaN(parseFloat(allValue));
  return isMixed;
}

/**
 * Checks to determine if values are defined.
 *
 * @param values Box values.
 *
 * @return  Whether values are mixed.
 */
function utils_isValuesDefined(values) {
  return values !== undefined && Object.values(values).filter(
  // Switching units when input is empty causes values only
  // containing units. This gives false positive on mixed values
  // unless filtered.
  value => !!value && /\d/.test(value)).length > 0;
}

/**
 * Get initial selected side, factoring in whether the sides are linked,
 * and whether the vertical / horizontal directions are grouped via splitOnAxis.
 *
 * @param isLinked    Whether the box control's fields are linked.
 * @param splitOnAxis Whether splitting by horizontal or vertical axis.
 * @return The initial side.
 */
function getInitialSide(isLinked, splitOnAxis) {
  let initialSide = 'all';
  if (!isLinked) {
    initialSide = splitOnAxis ? 'vertical' : 'top';
  }
  return initialSide;
}

/**
 * Normalizes provided sides configuration to an array containing only top,
 * right, bottom and left. This essentially just maps `horizontal` or `vertical`
 * to their appropriate sides to facilitate correctly determining value for
 * all input control.
 *
 * @param sides Available sides for box control.
 * @return Normalized sides configuration.
 */
function normalizeSides(sides) {
  const filteredSides = [];
  if (!sides?.length) {
    return utils_ALL_SIDES;
  }
  if (sides.includes('vertical')) {
    filteredSides.push(...['top', 'bottom']);
  } else if (sides.includes('horizontal')) {
    filteredSides.push(...['left', 'right']);
  } else {
    const newSides = utils_ALL_SIDES.filter(side => sides.includes(side));
    filteredSides.push(...newSides);
  }
  return filteredSides;
}

/**
 * Applies a value to an object representing top, right, bottom and left sides
 * while taking into account any custom side configuration.
 *
 * @param currentValues The current values for each side.
 * @param newValue      The value to apply to the sides object.
 * @param sides         Array defining valid sides.
 *
 * @return Object containing the updated values for each side.
 */
function applyValueToSides(currentValues, newValue, sides) {
  const newValues = {
    ...currentValues
  };
  if (sides?.length) {
    sides.forEach(side => {
      if (side === 'vertical') {
        newValues.top = newValue;
        newValues.bottom = newValue;
      } else if (side === 'horizontal') {
        newValues.left = newValue;
        newValues.right = newValue;
      } else {
        newValues[side] = newValue;
      }
    });
  } else {
    utils_ALL_SIDES.forEach(side => newValues[side] = newValue);
  }
  return newValues;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/box-control/all-input-control.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */







const all_input_control_noop = () => {};
function all_input_control_AllInputControl({
  __next40pxDefaultSize,
  onChange = all_input_control_noop,
  onFocus = all_input_control_noop,
  values,
  sides,
  selectedUnits,
  setSelectedUnits,
  ...props
}) {
  var _CUSTOM_VALUE_SETTING, _CUSTOM_VALUE_SETTING2;
  const inputId = (0,use_instance_id/* default */.A)(all_input_control_AllInputControl, 'box-control-input-all');
  const allValue = utils_getAllValue(values, selectedUnits, sides);
  const hasValues = utils_isValuesDefined(values);
  const isMixed = hasValues && utils_isValuesMixed(values, selectedUnits, sides);
  const allPlaceholder = isMixed ? utils_LABELS.mixed : undefined;
  const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(allValue);
  const handleOnFocus = event => {
    onFocus(event, {
      side: 'all'
    });
  };
  const onValueChange = next => {
    const isNumeric = next !== undefined && !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    const nextValues = applyValueToSides(values, nextValue, sides);
    onChange(nextValues);
  };
  const sliderOnChange = next => {
    onValueChange(next !== undefined ? [next, parsedUnit].join('') : undefined);
  };

  // Set selected unit so it can be used as fallback by unlinked controls
  // when individual sides do not have a value containing a unit.
  const handleOnUnitChange = unit => {
    const newUnits = applyValueToSides(selectedUnits, unit, sides);
    setSelectedUnits(newUnits);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(box_control_styles_StyledUnitControl, {
      ...props,
      __next40pxDefaultSize: __next40pxDefaultSize,
      className: "component-box-control__unit-control",
      disableUnits: isMixed,
      id: inputId,
      isPressEnterToChange: true,
      value: allValue,
      onChange: onValueChange,
      onUnitChange: handleOnUnitChange,
      onFocus: handleOnFocus,
      placeholder: allPlaceholder,
      label: utils_LABELS.all,
      hideLabelFromVision: true
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(FlexedRangeControl, {
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: __next40pxDefaultSize,
      "aria-controls": inputId,
      label: utils_LABELS.all,
      hideLabelFromVision: true,
      onChange: sliderOnChange,
      min: 0,
      max: (_CUSTOM_VALUE_SETTING = CUSTOM_VALUE_SETTINGS[parsedUnit !== null && parsedUnit !== void 0 ? parsedUnit : 'px']?.max) !== null && _CUSTOM_VALUE_SETTING !== void 0 ? _CUSTOM_VALUE_SETTING : 10,
      step: (_CUSTOM_VALUE_SETTING2 = CUSTOM_VALUE_SETTINGS[parsedUnit !== null && parsedUnit !== void 0 ? parsedUnit : 'px']?.step) !== null && _CUSTOM_VALUE_SETTING2 !== void 0 ? _CUSTOM_VALUE_SETTING2 : 0.1,
      value: parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : 0,
      withInputField: false
    })]
  });
}
//# sourceMappingURL=all-input-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/box-control/input-controls.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */







const input_controls_noop = () => {};
function input_controls_BoxInputControls({
  __next40pxDefaultSize,
  onChange = input_controls_noop,
  onFocus = input_controls_noop,
  values,
  selectedUnits,
  setSelectedUnits,
  sides,
  ...props
}) {
  const generatedId = (0,use_instance_id/* default */.A)(input_controls_BoxInputControls, 'box-control-input');
  const createHandleOnFocus = side => event => {
    onFocus(event, {
      side
    });
  };
  const handleOnChange = nextValues => {
    onChange(nextValues);
  };
  const handleOnValueChange = (side, next, extra) => {
    const nextValues = {
      ...values
    };
    const isNumeric = next !== undefined && !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    nextValues[side] = nextValue;

    /**
     * Supports changing pair sides. For example, holding the ALT key
     * when changing the TOP will also update BOTTOM.
     */
    // @ts-expect-error - TODO: event.altKey is only present when the change event was
    // triggered by a keyboard event. Should this feature be implemented differently so
    // it also works with drag events?
    if (extra?.event.altKey) {
      switch (side) {
        case 'top':
          nextValues.bottom = nextValue;
          break;
        case 'bottom':
          nextValues.top = nextValue;
          break;
        case 'left':
          nextValues.right = nextValue;
          break;
        case 'right':
          nextValues.left = nextValue;
          break;
      }
    }
    handleOnChange(nextValues);
  };
  const createHandleOnUnitChange = side => next => {
    const newUnits = {
      ...selectedUnits
    };
    newUnits[side] = next;
    setSelectedUnits(newUnits);
  };

  // Filter sides if custom configuration provided, maintaining default order.
  const filteredSides = sides?.length ? utils_ALL_SIDES.filter(side => sides.includes(side)) : utils_ALL_SIDES;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: filteredSides.map(side => {
      var _CUSTOM_VALUE_SETTING, _CUSTOM_VALUE_SETTING2;
      const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(values[side]);
      const computedUnit = values[side] ? parsedUnit : selectedUnits[side];
      const inputId = [generatedId, side].join('-');
      return /*#__PURE__*/(0,jsx_runtime.jsxs)(InputWrapper, {
        expanded: true,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(FlexedBoxControlIcon, {
          side: side,
          sides: sides
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
          placement: "top-end",
          text: utils_LABELS[side],
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(box_control_styles_StyledUnitControl, {
            ...props,
            __next40pxDefaultSize: __next40pxDefaultSize,
            className: "component-box-control__unit-control",
            id: inputId,
            isPressEnterToChange: true,
            value: [parsedQuantity, computedUnit].join(''),
            onChange: (nextValue, extra) => handleOnValueChange(side, nextValue, extra),
            onUnitChange: createHandleOnUnitChange(side),
            onFocus: createHandleOnFocus(side),
            label: utils_LABELS[side],
            hideLabelFromVision: true
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FlexedRangeControl, {
          __nextHasNoMarginBottom: true,
          __next40pxDefaultSize: __next40pxDefaultSize,
          "aria-controls": inputId,
          label: utils_LABELS[side],
          hideLabelFromVision: true,
          onChange: newValue => {
            handleOnValueChange(side, newValue !== undefined ? [newValue, computedUnit].join('') : undefined);
          },
          min: 0,
          max: (_CUSTOM_VALUE_SETTING = CUSTOM_VALUE_SETTINGS[computedUnit !== null && computedUnit !== void 0 ? computedUnit : 'px']?.max) !== null && _CUSTOM_VALUE_SETTING !== void 0 ? _CUSTOM_VALUE_SETTING : 10,
          step: (_CUSTOM_VALUE_SETTING2 = CUSTOM_VALUE_SETTINGS[computedUnit !== null && computedUnit !== void 0 ? computedUnit : 'px']?.step) !== null && _CUSTOM_VALUE_SETTING2 !== void 0 ? _CUSTOM_VALUE_SETTING2 : 0.1,
          value: parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : 0,
          withInputField: false
        })]
      }, `box-control-${side}`);
    })
  });
}
//# sourceMappingURL=input-controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/box-control/axial-input-controls.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */








const groupedSides = ['vertical', 'horizontal'];
function AxialInputControls({
  __next40pxDefaultSize,
  onChange,
  onFocus,
  values,
  selectedUnits,
  setSelectedUnits,
  sides,
  ...props
}) {
  const generatedId = (0,use_instance_id/* default */.A)(AxialInputControls, `box-control-input`);
  const createHandleOnFocus = side => event => {
    if (!onFocus) {
      return;
    }
    onFocus(event, {
      side
    });
  };
  const handleOnValueChange = (side, next) => {
    if (!onChange) {
      return;
    }
    const nextValues = {
      ...values
    };
    const isNumeric = next !== undefined && !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    if (side === 'vertical') {
      nextValues.top = nextValue;
      nextValues.bottom = nextValue;
    }
    if (side === 'horizontal') {
      nextValues.left = nextValue;
      nextValues.right = nextValue;
    }
    onChange(nextValues);
  };
  const createHandleOnUnitChange = side => next => {
    const newUnits = {
      ...selectedUnits
    };
    if (side === 'vertical') {
      newUnits.top = next;
      newUnits.bottom = next;
    }
    if (side === 'horizontal') {
      newUnits.left = next;
      newUnits.right = next;
    }
    setSelectedUnits(newUnits);
  };

  // Filter sides if custom configuration provided, maintaining default order.
  const filteredSides = sides?.length ? groupedSides.filter(side => sides.includes(side)) : groupedSides;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: filteredSides.map(side => {
      var _CUSTOM_VALUE_SETTING, _CUSTOM_VALUE_SETTING2;
      const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(side === 'vertical' ? values.top : values.left);
      const selectedUnit = side === 'vertical' ? selectedUnits.top : selectedUnits.left;
      const inputId = [generatedId, side].join('-');
      return /*#__PURE__*/(0,jsx_runtime.jsxs)(InputWrapper, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(FlexedBoxControlIcon, {
          side: side,
          sides: sides
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
          placement: "top-end",
          text: utils_LABELS[side],
          children: /*#__PURE__*/(0,react.createElement)(box_control_styles_StyledUnitControl, {
            ...props,
            __next40pxDefaultSize: __next40pxDefaultSize,
            className: "component-box-control__unit-control",
            id: inputId,
            isPressEnterToChange: true,
            value: [parsedQuantity, selectedUnit !== null && selectedUnit !== void 0 ? selectedUnit : parsedUnit].join(''),
            onChange: newValue => handleOnValueChange(side, newValue),
            onUnitChange: createHandleOnUnitChange(side),
            onFocus: createHandleOnFocus(side),
            label: utils_LABELS[side],
            hideLabelFromVision: true,
            key: side
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FlexedRangeControl, {
          __nextHasNoMarginBottom: true,
          __next40pxDefaultSize: __next40pxDefaultSize,
          "aria-controls": inputId,
          label: utils_LABELS[side],
          hideLabelFromVision: true,
          onChange: newValue => handleOnValueChange(side, newValue !== undefined ? [newValue, selectedUnit !== null && selectedUnit !== void 0 ? selectedUnit : parsedUnit].join('') : undefined),
          min: 0,
          max: (_CUSTOM_VALUE_SETTING = CUSTOM_VALUE_SETTINGS[selectedUnit !== null && selectedUnit !== void 0 ? selectedUnit : 'px']?.max) !== null && _CUSTOM_VALUE_SETTING !== void 0 ? _CUSTOM_VALUE_SETTING : 10,
          step: (_CUSTOM_VALUE_SETTING2 = CUSTOM_VALUE_SETTINGS[selectedUnit !== null && selectedUnit !== void 0 ? selectedUnit : 'px']?.step) !== null && _CUSTOM_VALUE_SETTING2 !== void 0 ? _CUSTOM_VALUE_SETTING2 : 0.1,
          value: parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : 0,
          withInputField: false
        })]
      }, side);
    })
  });
}
//# sourceMappingURL=axial-input-controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/box-control/linked-button.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function linked_button_LinkedButton({
  isLinked,
  ...props
}) {
  const label = isLinked ? (0,i18n_build_module.__)('Unlink sides') : (0,i18n_build_module.__)('Link sides');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
    text: label,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      ...props,
      className: "component-box-control__linked-button",
      size: "small",
      icon: isLinked ? library_link : link_off,
      iconSize: 24,
      "aria-label": label
    })
  });
}
//# sourceMappingURL=linked-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/box-control/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */












const defaultInputProps = {
  min: 0
};
const box_control_noop = () => {};
function useUniqueId(idProp) {
  const instanceId = (0,use_instance_id/* default */.A)(BoxControl, 'inspector-box-control');
  return idProp || instanceId;
}

/**
 * BoxControl components let users set values for Top, Right, Bottom, and Left.
 * This can be used as an input control for values like `padding` or `margin`.
 *
 * ```jsx
 * import { __experimentalBoxControl as BoxControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const Example = () => {
 * 	const [ values, setValues ] = useState( {
 * 		top: '50px',
 * 		left: '10%',
 * 		right: '10%',
 * 		bottom: '50px',
 * 	} );
 *
 * 	return (
 * 		<BoxControl
 * 			values={ values }
 * 			onChange={ ( nextValues ) => setValues( nextValues ) }
 * 		/>
 * 	);
 * };
 * ```
 */
function BoxControl({
  __next40pxDefaultSize = false,
  id: idProp,
  inputProps = defaultInputProps,
  onChange = box_control_noop,
  label = (0,i18n_build_module.__)('Box Control'),
  values: valuesProp,
  units,
  sides,
  splitOnAxis = false,
  allowReset = true,
  resetValues = utils_DEFAULT_VALUES,
  onMouseOver,
  onMouseOut
}) {
  const [values, setValues] = use_controlled_state(valuesProp, {
    fallback: utils_DEFAULT_VALUES
  });
  const inputValues = values || utils_DEFAULT_VALUES;
  const hasInitialValue = utils_isValuesDefined(valuesProp);
  const hasOneSide = sides?.length === 1;
  const [isDirty, setIsDirty] = (0,react.useState)(hasInitialValue);
  const [isLinked, setIsLinked] = (0,react.useState)(!hasInitialValue || !utils_isValuesMixed(inputValues) || hasOneSide);
  const [side, setSide] = (0,react.useState)(getInitialSide(isLinked, splitOnAxis));

  // Tracking selected units via internal state allows filtering of CSS unit
  // only values from being saved while maintaining preexisting unit selection
  // behaviour. Filtering CSS only values prevents invalid style values.
  const [selectedUnits, setSelectedUnits] = (0,react.useState)({
    top: parseQuantityAndUnitFromRawValue(valuesProp?.top)[1],
    right: parseQuantityAndUnitFromRawValue(valuesProp?.right)[1],
    bottom: parseQuantityAndUnitFromRawValue(valuesProp?.bottom)[1],
    left: parseQuantityAndUnitFromRawValue(valuesProp?.left)[1]
  });
  const id = useUniqueId(idProp);
  const headingId = `${id}-heading`;
  const toggleLinked = () => {
    setIsLinked(!isLinked);
    setSide(getInitialSide(!isLinked, splitOnAxis));
  };
  const handleOnFocus = (_event, {
    side: nextSide
  }) => {
    setSide(nextSide);
  };
  const handleOnChange = nextValues => {
    onChange(nextValues);
    setValues(nextValues);
    setIsDirty(true);
  };
  const handleOnReset = () => {
    onChange(resetValues);
    setValues(resetValues);
    setSelectedUnits(resetValues);
    setIsDirty(false);
  };
  const inputControlProps = {
    ...inputProps,
    onChange: handleOnChange,
    onFocus: handleOnFocus,
    isLinked,
    units,
    selectedUnits,
    setSelectedUnits,
    sides,
    values: inputValues,
    onMouseOver,
    onMouseOut,
    __next40pxDefaultSize
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(grid_component, {
    id: id,
    columns: 3,
    templateColumns: "1fr min-content min-content",
    role: "group",
    "aria-labelledby": headingId,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* BaseControl */.pu.VisualLabel, {
      id: headingId,
      children: label
    }), isLinked && /*#__PURE__*/(0,jsx_runtime.jsxs)(InputWrapper, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(FlexedBoxControlIcon, {
        side: side,
        sides: sides
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(all_input_control_AllInputControl, {
        ...inputControlProps
      })]
    }), !hasOneSide && /*#__PURE__*/(0,jsx_runtime.jsx)(LinkedButtonWrapper, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(linked_button_LinkedButton, {
        onClick: toggleLinked,
        isLinked: isLinked
      })
    }), !isLinked && splitOnAxis && /*#__PURE__*/(0,jsx_runtime.jsx)(AxialInputControls, {
      ...inputControlProps
    }), !isLinked && !splitOnAxis && /*#__PURE__*/(0,jsx_runtime.jsx)(input_controls_BoxInputControls, {
      ...inputControlProps
    }), allowReset && /*#__PURE__*/(0,jsx_runtime.jsx)(ResetButton, {
      className: "component-box-control__reset-button",
      variant: "secondary",
      size: "small",
      onClick: handleOnReset,
      disabled: !isDirty,
      children: (0,i18n_build_module.__)('Reset')
    })]
  });
}

/* harmony default export */ const box_control = (BoxControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/spacing-input-control.js
/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */






const spacing_input_control_CUSTOM_VALUE_SETTINGS = {
  px: {
    max: 300,
    steps: 1
  },
  '%': {
    max: 100,
    steps: 1
  },
  vw: {
    max: 100,
    steps: 1
  },
  vh: {
    max: 100,
    steps: 1
  },
  em: {
    max: 10,
    steps: 0.1
  },
  rm: {
    max: 10,
    steps: 0.1
  },
  svw: {
    max: 100,
    steps: 1
  },
  lvw: {
    max: 100,
    steps: 1
  },
  dvw: {
    max: 100,
    steps: 1
  },
  svh: {
    max: 100,
    steps: 1
  },
  lvh: {
    max: 100,
    steps: 1
  },
  dvh: {
    max: 100,
    steps: 1
  },
  vi: {
    max: 100,
    steps: 1
  },
  svi: {
    max: 100,
    steps: 1
  },
  lvi: {
    max: 100,
    steps: 1
  },
  dvi: {
    max: 100,
    steps: 1
  },
  vb: {
    max: 100,
    steps: 1
  },
  svb: {
    max: 100,
    steps: 1
  },
  lvb: {
    max: 100,
    steps: 1
  },
  dvb: {
    max: 100,
    steps: 1
  },
  vmin: {
    max: 100,
    steps: 1
  },
  svmin: {
    max: 100,
    steps: 1
  },
  lvmin: {
    max: 100,
    steps: 1
  },
  dvmin: {
    max: 100,
    steps: 1
  },
  vmax: {
    max: 100,
    steps: 1
  },
  svmax: {
    max: 100,
    steps: 1
  },
  lvmax: {
    max: 100,
    steps: 1
  },
  dvmax: {
    max: 100,
    steps: 1
  }
};
function SpacingInputControl({
  icon,
  isMixed = false,
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  showSideInLabel = true,
  side,
  spacingSizes,
  type,
  value
}) {
  var _CUSTOM_VALUE_SETTING, _CUSTOM_VALUE_SETTING2;
  // Treat value as a preset value if the passed in value matches the value of one of the spacingSizes.
  value = getPresetValueFromCustomValue(value, spacingSizes);
  let selectListSizes = spacingSizes;
  const showRangeControl = spacingSizes.length <= RANGE_CONTROL_MAX_SIZE;
  const disableCustomSpacingSizes = (0,use_select/* default */.A)(select => {
    const editorSettings = select(store_store).getSettings();
    return editorSettings?.disableCustomSpacingSizes;
  });
  const [showCustomValueControl, setShowCustomValueControl] = (0,react.useState)(!disableCustomSpacingSizes && value !== undefined && !isValueSpacingPreset(value));
  const [minValue, setMinValue] = (0,react.useState)(minimumCustomValue);
  const previousValue = (0,use_previous/* default */.A)(value);
  if (!!value && previousValue !== value && !isValueSpacingPreset(value) && showCustomValueControl !== true) {
    setShowCustomValueControl(true);
  }
  const [availableUnits] = use_settings_useSettings('spacing.units');
  const units = useCustomUnits({
    availableUnits: availableUnits || ['px', 'em', 'rem']
  });
  let currentValue = null;
  const showCustomValueInSelectList = !showRangeControl && !showCustomValueControl && value !== undefined && (!isValueSpacingPreset(value) || isValueSpacingPreset(value) && isMixed);
  if (showCustomValueInSelectList) {
    selectListSizes = [...spacingSizes, {
      name: !isMixed ?
      // translators: A custom measurement, eg. a number followed by a unit like 12px.
      (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Custom (%s)'), value) : (0,i18n_build_module.__)('Mixed'),
      slug: 'custom',
      size: value
    }];
    currentValue = selectListSizes.length - 1;
  } else if (!isMixed) {
    currentValue = !showCustomValueControl ? getSliderValueFromPreset(value, spacingSizes) : getCustomValueFromPreset(value, spacingSizes);
  }
  const selectedUnit = (0,react.useMemo)(() => parseQuantityAndUnitFromRawValue(currentValue), [currentValue])[1] || units[0]?.value;
  const setInitialValue = () => {
    if (value === undefined) {
      onChange('0');
    }
  };
  const customTooltipContent = newValue => value === undefined ? undefined : spacingSizes[newValue]?.name;
  const customRangeValue = parseFloat(currentValue, 10);
  const getNewCustomValue = newSize => {
    const isNumeric = !isNaN(parseFloat(newSize));
    const nextValue = isNumeric ? newSize : undefined;
    return nextValue;
  };
  const getNewPresetValue = (newSize, controlType) => {
    const size = parseInt(newSize, 10);
    if (controlType === 'selectList') {
      if (size === 0) {
        return undefined;
      }
      if (size === 1) {
        return '0';
      }
    } else if (size === 0) {
      return '0';
    }
    return `var:preset|spacing|${spacingSizes[newSize]?.slug}`;
  };
  const handleCustomValueSliderChange = next => {
    onChange([next, selectedUnit].join(''));
  };
  const allPlaceholder = isMixed ? (0,i18n_build_module.__)('Mixed') : null;
  const options = selectListSizes.map((size, index) => ({
    key: index,
    name: size.name
  }));
  const marks = spacingSizes.map((_newValue, index) => ({
    value: index,
    label: undefined
  }));
  const sideLabel = ALL_SIDES.includes(side) && showSideInLabel ? LABELS[side] : '';
  const typeLabel = showSideInLabel ? type?.toLowerCase() : type;
  const ariaLabel = (0,i18n_build_module/* sprintf */.nv)(
  // translators: 1: The side of the block being modified (top, bottom, left, All sides etc.). 2. Type of spacing being modified (Padding, margin, etc)
  (0,i18n_build_module.__)('%1$s %2$s'), sideLabel, typeLabel).trim();
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
    className: "spacing-sizes-control__wrapper",
    children: [icon && /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
      className: "spacing-sizes-control__icon",
      icon: icon,
      size: 24
    }), showCustomValueControl && /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
        onMouseOver: onMouseOver,
        onMouseOut: onMouseOut,
        onFocus: onMouseOver,
        onBlur: onMouseOut,
        onChange: newSize => onChange(getNewCustomValue(newSize)),
        value: currentValue,
        units: units,
        min: minValue,
        placeholder: allPlaceholder,
        disableUnits: isMixed,
        label: ariaLabel,
        hideLabelFromVision: true,
        className: "spacing-sizes-control__custom-value-input",
        size: "__unstable-large",
        onDragStart: () => {
          if (value?.charAt(0) === '-') {
            setMinValue(0);
          }
        },
        onDrag: () => {
          if (value?.charAt(0) === '-') {
            setMinValue(0);
          }
        },
        onDragEnd: () => {
          setMinValue(minimumCustomValue);
        }
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(range_control, {
        onMouseOver: onMouseOver,
        onMouseOut: onMouseOut,
        onFocus: onMouseOver,
        onBlur: onMouseOut,
        value: customRangeValue,
        min: 0,
        max: (_CUSTOM_VALUE_SETTING = spacing_input_control_CUSTOM_VALUE_SETTINGS[selectedUnit]?.max) !== null && _CUSTOM_VALUE_SETTING !== void 0 ? _CUSTOM_VALUE_SETTING : 10,
        step: (_CUSTOM_VALUE_SETTING2 = spacing_input_control_CUSTOM_VALUE_SETTINGS[selectedUnit]?.steps) !== null && _CUSTOM_VALUE_SETTING2 !== void 0 ? _CUSTOM_VALUE_SETTING2 : 0.1,
        withInputField: false,
        onChange: handleCustomValueSliderChange,
        className: "spacing-sizes-control__custom-value-range",
        __nextHasNoMarginBottom: true
      })]
    }), showRangeControl && !showCustomValueControl && /*#__PURE__*/(0,jsx_runtime.jsx)(range_control, {
      onMouseOver: onMouseOver,
      onMouseOut: onMouseOut,
      className: "spacing-sizes-control__range-control",
      value: currentValue,
      onChange: newSize => onChange(getNewPresetValue(newSize)),
      onMouseDown: event => {
        // If mouse down is near start of range set initial value to 0, which
        // prevents the user have to drag right then left to get 0 setting.
        if (event?.nativeEvent?.offsetX < 35) {
          setInitialValue();
        }
      },
      withInputField: false,
      "aria-valuenow": currentValue,
      "aria-valuetext": spacingSizes[currentValue]?.name,
      renderTooltipContent: customTooltipContent,
      min: 0,
      max: spacingSizes.length - 1,
      marks: marks,
      label: ariaLabel,
      hideLabelFromVision: true,
      __nextHasNoMarginBottom: true,
      onFocus: onMouseOver,
      onBlur: onMouseOut
    }), !showRangeControl && !showCustomValueControl && /*#__PURE__*/(0,jsx_runtime.jsx)(StableCustomSelectControl, {
      className: "spacing-sizes-control__custom-select-control",
      value: options.find(option => option.key === currentValue) || '' // passing undefined here causes a downshift controlled/uncontrolled warning
      ,
      onChange: selection => {
        onChange(getNewPresetValue(selection.selectedItem.key, 'selectList'));
      },
      options: options,
      label: ariaLabel,
      hideLabelFromVision: true,
      size: "__unstable-large",
      onMouseOver: onMouseOver,
      onMouseOut: onMouseOut,
      onFocus: onMouseOver,
      onBlur: onMouseOut
    }), !disableCustomSpacingSizes && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      label: showCustomValueControl ? (0,i18n_build_module.__)('Use size preset') : (0,i18n_build_module.__)('Set custom size'),
      icon: library_settings,
      onClick: () => {
        setShowCustomValueControl(!showCustomValueControl);
      },
      isPressed: showCustomValueControl,
      size: "small",
      className: "spacing-sizes-control__custom-toggle",
      iconSize: 24
    })]
  });
}
//# sourceMappingURL=spacing-input-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/axial.js
/**
 * Internal dependencies
 */




const axial_groupedSides = ['vertical', 'horizontal'];
function axial_AxialInputControls({
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  sides,
  spacingSizes,
  type,
  values
}) {
  const createHandleOnChange = side => next => {
    if (!onChange) {
      return;
    }

    // Encode the existing value into the preset value if the passed in value matches the value of one of the spacingSizes.
    const nextValues = {
      ...Object.keys(values).reduce((acc, key) => {
        acc[key] = getPresetValueFromCustomValue(values[key], spacingSizes);
        return acc;
      }, {})
    };
    if (side === 'vertical') {
      nextValues.top = next;
      nextValues.bottom = next;
    }
    if (side === 'horizontal') {
      nextValues.left = next;
      nextValues.right = next;
    }
    onChange(nextValues);
  };

  // Filter sides if custom configuration provided, maintaining default order.
  const filteredSides = sides?.length ? axial_groupedSides.filter(side => hasAxisSupport(sides, side)) : axial_groupedSides;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: filteredSides.map(side => {
      const axisValue = side === 'vertical' ? values.top : values.left;
      return /*#__PURE__*/(0,jsx_runtime.jsx)(SpacingInputControl, {
        icon: ICONS[side],
        label: LABELS[side],
        minimumCustomValue: minimumCustomValue,
        onChange: createHandleOnChange(side),
        onMouseOut: onMouseOut,
        onMouseOver: onMouseOver,
        side: side,
        spacingSizes: spacingSizes,
        type: type,
        value: axisValue,
        withInputField: false
      }, `spacing-sizes-control-${side}`);
    })
  });
}
//# sourceMappingURL=axial.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/separated.js
/**
 * Internal dependencies
 */




function SeparatedInputControls({
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  sides,
  spacingSizes,
  type,
  values
}) {
  // Filter sides if custom configuration provided, maintaining default order.
  const filteredSides = sides?.length ? ALL_SIDES.filter(side => sides.includes(side)) : ALL_SIDES;
  const createHandleOnChange = side => next => {
    // Encode the existing value into the preset value if the passed in value matches the value of one of the spacingSizes.
    const nextValues = {
      ...Object.keys(values).reduce((acc, key) => {
        acc[key] = getPresetValueFromCustomValue(values[key], spacingSizes);
        return acc;
      }, {})
    };
    nextValues[side] = next;
    onChange(nextValues);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: filteredSides.map(side => {
      return /*#__PURE__*/(0,jsx_runtime.jsx)(SpacingInputControl, {
        icon: ICONS[side],
        label: LABELS[side],
        minimumCustomValue: minimumCustomValue,
        onChange: createHandleOnChange(side),
        onMouseOut: onMouseOut,
        onMouseOver: onMouseOver,
        side: side,
        spacingSizes: spacingSizes,
        type: type,
        value: values[side],
        withInputField: false
      }, `spacing-sizes-control-${side}`);
    })
  });
}
//# sourceMappingURL=separated.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/single.js
/**
 * Internal dependencies
 */



function SingleInputControl({
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  showSideInLabel,
  side,
  spacingSizes,
  type,
  values
}) {
  const createHandleOnChange = currentSide => next => {
    // Encode the existing value into the preset value if the passed in value matches the value of one of the spacingSizes.
    const nextValues = {
      ...Object.keys(values).reduce((acc, key) => {
        acc[key] = getPresetValueFromCustomValue(values[key], spacingSizes);
        return acc;
      }, {})
    };
    nextValues[currentSide] = next;
    onChange(nextValues);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(SpacingInputControl, {
    label: LABELS[side],
    minimumCustomValue: minimumCustomValue,
    onChange: createHandleOnChange(side),
    onMouseOut: onMouseOut,
    onMouseOver: onMouseOver,
    showSideInLabel: showSideInLabel,
    side: side,
    spacingSizes: spacingSizes,
    type: type,
    value: values[side],
    withInputField: false
  });
}
//# sourceMappingURL=single.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/sides-dropdown/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const checkIcon = /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
  icon: check/* default */.A,
  size: 24
});
function SidesDropdown({
  label: labelProp,
  onChange,
  sides,
  value
}) {
  if (!sides || !sides.length) {
    return;
  }
  const supportedItems = getSupportedMenuItems(sides);
  const sideIcon = supportedItems[value].icon;
  const {
    custom: customItem,
    ...menuItems
  } = supportedItems;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_menu/* default */.A, {
    icon: sideIcon,
    label: labelProp,
    className: "spacing-sizes-control__dropdown",
    toggleProps: {
      size: 'small'
    },
    children: ({
      onClose
    }) => {
      return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
          children: Object.entries(menuItems).map(([slug, {
            label,
            icon
          }]) => {
            const isSelected = value === slug;
            return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
              icon: icon,
              iconPosition: "left",
              isSelected: isSelected,
              role: "menuitemradio",
              onClick: () => {
                onChange(slug);
                onClose();
              },
              suffix: isSelected ? checkIcon : undefined,
              children: label
            }, slug);
          })
        }), !!customItem && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
            icon: customItem.icon,
            iconPosition: "left",
            isSelected: value === VIEWS.custom,
            role: "menuitemradio",
            onClick: () => {
              onChange(VIEWS.custom);
              onClose();
            },
            suffix: value === VIEWS.custom ? checkIcon : undefined,
            children: customItem.label
          })
        })]
      });
    }
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/hooks/use-spacing-sizes.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const use_spacing_sizes_EMPTY_ARRAY = [];
const compare = new Intl.Collator('und', {
  numeric: true
}).compare;
function useSpacingSizes() {
  const [customSpacingSizes, themeSpacingSizes, defaultSpacingSizes, defaultSpacingSizesEnabled] = use_settings_useSettings('spacing.spacingSizes.custom', 'spacing.spacingSizes.theme', 'spacing.spacingSizes.default', 'spacing.defaultSpacingSizes');
  const customSizes = customSpacingSizes !== null && customSpacingSizes !== void 0 ? customSpacingSizes : use_spacing_sizes_EMPTY_ARRAY;
  const themeSizes = themeSpacingSizes !== null && themeSpacingSizes !== void 0 ? themeSpacingSizes : use_spacing_sizes_EMPTY_ARRAY;
  const defaultSizes = defaultSpacingSizes && defaultSpacingSizesEnabled !== false ? defaultSpacingSizes : use_spacing_sizes_EMPTY_ARRAY;
  return (0,react.useMemo)(() => {
    const sizes = [{
      name: (0,i18n_build_module.__)('None'),
      slug: '0',
      size: 0
    }, ...customSizes, ...themeSizes, ...defaultSizes];

    // Using numeric slugs opts-in to sorting by slug.
    if (sizes.every(({
      slug
    }) => /^[0-9]/.test(slug))) {
      sizes.sort((a, b) => compare(a.slug, b.slug));
    }
    return sizes.length > RANGE_CONTROL_MAX_SIZE ? [{
      name: (0,i18n_build_module.__)('Default'),
      slug: 'default',
      size: undefined
    }, ...sizes] : sizes;
  }, [customSizes, themeSizes, defaultSizes]);
}
//# sourceMappingURL=use-spacing-sizes.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */








function SpacingSizesControl({
  inputProps,
  label: labelProp,
  minimumCustomValue = 0,
  onChange,
  onMouseOut,
  onMouseOver,
  showSideInLabel = true,
  sides = ALL_SIDES,
  useSelect,
  values
}) {
  const spacingSizes = useSpacingSizes();
  const inputValues = values || DEFAULT_VALUES;
  const hasOneSide = sides?.length === 1;
  const hasOnlyAxialSides = sides?.includes('horizontal') && sides?.includes('vertical') && sides?.length === 2;
  const [view, setView] = (0,react.useState)(getInitialView(inputValues, sides));
  const handleOnChange = nextValue => {
    const newValues = {
      ...values,
      ...nextValue
    };
    onChange(newValues);
  };
  const inputControlProps = {
    ...inputProps,
    minimumCustomValue,
    onChange: handleOnChange,
    onMouseOut,
    onMouseOver,
    sides,
    spacingSizes,
    type: labelProp,
    useSelect,
    values: inputValues
  };
  const renderControls = () => {
    if (view === VIEWS.axial) {
      return /*#__PURE__*/(0,jsx_runtime.jsx)(axial_AxialInputControls, {
        ...inputControlProps
      });
    }
    if (view === VIEWS.custom) {
      return /*#__PURE__*/(0,jsx_runtime.jsx)(SeparatedInputControls, {
        ...inputControlProps
      });
    }
    return /*#__PURE__*/(0,jsx_runtime.jsx)(SingleInputControl, {
      side: view,
      ...inputControlProps,
      showSideInLabel: showSideInLabel
    });
  };
  const sideLabel = ALL_SIDES.includes(view) && showSideInLabel ? LABELS[view] : '';
  const label = (0,i18n_build_module/* sprintf */.nv)(
  // translators: 2. Type of spacing being modified (Padding, margin, etc). 1: The side of the block being modified (top, bottom, left etc.).
  (0,i18n_build_module.__)('%1$s %2$s'), labelProp, sideLabel).trim();
  const dropdownLabelText = (0,i18n_build_module/* sprintf */.nv)(
  // translators: %s: The current spacing property e.g. "Padding", "Margin".
  (0,i18n_build_module._x)('%s options', 'Button label to reveal side configuration options'), labelProp);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {
    className: "spacing-sizes-control",
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
      className: "spacing-sizes-control__header",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
        as: "legend",
        className: "spacing-sizes-control__label",
        children: label
      }), !hasOneSide && !hasOnlyAxialSides && /*#__PURE__*/(0,jsx_runtime.jsx)(SidesDropdown, {
        label: dropdownLabelText,
        onChange: setView,
        sides: sides,
        value: view
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(v_stack_component/* default */.A, {
      spacing: 0.5,
      children: renderControls()
    })]
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/height-control/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const RANGE_CONTROL_CUSTOM_SETTINGS = {
  px: {
    max: 1000,
    step: 1
  },
  '%': {
    max: 100,
    step: 1
  },
  vw: {
    max: 100,
    step: 1
  },
  vh: {
    max: 100,
    step: 1
  },
  em: {
    max: 50,
    step: 0.1
  },
  rem: {
    max: 50,
    step: 0.1
  },
  svw: {
    max: 100,
    step: 1
  },
  lvw: {
    max: 100,
    step: 1
  },
  dvw: {
    max: 100,
    step: 1
  },
  svh: {
    max: 100,
    step: 1
  },
  lvh: {
    max: 100,
    step: 1
  },
  dvh: {
    max: 100,
    step: 1
  },
  vi: {
    max: 100,
    step: 1
  },
  svi: {
    max: 100,
    step: 1
  },
  lvi: {
    max: 100,
    step: 1
  },
  dvi: {
    max: 100,
    step: 1
  },
  vb: {
    max: 100,
    step: 1
  },
  svb: {
    max: 100,
    step: 1
  },
  lvb: {
    max: 100,
    step: 1
  },
  dvb: {
    max: 100,
    step: 1
  },
  vmin: {
    max: 100,
    step: 1
  },
  svmin: {
    max: 100,
    step: 1
  },
  lvmin: {
    max: 100,
    step: 1
  },
  dvmin: {
    max: 100,
    step: 1
  },
  vmax: {
    max: 100,
    step: 1
  },
  svmax: {
    max: 100,
    step: 1
  },
  lvmax: {
    max: 100,
    step: 1
  },
  dvmax: {
    max: 100,
    step: 1
  }
};

/**
 * HeightControl renders a linked unit control and range control for adjusting the height of a block.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/height-control/README.md
 *
 * @param {Object}                     props
 * @param {?string}                    props.label    A label for the control.
 * @param {( value: string ) => void } props.onChange Called when the height changes.
 * @param {string}                     props.value    The current height value.
 *
 * @return {Component} The component to be rendered.
 */
function HeightControl({
  label = (0,i18n_build_module.__)('Height'),
  onChange,
  value
}) {
  var _RANGE_CONTROL_CUSTOM, _RANGE_CONTROL_CUSTOM2;
  const customRangeValue = parseFloat(value);
  const [availableUnits] = use_settings_useSettings('spacing.units');
  const units = useCustomUnits({
    availableUnits: availableUnits || ['%', 'px', 'em', 'rem', 'vh', 'vw']
  });
  const selectedUnit = (0,react.useMemo)(() => parseQuantityAndUnitFromRawValue(value), [value])[1] || units[0]?.value || 'px';
  const handleSliderChange = next => {
    onChange([next, selectedUnit].join(''));
  };
  const handleUnitChange = newUnit => {
    // Attempt to smooth over differences between currentUnit and newUnit.
    // This should slightly improve the experience of switching between unit types.
    const [currentValue, currentUnit] = parseQuantityAndUnitFromRawValue(value);
    if (['em', 'rem'].includes(newUnit) && currentUnit === 'px') {
      // Convert pixel value to an approximate of the new unit, assuming a root size of 16px.
      onChange((currentValue / 16).toFixed(2) + newUnit);
    } else if (['em', 'rem'].includes(currentUnit) && newUnit === 'px') {
      // Convert to pixel value assuming a root size of 16px.
      onChange(Math.round(currentValue * 16) + newUnit);
    } else if (['%', 'vw', 'svw', 'lvw', 'dvw', 'vh', 'svh', 'lvh', 'dvh', 'vi', 'svi', 'lvi', 'dvi', 'vb', 'svb', 'lvb', 'dvb', 'vmin', 'svmin', 'lvmin', 'dvmin', 'vmax', 'svmax', 'lvmax', 'dvmax'].includes(newUnit) && currentValue > 100) {
      // When converting to `%` or viewport-relative units, cap the new value at 100.
      onChange(100 + newUnit);
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("fieldset", {
    className: "block-editor-height-control",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default.VisualLabel */.Ay.VisualLabel, {
      as: "legend",
      children: label
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        isBlock: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
          value: value,
          units: units,
          onChange: onChange,
          onUnitChange: handleUnitChange,
          min: 0,
          size: "__unstable-large",
          label: label,
          hideLabelFromVision: true
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        isBlock: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
          marginX: 2,
          marginBottom: 0,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(range_control, {
            value: customRangeValue,
            min: 0,
            max: (_RANGE_CONTROL_CUSTOM = RANGE_CONTROL_CUSTOM_SETTINGS[selectedUnit]?.max) !== null && _RANGE_CONTROL_CUSTOM !== void 0 ? _RANGE_CONTROL_CUSTOM : 100,
            step: (_RANGE_CONTROL_CUSTOM2 = RANGE_CONTROL_CUSTOM_SETTINGS[selectedUnit]?.step) !== null && _RANGE_CONTROL_CUSTOM2 !== void 0 ? _RANGE_CONTROL_CUSTOM2 : 0.1,
            withInputField: false,
            onChange: handleSliderChange,
            __nextHasNoMarginBottom: true,
            label: label,
            hideLabelFromVision: true
          })
        })
      })]
    })]
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/child-layout-control/index.js
/**
 * WordPress dependencies
 */






function helpText(selfStretch, parentLayout) {
  const {
    orientation = 'horizontal'
  } = parentLayout;
  if (selfStretch === 'fill') {
    return (0,i18n_build_module.__)('Stretch to fill available space.');
  }
  if (selfStretch === 'fixed' && orientation === 'horizontal') {
    return (0,i18n_build_module.__)('Specify a fixed width.');
  } else if (selfStretch === 'fixed') {
    return (0,i18n_build_module.__)('Specify a fixed height.');
  }
  return (0,i18n_build_module.__)('Fit contents.');
}

/**
 * Form to edit the child layout value.
 *
 * @param {Object}   props                  Props.
 * @param {Object}   props.value            The child layout value.
 * @param {Function} props.onChange         Function to update the child layout value.
 * @param {Object}   props.parentLayout     The parent layout value.
 *
 * @param {boolean}  props.isShownByDefault
 * @param {string}   props.panelId
 * @return {Element} child layout edit element.
 */
function ChildLayoutControl({
  value: childLayout = {},
  onChange,
  parentLayout,
  isShownByDefault,
  panelId
}) {
  const {
    selfStretch,
    flexSize,
    columnStart,
    rowStart,
    columnSpan,
    rowSpan
  } = childLayout;
  const {
    type: parentType,
    default: {
      type: defaultParentType = 'default'
    } = {},
    orientation = 'horizontal'
  } = parentLayout !== null && parentLayout !== void 0 ? parentLayout : {};
  const parentLayoutType = parentType || defaultParentType;
  const hasFlexValue = () => !!selfStretch;
  const flexResetLabel = orientation === 'horizontal' ? (0,i18n_build_module.__)('Width') : (0,i18n_build_module.__)('Height');
  const resetFlex = () => {
    onChange({
      selfStretch: undefined,
      flexSize: undefined
    });
  };
  const hasStartValue = () => !!columnStart || !!rowStart;
  const hasSpanValue = () => !!columnSpan || !!rowSpan;
  const resetGridStarts = () => {
    onChange({
      columnStart: undefined,
      rowStart: undefined
    });
  };
  const resetGridSpans = () => {
    onChange({
      columnSpan: undefined,
      rowSpan: undefined
    });
  };
  (0,react.useEffect)(() => {
    if (selfStretch === 'fixed' && !flexSize) {
      onChange({
        ...childLayout,
        selfStretch: 'fit'
      });
    }
  }, []);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [parentLayoutType === 'flex' && /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
      as: tools_panel_item_component,
      spacing: 2,
      hasValue: hasFlexValue,
      label: flexResetLabel,
      onDeselect: resetFlex,
      isShownByDefault: isShownByDefault,
      panelId: panelId,
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(toggle_group_control_component, {
        __nextHasNoMarginBottom: true,
        size: "__unstable-large",
        label: childLayoutOrientation(parentLayout),
        value: selfStretch || 'fit',
        help: helpText(selfStretch, parentLayout),
        onChange: value => {
          const newFlexSize = value !== 'fixed' ? null : flexSize;
          onChange({
            selfStretch: value,
            flexSize: newFlexSize
          });
        },
        isBlock: true,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_component, {
          value: "fit",
          label: (0,i18n_build_module.__)('Fit')
        }, "fit"), /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_component, {
          value: "fill",
          label: (0,i18n_build_module.__)('Fill')
        }, "fill"), /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_group_control_option_component, {
          value: "fixed",
          label: (0,i18n_build_module.__)('Fixed')
        }, "fixed")]
      }), selfStretch === 'fixed' && /*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
        size: "__unstable-large",
        onChange: value => {
          onChange({
            selfStretch,
            flexSize: value
          });
        },
        value: flexSize
      })]
    }), parentLayoutType === 'grid' && /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
        as: tools_panel_item_component,
        hasValue: hasSpanValue,
        label: (0,i18n_build_module.__)('Grid span'),
        onDeselect: resetGridSpans,
        isShownByDefault: isShownByDefault,
        panelId: panelId,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(input_control/* default */.Ay, {
          size: "__unstable-large",
          label: (0,i18n_build_module.__)('Column span'),
          type: "number",
          onChange: value => {
            onChange({
              columnStart,
              rowStart,
              rowSpan,
              columnSpan: value
            });
          },
          value: columnSpan,
          min: 1
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(input_control/* default */.Ay, {
          size: "__unstable-large",
          label: (0,i18n_build_module.__)('Row span'),
          type: "number",
          onChange: value => {
            onChange({
              columnStart,
              rowStart,
              columnSpan,
              rowSpan: value
            });
          },
          value: rowSpan,
          min: 1
        })]
      }), window.__experimentalEnableGridInteractivity &&
      /*#__PURE__*/
      // Use Flex with an explicit width on the FlexItem instead of HStack to
      // work around an issue in webkit where inputs with a max attribute are
      // sized incorrectly.
      (0,jsx_runtime.jsxs)(flex_component/* default */.A, {
        as: tools_panel_item_component,
        hasValue: hasStartValue,
        label: (0,i18n_build_module.__)('Grid placement'),
        onDeselect: resetGridStarts,
        isShownByDefault: false,
        panelId: panelId,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          style: {
            width: '50%'
          },
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(input_control/* default */.Ay, {
            size: "__unstable-large",
            label: (0,i18n_build_module.__)('Column'),
            type: "number",
            onChange: value => {
              onChange({
                columnStart: value,
                rowStart,
                columnSpan,
                rowSpan
              });
            },
            value: columnStart,
            min: 1,
            max: parentLayout?.columnCount ? parentLayout.columnCount - (columnSpan !== null && columnSpan !== void 0 ? columnSpan : 1) + 1 : undefined
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          style: {
            width: '50%'
          },
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(input_control/* default */.Ay, {
            size: "__unstable-large",
            label: (0,i18n_build_module.__)('Row'),
            type: "number",
            onChange: value => {
              onChange({
                columnStart,
                rowStart: value,
                columnSpan,
                rowSpan
              });
            },
            value: rowStart,
            min: 1,
            max: parentLayout?.rowCount ? parentLayout.rowCount - (rowSpan !== null && rowSpan !== void 0 ? rowSpan : 1) + 1 : undefined
          })
        })]
      })]
    })]
  });
}
function childLayoutOrientation(parentLayout) {
  const {
    orientation = 'horizontal'
  } = parentLayout;
  return orientation === 'horizontal' ? (0,i18n_build_module.__)('Width') : (0,i18n_build_module.__)('Height');
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/dimensions-tool/aspect-ratio-tool.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * @typedef {import('@wordpress/components/build-types/select-control/types').SelectControlProps} SelectControlProps
 */

/**
 * @callback AspectRatioToolPropsOnChange
 * @param {string} [value] New aspect ratio value.
 * @return {void} No return.
 */

/**
 * @typedef {Object} AspectRatioToolProps
 * @property {string}                       [panelId]          ID of the panel this tool is associated with.
 * @property {string}                       [value]            Current aspect ratio value.
 * @property {AspectRatioToolPropsOnChange} [onChange]         Callback to update the aspect ratio value.
 * @property {SelectControlProps[]}         [options]          Aspect ratio options.
 * @property {string}                       [defaultValue]     Default aspect ratio value.
 * @property {boolean}                      [isShownByDefault] Whether the tool is shown by default.
 */

function AspectRatioTool({
  panelId,
  value,
  onChange = () => {},
  options,
  defaultValue = 'auto',
  hasValue,
  isShownByDefault = true
}) {
  // Match the CSS default so if the value is used directly in CSS it will look correct in the control.
  const displayValue = value !== null && value !== void 0 ? value : 'auto';
  const [defaultRatios, themeRatios, showDefaultRatios] = use_settings_useSettings('dimensions.aspectRatios.default', 'dimensions.aspectRatios.theme', 'dimensions.defaultAspectRatios');
  const themeOptions = themeRatios?.map(({
    name,
    ratio
  }) => ({
    label: name,
    value: ratio
  }));
  const defaultOptions = defaultRatios?.map(({
    name,
    ratio
  }) => ({
    label: name,
    value: ratio
  }));
  const aspectRatioOptions = [{
    label: (0,i18n_build_module._x)('Original', 'Aspect ratio option for dimensions control'),
    value: 'auto'
  }, ...(showDefaultRatios ? defaultOptions : []), ...(themeOptions ? themeOptions : []), {
    label: (0,i18n_build_module._x)('Custom', 'Aspect ratio option for dimensions control'),
    value: 'custom',
    disabled: true,
    hidden: true
  }];
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
    hasValue: hasValue ? hasValue : () => displayValue !== defaultValue,
    label: (0,i18n_build_module.__)('Aspect ratio'),
    onDeselect: () => onChange(undefined),
    isShownByDefault: isShownByDefault,
    panelId: panelId,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(select_control/* default */.A, {
      label: (0,i18n_build_module.__)('Aspect ratio'),
      value: displayValue,
      options: options !== null && options !== void 0 ? options : aspectRatioOptions,
      onChange: onChange,
      size: "__unstable-large",
      __nextHasNoMarginBottom: true
    })
  });
}
//# sourceMappingURL=aspect-ratio-tool.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/dimensions-panel.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */









const AXIAL_SIDES = ['horizontal', 'vertical'];
function useHasDimensionsPanel(settings) {
  const hasContentSize = useHasContentSize(settings);
  const hasWideSize = useHasWideSize(settings);
  const hasPadding = useHasPadding(settings);
  const hasMargin = useHasMargin(settings);
  const hasGap = useHasGap(settings);
  const hasMinHeight = useHasMinHeight(settings);
  const hasAspectRatio = useHasAspectRatio(settings);
  const hasChildLayout = useHasChildLayout(settings);
  return platform/* default */.A.OS === 'web' && (hasContentSize || hasWideSize || hasPadding || hasMargin || hasGap || hasMinHeight || hasAspectRatio || hasChildLayout);
}
function useHasContentSize(settings) {
  return settings?.layout?.contentSize;
}
function useHasWideSize(settings) {
  return settings?.layout?.wideSize;
}
function useHasPadding(settings) {
  return settings?.spacing?.padding;
}
function useHasMargin(settings) {
  return settings?.spacing?.margin;
}
function useHasGap(settings) {
  return settings?.spacing?.blockGap;
}
function useHasMinHeight(settings) {
  return settings?.dimensions?.minHeight;
}
function useHasAspectRatio(settings) {
  return settings?.dimensions?.aspectRatio;
}
function useHasChildLayout(settings) {
  var _settings$parentLayou;
  const {
    type: parentLayoutType = 'default',
    default: {
      type: defaultParentLayoutType = 'default'
    } = {},
    allowSizingOnChildren = false
  } = (_settings$parentLayou = settings?.parentLayout) !== null && _settings$parentLayou !== void 0 ? _settings$parentLayou : {};
  const support = (defaultParentLayoutType === 'flex' || parentLayoutType === 'flex' || defaultParentLayoutType === 'grid' || parentLayoutType === 'grid') && allowSizingOnChildren;
  return !!settings?.layout && support;
}
function useHasSpacingPresets(settings) {
  const {
    defaultSpacingSizes,
    spacingSizes
  } = settings?.spacing || {};
  return defaultSpacingSizes !== false && spacingSizes?.default?.length > 0 || spacingSizes?.theme?.length > 0 || spacingSizes?.custom?.length > 0;
}
function filterValuesBySides(values, sides) {
  // If no custom side configuration, all sides are opted into by default.
  // Without any values, we have nothing to filter either.
  if (!sides || !values) {
    return values;
  }

  // Only include sides opted into within filtered values.
  const filteredValues = {};
  sides.forEach(side => {
    if (side === 'vertical') {
      filteredValues.top = values.top;
      filteredValues.bottom = values.bottom;
    }
    if (side === 'horizontal') {
      filteredValues.left = values.left;
      filteredValues.right = values.right;
    }
    filteredValues[side] = values?.[side];
  });
  return filteredValues;
}
function splitStyleValue(value) {
  // Check for shorthand value (a string value).
  if (value && typeof value === 'string') {
    // Convert to value for individual sides for BoxControl.
    return {
      top: value,
      right: value,
      bottom: value,
      left: value
    };
  }
  return value;
}
function splitGapValue(value) {
  // Check for shorthand value (a string value).
  if (value && typeof value === 'string') {
    // If the value is a string, treat it as a single side (top) for the spacing controls.
    return {
      top: value
    };
  }
  if (value) {
    return {
      ...value,
      right: value?.left,
      bottom: value?.top
    };
  }
  return value;
}
function DimensionsToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_component, {
    label: (0,i18n_build_module.__)('Dimensions'),
    resetAll: resetAll,
    panelId: panelId,
    dropdownMenuProps: dropdownMenuProps,
    children: children
  });
}
const dimensions_panel_DEFAULT_CONTROLS = {
  contentSize: true,
  wideSize: true,
  padding: true,
  margin: true,
  blockGap: true,
  minHeight: true,
  aspectRatio: true,
  childLayout: true
};
function DimensionsPanel({
  as: Wrapper = DimensionsToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = dimensions_panel_DEFAULT_CONTROLS,
  onVisualize = () => {},
  // Special case because the layout controls are not part of the dimensions panel
  // in global styles but not in block inspector.
  includeLayoutControls = false
}) {
  var _defaultControls$cont, _defaultControls$wide, _defaultControls$padd, _defaultControls$marg, _defaultControls$bloc, _defaultControls$chil, _defaultControls$minH, _defaultControls$aspe;
  const {
    dimensions,
    spacing
  } = settings;
  const decodeValue = rawValue => {
    if (rawValue && typeof rawValue === 'object') {
      return Object.keys(rawValue).reduce((acc, key) => {
        acc[key] = utils_getValueFromVariable({
          settings: {
            dimensions,
            spacing
          }
        }, '', rawValue[key]);
        return acc;
      }, {});
    }
    return utils_getValueFromVariable({
      settings: {
        dimensions,
        spacing
      }
    }, '', rawValue);
  };
  const showSpacingPresetsControl = useHasSpacingPresets(settings);
  const units = useCustomUnits({
    availableUnits: settings?.spacing?.units || ['%', 'px', 'em', 'rem', 'vw']
  });

  //Minimum Margin Value
  const minimumMargin = -Infinity;
  const [minMarginValue, setMinMarginValue] = (0,react.useState)(minimumMargin);

  // Content Size
  const showContentSizeControl = useHasContentSize(settings) && includeLayoutControls;
  const contentSizeValue = decodeValue(inheritedValue?.layout?.contentSize);
  const setContentSizeValue = newValue => {
    onChange(object_setImmutably(value, ['layout', 'contentSize'], newValue || undefined));
  };
  const hasUserSetContentSizeValue = () => !!value?.layout?.contentSize;
  const resetContentSizeValue = () => setContentSizeValue(undefined);

  // Wide Size
  const showWideSizeControl = useHasWideSize(settings) && includeLayoutControls;
  const wideSizeValue = decodeValue(inheritedValue?.layout?.wideSize);
  const setWideSizeValue = newValue => {
    onChange(object_setImmutably(value, ['layout', 'wideSize'], newValue || undefined));
  };
  const hasUserSetWideSizeValue = () => !!value?.layout?.wideSize;
  const resetWideSizeValue = () => setWideSizeValue(undefined);

  // Padding
  const showPaddingControl = useHasPadding(settings);
  const rawPadding = decodeValue(inheritedValue?.spacing?.padding);
  const paddingValues = splitStyleValue(rawPadding);
  const paddingSides = Array.isArray(settings?.spacing?.padding) ? settings?.spacing?.padding : settings?.spacing?.padding?.sides;
  const isAxialPadding = paddingSides && paddingSides.some(side => AXIAL_SIDES.includes(side));
  const setPaddingValues = newPaddingValues => {
    const padding = filterValuesBySides(newPaddingValues, paddingSides);
    onChange(object_setImmutably(value, ['spacing', 'padding'], padding));
  };
  const hasPaddingValue = () => !!value?.spacing?.padding && Object.keys(value?.spacing?.padding).length;
  const resetPaddingValue = () => setPaddingValues(undefined);
  const onMouseOverPadding = () => onVisualize('padding');

  // Margin
  const showMarginControl = useHasMargin(settings);
  const rawMargin = decodeValue(inheritedValue?.spacing?.margin);
  const marginValues = splitStyleValue(rawMargin);
  const marginSides = Array.isArray(settings?.spacing?.margin) ? settings?.spacing?.margin : settings?.spacing?.margin?.sides;
  const isAxialMargin = marginSides && marginSides.some(side => AXIAL_SIDES.includes(side));
  const setMarginValues = newMarginValues => {
    const margin = filterValuesBySides(newMarginValues, marginSides);
    onChange(object_setImmutably(value, ['spacing', 'margin'], margin));
  };
  const hasMarginValue = () => !!value?.spacing?.margin && Object.keys(value?.spacing?.margin).length;
  const resetMarginValue = () => setMarginValues(undefined);
  const onMouseOverMargin = () => onVisualize('margin');

  // Block Gap
  const showGapControl = useHasGap(settings);
  const gapValue = decodeValue(inheritedValue?.spacing?.blockGap);
  const gapValues = splitGapValue(gapValue);
  const gapSides = Array.isArray(settings?.spacing?.blockGap) ? settings?.spacing?.blockGap : settings?.spacing?.blockGap?.sides;
  const isAxialGap = gapSides && gapSides.some(side => AXIAL_SIDES.includes(side));
  const setGapValue = newGapValue => {
    onChange(object_setImmutably(value, ['spacing', 'blockGap'], newGapValue));
  };
  const setGapValues = nextBoxGapValue => {
    if (!nextBoxGapValue) {
      setGapValue(null);
    }
    // If axial gap is not enabled, treat the 'top' value as the shorthand gap value.
    if (!isAxialGap && nextBoxGapValue?.hasOwnProperty('top')) {
      setGapValue(nextBoxGapValue.top);
    } else {
      setGapValue({
        top: nextBoxGapValue?.top,
        left: nextBoxGapValue?.left
      });
    }
  };
  const resetGapValue = () => setGapValue(undefined);
  const hasGapValue = () => !!value?.spacing?.blockGap;

  // Min Height
  const showMinHeightControl = useHasMinHeight(settings);
  const minHeightValue = decodeValue(inheritedValue?.dimensions?.minHeight);
  const setMinHeightValue = newValue => {
    const tempValue = object_setImmutably(value, ['dimensions', 'minHeight'], newValue);
    // Apply min-height, while removing any applied aspect ratio.
    onChange(object_setImmutably(tempValue, ['dimensions', 'aspectRatio'], undefined));
  };
  const resetMinHeightValue = () => {
    setMinHeightValue(undefined);
  };
  const hasMinHeightValue = () => !!value?.dimensions?.minHeight;

  // Aspect Ratio
  const showAspectRatioControl = useHasAspectRatio(settings);
  const aspectRatioValue = decodeValue(inheritedValue?.dimensions?.aspectRatio);
  const setAspectRatioValue = newValue => {
    const tempValue = object_setImmutably(value, ['dimensions', 'aspectRatio'], newValue);
    // Apply aspect-ratio, while removing any applied min-height.
    onChange(object_setImmutably(tempValue, ['dimensions', 'minHeight'], undefined));
  };
  const hasAspectRatioValue = () => !!value?.dimensions?.aspectRatio;

  // Child Layout
  const showChildLayoutControl = useHasChildLayout(settings);
  const childLayout = inheritedValue?.layout;
  const setChildLayout = newChildLayout => {
    onChange({
      ...value,
      layout: {
        ...newChildLayout
      }
    });
  };
  const resetAllFilter = (0,react.useCallback)(previousValue => {
    return {
      ...previousValue,
      layout: utils_cleanEmptyObject({
        ...previousValue?.layout,
        contentSize: undefined,
        wideSize: undefined,
        selfStretch: undefined,
        flexSize: undefined,
        columnStart: undefined,
        rowStart: undefined,
        columnSpan: undefined,
        rowSpan: undefined
      }),
      spacing: {
        ...previousValue?.spacing,
        padding: undefined,
        margin: undefined,
        blockGap: undefined
      },
      dimensions: {
        ...previousValue?.dimensions,
        minHeight: undefined,
        aspectRatio: undefined
      }
    };
  }, []);
  const onMouseLeaveControls = () => onVisualize(false);
  const inputProps = {
    min: minMarginValue,
    onDragStart: () => {
      //Reset to 0 in case the value was negative.
      setMinMarginValue(0);
    },
    onDragEnd: () => {
      setMinMarginValue(minimumMargin);
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId,
    children: [(showContentSizeControl || showWideSizeControl) && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
      className: "span-columns",
      children: (0,i18n_build_module.__)('Set the width of the main content area.')
    }), showContentSizeControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      className: "single-column",
      label: (0,i18n_build_module.__)('Content size'),
      hasValue: hasUserSetContentSizeValue,
      onDeselect: resetContentSizeValue,
      isShownByDefault: (_defaultControls$cont = defaultControls.contentSize) !== null && _defaultControls$cont !== void 0 ? _defaultControls$cont : dimensions_panel_DEFAULT_CONTROLS.contentSize,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
        alignment: "flex-end",
        justify: "flex-start",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
          label: (0,i18n_build_module.__)('Content'),
          labelPosition: "top",
          __unstableInputWidth: "80px",
          value: contentSizeValue || '',
          onChange: nextContentSize => {
            setContentSizeValue(nextContentSize);
          },
          units: units
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
            icon: position_center
          })
        })]
      })
    }), showWideSizeControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      className: "single-column",
      label: (0,i18n_build_module.__)('Wide size'),
      hasValue: hasUserSetWideSizeValue,
      onDeselect: resetWideSizeValue,
      isShownByDefault: (_defaultControls$wide = defaultControls.wideSize) !== null && _defaultControls$wide !== void 0 ? _defaultControls$wide : dimensions_panel_DEFAULT_CONTROLS.wideSize,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
        alignment: "flex-end",
        justify: "flex-start",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
          label: (0,i18n_build_module.__)('Wide'),
          labelPosition: "top",
          __unstableInputWidth: "80px",
          value: wideSizeValue || '',
          onChange: nextWideSize => {
            setWideSizeValue(nextWideSize);
          },
          units: units
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
            icon: stretch_wide
          })
        })]
      })
    }), showPaddingControl && /*#__PURE__*/(0,jsx_runtime.jsxs)(tools_panel_item_component, {
      hasValue: hasPaddingValue,
      label: (0,i18n_build_module.__)('Padding'),
      onDeselect: resetPaddingValue,
      isShownByDefault: (_defaultControls$padd = defaultControls.padding) !== null && _defaultControls$padd !== void 0 ? _defaultControls$padd : dimensions_panel_DEFAULT_CONTROLS.padding,
      className: (0,dist_clsx/* default */.A)({
        'tools-panel-item-spacing': showSpacingPresetsControl
      }),
      panelId: panelId,
      children: [!showSpacingPresetsControl && /*#__PURE__*/(0,jsx_runtime.jsx)(box_control, {
        values: paddingValues,
        onChange: setPaddingValues,
        label: (0,i18n_build_module.__)('Padding'),
        sides: paddingSides,
        units: units,
        allowReset: false,
        splitOnAxis: isAxialPadding,
        onMouseOver: onMouseOverPadding,
        onMouseOut: onMouseLeaveControls
      }), showSpacingPresetsControl && /*#__PURE__*/(0,jsx_runtime.jsx)(SpacingSizesControl, {
        values: paddingValues,
        onChange: setPaddingValues,
        label: (0,i18n_build_module.__)('Padding'),
        sides: paddingSides,
        units: units,
        allowReset: false,
        onMouseOver: onMouseOverPadding,
        onMouseOut: onMouseLeaveControls
      })]
    }), showMarginControl && /*#__PURE__*/(0,jsx_runtime.jsxs)(tools_panel_item_component, {
      hasValue: hasMarginValue,
      label: (0,i18n_build_module.__)('Margin'),
      onDeselect: resetMarginValue,
      isShownByDefault: (_defaultControls$marg = defaultControls.margin) !== null && _defaultControls$marg !== void 0 ? _defaultControls$marg : dimensions_panel_DEFAULT_CONTROLS.margin,
      className: (0,dist_clsx/* default */.A)({
        'tools-panel-item-spacing': showSpacingPresetsControl
      }),
      panelId: panelId,
      children: [!showSpacingPresetsControl && /*#__PURE__*/(0,jsx_runtime.jsx)(box_control, {
        values: marginValues,
        onChange: setMarginValues,
        inputProps: inputProps,
        label: (0,i18n_build_module.__)('Margin'),
        sides: marginSides,
        units: units,
        allowReset: false,
        splitOnAxis: isAxialMargin,
        onMouseOver: onMouseOverMargin,
        onMouseOut: onMouseLeaveControls
      }), showSpacingPresetsControl && /*#__PURE__*/(0,jsx_runtime.jsx)(SpacingSizesControl, {
        values: marginValues,
        onChange: setMarginValues,
        minimumCustomValue: -Infinity,
        label: (0,i18n_build_module.__)('Margin'),
        sides: marginSides,
        units: units,
        allowReset: false,
        onMouseOver: onMouseOverMargin,
        onMouseOut: onMouseLeaveControls
      })]
    }), showGapControl && /*#__PURE__*/(0,jsx_runtime.jsxs)(tools_panel_item_component, {
      hasValue: hasGapValue,
      label: (0,i18n_build_module.__)('Block spacing'),
      onDeselect: resetGapValue,
      isShownByDefault: (_defaultControls$bloc = defaultControls.blockGap) !== null && _defaultControls$bloc !== void 0 ? _defaultControls$bloc : dimensions_panel_DEFAULT_CONTROLS.blockGap,
      className: (0,dist_clsx/* default */.A)({
        'tools-panel-item-spacing': showSpacingPresetsControl
      }),
      panelId: panelId,
      children: [!showSpacingPresetsControl && (isAxialGap ? /*#__PURE__*/(0,jsx_runtime.jsx)(box_control, {
        label: (0,i18n_build_module.__)('Block spacing'),
        min: 0,
        onChange: setGapValues,
        units: units,
        sides: gapSides,
        values: gapValues,
        allowReset: false,
        splitOnAxis: isAxialGap
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)(unit_control, {
        label: (0,i18n_build_module.__)('Block spacing'),
        __unstableInputWidth: "80px",
        min: 0,
        onChange: setGapValue,
        units: units,
        value: gapValue
      })), showSpacingPresetsControl && /*#__PURE__*/(0,jsx_runtime.jsx)(SpacingSizesControl, {
        label: (0,i18n_build_module.__)('Block spacing'),
        min: 0,
        onChange: setGapValues,
        showSideInLabel: false,
        sides: isAxialGap ? gapSides : ['top'] // Use 'top' as the shorthand property in non-axial configurations.
        ,
        values: gapValues,
        allowReset: false
      })]
    }), showChildLayoutControl && /*#__PURE__*/(0,jsx_runtime.jsx)(ChildLayoutControl, {
      value: childLayout,
      onChange: setChildLayout,
      parentLayout: settings?.parentLayout,
      panelId: panelId,
      isShownByDefault: (_defaultControls$chil = defaultControls.childLayout) !== null && _defaultControls$chil !== void 0 ? _defaultControls$chil : dimensions_panel_DEFAULT_CONTROLS.childLayout
    }), showMinHeightControl && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      hasValue: hasMinHeightValue,
      label: (0,i18n_build_module.__)('Minimum height'),
      onDeselect: resetMinHeightValue,
      isShownByDefault: (_defaultControls$minH = defaultControls.minHeight) !== null && _defaultControls$minH !== void 0 ? _defaultControls$minH : dimensions_panel_DEFAULT_CONTROLS.minHeight,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(HeightControl, {
        label: (0,i18n_build_module.__)('Minimum height'),
        value: minHeightValue,
        onChange: setMinHeightValue
      })
    }), showAspectRatioControl && /*#__PURE__*/(0,jsx_runtime.jsx)(AspectRatioTool, {
      hasValue: hasAspectRatioValue,
      value: aspectRatioValue,
      onChange: setAspectRatioValue,
      panelId: panelId,
      isShownByDefault: (_defaultControls$aspe = defaultControls.aspectRatio) !== null && _defaultControls$aspe !== void 0 ? _defaultControls$aspe : dimensions_panel_DEFAULT_CONTROLS.aspectRatio
    })]
  });
}
//# sourceMappingURL=dimensions-panel.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.10.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js + 1 modules
var is_shallow_equal_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.10.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/spacing-visualizer.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function SpacingVisualizer({
  clientId,
  value,
  computeStyle,
  forceShow
}) {
  const blockElement = useBlockElement(clientId);
  const [style, updateStyle] = (0,react.useReducer)(() => computeStyle(blockElement));
  (0,react.useLayoutEffect)(() => {
    if (!blockElement) {
      return;
    }
    // It's not sufficient to read the computed spacing value when value.spacing changes as
    // useEffect may run before the browser recomputes CSS. We therefore combine
    // useLayoutEffect and two rAF calls to ensure that we read the spacing after the current
    // paint but before the next paint.
    // See https://github.com/WordPress/gutenberg/pull/59227.
    window.requestAnimationFrame(() => window.requestAnimationFrame(updateStyle));
  }, [blockElement, value]);
  const previousValue = (0,react.useRef)(value);
  const [isActive, setIsActive] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    if ((0,is_shallow_equal_build_module/* default */.Ay)(value, previousValue.current) || forceShow) {
      return;
    }
    setIsActive(true);
    previousValue.current = value;
    const timeout = setTimeout(() => {
      setIsActive(false);
    }, 400);
    return () => {
      setIsActive(false);
      clearTimeout(timeout);
    };
  }, [value, forceShow]);
  if (!isActive && !forceShow) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(cover, {
    clientId: clientId,
    __unstablePopoverSlot: "block-toolbar",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor__spacing-visualizer",
      style: style
    })
  });
}
function spacing_visualizer_getComputedCSS(element, property) {
  return element.ownerDocument.defaultView.getComputedStyle(element).getPropertyValue(property);
}
function MarginVisualizer({
  clientId,
  value,
  forceShow
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(SpacingVisualizer, {
    clientId: clientId,
    value: value?.spacing?.margin,
    computeStyle: blockElement => {
      const top = spacing_visualizer_getComputedCSS(blockElement, 'margin-top');
      const right = spacing_visualizer_getComputedCSS(blockElement, 'margin-right');
      const bottom = spacing_visualizer_getComputedCSS(blockElement, 'margin-bottom');
      const left = spacing_visualizer_getComputedCSS(blockElement, 'margin-left');
      return {
        borderTopWidth: top,
        borderRightWidth: right,
        borderBottomWidth: bottom,
        borderLeftWidth: left,
        top: top ? `-${top}` : 0,
        right: right ? `-${right}` : 0,
        bottom: bottom ? `-${bottom}` : 0,
        left: left ? `-${left}` : 0
      };
    },
    forceShow: forceShow
  });
}
function PaddingVisualizer({
  clientId,
  value,
  forceShow
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(SpacingVisualizer, {
    clientId: clientId,
    value: value?.spacing?.padding,
    computeStyle: blockElement => ({
      borderTopWidth: spacing_visualizer_getComputedCSS(blockElement, 'padding-top'),
      borderRightWidth: spacing_visualizer_getComputedCSS(blockElement, 'padding-right'),
      borderBottomWidth: spacing_visualizer_getComputedCSS(blockElement, 'padding-bottom'),
      borderLeftWidth: spacing_visualizer_getComputedCSS(blockElement, 'padding-left')
    }),
    forceShow: forceShow
  });
}
//# sourceMappingURL=spacing-visualizer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/dimensions.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */









const DIMENSIONS_SUPPORT_KEY = 'dimensions';
const SPACING_SUPPORT_KEY = 'spacing';
const dimensions_ALL_SIDES = (/* unused pure expression or super */ null && (['top', 'right', 'bottom', 'left']));
const dimensions_AXIAL_SIDES = (/* unused pure expression or super */ null && (['vertical', 'horizontal']));
function useVisualizer() {
  const [property, setProperty] = (0,react.useState)(false);
  const {
    hideBlockInterface,
    showBlockInterface
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  (0,react.useEffect)(() => {
    if (!property) {
      showBlockInterface();
    } else {
      hideBlockInterface();
    }
  }, [property, showBlockInterface, hideBlockInterface]);
  return [property, setProperty];
}
function DimensionsInspectorControl({
  children,
  resetAllFilter
}) {
  const attributesResetAllFilter = (0,react.useCallback)(attributes => {
    const existingStyle = attributes.style;
    const updatedStyle = resetAllFilter(existingStyle);
    return {
      ...attributes,
      style: updatedStyle
    };
  }, [resetAllFilter]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
    group: "dimensions",
    resetAllFilter: attributesResetAllFilter,
    children: children
  });
}
function dimensions_DimensionsPanel({
  clientId,
  name,
  setAttributes,
  settings
}) {
  const isEnabled = useHasDimensionsPanel(settings);
  const value = (0,use_select/* default */.A)(select => select(store_store).getBlockAttributes(clientId)?.style, [clientId]);
  const [visualizedProperty, setVisualizedProperty] = useVisualizer();
  const onChange = newStyle => {
    setAttributes({
      style: utils_cleanEmptyObject(newStyle)
    });
  };
  if (!isEnabled) {
    return null;
  }
  const defaultDimensionsControls = (0,build_module/* getBlockSupport */.bI)(name, [DIMENSIONS_SUPPORT_KEY, '__experimentalDefaultControls']);
  const defaultSpacingControls = (0,build_module/* getBlockSupport */.bI)(name, [SPACING_SUPPORT_KEY, '__experimentalDefaultControls']);
  const defaultControls = {
    ...defaultDimensionsControls,
    ...defaultSpacingControls
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(DimensionsPanel, {
      as: DimensionsInspectorControl,
      panelId: clientId,
      settings: settings,
      value: value,
      onChange: onChange,
      defaultControls: defaultControls,
      onVisualize: setVisualizedProperty
    }), !!settings?.spacing?.padding && /*#__PURE__*/(0,jsx_runtime.jsx)(PaddingVisualizer, {
      forceShow: visualizedProperty === 'padding',
      clientId: clientId,
      value: value
    }), !!settings?.spacing?.margin && /*#__PURE__*/(0,jsx_runtime.jsx)(MarginVisualizer, {
      forceShow: visualizedProperty === 'margin',
      clientId: clientId,
      value: value
    })]
  });
}

/**
 * Determine whether there is block support for dimensions.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   Background image feature to check for.
 *
 * @return {boolean} Whether there is support.
 */
function hasDimensionsSupport(blockName, feature = 'any') {
  if (platform/* default */.A.OS !== 'web') {
    return false;
  }
  const support = (0,build_module/* getBlockSupport */.bI)(blockName, DIMENSIONS_SUPPORT_KEY);
  if (support === true) {
    return true;
  }
  if (feature === 'any') {
    return !!(support?.aspectRatio || !!support?.minHeight);
  }
  return !!support?.[feature];
}
/* harmony default export */ const hooks_dimensions = ({
  useBlockProps: dimensions_useBlockProps,
  attributeKeys: ['minHeight', 'style'],
  hasSupport(name) {
    return hasDimensionsSupport(name, 'aspectRatio');
  }
});
function dimensions_useBlockProps({
  name,
  minHeight,
  style
}) {
  if (!hasDimensionsSupport(name, 'aspectRatio') || shouldSkipSerialization(name, DIMENSIONS_SUPPORT_KEY, 'aspectRatio')) {
    return {};
  }
  const className = (0,dist_clsx/* default */.A)({
    'has-aspect-ratio': !!style?.dimensions?.aspectRatio
  });

  // Allow dimensions-based inline style overrides to override any global styles rules that
  // might be set for the block, and therefore affect the display of the aspect ratio.
  const inlineStyleOverrides = {};

  // Apply rules to unset incompatible styles.
  // Note that a set `aspectRatio` will win out if both an aspect ratio and a minHeight are set.
  // This is because the aspect ratio is a newer block support, so (in theory) any aspect ratio
  // that is set should be intentional and should override any existing minHeight. The Cover block
  // and dimensions controls have logic that will manually clear the aspect ratio if a minHeight
  // is set.
  if (style?.dimensions?.aspectRatio) {
    // To ensure the aspect ratio does not get overridden by `minHeight` unset any existing rule.
    inlineStyleOverrides.minHeight = 'unset';
  } else if (minHeight || style?.dimensions?.minHeight) {
    // To ensure the minHeight does not get overridden by `aspectRatio` unset any existing rule.
    inlineStyleOverrides.aspectRatio = 'unset';
  }
  return {
    className,
    style: inlineStyleOverrides
  };
}

/**
 * @deprecated
 */
function useCustomSides() {
  deprecated('wp.blockEditor.__experimentalUseCustomSides', {
    since: '6.3',
    version: '6.4'
  });
}
//# sourceMappingURL=dimensions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/style.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */











const styleSupportKeys = [...TYPOGRAPHY_SUPPORT_KEYS, BORDER_SUPPORT_KEY, COLOR_SUPPORT_KEY, DIMENSIONS_SUPPORT_KEY, BACKGROUND_SUPPORT_KEY, SPACING_SUPPORT_KEY, SHADOW_SUPPORT_KEY];
const hasStyleSupport = nameOrType => styleSupportKeys.some(key => (0,build_module/* hasBlockSupport */.pN)(nameOrType, key));

/**
 * Returns the inline styles to add depending on the style object
 *
 * @param {Object} styles Styles configuration.
 *
 * @return {Object} Flattened CSS variables declaration.
 */
function style_getInlineStyles(styles = {}) {
  const output = {};
  // The goal is to move everything to server side generated engine styles
  // This is temporary as we absorb more and more styles into the engine.
  getCSSRules(styles).forEach(rule => {
    output[rule.key] = rule.value;
  });
  return output;
}

/**
 * Filters registered block settings, extending attributes to include `style` attribute.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function style_addAttribute(settings) {
  if (!hasStyleSupport(settings)) {
    return settings;
  }

  // Allow blocks to specify their own attribute definition with default values if needed.
  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: 'object'
      }
    });
  }
  return settings;
}

/**
 * A dictionary of paths to flag skipping block support serialization as the key,
 * with values providing the style paths to be omitted from serialization.
 *
 * @constant
 * @type {Record<string, string[]>}
 */
const skipSerializationPathsEdit = {
  [`${BORDER_SUPPORT_KEY}.__experimentalSkipSerialization`]: ['border'],
  [`${COLOR_SUPPORT_KEY}.__experimentalSkipSerialization`]: [COLOR_SUPPORT_KEY],
  [`${TYPOGRAPHY_SUPPORT_KEY}.__experimentalSkipSerialization`]: [TYPOGRAPHY_SUPPORT_KEY],
  [`${DIMENSIONS_SUPPORT_KEY}.__experimentalSkipSerialization`]: [DIMENSIONS_SUPPORT_KEY],
  [`${SPACING_SUPPORT_KEY}.__experimentalSkipSerialization`]: [SPACING_SUPPORT_KEY],
  [`${SHADOW_SUPPORT_KEY}.__experimentalSkipSerialization`]: [SHADOW_SUPPORT_KEY]
};

/**
 * A dictionary of paths to flag skipping block support serialization as the key,
 * with values providing the style paths to be omitted from serialization.
 *
 * Extends the Edit skip paths to enable skipping additional paths in just
 * the Save component. This allows a block support to be serialized within the
 * editor, while using an alternate approach, such as server-side rendering, when
 * the support is saved.
 *
 * @constant
 * @type {Record<string, string[]>}
 */
const skipSerializationPathsSave = {
  ...skipSerializationPathsEdit,
  [`${DIMENSIONS_SUPPORT_KEY}.aspectRatio`]: [`${DIMENSIONS_SUPPORT_KEY}.aspectRatio`],
  // Skip serialization of aspect ratio in save mode.
  [`${BACKGROUND_SUPPORT_KEY}`]: [BACKGROUND_SUPPORT_KEY] // Skip serialization of background support in save mode.
};
const skipSerializationPathsSaveChecks = {
  [`${DIMENSIONS_SUPPORT_KEY}.aspectRatio`]: true,
  [`${BACKGROUND_SUPPORT_KEY}`]: true
};

/**
 * A dictionary used to normalize feature names between support flags, style
 * object properties and __experimentSkipSerialization configuration arrays.
 *
 * This allows not having to provide a migration for a support flag and possible
 * backwards compatibility bridges, while still achieving consistency between
 * the support flag and the skip serialization array.
 *
 * @constant
 * @type {Record<string, string>}
 */
const renamedFeatures = {
  gradients: 'gradient'
};

/**
 * A utility function used to remove one or more paths from a style object.
 * Works in a way similar to Lodash's `omit()`. See unit tests and examples below.
 *
 * It supports a single string path:
 *
 * ```
 * omitStyle( { color: 'red' }, 'color' ); // {}
 * ```
 *
 * or an array of paths:
 *
 * ```
 * omitStyle( { color: 'red', background: '#fff' }, [ 'color', 'background' ] ); // {}
 * ```
 *
 * It also allows you to specify paths at multiple levels in a string.
 *
 * ```
 * omitStyle( { typography: { textDecoration: 'underline' } }, 'typography.textDecoration' ); // {}
 * ```
 *
 * You can remove multiple paths at the same time:
 *
 * ```
 * omitStyle(
 * 		{
 * 			typography: {
 * 				textDecoration: 'underline',
 * 				textTransform: 'uppercase',
 * 			}
 *		},
 *		[
 * 			'typography.textDecoration',
 * 			'typography.textTransform',
 *		]
 * );
 * // {}
 * ```
 *
 * You can also specify nested paths as arrays:
 *
 * ```
 * omitStyle(
 * 		{
 * 			typography: {
 * 				textDecoration: 'underline',
 * 				textTransform: 'uppercase',
 * 			}
 *		},
 *		[
 * 			[ 'typography', 'textDecoration' ],
 * 			[ 'typography', 'textTransform' ],
 *		]
 * );
 * // {}
 * ```
 *
 * With regards to nesting of styles, infinite depth is supported:
 *
 * ```
 * omitStyle(
 * 		{
 * 			border: {
 * 				radius: {
 * 					topLeft: '10px',
 * 					topRight: '0.5rem',
 * 				}
 * 			}
 *		},
 *		[
 * 			[ 'border', 'radius', 'topRight' ],
 *		]
 * );
 * // { border: { radius: { topLeft: '10px' } } }
 * ```
 *
 * The third argument, `preserveReference`, defines how to treat the input style object.
 * It is mostly necessary to properly handle mutation when recursively handling the style object.
 * Defaulting to `false`, this will always create a new object, avoiding to mutate `style`.
 * However, when recursing, we change that value to `true` in order to work with a single copy
 * of the original style object.
 *
 * @see https://lodash.com/docs/4.17.15#omit
 *
 * @param {Object}       style             Styles object.
 * @param {Array|string} paths             Paths to remove.
 * @param {boolean}      preserveReference True to mutate the `style` object, false otherwise.
 * @return {Object}      Styles object with the specified paths removed.
 */
function omitStyle(style, paths, preserveReference = false) {
  if (!style) {
    return style;
  }
  let newStyle = style;
  if (!preserveReference) {
    newStyle = JSON.parse(JSON.stringify(style));
  }
  if (!Array.isArray(paths)) {
    paths = [paths];
  }
  paths.forEach(path => {
    if (!Array.isArray(path)) {
      path = path.split('.');
    }
    if (path.length > 1) {
      const [firstSubpath, ...restPath] = path;
      omitStyle(newStyle[firstSubpath], [restPath], true);
    } else if (path.length === 1) {
      delete newStyle[path[0]];
    }
  });
  return newStyle;
}

/**
 * Override props assigned to save component to inject the CSS variables definition.
 *
 * @param {Object}                    props           Additional props applied to save element.
 * @param {Object|string}             blockNameOrType Block type.
 * @param {Object}                    attributes      Block attributes.
 * @param {?Record<string, string[]>} skipPaths       An object of keys and paths to skip serialization.
 *
 * @return {Object} Filtered props applied to save element.
 */
function style_addSaveProps(props, blockNameOrType, attributes, skipPaths = skipSerializationPathsSave) {
  if (!hasStyleSupport(blockNameOrType)) {
    return props;
  }
  let {
    style
  } = attributes;
  Object.entries(skipPaths).forEach(([indicator, path]) => {
    const skipSerialization = skipSerializationPathsSaveChecks[indicator] || (0,build_module/* getBlockSupport */.bI)(blockNameOrType, indicator);
    if (skipSerialization === true) {
      style = omitStyle(style, path);
    }
    if (Array.isArray(skipSerialization)) {
      skipSerialization.forEach(featureName => {
        const feature = renamedFeatures[featureName] || featureName;
        style = omitStyle(style, [[...path, feature]]);
      });
    }
  });
  props.style = {
    ...style_getInlineStyles(style),
    ...props.style
  };
  return props;
}
function BlockStyleControls({
  clientId,
  name,
  setAttributes,
  __unstableParentLayout
}) {
  const settings = useBlockSettings(name, __unstableParentLayout);
  const blockEditingMode = useBlockEditingMode();
  const passedProps = {
    clientId,
    name,
    setAttributes,
    settings: {
      ...settings,
      typography: {
        ...settings.typography,
        // The text alignment UI for individual blocks is rendered in
        // the block toolbar, so disable it here.
        textAlign: false
      }
    }
  };
  if (blockEditingMode !== 'default') {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(ColorEdit, {
      ...passedProps
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(BackgroundImagePanel, {
      ...passedProps
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(typography_TypographyPanel, {
      ...passedProps
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(border_BorderPanel, {
      ...passedProps
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(dimensions_DimensionsPanel, {
      ...passedProps
    })]
  });
}
/* harmony default export */ const style = ({
  edit: BlockStyleControls,
  hasSupport: hasStyleSupport,
  addSaveProps: style_addSaveProps,
  attributeKeys: ['style'],
  useBlockProps: style_useBlockProps
});

// Defines which element types are supported, including their hover styles or
// any other elements that have been included under a single element type
// e.g. heading and h1-h6.
const elementTypes = [{
  elementType: 'button'
}, {
  elementType: 'link',
  pseudo: [':hover']
}, {
  elementType: 'heading',
  elements: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']
}];
function style_useBlockProps({
  name,
  style
}) {
  const blockElementsContainerIdentifier = `wp-elements-${(0,use_instance_id/* default */.A)(style_useBlockProps)}`;

  // The .editor-styles-wrapper selector is required on elements styles. As it is
  // added to all other editor styles, not providing it causes reset and global
  // styles to override element styles because of higher specificity.
  const baseElementSelector = `.editor-styles-wrapper .${blockElementsContainerIdentifier}`;
  const blockElementStyles = style?.elements;
  const styles = (0,react.useMemo)(() => {
    if (!blockElementStyles) {
      return;
    }
    const elementCSSRules = [];
    elementTypes.forEach(({
      elementType,
      pseudo,
      elements
    }) => {
      const skipSerialization = shouldSkipSerialization(name, COLOR_SUPPORT_KEY, elementType);
      if (skipSerialization) {
        return;
      }
      const elementStyles = blockElementStyles?.[elementType];

      // Process primary element type styles.
      if (elementStyles) {
        const selector = scopeSelector(baseElementSelector, build_module/* __EXPERIMENTAL_ELEMENTS */.dB[elementType]);
        elementCSSRules.push(compileCSS(elementStyles, {
          selector
        }));

        // Process any interactive states for the element type.
        if (pseudo) {
          pseudo.forEach(pseudoSelector => {
            if (elementStyles[pseudoSelector]) {
              elementCSSRules.push(compileCSS(elementStyles[pseudoSelector], {
                selector: scopeSelector(baseElementSelector, `${build_module/* __EXPERIMENTAL_ELEMENTS */.dB[elementType]}${pseudoSelector}`)
              }));
            }
          });
        }
      }

      // Process related elements e.g. h1-h6 for headings
      if (elements) {
        elements.forEach(element => {
          if (blockElementStyles[element]) {
            elementCSSRules.push(compileCSS(blockElementStyles[element], {
              selector: scopeSelector(baseElementSelector, build_module/* __EXPERIMENTAL_ELEMENTS */.dB[element])
            }));
          }
        });
      }
    });
    return elementCSSRules.length > 0 ? elementCSSRules.join('') : undefined;
  }, [baseElementSelector, blockElementStyles, name]);
  utils_useStyleOverride({
    css: styles
  });
  return style_addSaveProps({
    className: blockElementsContainerIdentifier
  }, name, {
    style
  }, skipSerializationPathsEdit);
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/style/addAttribute', style_addAttribute);
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/settings.js
/**
 * WordPress dependencies
 */


const hasSettingsSupport = blockType => (0,build_module/* hasBlockSupport */.pN)(blockType, '__experimentalSettings', false);
function settings_addAttribute(settings) {
  if (!hasSettingsSupport(settings)) {
    return settings;
  }

  // Allow blocks to specify their own attribute definition with default values if needed.
  if (!settings?.attributes?.settings) {
    settings.attributes = {
      ...settings.attributes,
      settings: {
        type: 'object'
      }
    };
  }
  return settings;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/settings/addAttribute', settings_addAttribute);
//# sourceMappingURL=settings.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/swatch.js
/**
 * WordPress dependencies
 */


const swatch = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M5 17.7c.4.5.8.9 1.2 1.2l1.1-1.4c-.4-.3-.7-.6-1-1L5 17.7zM5 6.3l1.4 1.1c.3-.4.6-.7 1-1L6.3 5c-.5.4-.9.8-1.3 1.3zm.1 7.8l-1.7.5c.2.6.4 1.1.7 1.6l1.5-.8c-.2-.4-.4-.8-.5-1.3zM4.8 12v-.7L3 11.1v1.8l1.7-.2c.1-.2.1-.5.1-.7zm3 7.9c.5.3 1.1.5 1.6.7l.5-1.7c-.5-.1-.9-.3-1.3-.5l-.8 1.5zM19 6.3c-.4-.5-.8-.9-1.2-1.2l-1.1 1.4c.4.3.7.6 1 1L19 6.3zm-.1 3.6l1.7-.5c-.2-.6-.4-1.1-.7-1.6l-1.5.8c.2.4.4.8.5 1.3zM5.6 8.6l-1.5-.8c-.3.5-.5 1-.7 1.6l1.7.5c.1-.5.3-.9.5-1.3zm2.2-4.5l.8 1.5c.4-.2.8-.4 1.3-.5l-.5-1.7c-.6.2-1.1.4-1.6.7zm8.8 13.5l1.1 1.4c.5-.4.9-.8 1.2-1.2l-1.4-1.1c-.2.3-.5.6-.9.9zm1.8-2.2l1.5.8c.3-.5.5-1.1.7-1.6l-1.7-.5c-.1.5-.3.9-.5 1.3zm2.6-4.3l-1.7.2v1.4l1.7.2V12v-.9zM11.1 3l.2 1.7h1.4l.2-1.7h-1.8zm3 2.1c.5.1.9.3 1.3.5l.8-1.5c-.5-.3-1.1-.5-1.6-.7l-.5 1.7zM12 19.2h-.7l-.2 1.8h1.8l-.2-1.7c-.2-.1-.5-.1-.7-.1zm2.1-.3l.5 1.7c.6-.2 1.1-.4 1.6-.7l-.8-1.5c-.4.2-.8.4-1.3.5z"
  })
});
/* harmony default export */ const library_swatch = (swatch);
//# sourceMappingURL=swatch.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/duotone-picker/utils.js
/**
 * External dependencies
 */



/**
 * Internal dependencies
 */

(0,node_modules_colord/* extend */.X$)([names/* default */.A]);

/**
 * Object representation for a color.
 *
 * @typedef {Object} RGBColor
 * @property {number} r Red component of the color in the range [0,1].
 * @property {number} g Green component of the color in the range [0,1].
 * @property {number} b Blue component of the color in the range [0,1].
 */

/**
 * Calculate the brightest and darkest values from a color palette.
 *
 * @param palette Color palette for the theme.
 *
 * @return Tuple of the darkest color and brightest color.
 */
function getDefaultColors(palette) {
  // A default dark and light color are required.
  if (!palette || palette.length < 2) {
    return ['#000', '#fff'];
  }
  return palette.map(({
    color
  }) => ({
    color,
    brightness: (0,node_modules_colord/* colord */.Mj)(color).brightness()
  })).reduce(([min, max], current) => {
    return [current.brightness <= min.brightness ? current : min, current.brightness >= max.brightness ? current : max];
  }, [{
    brightness: 1,
    color: ''
  }, {
    brightness: 0,
    color: ''
  }]).map(({
    color
  }) => color);
}

/**
 * Generate a duotone gradient from a list of colors.
 *
 * @param colors CSS color strings.
 * @param angle  CSS gradient angle.
 *
 * @return  CSS gradient string for the duotone swatch.
 */
function getGradientFromCSSColors(colors = [], angle = '90deg') {
  const l = 100 / colors.length;
  const stops = colors.map((c, i) => `${c} ${i * l}%, ${c} ${(i + 1) * l}%`).join(', ');
  return `linear-gradient( ${angle}, ${stops} )`;
}

/**
 * Convert a color array to an array of color stops.
 *
 * @param colors CSS colors array
 *
 * @return Color stop information.
 */
function getColorStopsFromColors(colors) {
  return colors.map((color, i) => ({
    position: i * 100 / (colors.length - 1),
    color
  }));
}

/**
 * Convert a color stop array to an array colors.
 *
 * @param colorStops Color stop information.
 *
 * @return CSS colors array.
 */
function getColorsFromColorStops(colorStops = []) {
  return colorStops.map(({
    color
  }) => color);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/duotone-picker/duotone-swatch.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function DuotoneSwatch({
  values
}) {
  return values ? /*#__PURE__*/(0,jsx_runtime.jsx)(color_indicator, {
    colorValue: getGradientFromCSSColors(values, '135deg')
  }) : /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
    icon: library_swatch
  });
}
/* harmony default export */ const duotone_swatch = (DuotoneSwatch);
//# sourceMappingURL=duotone-swatch.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/duotone-picker/color-list-picker/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */









function ColorOption({
  label,
  value,
  colors,
  disableCustomColors,
  enableAlpha,
  onChange
}) {
  const [isOpen, setIsOpen] = (0,react.useState)(false);
  const idRoot = (0,use_instance_id/* default */.A)(ColorOption, 'color-list-picker-option');
  const labelId = `${idRoot}__label`;
  const contentId = `${idRoot}__content`;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      className: "components-color-list-picker__swatch-button",
      onClick: () => setIsOpen(prev => !prev),
      "aria-expanded": isOpen,
      "aria-controls": contentId,
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
        justify: "flex-start",
        spacing: 2,
        children: [value ? /*#__PURE__*/(0,jsx_runtime.jsx)(color_indicator, {
          colorValue: value,
          className: "components-color-list-picker__swatch-color"
        }) : /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
          icon: library_swatch
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          id: labelId,
          children: label
        })]
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      role: "group",
      id: contentId,
      "aria-labelledby": labelId,
      "aria-hidden": !isOpen,
      children: isOpen && /*#__PURE__*/(0,jsx_runtime.jsx)(color_palette, {
        "aria-label": (0,i18n_build_module.__)('Color options'),
        className: "components-color-list-picker__color-picker",
        colors: colors,
        value: value,
        clearable: false,
        onChange: onChange,
        disableCustomColors: disableCustomColors,
        enableAlpha: enableAlpha
      })
    })]
  });
}
function ColorListPicker({
  colors,
  labels,
  value = [],
  disableCustomColors,
  enableAlpha,
  onChange
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "components-color-list-picker",
    children: labels.map((label, index) => /*#__PURE__*/(0,jsx_runtime.jsx)(ColorOption, {
      label: label,
      value: value[index],
      colors: colors,
      disableCustomColors: disableCustomColors,
      enableAlpha: enableAlpha,
      onChange: newColor => {
        const newColors = value.slice();
        newColors[index] = newColor;
        onChange(newColors);
      }
    }, index))
  });
}
/* harmony default export */ const color_list_picker = (ColorListPicker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/duotone-picker/custom-duotone-bar.js
/**
 * Internal dependencies
 */



const PLACEHOLDER_VALUES = ['#333', '#CCC'];
function CustomDuotoneBar({
  value,
  onChange
}) {
  const hasGradient = !!value;
  const values = hasGradient ? value : PLACEHOLDER_VALUES;
  const background = getGradientFromCSSColors(values);
  const controlPoints = getColorStopsFromColors(values);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(CustomGradientBar, {
    disableInserter: true,
    background: background,
    hasGradient: hasGradient,
    value: controlPoints,
    onChange: newColorStops => {
      const newValue = getColorsFromColorStops(newColorStops);
      onChange(newValue);
    }
  });
}
//# sourceMappingURL=custom-duotone-bar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/duotone-picker/duotone-picker.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */








/**
 * ```jsx
 * import { DuotonePicker, DuotoneSwatch } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const DUOTONE_PALETTE = [
 * 	{ colors: [ '#8c00b7', '#fcff41' ], name: 'Purple and yellow', slug: 'purple-yellow' },
 * 	{ colors: [ '#000097', '#ff4747' ], name: 'Blue and red', slug: 'blue-red' },
 * ];
 *
 * const COLOR_PALETTE = [
 * 	{ color: '#ff4747', name: 'Red', slug: 'red' },
 * 	{ color: '#fcff41', name: 'Yellow', slug: 'yellow' },
 * 	{ color: '#000097', name: 'Blue', slug: 'blue' },
 * 	{ color: '#8c00b7', name: 'Purple', slug: 'purple' },
 * ];
 *
 * const Example = () => {
 * 	const [ duotone, setDuotone ] = useState( [ '#000000', '#ffffff' ] );
 * 	return (
 * 		<>
 * 			<DuotonePicker
 * 				duotonePalette={ DUOTONE_PALETTE }
 * 				colorPalette={ COLOR_PALETTE }
 * 				value={ duotone }
 * 				onChange={ setDuotone }
 * 			/>
 * 			<DuotoneSwatch values={ duotone } />
 * 		</>
 * 	);
 * };
 * ```
 */
function DuotonePicker({
  asButtons,
  loop,
  clearable = true,
  unsetable = true,
  colorPalette,
  duotonePalette,
  disableCustomColors,
  disableCustomDuotone,
  value,
  onChange,
  'aria-label': ariaLabel,
  'aria-labelledby': ariaLabelledby,
  ...otherProps
}) {
  const [defaultDark, defaultLight] = (0,react.useMemo)(() => getDefaultColors(colorPalette), [colorPalette]);
  const isUnset = value === 'unset';
  const unsetOptionLabel = (0,i18n_build_module.__)('Unset');
  const unsetOption = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker.Option, {
    value: "unset",
    isSelected: isUnset,
    tooltipText: unsetOptionLabel,
    "aria-label": unsetOptionLabel,
    className: "components-duotone-picker__color-indicator",
    onClick: () => {
      onChange(isUnset ? undefined : 'unset');
    }
  }, "unset");
  const duotoneOptions = duotonePalette.map(({
    colors,
    slug,
    name
  }) => {
    const style = {
      background: getGradientFromCSSColors(colors, '135deg'),
      color: 'transparent'
    };
    const tooltipText = name !== null && name !== void 0 ? name : (0,i18n_build_module/* sprintf */.nv)(
    // translators: %s: duotone code e.g: "dark-grayscale" or "7f7f7f-ffffff".
    (0,i18n_build_module.__)('Duotone code: %s'), slug);
    const label = name ? (0,i18n_build_module/* sprintf */.nv)(
    // translators: %s: The name of the option e.g: "Dark grayscale".
    (0,i18n_build_module.__)('Duotone: %s'), name) : tooltipText;
    const isSelected = es6_default()(colors, value);
    return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker.Option, {
      value: colors,
      isSelected: isSelected,
      "aria-label": label,
      tooltipText: tooltipText,
      style: style,
      onClick: () => {
        onChange(isSelected ? undefined : colors);
      }
    }, slug);
  });
  let metaProps;
  if (asButtons) {
    metaProps = {
      asButtons: true
    };
  } else {
    const _metaProps = {
      asButtons: false,
      loop
    };
    if (ariaLabel) {
      metaProps = {
        ..._metaProps,
        'aria-label': ariaLabel
      };
    } else if (ariaLabelledby) {
      metaProps = {
        ..._metaProps,
        'aria-labelledby': ariaLabelledby
      };
    } else {
      metaProps = {
        ..._metaProps,
        'aria-label': (0,i18n_build_module.__)('Custom color picker.')
      };
    }
  }
  const options = unsetable ? [unsetOption, ...duotoneOptions] : duotoneOptions;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker, {
    ...otherProps,
    ...metaProps,
    options: options,
    actions: !!clearable && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_circular_option_picker.ButtonAction, {
      onClick: () => onChange(undefined),
      children: (0,i18n_build_module.__)('Clear')
    }),
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
      paddingTop: options.length === 0 ? 0 : 4,
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
        spacing: 3,
        children: [!disableCustomColors && !disableCustomDuotone && /*#__PURE__*/(0,jsx_runtime.jsx)(CustomDuotoneBar, {
          value: isUnset ? undefined : value,
          onChange: onChange
        }), !disableCustomDuotone && /*#__PURE__*/(0,jsx_runtime.jsx)(color_list_picker, {
          labels: [(0,i18n_build_module.__)('Shadows'), (0,i18n_build_module.__)('Highlights')],
          colors: colorPalette,
          value: isUnset ? undefined : value,
          disableCustomColors: disableCustomColors,
          enableAlpha: true,
          onChange: newColors => {
            if (!newColors[0]) {
              newColors[0] = defaultDark;
            }
            if (!newColors[1]) {
              newColors[1] = defaultLight;
            }
            const newValue = newColors.length >= 2 ? newColors : undefined;
            // @ts-expect-error TODO: The color arrays for a DuotonePicker should be a tuple of two colors,
            // but it's currently typed as a string[].
            // See also https://github.com/WordPress/gutenberg/pull/49060#discussion_r1136951035
            onChange(newValue);
          }
        })]
      })
    })
  });
}
/* harmony default export */ const duotone_picker = (DuotonePicker);
//# sourceMappingURL=duotone-picker.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/filter.js
/**
 * WordPress dependencies
 */


const filter = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M12 4 4 19h16L12 4zm0 3.2 5.5 10.3H12V7.2z"
  })
});
/* harmony default export */ const library_filter = (filter);
//# sourceMappingURL=filter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/duotone-control/index.js
/**
 * WordPress dependencies
 */







function DuotoneControl({
  id: idProp,
  colorPalette,
  duotonePalette,
  disableCustomColors,
  disableCustomDuotone,
  value,
  onChange
}) {
  let toolbarIcon;
  if (value === 'unset') {
    toolbarIcon = /*#__PURE__*/(0,jsx_runtime.jsx)(color_indicator, {
      className: "block-editor-duotone-control__unset-indicator"
    });
  } else if (value) {
    toolbarIcon = /*#__PURE__*/(0,jsx_runtime.jsx)(duotone_swatch, {
      values: value
    });
  } else {
    toolbarIcon = /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
      icon: library_filter
    });
  }
  const actionLabel = (0,i18n_build_module.__)('Apply duotone filter');
  const id = (0,use_instance_id/* default */.A)(DuotoneControl, 'duotone-control', idProp);
  const descriptionId = `${id}__description`;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown/* default */.A, {
    popoverProps: {
      className: 'block-editor-duotone-control__popover',
      headerTitle: (0,i18n_build_module.__)('Duotone')
    },
    renderToggle: ({
      isOpen,
      onToggle
    }) => {
      const openOnArrowDown = event => {
        if (!isOpen && event.keyCode === keycodes_build_module/* DOWN */.PX) {
          event.preventDefault();
          onToggle();
        }
      };
      return /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
        showTooltip: true,
        onClick: onToggle,
        "aria-haspopup": "true",
        "aria-expanded": isOpen,
        onKeyDown: openOnArrowDown,
        label: actionLabel,
        icon: toolbarIcon
      });
    },
    renderContent: () => /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_group/* default */.A, {
      label: (0,i18n_build_module.__)('Duotone'),
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("p", {
        children: (0,i18n_build_module.__)('Create a two-tone color effect without losing your original image.')
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(duotone_picker, {
        "aria-label": actionLabel,
        "aria-describedby": descriptionId,
        colorPalette: colorPalette,
        duotonePalette: duotonePalette,
        disableCustomColors: disableCustomColors,
        disableCustomDuotone: disableCustomDuotone,
        value: value,
        onChange: onChange
      })]
    })
  });
}
/* harmony default export */ const duotone_control = (DuotoneControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/duotone/utils.js
/**
 * External dependencies
 */


/**
 * Convert a list of colors to an object of R, G, and B values.
 *
 * @param {string[]} colors Array of RBG color strings.
 *
 * @return {Object} R, G, and B values.
 */
function getValuesFromColors(colors = []) {
  const values = {
    r: [],
    g: [],
    b: [],
    a: []
  };
  colors.forEach(color => {
    const rgbColor = (0,node_modules_colord/* colord */.Mj)(color).toRgb();
    values.r.push(rgbColor.r / 255);
    values.g.push(rgbColor.g / 255);
    values.b.push(rgbColor.b / 255);
    values.a.push(rgbColor.a);
  });
  return values;
}

/**
 * Stylesheet for disabling a global styles duotone filter.
 *
 * @param {string} selector Selector to disable the filter for.
 *
 * @return {string} Filter none style.
 */
function getDuotoneUnsetStylesheet(selector) {
  return `${selector}{filter:none}`;
}

/**
 * SVG and stylesheet needed for rendering the duotone filter.
 *
 * @param {string} selector Selector to apply the filter to.
 * @param {string} id       Unique id for this duotone filter.
 *
 * @return {string} Duotone filter style.
 */
function getDuotoneStylesheet(selector, id) {
  return `${selector}{filter:url(#${id})}`;
}

/**
 * The SVG part of the duotone filter.
 *
 * @param {string}   id     Unique id for this duotone filter.
 * @param {string[]} colors Color strings from dark to light.
 *
 * @return {string} Duotone SVG.
 */
function utils_getDuotoneFilter(id, colors) {
  const values = getValuesFromColors(colors);
  return `
<svg
	xmlns:xlink="http://www.w3.org/1999/xlink"
	viewBox="0 0 0 0"
	width="0"
	height="0"
	focusable="false"
	role="none"
	aria-hidden="true"
	style="visibility: hidden; position: absolute; left: -9999px; overflow: hidden;"
>
	<defs>
		<filter id="${id}">
			<!--
				Use sRGB instead of linearRGB so transparency looks correct.
				Use perceptual brightness to convert to grayscale.
			-->
			<feColorMatrix color-interpolation-filters="sRGB" type="matrix" values=" .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 "></feColorMatrix>
			<!-- Use sRGB instead of linearRGB to be consistent with how CSS gradients work. -->
			<feComponentTransfer color-interpolation-filters="sRGB">
				<feFuncR type="table" tableValues="${values.r.join(' ')}"></feFuncR>
				<feFuncG type="table" tableValues="${values.g.join(' ')}"></feFuncG>
				<feFuncB type="table" tableValues="${values.b.join(' ')}"></feFuncB>
				<feFuncA type="table" tableValues="${values.a.join(' ')}"></feFuncA>
			</feComponentTransfer>
			<!-- Re-mask the image with the original transparency since the feColorMatrix above loses that information. -->
			<feComposite in2="SourceGraphic" operator="in"></feComposite>
		</filter>
	</defs>
</svg>`;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/get-block-css-selector.js
/**
 * Internal dependencies
 */



/**
 * Determine the CSS selector for the block type and target provided, returning
 * it if available.
 *
 * @param {import('@wordpress/blocks').Block} blockType        The block's type.
 * @param {string|string[]}                   target           The desired selector's target e.g. `root`, delimited string, or array path.
 * @param {Object}                            options          Options object.
 * @param {boolean}                           options.fallback Whether or not to fallback to broader selector.
 *
 * @return {?string} The CSS selector or `null` if no selector available.
 */
function getBlockCSSSelector(blockType, target = 'root', options = {}) {
  if (!target) {
    return null;
  }
  const {
    fallback = false
  } = options;
  const {
    name,
    selectors,
    supports
  } = blockType;
  const hasSelectors = selectors && Object.keys(selectors).length > 0;
  const path = Array.isArray(target) ? target.join('.') : target;

  // Root selector.

  // Calculated before returning as it can be used as a fallback for feature
  // selectors later on.
  let rootSelector = null;
  if (hasSelectors && selectors.root) {
    // Use the selectors API if available.
    rootSelector = selectors?.root;
  } else if (supports?.__experimentalSelector) {
    // Use the old experimental selector supports property if set.
    rootSelector = supports.__experimentalSelector;
  } else {
    // If no root selector found, generate default block class selector.
    rootSelector = '.wp-block-' + name.replace('core/', '').replace('/', '-');
  }

  // Return selector if it's the root target we are looking for.
  if (path === 'root') {
    return rootSelector;
  }

  // If target is not `root` or `duotone` we have a feature or subfeature
  // as the target. If the target is a string convert to an array.
  const pathArray = Array.isArray(target) ? target : target.split('.');

  // Feature selectors ( may fallback to root selector );
  if (pathArray.length === 1) {
    const fallbackSelector = fallback ? rootSelector : null;

    // Prefer the selectors API if available.
    if (hasSelectors) {
      // Get selector from either `feature.root` or shorthand path.
      const featureSelector = object_getValueFromObjectPath(selectors, `${path}.root`, null) || object_getValueFromObjectPath(selectors, path, null);

      // Return feature selector if found or any available fallback.
      return featureSelector || fallbackSelector;
    }

    // Try getting old experimental supports selector value.
    const featureSelector = object_getValueFromObjectPath(supports, `${path}.__experimentalSelector`, null);

    // If nothing to work with, provide fallback selector if available.
    if (!featureSelector) {
      return fallbackSelector;
    }

    // Scope the feature selector by the block's root selector.
    return scopeSelector(rootSelector, featureSelector);
  }

  // Subfeature selector.
  // This may fallback either to parent feature or root selector.
  let subfeatureSelector;

  // Use selectors API if available.
  if (hasSelectors) {
    subfeatureSelector = object_getValueFromObjectPath(selectors, path, null);
  }

  // Only return if we have a subfeature selector.
  if (subfeatureSelector) {
    return subfeatureSelector;
  }

  // To this point we don't have a subfeature selector. If a fallback has been
  // requested, remove subfeature from target path and return results of a
  // call for the parent feature's selector.
  if (fallback) {
    return getBlockCSSSelector(blockType, pathArray[0], options);
  }

  // We tried.
  return null;
}
//# sourceMappingURL=get-block-css-selector.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/filters-panel.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const filters_panel_EMPTY_ARRAY = [];
function useMultiOriginColorPresets(settings, {
  presetSetting,
  defaultSetting
}) {
  const disableDefault = !settings?.color?.[defaultSetting];
  const userPresets = settings?.color?.[presetSetting]?.custom || filters_panel_EMPTY_ARRAY;
  const themePresets = settings?.color?.[presetSetting]?.theme || filters_panel_EMPTY_ARRAY;
  const defaultPresets = settings?.color?.[presetSetting]?.default || filters_panel_EMPTY_ARRAY;
  return (0,react.useMemo)(() => [...userPresets, ...themePresets, ...(disableDefault ? filters_panel_EMPTY_ARRAY : defaultPresets)], [disableDefault, userPresets, themePresets, defaultPresets]);
}
function useHasFiltersPanel(settings) {
  return useHasDuotoneControl(settings);
}
function useHasDuotoneControl(settings) {
  return settings.color.customDuotone || settings.color.defaultDuotone || settings.color.duotone.length > 0;
}
function FiltersToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_component, {
    label: (0,i18n_build_module._x)('Filters', 'Name for applying graphical effects'),
    resetAll: resetAll,
    panelId: panelId,
    dropdownMenuProps: dropdownMenuProps,
    children: children
  });
}
const filters_panel_DEFAULT_CONTROLS = {
  duotone: true
};
const filters_panel_popoverProps = {
  placement: 'left-start',
  offset: 36,
  shift: true,
  className: 'block-editor-duotone-control__popover',
  headerTitle: (0,i18n_build_module.__)('Duotone')
};
const LabeledColorIndicator = ({
  indicator,
  label
}) => /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
  justify: "flex-start",
  children: [/*#__PURE__*/(0,jsx_runtime.jsx)(z_stack_component, {
    isLayered: false,
    offset: -8,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(flex_component/* default */.A, {
      expanded: false,
      children: indicator === 'unset' || !indicator ? /*#__PURE__*/(0,jsx_runtime.jsx)(color_indicator, {
        className: "block-editor-duotone-control__unset-indicator"
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)(duotone_swatch, {
        values: indicator
      })
    })
  }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
    title: label,
    children: label
  })]
});
function FiltersPanel({
  as: Wrapper = FiltersToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = filters_panel_DEFAULT_CONTROLS
}) {
  const decodeValue = rawValue => utils_getValueFromVariable({
    settings
  }, '', rawValue);

  // Duotone
  const hasDuotoneEnabled = useHasDuotoneControl(settings);
  const duotonePalette = useMultiOriginColorPresets(settings, {
    presetSetting: 'duotone',
    defaultSetting: 'defaultDuotone'
  });
  const colorPalette = useMultiOriginColorPresets(settings, {
    presetSetting: 'palette',
    defaultSetting: 'defaultPalette'
  });
  const duotone = decodeValue(inheritedValue?.filter?.duotone);
  const setDuotone = newValue => {
    const duotonePreset = duotonePalette.find(({
      colors
    }) => {
      return colors === newValue;
    });
    const settedValue = duotonePreset ? `var:preset|duotone|${duotonePreset.slug}` : newValue;
    onChange(object_setImmutably(value, ['filter', 'duotone'], settedValue));
  };
  const hasDuotone = () => !!value?.filter?.duotone;
  const resetDuotone = () => setDuotone(undefined);
  const resetAllFilter = (0,react.useCallback)(previousValue => {
    return {
      ...previousValue,
      filter: {
        ...previousValue.filter,
        duotone: undefined
      }
    };
  }, []);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId,
    children: hasDuotoneEnabled && /*#__PURE__*/(0,jsx_runtime.jsx)(tools_panel_item_component, {
      label: (0,i18n_build_module.__)('Duotone'),
      hasValue: hasDuotone,
      onDeselect: resetDuotone,
      isShownByDefault: defaultControls.duotone,
      panelId: panelId,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown/* default */.A, {
        popoverProps: filters_panel_popoverProps,
        className: "block-editor-global-styles-filters-panel__dropdown",
        renderToggle: ({
          onToggle,
          isOpen
        }) => {
          const toggleProps = {
            onClick: onToggle,
            className: (0,dist_clsx/* default */.A)({
              'is-open': isOpen
            }),
            'aria-expanded': isOpen
          };
          return /*#__PURE__*/(0,jsx_runtime.jsx)(item_group_component, {
            isBordered: true,
            isSeparated: true,
            children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
              ...toggleProps,
              children: /*#__PURE__*/(0,jsx_runtime.jsx)(LabeledColorIndicator, {
                indicator: duotone,
                label: (0,i18n_build_module.__)('Duotone')
              })
            })
          });
        },
        renderContent: () => /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_content_wrapper, {
          paddingSize: "small",
          children: /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_group/* default */.A, {
            label: (0,i18n_build_module.__)('Duotone'),
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)("p", {
              children: (0,i18n_build_module.__)('Create a two-tone color effect without losing your original image.')
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(duotone_picker, {
              colorPalette: colorPalette,
              duotonePalette: duotonePalette
              // TODO: Re-enable both when custom colors are supported for block-level styles.
              ,
              disableCustomColors: true,
              disableCustomDuotone: true,
              value: duotone,
              onChange: setDuotone
            })]
          })
        })
      })
    })
  });
}
//# sourceMappingURL=filters-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/duotone.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */











const duotone_EMPTY_ARRAY = [];

// Safari does not always update the duotone filter when the duotone colors
// are changed. This browser check is later used to force a re-render of the block
// element to ensure the duotone filter is updated. The check is included at the
// root of this file as it only needs to be run once per page load.
const isSafari = window?.navigator.userAgent && window.navigator.userAgent.includes('Safari') && !window.navigator.userAgent.includes('Chrome') && !window.navigator.userAgent.includes('Chromium');
(0,node_modules_colord/* extend */.X$)([names/* default */.A]);
function useMultiOriginPresets({
  presetSetting,
  defaultSetting
}) {
  const [enableDefault, userPresets, themePresets, defaultPresets] = use_settings_useSettings(defaultSetting, `${presetSetting}.custom`, `${presetSetting}.theme`, `${presetSetting}.default`);
  return (0,react.useMemo)(() => [...(userPresets || duotone_EMPTY_ARRAY), ...(themePresets || duotone_EMPTY_ARRAY), ...(enableDefault && defaultPresets || duotone_EMPTY_ARRAY)], [enableDefault, userPresets, themePresets, defaultPresets]);
}
function getColorsFromDuotonePreset(duotone, duotonePalette) {
  if (!duotone) {
    return;
  }
  const preset = duotonePalette?.find(({
    slug
  }) => {
    return duotone === `var:preset|duotone|${slug}`;
  });
  return preset ? preset.colors : undefined;
}
function getDuotonePresetFromColors(colors, duotonePalette) {
  if (!colors || !Array.isArray(colors)) {
    return;
  }
  const preset = duotonePalette?.find(duotonePreset => {
    return duotonePreset?.colors?.every((val, index) => val === colors[index]);
  });
  return preset ? `var:preset|duotone|${preset.slug}` : undefined;
}
function DuotonePanelPure({
  style,
  setAttributes,
  name
}) {
  const duotoneStyle = style?.color?.duotone;
  const settings = useBlockSettings(name);
  const blockEditingMode = useBlockEditingMode();
  const duotonePalette = useMultiOriginPresets({
    presetSetting: 'color.duotone',
    defaultSetting: 'color.defaultDuotone'
  });
  const colorPalette = useMultiOriginPresets({
    presetSetting: 'color.palette',
    defaultSetting: 'color.defaultPalette'
  });
  const [enableCustomColors, enableCustomDuotone] = use_settings_useSettings('color.custom', 'color.customDuotone');
  const disableCustomColors = !enableCustomColors;
  const disableCustomDuotone = !enableCustomDuotone || colorPalette?.length === 0 && disableCustomColors;
  if (duotonePalette?.length === 0 && disableCustomDuotone) {
    return null;
  }
  if (blockEditingMode !== 'default') {
    return null;
  }
  const duotonePresetOrColors = !Array.isArray(duotoneStyle) ? getColorsFromDuotonePreset(duotoneStyle, duotonePalette) : duotoneStyle;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
      group: "filter",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(FiltersPanel, {
        value: {
          filter: {
            duotone: duotonePresetOrColors
          }
        },
        onChange: newDuotone => {
          const newStyle = {
            ...style,
            color: {
              ...newDuotone?.filter
            }
          };
          setAttributes({
            style: newStyle
          });
        },
        settings: settings
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_controls, {
      group: "block",
      __experimentalShareWithChildBlocks: true,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(duotone_control, {
        duotonePalette: duotonePalette,
        colorPalette: colorPalette,
        disableCustomDuotone: disableCustomDuotone,
        disableCustomColors: disableCustomColors,
        value: duotonePresetOrColors,
        onChange: newDuotone => {
          const maybePreset = getDuotonePresetFromColors(newDuotone, duotonePalette);
          const newStyle = {
            ...style,
            color: {
              ...style?.color,
              duotone: maybePreset !== null && maybePreset !== void 0 ? maybePreset : newDuotone // use preset or fallback to custom colors.
            }
          };
          setAttributes({
            style: newStyle
          });
        },
        settings: settings
      })
    })]
  });
}
/* harmony default export */ const duotone = ({
  shareWithChildBlocks: true,
  edit: DuotonePanelPure,
  useBlockProps: duotone_useBlockProps,
  attributeKeys: ['style'],
  hasSupport(name) {
    return (0,build_module/* hasBlockSupport */.pN)(name, 'filter.duotone');
  }
});

/**
 * Filters registered block settings, extending attributes to include
 * the `duotone` attribute.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function addDuotoneAttributes(settings) {
  // Previous `color.__experimentalDuotone` support flag is migrated via
  // block_type_metadata_settings filter in `lib/block-supports/duotone.php`.
  if (!(0,build_module/* hasBlockSupport */.pN)(settings, 'filter.duotone')) {
    return settings;
  }

  // Allow blocks to specify their own attribute definition with default
  // values if needed.
  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: 'object'
      }
    });
  }
  return settings;
}
function useDuotoneStyles({
  clientId,
  id: filterId,
  selector: duotoneSelector,
  attribute: duotoneAttr
}) {
  const duotonePalette = useMultiOriginPresets({
    presetSetting: 'color.duotone',
    defaultSetting: 'color.defaultDuotone'
  });

  // Possible values for duotone attribute:
  // 1. Array of colors - e.g. ['#000000', '#ffffff'].
  // 2. Variable for an existing Duotone preset - e.g. 'var:preset|duotone|green-blue' or 'var(--wp--preset--duotone--green-blue)''
  // 3. A CSS string - e.g. 'unset' to remove globally applied duotone.
  const isCustom = Array.isArray(duotoneAttr);
  const duotonePreset = isCustom ? undefined : getColorsFromDuotonePreset(duotoneAttr, duotonePalette);
  const isPreset = typeof duotoneAttr === 'string' && duotonePreset;
  const isCSS = typeof duotoneAttr === 'string' && !isPreset;

  // Match the structure of WP_Duotone_Gutenberg::render_duotone_support() in PHP.
  let colors = null;
  if (isPreset) {
    // Array of colors.
    colors = duotonePreset;
  } else if (isCSS) {
    // CSS filter property string (e.g. 'unset').
    colors = duotoneAttr;
  } else if (isCustom) {
    // Array of colors.
    colors = duotoneAttr;
  }

  // Build the CSS selectors to which the filter will be applied.
  const selectors = duotoneSelector.split(',');
  const selectorsScoped = selectors.map(selectorPart => {
    // Extra .editor-styles-wrapper specificity is needed in the editor
    // since we're not using inline styles to apply the filter. We need to
    // override duotone applied by global styles and theme.json.

    // Assuming the selector part is a subclass selector (not a tag name)
    // so we can prepend the filter id class. If we want to support elements
    // such as `img` or namespaces, we'll need to add a case for that here.
    return `.${filterId}${selectorPart.trim()}`;
  });
  const selector = selectorsScoped.join(', ');
  const isValidFilter = Array.isArray(colors) || colors === 'unset';
  utils_useStyleOverride(isValidFilter ? {
    css: colors !== 'unset' ? getDuotoneStylesheet(selector, filterId) : getDuotoneUnsetStylesheet(selector),
    __unstableType: 'presets'
  } : undefined);
  utils_useStyleOverride(isValidFilter ? {
    assets: colors !== 'unset' ? utils_getDuotoneFilter(filterId, colors) : '',
    __unstableType: 'svgs'
  } : undefined);
  const blockElement = useBlockElement(clientId);
  (0,react.useEffect)(() => {
    if (!isValidFilter) {
      return;
    }

    // Safari does not always update the duotone filter when the duotone
    // colors are changed. When using Safari, force the block element to be
    // repainted by the browser to ensure any changes are reflected
    // visually. This logic matches that used on the site frontend in
    // `block-supports/duotone.php`.
    if (blockElement && isSafari) {
      const display = blockElement.style.display;
      // Switch to `inline-block` to force a repaint. In the editor,
      // `inline-block` is used instead of `none` to ensure that scroll
      // position is not affected, as `none` results in the editor
      // scrolling to the top of the block.
      blockElement.style.display = 'inline-block';
      // Simply accessing el.offsetHeight flushes layout and style changes
      // in WebKit without having to wait for setTimeout.
      // eslint-disable-next-line no-unused-expressions
      blockElement.offsetHeight;
      blockElement.style.display = display;
    }
    // `colors` must be a dependency so this effect runs when the colors
    // change in Safari.
  }, [isValidFilter, blockElement, colors]);
}
function duotone_useBlockProps({
  clientId,
  name,
  style
}) {
  const id = (0,use_instance_id/* default */.A)(duotone_useBlockProps);
  const selector = (0,react.useMemo)(() => {
    const blockType = (0,build_module/* getBlockType */.E7)(name);
    if (blockType) {
      // Backwards compatibility for `supports.color.__experimentalDuotone`
      // is provided via the `block_type_metadata_settings` filter. If
      // `supports.filter.duotone` has not been set and the
      // experimental property has been, the experimental property
      // value is copied into `supports.filter.duotone`.
      const duotoneSupport = (0,build_module/* getBlockSupport */.bI)(blockType, 'filter.duotone', false);
      if (!duotoneSupport) {
        return null;
      }

      // If the experimental duotone support was set, that value is
      // to be treated as a selector and requires scoping.
      const experimentalDuotone = (0,build_module/* getBlockSupport */.bI)(blockType, 'color.__experimentalDuotone', false);
      if (experimentalDuotone) {
        const rootSelector = getBlockCSSSelector(blockType);
        return typeof experimentalDuotone === 'string' ? scopeSelector(rootSelector, experimentalDuotone) : rootSelector;
      }

      // Regular filter.duotone support uses filter.duotone selectors with fallbacks.
      return getBlockCSSSelector(blockType, 'filter.duotone', {
        fallback: true
      });
    }
  }, [name]);
  const attribute = style?.color?.duotone;
  const filterClass = `wp-duotone-${id}`;
  const shouldRender = selector && attribute;
  useDuotoneStyles({
    clientId,
    id: filterClass,
    selector,
    attribute
  });
  return {
    className: shouldRender ? filterClass : ''
  };
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/editor/duotone/add-attributes', addDuotoneAttributes);
//# sourceMappingURL=duotone.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/use-block-display-information/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/blocks').WPIcon} WPIcon */

/**
 * Contains basic block's information for display reasons.
 *
 * @typedef {Object} WPBlockDisplayInformation
 *
 * @property {boolean} isSynced    True if is a reusable block or template part
 * @property {string}  title       Human-readable block type label.
 * @property {WPIcon}  icon        Block type icon.
 * @property {string}  description A detailed block type description.
 * @property {string}  anchor      HTML anchor.
 * @property {name}    name        A custom, human readable name for the block.
 */

/**
 * Get the display label for a block's position type.
 *
 * @param {Object} attributes Block attributes.
 * @return {string} The position type label.
 */
function getPositionTypeLabel(attributes) {
  const positionType = attributes?.style?.position?.type;
  if (positionType === 'sticky') {
    return (0,i18n_build_module.__)('Sticky');
  }
  if (positionType === 'fixed') {
    return (0,i18n_build_module.__)('Fixed');
  }
  return null;
}

/**
 * Hook used to try to find a matching block variation and return
 * the appropriate information for display reasons. In order to
 * to try to find a match we need to things:
 * 1. Block's client id to extract it's current attributes.
 * 2. A block variation should have set `isActive` prop to a proper function.
 *
 * If for any reason a block variation match cannot be found,
 * the returned information come from the Block Type.
 * If no blockType is found with the provided clientId, returns null.
 *
 * @param {string} clientId Block's client id.
 * @return {?WPBlockDisplayInformation} Block's display information, or `null` when the block or its type not found.
 */

function useBlockDisplayInformation(clientId) {
  return (0,use_select/* default */.A)(select => {
    if (!clientId) {
      return null;
    }
    const {
      getBlockName,
      getBlockAttributes
    } = select(store_store);
    const {
      getBlockType,
      getActiveBlockVariation
    } = select(build_module/* store */.M_);
    const blockName = getBlockName(clientId);
    const blockType = getBlockType(blockName);
    if (!blockType) {
      return null;
    }
    const attributes = getBlockAttributes(clientId);
    const match = getActiveBlockVariation(blockName, attributes);
    const isSynced = (0,build_module/* isReusableBlock */.tk)(blockType) || (0,build_module/* isTemplatePart */.gc)(blockType);
    const syncedTitle = isSynced ? (0,build_module/* __experimentalGetBlockLabel */.Y0)(blockType, attributes) : undefined;
    const title = syncedTitle || blockType.title;
    const positionLabel = getPositionTypeLabel(attributes);
    const blockTypeInfo = {
      isSynced,
      title,
      icon: blockType.icon,
      description: blockType.description,
      anchor: attributes?.anchor,
      positionLabel,
      positionType: attributes?.style?.position?.type,
      name: attributes?.metadata?.name
    };
    if (!match) {
      return blockTypeInfo;
    }
    return {
      isSynced,
      title: match.title || blockType.title,
      icon: match.icon || blockType.icon,
      description: match.description || blockType.description,
      anchor: attributes?.anchor,
      positionLabel,
      positionType: attributes?.style?.position?.type,
      name: attributes?.metadata?.name
    };
  }, [clientId]);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/position.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */







const {
  CustomSelectControl: position_CustomSelectControl
} = lock_unlock_unlock(privateApis);
const POSITION_SUPPORT_KEY = 'position';
const OPTION_CLASSNAME = 'block-editor-hooks__position-selection__select-control__option';
const position_DEFAULT_OPTION = {
  key: 'default',
  value: '',
  name: (0,i18n_build_module.__)('Default'),
  className: OPTION_CLASSNAME
};
const STICKY_OPTION = {
  key: 'sticky',
  value: 'sticky',
  name: (0,i18n_build_module._x)('Sticky', 'Name for the value of the CSS position property'),
  className: OPTION_CLASSNAME,
  __experimentalHint: (0,i18n_build_module.__)('The block will stick to the top of the window instead of scrolling.')
};
const FIXED_OPTION = {
  key: 'fixed',
  value: 'fixed',
  name: (0,i18n_build_module._x)('Fixed', 'Name for the value of the CSS position property'),
  className: OPTION_CLASSNAME,
  __experimentalHint: (0,i18n_build_module.__)('The block will not move when the page is scrolled.')
};
const POSITION_SIDES = ['top', 'right', 'bottom', 'left'];
const VALID_POSITION_TYPES = ['sticky', 'fixed'];

/**
 * Get calculated position CSS.
 *
 * @param {Object} props          Component props.
 * @param {string} props.selector Selector to use.
 * @param {Object} props.style    Style object.
 * @return {string} The generated CSS rules.
 */
function getPositionCSS({
  selector,
  style
}) {
  let output = '';
  const {
    type: positionType
  } = style?.position || {};
  if (!VALID_POSITION_TYPES.includes(positionType)) {
    return output;
  }
  output += `${selector} {`;
  output += `position: ${positionType};`;
  POSITION_SIDES.forEach(side => {
    if (style?.position?.[side] !== undefined) {
      output += `${side}: ${style.position[side]};`;
    }
  });
  if (positionType === 'sticky' || positionType === 'fixed') {
    // TODO: Replace hard-coded z-index value with a z-index preset approach in theme.json.
    output += `z-index: 10`;
  }
  output += `}`;
  return output;
}

/**
 * Determines if there is sticky position support.
 *
 * @param {string|Object} blockType Block name or Block Type object.
 *
 * @return {boolean} Whether there is support.
 */
function hasStickyPositionSupport(blockType) {
  const support = (0,build_module/* getBlockSupport */.bI)(blockType, POSITION_SUPPORT_KEY);
  return !!(true === support || support?.sticky);
}

/**
 * Determines if there is fixed position support.
 *
 * @param {string|Object} blockType Block name or Block Type object.
 *
 * @return {boolean} Whether there is support.
 */
function hasFixedPositionSupport(blockType) {
  const support = (0,build_module/* getBlockSupport */.bI)(blockType, POSITION_SUPPORT_KEY);
  return !!(true === support || support?.fixed);
}

/**
 * Determines if there is position support.
 *
 * @param {string|Object} blockType Block name or Block Type object.
 *
 * @return {boolean} Whether there is support.
 */
function hasPositionSupport(blockType) {
  const support = (0,build_module/* getBlockSupport */.bI)(blockType, POSITION_SUPPORT_KEY);
  return !!support;
}

/**
 * Checks if there is a current value in the position block support attributes.
 *
 * @param {Object} props Block props.
 * @return {boolean} Whether or not the block has a position value set.
 */
function hasPositionValue(props) {
  return props.attributes.style?.position?.type !== undefined;
}

/**
 * Checks if the block is currently set to a sticky or fixed position.
 * This check is helpful for determining how to position block toolbars or other elements.
 *
 * @param {Object} attributes Block attributes.
 * @return {boolean} Whether or not the block is set to a sticky or fixed position.
 */
function hasStickyOrFixedPositionValue(attributes) {
  const positionType = attributes?.style?.position?.type;
  return positionType === 'sticky' || positionType === 'fixed';
}

/**
 * Resets the position block support attributes. This can be used when disabling
 * the position support controls for a block via a `ToolsPanel`.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */
function resetPosition({
  attributes = {},
  setAttributes
}) {
  const {
    style = {}
  } = attributes;
  setAttributes({
    style: cleanEmptyObject({
      ...style,
      position: {
        ...style?.position,
        type: undefined,
        top: undefined,
        right: undefined,
        bottom: undefined,
        left: undefined
      }
    })
  });
}

/**
 * Custom hook that checks if position settings have been disabled.
 *
 * @param {string} name The name of the block.
 *
 * @return {boolean} Whether padding setting is disabled.
 */
function useIsPositionDisabled({
  name: blockName
} = {}) {
  const [allowFixed, allowSticky] = use_settings_useSettings('position.fixed', 'position.sticky');
  const isDisabled = !allowFixed && !allowSticky;
  return !hasPositionSupport(blockName) || isDisabled;
}

/*
 * Position controls rendered in an inspector control panel.
 *
 * @param {Object} props
 *
 * @return {Element} Position panel.
 */
function PositionPanelPure({
  style = {},
  clientId,
  name: blockName,
  setAttributes
}) {
  const allowFixed = hasFixedPositionSupport(blockName);
  const allowSticky = hasStickyPositionSupport(blockName);
  const value = style?.position?.type;
  const {
    firstParentClientId
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockParents
    } = select(store_store);
    const parents = getBlockParents(clientId);
    return {
      firstParentClientId: parents[parents.length - 1]
    };
  }, [clientId]);
  const blockInformation = useBlockDisplayInformation(firstParentClientId);
  const stickyHelpText = allowSticky && value === STICKY_OPTION.value && blockInformation ? (0,i18n_build_module/* sprintf */.nv)( /* translators: %s: the name of the parent block. */
  (0,i18n_build_module.__)('The block will stick to the scrollable area of the parent %s block.'), blockInformation.title) : null;
  const options = (0,react.useMemo)(() => {
    const availableOptions = [position_DEFAULT_OPTION];
    // Display options if they are allowed, or if a block already has a valid value set.
    // This allows for a block to be switched off from a position type that is not allowed.
    if (allowSticky || value === STICKY_OPTION.value) {
      availableOptions.push(STICKY_OPTION);
    }
    if (allowFixed || value === FIXED_OPTION.value) {
      availableOptions.push(FIXED_OPTION);
    }
    return availableOptions;
  }, [allowFixed, allowSticky, value]);
  const onChangeType = next => {
    // For now, use a hard-coded `0px` value for the position.
    // `0px` is preferred over `0` as it can be used in `calc()` functions.
    // In the future, it could be useful to allow for an offset value.
    const placementValue = '0px';
    const newStyle = {
      ...style,
      position: {
        ...style?.position,
        type: next,
        top: next === 'sticky' || next === 'fixed' ? placementValue : undefined
      }
    };
    setAttributes({
      style: utils_cleanEmptyObject(newStyle)
    });
  };
  const selectedOption = value ? options.find(option => option.value === value) || position_DEFAULT_OPTION : position_DEFAULT_OPTION;

  // Only display position controls if there is at least one option to choose from.
  return platform/* default */.A.select({
    web: options.length > 1 ? /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
      group: "position",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default */.Ay, {
        className: "block-editor-hooks__position-selection",
        __nextHasNoMarginBottom: true,
        help: stickyHelpText,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(position_CustomSelectControl, {
          __next40pxDefaultSize: true,
          className: "block-editor-hooks__position-selection__select-control",
          label: (0,i18n_build_module.__)('Position'),
          hideLabelFromVision: true,
          describedBy: (0,i18n_build_module/* sprintf */.nv)(
          // translators: %s: Currently selected position.
          (0,i18n_build_module.__)('Currently selected position: %s'), selectedOption.name),
          options: options,
          value: selectedOption,
          __experimentalShowSelectedHint: true,
          onChange: ({
            selectedItem
          }) => {
            onChangeType(selectedItem.value);
          },
          size: "__unstable-large"
        })
      })
    }) : null,
    native: null
  });
}
/* harmony default export */ const position = ({
  edit: function Edit(props) {
    const isPositionDisabled = useIsPositionDisabled(props);
    if (isPositionDisabled) {
      return null;
    }
    return /*#__PURE__*/(0,jsx_runtime.jsx)(PositionPanelPure, {
      ...props
    });
  },
  useBlockProps: position_useBlockProps,
  attributeKeys: ['style'],
  hasSupport(name) {
    return (0,build_module/* hasBlockSupport */.pN)(name, POSITION_SUPPORT_KEY);
  }
});
function position_useBlockProps({
  name,
  style
}) {
  const hasPositionBlockSupport = (0,build_module/* hasBlockSupport */.pN)(name, POSITION_SUPPORT_KEY);
  const isPositionDisabled = useIsPositionDisabled({
    name
  });
  const allowPositionStyles = hasPositionBlockSupport && !isPositionDisabled;
  const id = (0,use_instance_id/* default */.A)(position_useBlockProps);

  // Higher specificity to override defaults in editor UI.
  const positionSelector = `.wp-container-${id}.wp-container-${id}`;

  // Get CSS string for the current position values.
  let css;
  if (allowPositionStyles) {
    css = getPositionCSS({
      selector: positionSelector,
      style
    }) || '';
  }

  // Attach a `wp-container-` id-based class name.
  const className = (0,dist_clsx/* default */.A)({
    [`wp-container-${id}`]: allowPositionStyles && !!css,
    // Only attach a container class if there is generated CSS to be attached.
    [`is-position-${style?.position?.type}`]: allowPositionStyles && !!css && !!style?.position?.type
  });
  utils_useStyleOverride({
    css
  });
  return {
    className
  };
}
//# sourceMappingURL=position.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/context.js
/**
 * WordPress dependencies
 */

const DEFAULT_GLOBAL_STYLES_CONTEXT = {
  user: {},
  base: {},
  merged: {},
  setUserConfig: () => {}
};
const context_GlobalStylesContext = (0,react.createContext)(DEFAULT_GLOBAL_STYLES_CONTEXT);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/global-styles/use-global-styles-output.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */













// Elements that rely on class names in their selectors.
const ELEMENT_CLASS_NAMES = {
  button: 'wp-element-button',
  caption: 'wp-element-caption'
};

// List of block support features that can have their related styles
// generated under their own feature level selector rather than the block's.
const BLOCK_SUPPORT_FEATURE_LEVEL_SELECTORS = {
  __experimentalBorder: 'border',
  color: 'color',
  spacing: 'spacing',
  typography: 'typography'
};
const {
  kebabCase: use_global_styles_output_kebabCase
} = lock_unlock_unlock(privateApis);
function compileStyleValue(uncompiledValue) {
  const VARIABLE_REFERENCE_PREFIX = 'var:';
  const VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE = '|';
  const VARIABLE_PATH_SEPARATOR_TOKEN_STYLE = '--';
  if (uncompiledValue?.startsWith?.(VARIABLE_REFERENCE_PREFIX)) {
    const variable = uncompiledValue.slice(VARIABLE_REFERENCE_PREFIX.length).split(VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE).join(VARIABLE_PATH_SEPARATOR_TOKEN_STYLE);
    return `var(--wp--${variable})`;
  }
  return uncompiledValue;
}

/**
 * Transform given preset tree into a set of style declarations.
 *
 * @param {Object} blockPresets
 * @param {Object} mergedSettings Merged theme.json settings.
 *
 * @return {Array<Object>} An array of style declarations.
 */
function getPresetsDeclarations(blockPresets = {}, mergedSettings) {
  return PRESET_METADATA.reduce((declarations, {
    path,
    valueKey,
    valueFunc,
    cssVarInfix
  }) => {
    const presetByOrigin = getValueFromObjectPath(blockPresets, path, []);
    ['default', 'theme', 'custom'].forEach(origin => {
      if (presetByOrigin[origin]) {
        presetByOrigin[origin].forEach(value => {
          if (valueKey && !valueFunc) {
            declarations.push(`--wp--preset--${cssVarInfix}--${use_global_styles_output_kebabCase(value.slug)}: ${value[valueKey]}`);
          } else if (valueFunc && typeof valueFunc === 'function') {
            declarations.push(`--wp--preset--${cssVarInfix}--${use_global_styles_output_kebabCase(value.slug)}: ${valueFunc(value, mergedSettings)}`);
          }
        });
      }
    });
    return declarations;
  }, []);
}

/**
 * Transform given preset tree into a set of preset class declarations.
 *
 * @param {?string} blockSelector
 * @param {Object}  blockPresets
 * @return {string} CSS declarations for the preset classes.
 */
function getPresetsClasses(blockSelector = '*', blockPresets = {}) {
  return utils_PRESET_METADATA.reduce((declarations, {
    path,
    cssVarInfix,
    classes
  }) => {
    if (!classes) {
      return declarations;
    }
    const presetByOrigin = object_getValueFromObjectPath(blockPresets, path, []);
    ['default', 'theme', 'custom'].forEach(origin => {
      if (presetByOrigin[origin]) {
        presetByOrigin[origin].forEach(({
          slug
        }) => {
          classes.forEach(({
            classSuffix,
            propertyName
          }) => {
            const classSelectorToUse = `.has-${use_global_styles_output_kebabCase(slug)}-${classSuffix}`;
            const selectorToUse = blockSelector.split(',') // Selector can be "h1, h2, h3"
            .map(selector => `${selector}${classSelectorToUse}`).join(',');
            const value = `var(--wp--preset--${cssVarInfix}--${use_global_styles_output_kebabCase(slug)})`;
            declarations += `${selectorToUse}{${propertyName}: ${value} !important;}`;
          });
        });
      }
    });
    return declarations;
  }, '');
}
function getPresetsSvgFilters(blockPresets = {}) {
  return PRESET_METADATA.filter(
  // Duotone are the only type of filters for now.
  metadata => metadata.path.at(-1) === 'duotone').flatMap(metadata => {
    const presetByOrigin = getValueFromObjectPath(blockPresets, metadata.path, {});
    return ['default', 'theme'].filter(origin => presetByOrigin[origin]).flatMap(origin => presetByOrigin[origin].map(preset => getDuotoneFilter(`wp-duotone-${preset.slug}`, preset.colors))).join('');
  });
}
function flattenTree(input = {}, prefix, token) {
  let result = [];
  Object.keys(input).forEach(key => {
    const newKey = prefix + use_global_styles_output_kebabCase(key.replace('/', '-'));
    const newLeaf = input[key];
    if (newLeaf instanceof Object) {
      const newPrefix = newKey + token;
      result = [...result, ...flattenTree(newLeaf, newPrefix, token)];
    } else {
      result.push(`${newKey}: ${newLeaf}`);
    }
  });
  return result;
}

/**
 * Gets variation selector string from feature selector.
 *
 * @param {string} featureSelector        The feature selector.
 *
 * @param {string} styleVariationSelector The style variation selector.
 * @return {string} Combined selector string.
 */
function concatFeatureVariationSelectorString(featureSelector, styleVariationSelector) {
  const featureSelectors = featureSelector.split(',');
  const combinedSelectors = [];
  featureSelectors.forEach(selector => {
    combinedSelectors.push(`${styleVariationSelector.trim()}${selector.trim()}`);
  });
  return combinedSelectors.join(', ');
}

/**
 * Generate style declarations for a block's custom feature and subfeature
 * selectors.
 *
 * NOTE: The passed `styles` object will be mutated by this function.
 *
 * @param {Object} selectors Custom selectors object for a block.
 * @param {Object} styles    A block's styles object.
 *
 * @return {Object} Style declarations.
 */
const getFeatureDeclarations = (selectors, styles) => {
  const declarations = {};
  Object.entries(selectors).forEach(([feature, selector]) => {
    // We're only processing features/subfeatures that have styles.
    if (feature === 'root' || !styles?.[feature]) {
      return;
    }
    const isShorthand = typeof selector === 'string';

    // If we have a selector object instead of shorthand process it.
    if (!isShorthand) {
      Object.entries(selector).forEach(([subfeature, subfeatureSelector]) => {
        // Don't process root feature selector yet or any
        // subfeature that doesn't have a style.
        if (subfeature === 'root' || !styles?.[feature][subfeature]) {
          return;
        }

        // Create a temporary styles object and build
        // declarations for subfeature.
        const subfeatureStyles = {
          [feature]: {
            [subfeature]: styles[feature][subfeature]
          }
        };
        const newDeclarations = getStylesDeclarations(subfeatureStyles);

        // Merge new declarations in with any others that
        // share the same selector.
        declarations[subfeatureSelector] = [...(declarations[subfeatureSelector] || []), ...newDeclarations];

        // Remove the subfeature's style now it will be
        // included under its own selector not the block's.
        delete styles[feature][subfeature];
      });
    }

    // Now subfeatures have been processed and removed, we can
    // process root, or shorthand, feature selectors.
    if (isShorthand || selector.root) {
      const featureSelector = isShorthand ? selector : selector.root;

      // Create temporary style object and build declarations for feature.
      const featureStyles = {
        [feature]: styles[feature]
      };
      const newDeclarations = getStylesDeclarations(featureStyles);

      // Merge new declarations with any others that share the selector.
      declarations[featureSelector] = [...(declarations[featureSelector] || []), ...newDeclarations];

      // Remove the feature from the block's styles now as it will be
      // included under its own selector not the block's.
      delete styles[feature];
    }
  });
  return declarations;
};

/**
 * Transform given style tree into a set of style declarations.
 *
 * @param {Object}  blockStyles         Block styles.
 *
 * @param {string}  selector            The selector these declarations should attach to.
 *
 * @param {boolean} useRootPaddingAlign Whether to use CSS custom properties in root selector.
 *
 * @param {Object}  tree                A theme.json tree containing layout definitions.
 *
 * @param {boolean} disableRootPadding  Whether to force disable the root padding styles.
 * @return {Array} An array of style declarations.
 */
function getStylesDeclarations(blockStyles = {}, selector = '', useRootPaddingAlign, tree = {}, disableRootPadding = false) {
  const isRoot = ROOT_BLOCK_SELECTOR === selector;
  const output = Object.entries(build_module/* __EXPERIMENTAL_STYLE_PROPERTY */.RY).reduce((declarations, [key, {
    value,
    properties,
    useEngine,
    rootOnly
  }]) => {
    if (rootOnly && !isRoot) {
      return declarations;
    }
    const pathToValue = value;
    if (pathToValue[0] === 'elements' || useEngine) {
      return declarations;
    }
    const styleValue = object_getValueFromObjectPath(blockStyles, pathToValue);

    // Root-level padding styles don't currently support strings with CSS shorthand values.
    // This may change: https://github.com/WordPress/gutenberg/issues/40132.
    if (key === '--wp--style--root--padding' && (typeof styleValue === 'string' || !useRootPaddingAlign)) {
      return declarations;
    }
    if (properties && typeof styleValue !== 'string') {
      Object.entries(properties).forEach(entry => {
        const [name, prop] = entry;
        if (!object_getValueFromObjectPath(styleValue, [prop], false)) {
          // Do not create a declaration
          // for sub-properties that don't have any value.
          return;
        }
        const cssProperty = name.startsWith('--') ? name : use_global_styles_output_kebabCase(name);
        declarations.push(`${cssProperty}: ${compileStyleValue(object_getValueFromObjectPath(styleValue, [prop]))}`);
      });
    } else if (object_getValueFromObjectPath(blockStyles, pathToValue, false)) {
      const cssProperty = key.startsWith('--') ? key : use_global_styles_output_kebabCase(key);
      declarations.push(`${cssProperty}: ${compileStyleValue(object_getValueFromObjectPath(blockStyles, pathToValue))}`);
    }
    return declarations;
  }, []);

  // The goal is to move everything to server side generated engine styles
  // This is temporary as we absorb more and more styles into the engine.
  const extraRules = getCSSRules(blockStyles);
  extraRules.forEach(rule => {
    // Don't output padding properties if padding variables are set or if we're not editing a full template.
    if (isRoot && (useRootPaddingAlign || disableRootPadding) && rule.key.startsWith('padding')) {
      return;
    }
    const cssProperty = rule.key.startsWith('--') ? rule.key : use_global_styles_output_kebabCase(rule.key);
    let ruleValue = rule.value;
    if (typeof ruleValue !== 'string' && ruleValue?.ref) {
      const refPath = ruleValue.ref.split('.');
      ruleValue = compileStyleValue(object_getValueFromObjectPath(tree, refPath));
      // Presence of another ref indicates a reference to another dynamic value.
      // Pointing to another dynamic value is not supported.
      if (!ruleValue || ruleValue?.ref) {
        return;
      }
    }

    // Calculate fluid typography rules where available.
    if (cssProperty === 'font-size') {
      /*
       * getTypographyFontSizeValue() will check
       * if fluid typography has been activated and also
       * whether the incoming value can be converted to a fluid value.
       * Values that already have a "clamp()" function will not pass the test,
       * and therefore the original $value will be returned.
       */
      ruleValue = typography_utils_getTypographyFontSizeValue({
        size: ruleValue
      }, tree?.settings);
    }

    // For aspect ratio to work, other dimensions rules (and Cover block defaults) must be unset.
    // This ensures that a fixed height does not override the aspect ratio.
    if (cssProperty === 'aspect-ratio') {
      output.push('min-height: unset');
    }
    output.push(`${cssProperty}: ${ruleValue}`);
  });
  return output;
}

/**
 * Get generated CSS for layout styles by looking up layout definitions provided
 * in theme.json, and outputting common layout styles, and specific blockGap values.
 *
 * @param {Object}  props
 * @param {Object}  props.layoutDefinitions     Layout definitions, keyed by layout type.
 * @param {Object}  props.style                 A style object containing spacing values.
 * @param {string}  props.selector              Selector used to group together layout styling rules.
 * @param {boolean} props.hasBlockGapSupport    Whether or not the theme opts-in to blockGap support.
 * @param {boolean} props.hasFallbackGapSupport Whether or not the theme allows fallback gap styles.
 * @param {?string} props.fallbackGapValue      An optional fallback gap value if no real gap value is available.
 * @return {string} Generated CSS rules for the layout styles.
 */
function getLayoutStyles({
  layoutDefinitions = LAYOUT_DEFINITIONS,
  style,
  selector,
  hasBlockGapSupport,
  hasFallbackGapSupport,
  fallbackGapValue
}) {
  let ruleset = '';
  let gapValue = hasBlockGapSupport ? getGapCSSValue(style?.spacing?.blockGap) : '';

  // Ensure a fallback gap value for the root layout definitions,
  // and use a fallback value if one is provided for the current block.
  if (hasFallbackGapSupport) {
    if (selector === ROOT_BLOCK_SELECTOR) {
      gapValue = !gapValue ? '0.5em' : gapValue;
    } else if (!hasBlockGapSupport && fallbackGapValue) {
      gapValue = fallbackGapValue;
    }
  }
  if (gapValue && layoutDefinitions) {
    Object.values(layoutDefinitions).forEach(({
      className,
      name,
      spacingStyles
    }) => {
      // Allow outputting fallback gap styles for flex layout type when block gap support isn't available.
      if (!hasBlockGapSupport && 'flex' !== name && 'grid' !== name) {
        return;
      }
      if (spacingStyles?.length) {
        spacingStyles.forEach(spacingStyle => {
          const declarations = [];
          if (spacingStyle.rules) {
            Object.entries(spacingStyle.rules).forEach(([cssProperty, cssValue]) => {
              declarations.push(`${cssProperty}: ${cssValue ? cssValue : gapValue}`);
            });
          }
          if (declarations.length) {
            let combinedSelector = '';
            if (!hasBlockGapSupport) {
              // For fallback gap styles, use lower specificity, to ensure styles do not unintentionally override theme styles.
              combinedSelector = selector === ROOT_BLOCK_SELECTOR ? `:where(.${className}${spacingStyle?.selector || ''})` : `:where(${selector}.${className}${spacingStyle?.selector || ''})`;
            } else {
              combinedSelector = selector === ROOT_BLOCK_SELECTOR ? `:root :where(.${className})${spacingStyle?.selector || ''}` : `:root :where(${selector}-${className})${spacingStyle?.selector || ''}`;
            }
            ruleset += `${combinedSelector} { ${declarations.join('; ')}; }`;
          }
        });
      }
    });
    // For backwards compatibility, ensure the legacy block gap CSS variable is still available.
    if (selector === ROOT_BLOCK_SELECTOR && hasBlockGapSupport) {
      ruleset += `${ROOT_CSS_PROPERTIES_SELECTOR} { --wp--style--block-gap: ${gapValue}; }`;
    }
  }

  // Output base styles
  if (selector === ROOT_BLOCK_SELECTOR && layoutDefinitions) {
    const validDisplayModes = ['block', 'flex', 'grid'];
    Object.values(layoutDefinitions).forEach(({
      className,
      displayMode,
      baseStyles
    }) => {
      if (displayMode && validDisplayModes.includes(displayMode)) {
        ruleset += `${selector} .${className} { display:${displayMode}; }`;
      }
      if (baseStyles?.length) {
        baseStyles.forEach(baseStyle => {
          const declarations = [];
          if (baseStyle.rules) {
            Object.entries(baseStyle.rules).forEach(([cssProperty, cssValue]) => {
              declarations.push(`${cssProperty}: ${cssValue}`);
            });
          }
          if (declarations.length) {
            const combinedSelector = `.${className}${baseStyle?.selector || ''}`;
            ruleset += `${combinedSelector} { ${declarations.join('; ')}; }`;
          }
        });
      }
    });
  }
  return ruleset;
}
const STYLE_KEYS = ['border', 'color', 'dimensions', 'spacing', 'typography', 'filter', 'outline', 'shadow', 'background'];
function pickStyleKeys(treeToPickFrom) {
  if (!treeToPickFrom) {
    return {};
  }
  const entries = Object.entries(treeToPickFrom);
  const pickedEntries = entries.filter(([key]) => STYLE_KEYS.includes(key));
  // clone the style objects so that `getFeatureDeclarations` can remove consumed keys from it
  const clonedEntries = pickedEntries.map(([key, style]) => [key, JSON.parse(JSON.stringify(style))]);
  return Object.fromEntries(clonedEntries);
}
const getNodesWithStyles = (tree, blockSelectors) => {
  var _tree$styles$blocks;
  const nodes = [];
  if (!tree?.styles) {
    return nodes;
  }

  // Top-level.
  const styles = pickStyleKeys(tree.styles);
  if (styles) {
    nodes.push({
      styles,
      selector: ROOT_BLOCK_SELECTOR,
      // Root selector (body) styles should not be wrapped in `:root where()` to keep
      // specificity at (0,0,1) and maintain backwards compatibility.
      skipSelectorWrapper: true
    });
  }
  Object.entries(build_module/* __EXPERIMENTAL_ELEMENTS */.dB).forEach(([name, selector]) => {
    if (tree.styles?.elements?.[name]) {
      nodes.push({
        styles: tree.styles?.elements?.[name],
        selector,
        // Top level elements that don't use a class name should not receive the
        // `:root :where()` wrapper to maintain backwards compatibility.
        skipSelectorWrapper: !ELEMENT_CLASS_NAMES[name]
      });
    }
  });

  // Iterate over blocks: they can have styles & elements.
  Object.entries((_tree$styles$blocks = tree.styles?.blocks) !== null && _tree$styles$blocks !== void 0 ? _tree$styles$blocks : {}).forEach(([blockName, node]) => {
    var _node$elements;
    const blockStyles = pickStyleKeys(node);
    if (node?.variations) {
      const variations = {};
      Object.entries(node.variations).forEach(([variationName, variation]) => {
        var _variation$elements, _variation$blocks;
        variations[variationName] = pickStyleKeys(variation);
        if (variation?.css) {
          variations[variationName].css = variation.css;
        }
        const variationSelector = blockSelectors[blockName]?.styleVariationSelectors?.[variationName];

        // Process the variation's inner element styles.
        // This comes before the inner block styles so the
        // element styles within the block type styles take
        // precedence over these.
        Object.entries((_variation$elements = variation?.elements) !== null && _variation$elements !== void 0 ? _variation$elements : {}).forEach(([element, elementStyles]) => {
          if (elementStyles && build_module/* __EXPERIMENTAL_ELEMENTS */.dB[element]) {
            nodes.push({
              styles: elementStyles,
              selector: scopeSelector(variationSelector, build_module/* __EXPERIMENTAL_ELEMENTS */.dB[element])
            });
          }
        });

        // Process the variations inner block type styles.
        Object.entries((_variation$blocks = variation?.blocks) !== null && _variation$blocks !== void 0 ? _variation$blocks : {}).forEach(([variationBlockName, variationBlockStyles]) => {
          var _variationBlockStyles;
          const variationBlockSelector = scopeSelector(variationSelector, blockSelectors[variationBlockName]?.selector);
          const variationDuotoneSelector = scopeSelector(variationSelector, blockSelectors[variationBlockName]?.duotoneSelector);
          const variationFeatureSelectors = scopeFeatureSelectors(variationSelector, blockSelectors[variationBlockName]?.featureSelectors);
          const variationBlockStyleNodes = pickStyleKeys(variationBlockStyles);
          if (variationBlockStyles?.css) {
            variationBlockStyleNodes.css = variationBlockStyles.css;
          }
          nodes.push({
            selector: variationBlockSelector,
            duotoneSelector: variationDuotoneSelector,
            featureSelectors: variationFeatureSelectors,
            fallbackGapValue: blockSelectors[variationBlockName]?.fallbackGapValue,
            hasLayoutSupport: blockSelectors[variationBlockName]?.hasLayoutSupport,
            styles: variationBlockStyleNodes
          });

          // Process element styles for the inner blocks
          // of the variation.
          Object.entries((_variationBlockStyles = variationBlockStyles.elements) !== null && _variationBlockStyles !== void 0 ? _variationBlockStyles : {}).forEach(([variationBlockElement, variationBlockElementStyles]) => {
            if (variationBlockElementStyles && build_module/* __EXPERIMENTAL_ELEMENTS */.dB[variationBlockElement]) {
              nodes.push({
                styles: variationBlockElementStyles,
                selector: scopeSelector(variationBlockSelector, build_module/* __EXPERIMENTAL_ELEMENTS */.dB[variationBlockElement])
              });
            }
          });
        });
      });
      blockStyles.variations = variations;
    }
    if (blockSelectors?.[blockName]?.selector) {
      nodes.push({
        duotoneSelector: blockSelectors[blockName].duotoneSelector,
        fallbackGapValue: blockSelectors[blockName].fallbackGapValue,
        hasLayoutSupport: blockSelectors[blockName].hasLayoutSupport,
        selector: blockSelectors[blockName].selector,
        styles: blockStyles,
        featureSelectors: blockSelectors[blockName].featureSelectors,
        styleVariationSelectors: blockSelectors[blockName].styleVariationSelectors
      });
    }
    Object.entries((_node$elements = node?.elements) !== null && _node$elements !== void 0 ? _node$elements : {}).forEach(([elementName, value]) => {
      if (value && blockSelectors?.[blockName] && build_module/* __EXPERIMENTAL_ELEMENTS */.dB[elementName]) {
        nodes.push({
          styles: value,
          selector: blockSelectors[blockName]?.selector.split(',').map(sel => {
            const elementSelectors = build_module/* __EXPERIMENTAL_ELEMENTS */.dB[elementName].split(',');
            return elementSelectors.map(elementSelector => sel + ' ' + elementSelector);
          }).join(',')
        });
      }
    });
  });
  return nodes;
};
const getNodesWithSettings = (tree, blockSelectors) => {
  var _tree$settings$blocks;
  const nodes = [];
  if (!tree?.settings) {
    return nodes;
  }
  const pickPresets = treeToPickFrom => {
    let presets = {};
    utils_PRESET_METADATA.forEach(({
      path
    }) => {
      const value = object_getValueFromObjectPath(treeToPickFrom, path, false);
      if (value !== false) {
        presets = object_setImmutably(presets, path, value);
      }
    });
    return presets;
  };

  // Top-level.
  const presets = pickPresets(tree.settings);
  const custom = tree.settings?.custom;
  if (Object.keys(presets).length > 0 || custom) {
    nodes.push({
      presets,
      custom,
      selector: ROOT_CSS_PROPERTIES_SELECTOR
    });
  }

  // Blocks.
  Object.entries((_tree$settings$blocks = tree.settings?.blocks) !== null && _tree$settings$blocks !== void 0 ? _tree$settings$blocks : {}).forEach(([blockName, node]) => {
    const blockPresets = pickPresets(node);
    const blockCustom = node.custom;
    if (Object.keys(blockPresets).length > 0 || blockCustom) {
      nodes.push({
        presets: blockPresets,
        custom: blockCustom,
        selector: blockSelectors[blockName]?.selector
      });
    }
  });
  return nodes;
};
const toCustomProperties = (tree, blockSelectors) => {
  const settings = getNodesWithSettings(tree, blockSelectors);
  let ruleset = '';
  settings.forEach(({
    presets,
    custom,
    selector
  }) => {
    const declarations = getPresetsDeclarations(presets, tree?.settings);
    const customProps = flattenTree(custom, '--wp--custom--', '--');
    if (customProps.length > 0) {
      declarations.push(...customProps);
    }
    if (declarations.length > 0) {
      ruleset += `${selector}{${declarations.join(';')};}`;
    }
  });
  return ruleset;
};
const use_global_styles_output_toStyles = (tree, blockSelectors, hasBlockGapSupport, hasFallbackGapSupport, disableLayoutStyles = false, disableRootPadding = false, styleOptions = undefined) => {
  // These allow opting out of certain sets of styles.
  const options = {
    blockGap: true,
    blockStyles: true,
    layoutStyles: true,
    marginReset: true,
    presets: true,
    rootPadding: true,
    variationStyles: false,
    ...styleOptions
  };
  const nodesWithStyles = getNodesWithStyles(tree, blockSelectors);
  const nodesWithSettings = getNodesWithSettings(tree, blockSelectors);
  const useRootPaddingAlign = tree?.settings?.useRootPaddingAwareAlignments;
  const {
    contentSize,
    wideSize
  } = tree?.settings?.layout || {};
  const hasBodyStyles = options.marginReset || options.rootPadding || options.layoutStyles;
  let ruleset = '';
  if (options.presets && (contentSize || wideSize)) {
    ruleset += `${ROOT_CSS_PROPERTIES_SELECTOR} {`;
    ruleset = contentSize ? ruleset + ` --wp--style--global--content-size: ${contentSize};` : ruleset;
    ruleset = wideSize ? ruleset + ` --wp--style--global--wide-size: ${wideSize};` : ruleset;
    ruleset += '}';
  }
  if (hasBodyStyles) {
    /*
     * Reset default browser margin on the body element.
     * This is set on the body selector **before** generating the ruleset
     * from the `theme.json`. This is to ensure that if the `theme.json` declares
     * `margin` in its `spacing` declaration for the `body` element then these
     * user-generated values take precedence in the CSS cascade.
     * @link https://github.com/WordPress/gutenberg/issues/36147.
     */
    ruleset += ':where(body) {margin: 0;';

    // Root padding styles should be output for full templates, patterns and template parts.
    if (options.rootPadding && useRootPaddingAlign) {
      /*
       * These rules reproduce the ones from https://github.com/WordPress/gutenberg/blob/79103f124925d1f457f627e154f52a56228ed5ad/lib/class-wp-theme-json-gutenberg.php#L2508
       * almost exactly, but for the selectors that target block wrappers in the front end. This code only runs in the editor, so it doesn't need those selectors.
       */
      ruleset += `padding-right: 0; padding-left: 0; padding-top: var(--wp--style--root--padding-top); padding-bottom: var(--wp--style--root--padding-bottom) }
				.has-global-padding { padding-right: var(--wp--style--root--padding-right); padding-left: var(--wp--style--root--padding-left); }
				.has-global-padding > .alignfull { margin-right: calc(var(--wp--style--root--padding-right) * -1); margin-left: calc(var(--wp--style--root--padding-left) * -1); }
				.has-global-padding :where(:not(.alignfull.is-layout-flow) > .has-global-padding:not(.wp-block-block, .alignfull)) { padding-right: 0; padding-left: 0; }
				.has-global-padding :where(:not(.alignfull.is-layout-flow) > .has-global-padding:not(.wp-block-block, .alignfull)) > .alignfull { margin-left: 0; margin-right: 0;
				`;
    }
    ruleset += '}';
  }
  if (options.blockStyles) {
    nodesWithStyles.forEach(({
      selector,
      duotoneSelector,
      styles,
      fallbackGapValue,
      hasLayoutSupport,
      featureSelectors,
      styleVariationSelectors,
      skipSelectorWrapper
    }) => {
      // Process styles for block support features with custom feature level
      // CSS selectors set.
      if (featureSelectors) {
        const featureDeclarations = getFeatureDeclarations(featureSelectors, styles);
        Object.entries(featureDeclarations).forEach(([cssSelector, declarations]) => {
          if (declarations.length) {
            const rules = declarations.join(';');
            ruleset += `:root :where(${cssSelector}){${rules};}`;
          }
        });
      }

      // Process duotone styles.
      if (duotoneSelector) {
        const duotoneStyles = {};
        if (styles?.filter) {
          duotoneStyles.filter = styles.filter;
          delete styles.filter;
        }
        const duotoneDeclarations = getStylesDeclarations(duotoneStyles);
        if (duotoneDeclarations.length) {
          ruleset += `${duotoneSelector}{${duotoneDeclarations.join(';')};}`;
        }
      }

      // Process blockGap and layout styles.
      if (!disableLayoutStyles && (ROOT_BLOCK_SELECTOR === selector || hasLayoutSupport)) {
        ruleset += getLayoutStyles({
          style: styles,
          selector,
          hasBlockGapSupport,
          hasFallbackGapSupport,
          fallbackGapValue
        });
      }

      // Process the remaining block styles (they use either normal block class or __experimentalSelector).
      const styleDeclarations = getStylesDeclarations(styles, selector, useRootPaddingAlign, tree, disableRootPadding);
      if (styleDeclarations?.length) {
        const generalSelector = skipSelectorWrapper ? selector : `:root :where(${selector})`;
        ruleset += `${generalSelector}{${styleDeclarations.join(';')};}`;
      }
      if (styles?.css) {
        ruleset += processCSSNesting(styles.css, `:root :where(${selector})`);
      }
      if (options.variationStyles && styleVariationSelectors) {
        Object.entries(styleVariationSelectors).forEach(([styleVariationName, styleVariationSelector]) => {
          const styleVariations = styles?.variations?.[styleVariationName];
          if (styleVariations) {
            // If the block uses any custom selectors for block support, add those first.
            if (featureSelectors) {
              const featureDeclarations = getFeatureDeclarations(featureSelectors, styleVariations);
              Object.entries(featureDeclarations).forEach(([baseSelector, declarations]) => {
                if (declarations.length) {
                  const cssSelector = concatFeatureVariationSelectorString(baseSelector, styleVariationSelector);
                  const rules = declarations.join(';');
                  ruleset += `:root :where(${cssSelector}){${rules};}`;
                }
              });
            }

            // Otherwise add regular selectors.
            const styleVariationDeclarations = getStylesDeclarations(styleVariations, styleVariationSelector, useRootPaddingAlign, tree);
            if (styleVariationDeclarations.length) {
              ruleset += `:root :where(${styleVariationSelector}){${styleVariationDeclarations.join(';')};}`;
            }
            if (styleVariations?.css) {
              ruleset += processCSSNesting(styleVariations.css, `:root :where(${styleVariationSelector})`);
            }
          }
        });
      }

      // Check for pseudo selector in `styles` and handle separately.
      const pseudoSelectorStyles = Object.entries(styles).filter(([key]) => key.startsWith(':'));
      if (pseudoSelectorStyles?.length) {
        pseudoSelectorStyles.forEach(([pseudoKey, pseudoStyle]) => {
          const pseudoDeclarations = getStylesDeclarations(pseudoStyle);
          if (!pseudoDeclarations?.length) {
            return;
          }

          // `selector` may be provided in a form
          // where block level selectors have sub element
          // selectors appended to them as a comma separated
          // string.
          // e.g. `h1 a,h2 a,h3 a,h4 a,h5 a,h6 a`;
          // Split and append pseudo selector to create
          // the proper rules to target the elements.
          const _selector = selector.split(',').map(sel => sel + pseudoKey).join(',');

          // As pseudo classes such as :hover, :focus etc. have class-level
          // specificity, they must use the `:root :where()` wrapper. This.
          // caps the specificity at `0-1-0` to allow proper nesting of variations
          // and block type element styles.
          const pseudoRule = `:root :where(${_selector}){${pseudoDeclarations.join(';')};}`;
          ruleset += pseudoRule;
        });
      }
    });
  }
  if (options.layoutStyles) {
    /* Add alignment / layout styles */
    ruleset = ruleset + '.wp-site-blocks > .alignleft { float: left; margin-right: 2em; }';
    ruleset = ruleset + '.wp-site-blocks > .alignright { float: right; margin-left: 2em; }';
    ruleset = ruleset + '.wp-site-blocks > .aligncenter { justify-content: center; margin-left: auto; margin-right: auto; }';
  }
  if (options.blockGap && hasBlockGapSupport) {
    // Use fallback of `0.5em` just in case, however if there is blockGap support, there should nearly always be a real value.
    const gapValue = getGapCSSValue(tree?.styles?.spacing?.blockGap) || '0.5em';
    ruleset = ruleset + `:root :where(.wp-site-blocks) > * { margin-block-start: ${gapValue}; margin-block-end: 0; }`;
    ruleset = ruleset + ':root :where(.wp-site-blocks) > :first-child { margin-block-start: 0; }';
    ruleset = ruleset + ':root :where(.wp-site-blocks) > :last-child { margin-block-end: 0; }';
  }
  if (options.presets) {
    nodesWithSettings.forEach(({
      selector,
      presets
    }) => {
      if (ROOT_BLOCK_SELECTOR === selector || ROOT_CSS_PROPERTIES_SELECTOR === selector) {
        // Do not add extra specificity for top-level classes.
        selector = '';
      }
      const classes = getPresetsClasses(selector, presets);
      if (classes.length > 0) {
        ruleset += classes;
      }
    });
  }
  return ruleset;
};
function toSvgFilters(tree, blockSelectors) {
  const nodesWithSettings = getNodesWithSettings(tree, blockSelectors);
  return nodesWithSettings.flatMap(({
    presets
  }) => {
    return getPresetsSvgFilters(presets);
  });
}
const getSelectorsConfig = (blockType, rootSelector) => {
  if (blockType?.selectors && Object.keys(blockType.selectors).length > 0) {
    return blockType.selectors;
  }
  const config = {
    root: rootSelector
  };
  Object.entries(BLOCK_SUPPORT_FEATURE_LEVEL_SELECTORS).forEach(([featureKey, featureName]) => {
    const featureSelector = getBlockCSSSelector(blockType, featureKey);
    if (featureSelector) {
      config[featureName] = featureSelector;
    }
  });
  return config;
};
const use_global_styles_output_getBlockSelectors = (blockTypes, getBlockStyles, variationInstanceId) => {
  const result = {};
  blockTypes.forEach(blockType => {
    const name = blockType.name;
    const selector = getBlockCSSSelector(blockType);
    let duotoneSelector = getBlockCSSSelector(blockType, 'filter.duotone');

    // Keep backwards compatibility for support.color.__experimentalDuotone.
    if (!duotoneSelector) {
      const rootSelector = getBlockCSSSelector(blockType);
      const duotoneSupport = (0,build_module/* getBlockSupport */.bI)(blockType, 'color.__experimentalDuotone', false);
      duotoneSelector = duotoneSupport && scopeSelector(rootSelector, duotoneSupport);
    }
    const hasLayoutSupport = !!blockType?.supports?.layout || !!blockType?.supports?.__experimentalLayout;
    const fallbackGapValue = blockType?.supports?.spacing?.blockGap?.__experimentalDefault;
    const blockStyleVariations = getBlockStyles(name);
    const styleVariationSelectors = {};
    blockStyleVariations?.forEach(variation => {
      const variationSuffix = variationInstanceId ? `-${variationInstanceId}` : '';
      const variationName = `${variation.name}${variationSuffix}`;
      const styleVariationSelector = getBlockStyleVariationSelector(variationName, selector);
      styleVariationSelectors[variationName] = styleVariationSelector;
    });

    // For each block support feature add any custom selectors.
    const featureSelectors = getSelectorsConfig(blockType, selector);
    result[name] = {
      duotoneSelector,
      fallbackGapValue,
      featureSelectors: Object.keys(featureSelectors).length ? featureSelectors : undefined,
      hasLayoutSupport,
      name,
      selector,
      styleVariationSelectors: blockStyleVariations?.length ? styleVariationSelectors : undefined
    };
  });
  return result;
};

/**
 * If there is a separator block whose color is defined in theme.json via background,
 * update the separator color to the same value by using border color.
 *
 * @param {Object} config Theme.json configuration file object.
 * @return {Object} configTheme.json configuration file object updated.
 */
function updateConfigWithSeparator(config) {
  const needsSeparatorStyleUpdate = config.styles?.blocks?.['core/separator'] && config.styles?.blocks?.['core/separator'].color?.background && !config.styles?.blocks?.['core/separator'].color?.text && !config.styles?.blocks?.['core/separator'].border?.color;
  if (needsSeparatorStyleUpdate) {
    return {
      ...config,
      styles: {
        ...config.styles,
        blocks: {
          ...config.styles.blocks,
          'core/separator': {
            ...config.styles.blocks['core/separator'],
            color: {
              ...config.styles.blocks['core/separator'].color,
              text: config.styles?.blocks['core/separator'].color.background
            }
          }
        }
      }
    };
  }
  return config;
}
function processCSSNesting(css, blockSelector) {
  let processedCSS = '';
  if (!css || css.trim() === '') {
    return processedCSS;
  }

  // Split CSS nested rules.
  const parts = css.split('&');
  parts.forEach(part => {
    if (!part || part.trim() === '') {
      return;
    }
    const isRootCss = !part.includes('{');
    if (isRootCss) {
      // If the part doesn't contain braces, it applies to the root level.
      processedCSS += `:root :where(${blockSelector}){${part.trim()}}`;
    } else {
      // If the part contains braces, it's a nested CSS rule.
      const splittedPart = part.replace('}', '').split('{');
      if (splittedPart.length !== 2) {
        return;
      }
      const [nestedSelector, cssValue] = splittedPart;

      // Handle pseudo elements such as ::before, ::after, etc. Regex will also
      // capture any leading combinator such as >, +, or ~, as well as spaces.
      // This allows pseudo elements as descendants e.g. `.parent ::before`.
      const matches = nestedSelector.match(/([>+~\s]*::[a-zA-Z-]+)/);
      const pseudoPart = matches ? matches[1] : '';
      const withoutPseudoElement = matches ? nestedSelector.replace(pseudoPart, '').trim() : nestedSelector.trim();
      let combinedSelector;
      if (withoutPseudoElement === '') {
        // Only contained a pseudo element to use the block selector to form
        // the final `:root :where()` selector.
        combinedSelector = blockSelector;
      } else {
        // If the nested selector is a descendant of the block scope it with the
        // block selector. Otherwise append it to the block selector.
        combinedSelector = nestedSelector.startsWith(' ') ? scopeSelector(blockSelector, withoutPseudoElement) : appendToSelector(blockSelector, withoutPseudoElement);
      }

      // Build final rule, re-adding any pseudo element outside the `:where()`
      // to maintain valid CSS selector.
      processedCSS += `:root :where(${combinedSelector})${pseudoPart}{${cssValue.trim()}}`;
    }
  });
  return processedCSS;
}

/**
 * Returns the global styles output using a global styles configuration.
 * If wishing to generate global styles and settings based on the
 * global styles config loaded in the editor context, use `useGlobalStylesOutput()`.
 * The use case for a custom config is to generate bespoke styles
 * and settings for previews, or other out-of-editor experiences.
 *
 * @param {Object}  mergedConfig       Global styles configuration.
 * @param {boolean} disableRootPadding Disable root padding styles.
 *
 * @return {Array} Array of stylesheets and settings.
 */
function useGlobalStylesOutputWithConfig(mergedConfig = {}, disableRootPadding) {
  const [blockGap] = useGlobalSetting('spacing.blockGap');
  mergedConfig = setThemeFileUris(mergedConfig, mergedConfig?._links?.['wp:theme-file']);
  const hasBlockGapSupport = blockGap !== null;
  const hasFallbackGapSupport = !hasBlockGapSupport; // This setting isn't useful yet: it exists as a placeholder for a future explicit fallback styles support.
  const disableLayoutStyles = useSelect(select => {
    const {
      getSettings
    } = select(blockEditorStore);
    return !!getSettings().disableLayoutStyles;
  });
  const {
    getBlockStyles
  } = useSelect(blocksStore);
  return useMemo(() => {
    var _updatedConfig$styles;
    if (!mergedConfig?.styles || !mergedConfig?.settings) {
      return [];
    }
    const updatedConfig = updateConfigWithSeparator(mergedConfig);
    const blockSelectors = use_global_styles_output_getBlockSelectors(getBlockTypes(), getBlockStyles);
    const customProperties = toCustomProperties(updatedConfig, blockSelectors);
    const globalStyles = use_global_styles_output_toStyles(updatedConfig, blockSelectors, hasBlockGapSupport, hasFallbackGapSupport, disableLayoutStyles, disableRootPadding);
    const svgs = toSvgFilters(updatedConfig, blockSelectors);
    const styles = [{
      css: customProperties,
      isGlobalStyles: true
    }, {
      css: globalStyles,
      isGlobalStyles: true
    },
    // Load custom CSS in own stylesheet so that any invalid CSS entered in the input won't break all the global styles in the editor.
    {
      css: (_updatedConfig$styles = updatedConfig.styles.css) !== null && _updatedConfig$styles !== void 0 ? _updatedConfig$styles : '',
      isGlobalStyles: true
    }, {
      assets: svgs,
      __unstableType: 'svg',
      isGlobalStyles: true
    }];

    // Loop through the blocks to check if there are custom CSS values.
    // If there are, get the block selector and push the selector together with
    // the CSS value to the 'stylesheets' array.
    getBlockTypes().forEach(blockType => {
      if (updatedConfig.styles.blocks[blockType.name]?.css) {
        const selector = blockSelectors[blockType.name].selector;
        styles.push({
          css: processCSSNesting(updatedConfig.styles.blocks[blockType.name]?.css, selector),
          isGlobalStyles: true
        });
      }
    });
    return [styles, updatedConfig.settings];
  }, [hasBlockGapSupport, hasFallbackGapSupport, mergedConfig, disableLayoutStyles, disableRootPadding, getBlockStyles]);
}

/**
 * Returns the global styles output based on the current state of global styles config loaded in the editor context.
 *
 * @param {boolean} disableRootPadding Disable root padding styles.
 *
 * @return {Array} Array of stylesheets and settings.
 */
function useGlobalStylesOutput(disableRootPadding = false) {
  const {
    merged: mergedConfig
  } = useContext(GlobalStylesContext);
  return useGlobalStylesOutputWithConfig(mergedConfig, disableRootPadding);
}
//# sourceMappingURL=use-global-styles-output.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/block-style-variation.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */








const VARIATION_PREFIX = 'is-style-';
function getVariationMatches(className) {
  if (!className) {
    return [];
  }
  return className.split(/\s+/).reduce((matches, name) => {
    if (name.startsWith(VARIATION_PREFIX)) {
      const match = name.slice(VARIATION_PREFIX.length);
      if (match !== 'default') {
        matches.push(match);
      }
    }
    return matches;
  }, []);
}

/**
 * Get the first block style variation that has been registered from the class string.
 *
 * @param {string} className        CSS class string for a block.
 * @param {Array}  registeredStyles Currently registered block styles.
 *
 * @return {string|null} The name of the first registered variation.
 */
function getVariationNameFromClass(className, registeredStyles = []) {
  // The global flag affects how capturing groups work in JS. So the regex
  // below will only return full CSS classes not just the variation name.
  const matches = getVariationMatches(className);
  if (!matches) {
    return null;
  }
  for (const variation of matches) {
    if (registeredStyles.some(style => style.name === variation)) {
      return variation;
    }
  }
  return null;
}

// A helper component to apply a style override using the useStyleOverride hook.
function OverrideStyles({
  override
}) {
  useStyleOverride(override);
}

/**
 * This component is used to generate new block style variation overrides
 * based on an incoming theme config. If a matching style is found in the config,
 * a new override is created and returned. The overrides can be used in conjunction with
 * useStyleOverride to apply the new styles to the editor. Its use is
 * subject to change.
 *
 * @param {Object} props        Props.
 * @param {Object} props.config A global styles object, containing settings and styles.
 * @return {JSX.Element|undefined} An array of new block variation overrides.
 */
function __unstableBlockStyleVariationOverridesWithConfig({
  config
}) {
  const {
    getBlockStyles,
    overrides
  } = useSelect(select => ({
    getBlockStyles: select(blocksStore).getBlockStyles,
    overrides: unlock(select(blockEditorStore)).getStyleOverrides()
  }), []);
  const {
    getBlockName
  } = useSelect(blockEditorStore);
  const overridesWithConfig = useMemo(() => {
    if (!overrides?.length) {
      return;
    }
    const newOverrides = [];
    const overriddenClientIds = [];
    for (const [, override] of overrides) {
      if (override?.variation && override?.clientId &&
      /*
       * Because this component overwrites existing style overrides,
       * filter out any overrides that are already present in the store.
       */
      !overriddenClientIds.includes(override.clientId)) {
        const blockName = getBlockName(override.clientId);
        const configStyles = config?.styles?.blocks?.[blockName]?.variations?.[override.variation];
        if (configStyles) {
          const variationConfig = {
            settings: config?.settings,
            // The variation style data is all that is needed to generate
            // the styles for the current application to a block. The variation
            // name is updated to match the instance specific class name.
            styles: {
              blocks: {
                [blockName]: {
                  variations: {
                    [`${override.variation}-${override.clientId}`]: configStyles
                  }
                }
              }
            }
          };
          const blockSelectors = getBlockSelectors(getBlockTypes(), getBlockStyles, override.clientId);
          const hasBlockGapSupport = false;
          const hasFallbackGapSupport = true;
          const disableLayoutStyles = true;
          const disableRootPadding = true;
          const variationStyles = toStyles(variationConfig, blockSelectors, hasBlockGapSupport, hasFallbackGapSupport, disableLayoutStyles, disableRootPadding, {
            blockGap: false,
            blockStyles: true,
            layoutStyles: false,
            marginReset: false,
            presets: false,
            rootPadding: false,
            variationStyles: true
          });
          newOverrides.push({
            id: `${override.variation}-${override.clientId}`,
            css: variationStyles,
            __unstableType: 'variation',
            variation: override.variation,
            // The clientId will be stored with the override and used to ensure
            // the order of overrides matches the order of blocks so that the
            // correct CSS cascade is maintained.
            clientId: override.clientId
          });
          overriddenClientIds.push(override.clientId);
        }
      }
    }
    return newOverrides;
  }, [config, overrides, getBlockStyles, getBlockName]);
  if (!overridesWithConfig || !overridesWithConfig.length) {
    return;
  }
  return /*#__PURE__*/_jsx(_Fragment, {
    children: overridesWithConfig.map(override => /*#__PURE__*/_jsx(OverrideStyles, {
      override: override
    }, override.id))
  });
}

/**
 * Retrieves any variation styles data and resolves any referenced values.
 *
 * @param {Object}    globalStyles A complete global styles object, containing settings and styles.
 * @param {string}    name         The name of the desired block type.
 * @param {variation} variation    The of the block style variation to retrieve data for.
 *
 * @return {Object|undefined} The global styles data for the specified variation.
 */
function getVariationStylesWithRefValues(globalStyles, name, variation) {
  if (!globalStyles?.styles?.blocks?.[name]?.variations?.[variation]) {
    return;
  }

  // Helper to recursively look for `ref` values to resolve.
  const replaceRefs = variationStyles => {
    Object.keys(variationStyles).forEach(key => {
      const value = variationStyles[key];

      // Only process objects.
      if (typeof value === 'object' && value !== null) {
        // Process `ref` value if present.
        if (value.ref !== undefined) {
          if (typeof value.ref !== 'string' || value.ref.trim() === '') {
            // Remove invalid ref.
            delete variationStyles[key];
          } else {
            // Resolve `ref` value.
            const refValue = object_getValueFromObjectPath(globalStyles, value.ref);
            if (refValue) {
              variationStyles[key] = refValue;
            } else {
              delete variationStyles[key];
            }
          }
        } else {
          // Recursively resolve `ref` values in nested objects.
          replaceRefs(value);

          // After recursion, if value is empty due to explicitly
          // `undefined` ref value, remove it.
          if (Object.keys(value).length === 0) {
            delete variationStyles[key];
          }
        }
      }
    });
  };

  // Deep clone variation node to avoid mutating it within global styles and losing refs.
  const styles = JSON.parse(JSON.stringify(globalStyles.styles.blocks[name].variations[variation]));
  replaceRefs(styles);
  return styles;
}
function useBlockStyleVariation(name, variation, clientId) {
  // Prefer global styles data in GlobalStylesContext, which are available
  // if in the site editor. Otherwise fall back to whatever is in the
  // editor settings and available in the post editor.
  const {
    merged: mergedConfig
  } = (0,react.useContext)(context_GlobalStylesContext);
  const {
    globalSettings,
    globalStyles
  } = (0,use_select/* default */.A)(select => {
    const settings = select(store_store).getSettings();
    return {
      globalSettings: settings.__experimentalFeatures,
      globalStyles: settings[globalStylesDataKey]
    };
  }, []);
  return (0,react.useMemo)(() => {
    var _mergedConfig$setting, _mergedConfig$styles, _mergedConfig$setting2;
    const variationStyles = getVariationStylesWithRefValues({
      settings: (_mergedConfig$setting = mergedConfig?.settings) !== null && _mergedConfig$setting !== void 0 ? _mergedConfig$setting : globalSettings,
      styles: (_mergedConfig$styles = mergedConfig?.styles) !== null && _mergedConfig$styles !== void 0 ? _mergedConfig$styles : globalStyles
    }, name, variation);
    return {
      settings: (_mergedConfig$setting2 = mergedConfig?.settings) !== null && _mergedConfig$setting2 !== void 0 ? _mergedConfig$setting2 : globalSettings,
      // The variation style data is all that is needed to generate
      // the styles for the current application to a block. The variation
      // name is updated to match the instance specific class name.
      styles: {
        blocks: {
          [name]: {
            variations: {
              [`${variation}-${clientId}`]: variationStyles
            }
          }
        }
      }
    };
  }, [mergedConfig, globalSettings, globalStyles, variation, clientId, name]);
}

// Rather than leveraging `useInstanceId` here, the `clientId` is used.
// This is so that the variation style override's ID is predictable
// when the order of applied style variations changes.
function block_style_variation_useBlockProps({
  name,
  className,
  clientId
}) {
  const {
    getBlockStyles
  } = (0,use_select/* default */.A)(build_module/* store */.M_);
  const registeredStyles = getBlockStyles(name);
  const variation = getVariationNameFromClass(className, registeredStyles);
  const variationClass = `${VARIATION_PREFIX}${variation}-${clientId}`;
  const {
    settings,
    styles
  } = useBlockStyleVariation(name, variation, clientId);
  const variationStyles = (0,react.useMemo)(() => {
    if (!variation) {
      return;
    }
    const variationConfig = {
      settings,
      styles
    };
    const blockSelectors = use_global_styles_output_getBlockSelectors((0,build_module/* getBlockTypes */.li)(), getBlockStyles, clientId);
    const hasBlockGapSupport = false;
    const hasFallbackGapSupport = true;
    const disableLayoutStyles = true;
    const disableRootPadding = true;
    return use_global_styles_output_toStyles(variationConfig, blockSelectors, hasBlockGapSupport, hasFallbackGapSupport, disableLayoutStyles, disableRootPadding, {
      blockGap: false,
      blockStyles: true,
      layoutStyles: false,
      marginReset: false,
      presets: false,
      rootPadding: false,
      variationStyles: true
    });
  }, [variation, settings, styles, getBlockStyles, clientId]);
  utils_useStyleOverride({
    id: `variation-${clientId}`,
    css: variationStyles,
    __unstableType: 'variation',
    variation,
    // The clientId will be stored with the override and used to ensure
    // the order of overrides matches the order of blocks so that the
    // correct CSS cascade is maintained.
    clientId
  });
  return variation ? {
    className: variationClass
  } : {};
}
/* harmony default export */ const block_style_variation = ({
  hasSupport: () => true,
  attributeKeys: ['className'],
  isMatch: ({
    className
  }) => getVariationMatches(className).length > 0,
  useBlockProps: block_style_variation_useBlockProps
});
//# sourceMappingURL=block-style-variation.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-up.js
var chevron_up = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-up.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-down.js
var library_chevron_down = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-down.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/panel/body.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






const body_noop = () => {};
function UnforwardedPanelBody(props, ref) {
  const {
    buttonProps = {},
    children,
    className,
    icon,
    initialOpen,
    onToggle = body_noop,
    opened,
    title,
    scrollAfterOpen = true
  } = props;
  const [isOpened, setIsOpened] = use_controlled_state(opened, {
    initial: initialOpen === undefined ? true : initialOpen,
    fallback: false
  });
  const nodeRef = (0,react.useRef)(null);

  // Defaults to 'smooth' scrolling
  // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
  const scrollBehavior = (0,use_reduced_motion/* default */.A)() ? 'auto' : 'smooth';
  const handleOnToggle = event => {
    event.preventDefault();
    const next = !isOpened;
    setIsOpened(next);
    onToggle(next);
  };

  // Ref is used so that the effect does not re-run upon scrollAfterOpen changing value.
  const scrollAfterOpenRef = (0,react.useRef)();
  scrollAfterOpenRef.current = scrollAfterOpen;
  // Runs after initial render.
  (0,use_update_effect/* default */.A)(() => {
    if (isOpened && scrollAfterOpenRef.current && nodeRef.current?.scrollIntoView) {
      /*
       * Scrolls the content into view when visible.
       * This improves the UX when there are multiple stacking <PanelBody />
       * components in a scrollable container.
       */
      nodeRef.current.scrollIntoView({
        inline: 'nearest',
        block: 'nearest',
        behavior: scrollBehavior
      });
    }
  }, [isOpened, scrollBehavior]);
  const classes = (0,dist_clsx/* default */.A)('components-panel__body', className, {
    'is-opened': isOpened
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: classes,
    ref: (0,use_merge_refs/* default */.A)([nodeRef, ref]),
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(PanelBodyTitle, {
      icon: icon,
      isOpened: Boolean(isOpened),
      onClick: handleOnToggle,
      title: title,
      ...buttonProps
    }), typeof children === 'function' ? children({
      opened: Boolean(isOpened)
    }) : isOpened && children]
  });
}
const PanelBodyTitle = (0,react.forwardRef)(({
  isOpened,
  icon,
  title,
  ...props
}, ref) => {
  if (!title) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)("h2", {
    className: "components-panel__body-title",
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(build_module_button/* default */.Ay, {
      className: "components-panel__body-toggle",
      "aria-expanded": isOpened,
      ref: ref,
      ...props,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        "aria-hidden": "true",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
          className: "components-panel__arrow",
          icon: isOpened ? chevron_up/* default */.A : library_chevron_down/* default */.A
        })
      }), title, icon && /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
        icon: icon,
        className: "components-panel__icon",
        size: 20
      })]
    })
  });
});
const PanelBody = (0,react.forwardRef)(UnforwardedPanelBody);
/* harmony default export */ const body = (PanelBody);
//# sourceMappingURL=body.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/button-group/index.js
var button_group = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/button-group/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/layout.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */











const layoutBlockSupportKey = 'layout';
const {
  kebabCase: layout_kebabCase
} = lock_unlock_unlock(privateApis);
function hasLayoutBlockSupport(blockName) {
  return (0,build_module/* hasBlockSupport */.pN)(blockName, 'layout') || (0,build_module/* hasBlockSupport */.pN)(blockName, '__experimentalLayout');
}

/**
 * Generates the utility classnames for the given block's layout attributes.
 *
 * @param { Object } blockAttributes Block attributes.
 * @param { string } blockName       Block name.
 *
 * @return { Array } Array of CSS classname strings.
 */
function useLayoutClasses(blockAttributes = {}, blockName = '') {
  const {
    layout
  } = blockAttributes;
  const {
    default: defaultBlockLayout
  } = (0,build_module/* getBlockSupport */.bI)(blockName, layoutBlockSupportKey) || {};
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? {
    ...layout,
    type: 'constrained'
  } : layout || defaultBlockLayout || {};
  const layoutClassnames = [];
  if (LAYOUT_DEFINITIONS[usedLayout?.type || 'default']?.className) {
    const baseClassName = LAYOUT_DEFINITIONS[usedLayout?.type || 'default']?.className;
    const splitBlockName = blockName.split('/');
    const fullBlockName = splitBlockName[0] === 'core' ? splitBlockName.pop() : splitBlockName.join('-');
    const compoundClassName = `wp-block-${fullBlockName}-${baseClassName}`;
    layoutClassnames.push(baseClassName, compoundClassName);
  }
  const hasGlobalPadding = (0,use_select/* default */.A)(select => {
    return (usedLayout?.inherit || usedLayout?.contentSize || usedLayout?.type === 'constrained') && select(store_store).getSettings().__experimentalFeatures?.useRootPaddingAwareAlignments;
  }, [usedLayout?.contentSize, usedLayout?.inherit, usedLayout?.type]);
  if (hasGlobalPadding) {
    layoutClassnames.push('has-global-padding');
  }
  if (usedLayout?.orientation) {
    layoutClassnames.push(`is-${layout_kebabCase(usedLayout.orientation)}`);
  }
  if (usedLayout?.justifyContent) {
    layoutClassnames.push(`is-content-justification-${layout_kebabCase(usedLayout.justifyContent)}`);
  }
  if (usedLayout?.flexWrap && usedLayout.flexWrap === 'nowrap') {
    layoutClassnames.push('is-nowrap');
  }
  return layoutClassnames;
}

/**
 * Generates a CSS rule with the given block's layout styles.
 *
 * @param { Object } blockAttributes Block attributes.
 * @param { string } blockName       Block name.
 * @param { string } selector        A selector to use in generating the CSS rule.
 *
 * @return { string } CSS rule.
 */
function useLayoutStyles(blockAttributes = {}, blockName, selector) {
  const {
    layout = {},
    style = {}
  } = blockAttributes;
  // Update type for blocks using legacy layouts.
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? {
    ...layout,
    type: 'constrained'
  } : layout || {};
  const fullLayoutType = getLayoutType(usedLayout?.type || 'default');
  const [blockGapSupport] = useSettings('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null;
  return fullLayoutType?.getLayoutStyle?.({
    blockName,
    selector,
    layout,
    style,
    hasBlockGapSupport
  });
}
function LayoutPanelPure({
  layout,
  setAttributes,
  name: blockName,
  clientId
}) {
  const settings = useBlockSettings(blockName);
  // Block settings come from theme.json under settings.[blockName].
  const {
    layout: layoutSettings
  } = settings;
  const {
    themeSupportsLayout
  } = (0,use_select/* default */.A)(select => {
    const {
      getSettings
    } = select(store_store);
    return {
      themeSupportsLayout: getSettings().supportsLayout
    };
  }, []);
  const blockEditingMode = useBlockEditingMode();
  if (blockEditingMode !== 'default') {
    return null;
  }

  // Layout block support comes from the block's block.json.
  const layoutBlockSupport = (0,build_module/* getBlockSupport */.bI)(blockName, layoutBlockSupportKey, {});
  const blockSupportAndThemeSettings = {
    ...layoutSettings,
    ...layoutBlockSupport
  };
  const {
    allowSwitching,
    allowEditing = true,
    allowInheriting = true,
    default: defaultBlockLayout
  } = blockSupportAndThemeSettings;
  if (!allowEditing) {
    return null;
  }

  /*
   * Try to find the layout type from either the
   * block's layout settings or any saved layout config.
   */
  const blockSupportAndLayout = {
    ...layoutBlockSupport,
    ...layout
  };
  const {
    type,
    default: {
      type: defaultType = 'default'
    } = {}
  } = blockSupportAndLayout;
  const blockLayoutType = type || defaultType;

  // Only show the inherit toggle if it's supported,
  // and either the default / flow or the constrained layout type is in use, as the toggle switches from one to the other.
  const showInheritToggle = !!(allowInheriting && (!blockLayoutType || blockLayoutType === 'default' || blockLayoutType === 'constrained' || blockSupportAndLayout.inherit));
  const usedLayout = layout || defaultBlockLayout || {};
  const {
    inherit = false,
    contentSize = null
  } = usedLayout;
  /**
   * `themeSupportsLayout` is only relevant to the `default/flow` or
   * `constrained` layouts and it should not be taken into account when other
   * `layout` types are used.
   */
  if ((blockLayoutType === 'default' || blockLayoutType === 'constrained') && !themeSupportsLayout) {
    return null;
  }
  const layoutType = layouts_getLayoutType(blockLayoutType);
  const constrainedType = layouts_getLayoutType('constrained');
  const displayControlsForLegacyLayouts = !usedLayout.type && (contentSize || inherit);
  const hasContentSizeOrLegacySettings = !!inherit || !!contentSize;
  const onChangeType = newType => setAttributes({
    layout: {
      type: newType
    }
  });
  const onChangeLayout = newLayout => setAttributes({
    layout: newLayout
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(body, {
        title: (0,i18n_build_module.__)('Layout'),
        children: [showInheritToggle && /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_control/* default */.A, {
            __nextHasNoMarginBottom: true,
            className: "block-editor-hooks__toggle-control",
            label: (0,i18n_build_module.__)('Inner blocks use content width'),
            checked: layoutType?.name === 'constrained' || hasContentSizeOrLegacySettings,
            onChange: () => setAttributes({
              layout: {
                type: layoutType?.name === 'constrained' || hasContentSizeOrLegacySettings ? 'default' : 'constrained'
              }
            }),
            help: layoutType?.name === 'constrained' || hasContentSizeOrLegacySettings ? (0,i18n_build_module.__)('Nested blocks use content width with options for full and wide widths.') : (0,i18n_build_module.__)('Nested blocks will fill the width of this container. Toggle to constrain.')
          })
        }), !inherit && allowSwitching && /*#__PURE__*/(0,jsx_runtime.jsx)(LayoutTypeSwitcher, {
          type: blockLayoutType,
          onChange: onChangeType
        }), layoutType && layoutType.name !== 'default' && /*#__PURE__*/(0,jsx_runtime.jsx)(layoutType.inspectorControls, {
          layout: usedLayout,
          onChange: onChangeLayout,
          layoutBlockSupport: blockSupportAndThemeSettings,
          name: blockName,
          clientId: clientId
        }), constrainedType && displayControlsForLegacyLayouts && /*#__PURE__*/(0,jsx_runtime.jsx)(constrainedType.inspectorControls, {
          layout: usedLayout,
          onChange: onChangeLayout,
          layoutBlockSupport: blockSupportAndThemeSettings,
          name: blockName,
          clientId: clientId
        })]
      })
    }), !inherit && layoutType && /*#__PURE__*/(0,jsx_runtime.jsx)(layoutType.toolBarControls, {
      layout: usedLayout,
      onChange: onChangeLayout,
      layoutBlockSupport: layoutBlockSupport,
      name: blockName,
      clientId: clientId
    })]
  });
}
/* harmony default export */ const layout = ({
  shareWithChildBlocks: true,
  edit: LayoutPanelPure,
  attributeKeys: ['layout'],
  hasSupport(name) {
    return hasLayoutBlockSupport(name);
  }
});
function LayoutTypeSwitcher({
  type,
  onChange
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(button_group/* default */.A, {
    children: getLayoutTypes().map(({
      name,
      label
    }) => {
      return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        isPressed: type === name,
        onClick: () => onChange(name),
        children: label
      }, name);
    })
  });
}

/**
 * Filters registered block settings, extending attributes to include `layout`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function layout_addAttribute(settings) {
  var _settings$attributes$;
  if ('type' in ((_settings$attributes$ = settings.attributes?.layout) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  }
  if (hasLayoutBlockSupport(settings)) {
    settings.attributes = {
      ...settings.attributes,
      layout: {
        type: 'object'
      }
    };
  }
  return settings;
}
function BlockWithLayoutStyles({
  block: BlockListBlock,
  props,
  blockGapSupport,
  layoutClasses
}) {
  const {
    name,
    attributes
  } = props;
  const id = (0,use_instance_id/* default */.A)(BlockListBlock);
  const {
    layout
  } = attributes;
  const {
    default: defaultBlockLayout
  } = (0,build_module/* getBlockSupport */.bI)(name, layoutBlockSupportKey) || {};
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? {
    ...layout,
    type: 'constrained'
  } : layout || defaultBlockLayout || {};
  const selectorPrefix = `wp-container-${layout_kebabCase(name)}-is-layout-`;
  // Higher specificity to override defaults from theme.json.
  const selector = `.${selectorPrefix}${id}`;
  const hasBlockGapSupport = blockGapSupport !== null;

  // Get CSS string for the current layout type.
  // The CSS and `style` element is only output if it is not empty.
  const fullLayoutType = layouts_getLayoutType(usedLayout?.type || 'default');
  const css = fullLayoutType?.getLayoutStyle?.({
    blockName: name,
    selector,
    layout: usedLayout,
    style: attributes?.style,
    hasBlockGapSupport
  });

  // Attach a `wp-container-` id-based class name as well as a layout class name such as `is-layout-flex`.
  const layoutClassNames = (0,dist_clsx/* default */.A)({
    [`${selectorPrefix}${id}`]: !!css // Only attach a container class if there is generated CSS to be attached.
  }, layoutClasses);
  utils_useStyleOverride({
    css
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockListBlock, {
    ...props,
    __unstableLayoutClassNames: layoutClassNames
  });
}

/**
 * Override the default block element to add the layout styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */
const withLayoutStyles = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockListBlock => props => {
  const {
    clientId,
    name,
    attributes
  } = props;
  const blockSupportsLayout = hasLayoutBlockSupport(name);
  const layoutClasses = useLayoutClasses(attributes, name);
  const extraProps = (0,use_select/* default */.A)(select => {
    // The callback returns early to avoid block editor subscription.
    if (!blockSupportsLayout) {
      return;
    }
    const {
      getSettings,
      getBlockSettings
    } = lock_unlock_unlock(select(store_store));
    const {
      disableLayoutStyles
    } = getSettings();
    if (disableLayoutStyles) {
      return;
    }
    const [blockGapSupport] = getBlockSettings(clientId, 'spacing.blockGap');
    return {
      blockGapSupport
    };
  }, [blockSupportsLayout, clientId]);
  if (!extraProps) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockListBlock, {
      ...props,
      __unstableLayoutClassNames: blockSupportsLayout ? layoutClasses : undefined
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockWithLayoutStyles, {
    block: BlockListBlock,
    props: props,
    layoutClasses: layoutClasses,
    ...extraProps
  });
}, 'withLayoutStyles');
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/layout/addAttribute', layout_addAttribute);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockListBlock', 'core/editor/layout/with-layout-styles', withLayoutStyles);
//# sourceMappingURL=layout.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/index.js
var react_dom = __webpack_require__("../../node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/re-resizable@6.9.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/re-resizable/lib/resizer.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var rowSizeBase = {
    width: '100%',
    height: '10px',
    top: '0px',
    left: '0px',
    cursor: 'row-resize',
};
var colSizeBase = {
    width: '10px',
    height: '100%',
    top: '0px',
    left: '0px',
    cursor: 'col-resize',
};
var edgeBase = {
    width: '20px',
    height: '20px',
    position: 'absolute',
};
var styles = {
    top: __assign(__assign({}, rowSizeBase), { top: '-5px' }),
    right: __assign(__assign({}, colSizeBase), { left: undefined, right: '-5px' }),
    bottom: __assign(__assign({}, rowSizeBase), { top: undefined, bottom: '-5px' }),
    left: __assign(__assign({}, colSizeBase), { left: '-5px' }),
    topRight: __assign(__assign({}, edgeBase), { right: '-10px', top: '-10px', cursor: 'ne-resize' }),
    bottomRight: __assign(__assign({}, edgeBase), { right: '-10px', bottom: '-10px', cursor: 'se-resize' }),
    bottomLeft: __assign(__assign({}, edgeBase), { left: '-10px', bottom: '-10px', cursor: 'sw-resize' }),
    topLeft: __assign(__assign({}, edgeBase), { left: '-10px', top: '-10px', cursor: 'nw-resize' }),
};
var Resizer = /** @class */ (function (_super) {
    __extends(Resizer, _super);
    function Resizer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onMouseDown = function (e) {
            _this.props.onResizeStart(e, _this.props.direction);
        };
        _this.onTouchStart = function (e) {
            _this.props.onResizeStart(e, _this.props.direction);
        };
        return _this;
    }
    Resizer.prototype.render = function () {
        return (react.createElement("div", { className: this.props.className || '', style: __assign(__assign({ position: 'absolute', userSelect: 'none' }, styles[this.props.direction]), (this.props.replaceStyles || {})), onMouseDown: this.onMouseDown, onTouchStart: this.onTouchStart }, this.props.children));
    };
    return Resizer;
}(react.PureComponent));


;// CONCATENATED MODULE: ../../node_modules/.pnpm/re-resizable@6.9.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/re-resizable/lib/index.js
var lib_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var lib_assign = (undefined && undefined.__assign) || function () {
    lib_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return lib_assign.apply(this, arguments);
};



var DEFAULT_SIZE = {
    width: 'auto',
    height: 'auto',
};
var clamp = function (n, min, max) { return Math.max(Math.min(n, max), min); };
var snap = function (n, size) { return Math.round(n / size) * size; };
var hasDirection = function (dir, target) {
    return new RegExp(dir, 'i').test(target);
};
// INFO: In case of window is a Proxy and does not porxy Events correctly, use isTouchEvent & isMouseEvent to distinguish event type instead of `instanceof`.
var isTouchEvent = function (event) {
    return Boolean(event.touches && event.touches.length);
};
var isMouseEvent = function (event) {
    return Boolean((event.clientX || event.clientX === 0) &&
        (event.clientY || event.clientY === 0));
};
var findClosestSnap = function (n, snapArray, snapGap) {
    if (snapGap === void 0) { snapGap = 0; }
    var closestGapIndex = snapArray.reduce(function (prev, curr, index) { return (Math.abs(curr - n) < Math.abs(snapArray[prev] - n) ? index : prev); }, 0);
    var gap = Math.abs(snapArray[closestGapIndex] - n);
    return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n;
};
var getStringSize = function (n) {
    n = n.toString();
    if (n === 'auto') {
        return n;
    }
    if (n.endsWith('px')) {
        return n;
    }
    if (n.endsWith('%')) {
        return n;
    }
    if (n.endsWith('vh')) {
        return n;
    }
    if (n.endsWith('vw')) {
        return n;
    }
    if (n.endsWith('vmax')) {
        return n;
    }
    if (n.endsWith('vmin')) {
        return n;
    }
    return n + "px";
};
var getPixelSize = function (size, parentSize, innerWidth, innerHeight) {
    if (size && typeof size === 'string') {
        if (size.endsWith('px')) {
            return Number(size.replace('px', ''));
        }
        if (size.endsWith('%')) {
            var ratio = Number(size.replace('%', '')) / 100;
            return parentSize * ratio;
        }
        if (size.endsWith('vw')) {
            var ratio = Number(size.replace('vw', '')) / 100;
            return innerWidth * ratio;
        }
        if (size.endsWith('vh')) {
            var ratio = Number(size.replace('vh', '')) / 100;
            return innerHeight * ratio;
        }
    }
    return size;
};
var calculateNewMax = function (parentSize, innerWidth, innerHeight, maxWidth, maxHeight, minWidth, minHeight) {
    maxWidth = getPixelSize(maxWidth, parentSize.width, innerWidth, innerHeight);
    maxHeight = getPixelSize(maxHeight, parentSize.height, innerWidth, innerHeight);
    minWidth = getPixelSize(minWidth, parentSize.width, innerWidth, innerHeight);
    minHeight = getPixelSize(minHeight, parentSize.height, innerWidth, innerHeight);
    return {
        maxWidth: typeof maxWidth === 'undefined' ? undefined : Number(maxWidth),
        maxHeight: typeof maxHeight === 'undefined' ? undefined : Number(maxHeight),
        minWidth: typeof minWidth === 'undefined' ? undefined : Number(minWidth),
        minHeight: typeof minHeight === 'undefined' ? undefined : Number(minHeight),
    };
};
var definedProps = [
    'as',
    'style',
    'className',
    'grid',
    'snap',
    'bounds',
    'boundsByDirection',
    'size',
    'defaultSize',
    'minWidth',
    'minHeight',
    'maxWidth',
    'maxHeight',
    'lockAspectRatio',
    'lockAspectRatioExtraWidth',
    'lockAspectRatioExtraHeight',
    'enable',
    'handleStyles',
    'handleClasses',
    'handleWrapperStyle',
    'handleWrapperClass',
    'children',
    'onResizeStart',
    'onResize',
    'onResizeStop',
    'handleComponent',
    'scale',
    'resizeRatio',
    'snapGap',
];
// HACK: This class is used to calculate % size.
var baseClassName = '__resizable_base__';
var Resizable = /** @class */ (function (_super) {
    lib_extends(Resizable, _super);
    function Resizable(props) {
        var _this = _super.call(this, props) || this;
        _this.ratio = 1;
        _this.resizable = null;
        // For parent boundary
        _this.parentLeft = 0;
        _this.parentTop = 0;
        // For boundary
        _this.resizableLeft = 0;
        _this.resizableRight = 0;
        _this.resizableTop = 0;
        _this.resizableBottom = 0;
        // For target boundary
        _this.targetLeft = 0;
        _this.targetTop = 0;
        _this.appendBase = function () {
            if (!_this.resizable || !_this.window) {
                return null;
            }
            var parent = _this.parentNode;
            if (!parent) {
                return null;
            }
            var element = _this.window.document.createElement('div');
            element.style.width = '100%';
            element.style.height = '100%';
            element.style.position = 'absolute';
            element.style.transform = 'scale(0, 0)';
            element.style.left = '0';
            element.style.flex = '0 0 100%';
            if (element.classList) {
                element.classList.add(baseClassName);
            }
            else {
                element.className += baseClassName;
            }
            parent.appendChild(element);
            return element;
        };
        _this.removeBase = function (base) {
            var parent = _this.parentNode;
            if (!parent) {
                return;
            }
            parent.removeChild(base);
        };
        _this.ref = function (c) {
            if (c) {
                _this.resizable = c;
            }
        };
        _this.state = {
            isResizing: false,
            width: typeof (_this.propsSize && _this.propsSize.width) === 'undefined'
                ? 'auto'
                : _this.propsSize && _this.propsSize.width,
            height: typeof (_this.propsSize && _this.propsSize.height) === 'undefined'
                ? 'auto'
                : _this.propsSize && _this.propsSize.height,
            direction: 'right',
            original: {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
            },
            backgroundStyle: {
                height: '100%',
                width: '100%',
                backgroundColor: 'rgba(0,0,0,0)',
                cursor: 'auto',
                opacity: 0,
                position: 'fixed',
                zIndex: 9999,
                top: '0',
                left: '0',
                bottom: '0',
                right: '0',
            },
            flexBasis: undefined,
        };
        _this.onResizeStart = _this.onResizeStart.bind(_this);
        _this.onMouseMove = _this.onMouseMove.bind(_this);
        _this.onMouseUp = _this.onMouseUp.bind(_this);
        return _this;
    }
    Object.defineProperty(Resizable.prototype, "parentNode", {
        get: function () {
            if (!this.resizable) {
                return null;
            }
            return this.resizable.parentNode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Resizable.prototype, "window", {
        get: function () {
            if (!this.resizable) {
                return null;
            }
            if (!this.resizable.ownerDocument) {
                return null;
            }
            return this.resizable.ownerDocument.defaultView;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Resizable.prototype, "propsSize", {
        get: function () {
            return this.props.size || this.props.defaultSize || DEFAULT_SIZE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Resizable.prototype, "size", {
        get: function () {
            var width = 0;
            var height = 0;
            if (this.resizable && this.window) {
                var orgWidth = this.resizable.offsetWidth;
                var orgHeight = this.resizable.offsetHeight;
                // HACK: Set position `relative` to get parent size.
                //       This is because when re-resizable set `absolute`, I can not get base width correctly.
                var orgPosition = this.resizable.style.position;
                if (orgPosition !== 'relative') {
                    this.resizable.style.position = 'relative';
                }
                // INFO: Use original width or height if set auto.
                width = this.resizable.style.width !== 'auto' ? this.resizable.offsetWidth : orgWidth;
                height = this.resizable.style.height !== 'auto' ? this.resizable.offsetHeight : orgHeight;
                // Restore original position
                this.resizable.style.position = orgPosition;
            }
            return { width: width, height: height };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Resizable.prototype, "sizeStyle", {
        get: function () {
            var _this = this;
            var size = this.props.size;
            var getSize = function (key) {
                if (typeof _this.state[key] === 'undefined' || _this.state[key] === 'auto') {
                    return 'auto';
                }
                if (_this.propsSize && _this.propsSize[key] && _this.propsSize[key].toString().endsWith('%')) {
                    if (_this.state[key].toString().endsWith('%')) {
                        return _this.state[key].toString();
                    }
                    var parentSize = _this.getParentSize();
                    var value = Number(_this.state[key].toString().replace('px', ''));
                    var percent = (value / parentSize[key]) * 100;
                    return percent + "%";
                }
                return getStringSize(_this.state[key]);
            };
            var width = size && typeof size.width !== 'undefined' && !this.state.isResizing
                ? getStringSize(size.width)
                : getSize('width');
            var height = size && typeof size.height !== 'undefined' && !this.state.isResizing
                ? getStringSize(size.height)
                : getSize('height');
            return { width: width, height: height };
        },
        enumerable: false,
        configurable: true
    });
    Resizable.prototype.getParentSize = function () {
        if (!this.parentNode) {
            if (!this.window) {
                return { width: 0, height: 0 };
            }
            return { width: this.window.innerWidth, height: this.window.innerHeight };
        }
        var base = this.appendBase();
        if (!base) {
            return { width: 0, height: 0 };
        }
        // INFO: To calculate parent width with flex layout
        var wrapChanged = false;
        var wrap = this.parentNode.style.flexWrap;
        if (wrap !== 'wrap') {
            wrapChanged = true;
            this.parentNode.style.flexWrap = 'wrap';
            // HACK: Use relative to get parent padding size
        }
        base.style.position = 'relative';
        base.style.minWidth = '100%';
        base.style.minHeight = '100%';
        var size = {
            width: base.offsetWidth,
            height: base.offsetHeight,
        };
        if (wrapChanged) {
            this.parentNode.style.flexWrap = wrap;
        }
        this.removeBase(base);
        return size;
    };
    Resizable.prototype.bindEvents = function () {
        if (this.window) {
            this.window.addEventListener('mouseup', this.onMouseUp);
            this.window.addEventListener('mousemove', this.onMouseMove);
            this.window.addEventListener('mouseleave', this.onMouseUp);
            this.window.addEventListener('touchmove', this.onMouseMove, {
                capture: true,
                passive: false,
            });
            this.window.addEventListener('touchend', this.onMouseUp);
        }
    };
    Resizable.prototype.unbindEvents = function () {
        if (this.window) {
            this.window.removeEventListener('mouseup', this.onMouseUp);
            this.window.removeEventListener('mousemove', this.onMouseMove);
            this.window.removeEventListener('mouseleave', this.onMouseUp);
            this.window.removeEventListener('touchmove', this.onMouseMove, true);
            this.window.removeEventListener('touchend', this.onMouseUp);
        }
    };
    Resizable.prototype.componentDidMount = function () {
        if (!this.resizable || !this.window) {
            return;
        }
        var computedStyle = this.window.getComputedStyle(this.resizable);
        this.setState({
            width: this.state.width || this.size.width,
            height: this.state.height || this.size.height,
            flexBasis: computedStyle.flexBasis !== 'auto' ? computedStyle.flexBasis : undefined,
        });
    };
    Resizable.prototype.componentWillUnmount = function () {
        if (this.window) {
            this.unbindEvents();
        }
    };
    Resizable.prototype.createSizeForCssProperty = function (newSize, kind) {
        var propsSize = this.propsSize && this.propsSize[kind];
        return this.state[kind] === 'auto' &&
            this.state.original[kind] === newSize &&
            (typeof propsSize === 'undefined' || propsSize === 'auto')
            ? 'auto'
            : newSize;
    };
    Resizable.prototype.calculateNewMaxFromBoundary = function (maxWidth, maxHeight) {
        var boundsByDirection = this.props.boundsByDirection;
        var direction = this.state.direction;
        var widthByDirection = boundsByDirection && hasDirection('left', direction);
        var heightByDirection = boundsByDirection && hasDirection('top', direction);
        var boundWidth;
        var boundHeight;
        if (this.props.bounds === 'parent') {
            var parent_1 = this.parentNode;
            if (parent_1) {
                boundWidth = widthByDirection
                    ? this.resizableRight - this.parentLeft
                    : parent_1.offsetWidth + (this.parentLeft - this.resizableLeft);
                boundHeight = heightByDirection
                    ? this.resizableBottom - this.parentTop
                    : parent_1.offsetHeight + (this.parentTop - this.resizableTop);
            }
        }
        else if (this.props.bounds === 'window') {
            if (this.window) {
                boundWidth = widthByDirection ? this.resizableRight : this.window.innerWidth - this.resizableLeft;
                boundHeight = heightByDirection ? this.resizableBottom : this.window.innerHeight - this.resizableTop;
            }
        }
        else if (this.props.bounds) {
            boundWidth = widthByDirection
                ? this.resizableRight - this.targetLeft
                : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);
            boundHeight = heightByDirection
                ? this.resizableBottom - this.targetTop
                : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);
        }
        if (boundWidth && Number.isFinite(boundWidth)) {
            maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
        }
        if (boundHeight && Number.isFinite(boundHeight)) {
            maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
        }
        return { maxWidth: maxWidth, maxHeight: maxHeight };
    };
    Resizable.prototype.calculateNewSizeFromDirection = function (clientX, clientY) {
        var scale = this.props.scale || 1;
        var resizeRatio = this.props.resizeRatio || 1;
        var _a = this.state, direction = _a.direction, original = _a.original;
        var _b = this.props, lockAspectRatio = _b.lockAspectRatio, lockAspectRatioExtraHeight = _b.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _b.lockAspectRatioExtraWidth;
        var newWidth = original.width;
        var newHeight = original.height;
        var extraHeight = lockAspectRatioExtraHeight || 0;
        var extraWidth = lockAspectRatioExtraWidth || 0;
        if (hasDirection('right', direction)) {
            newWidth = original.width + ((clientX - original.x) * resizeRatio) / scale;
            if (lockAspectRatio) {
                newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
            }
        }
        if (hasDirection('left', direction)) {
            newWidth = original.width - ((clientX - original.x) * resizeRatio) / scale;
            if (lockAspectRatio) {
                newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
            }
        }
        if (hasDirection('bottom', direction)) {
            newHeight = original.height + ((clientY - original.y) * resizeRatio) / scale;
            if (lockAspectRatio) {
                newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
            }
        }
        if (hasDirection('top', direction)) {
            newHeight = original.height - ((clientY - original.y) * resizeRatio) / scale;
            if (lockAspectRatio) {
                newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
            }
        }
        return { newWidth: newWidth, newHeight: newHeight };
    };
    Resizable.prototype.calculateNewSizeFromAspectRatio = function (newWidth, newHeight, max, min) {
        var _a = this.props, lockAspectRatio = _a.lockAspectRatio, lockAspectRatioExtraHeight = _a.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a.lockAspectRatioExtraWidth;
        var computedMinWidth = typeof min.width === 'undefined' ? 10 : min.width;
        var computedMaxWidth = typeof max.width === 'undefined' || max.width < 0 ? newWidth : max.width;
        var computedMinHeight = typeof min.height === 'undefined' ? 10 : min.height;
        var computedMaxHeight = typeof max.height === 'undefined' || max.height < 0 ? newHeight : max.height;
        var extraHeight = lockAspectRatioExtraHeight || 0;
        var extraWidth = lockAspectRatioExtraWidth || 0;
        if (lockAspectRatio) {
            var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;
            var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;
            var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;
            var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;
            var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);
            var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);
            var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);
            var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);
            newWidth = clamp(newWidth, lockedMinWidth, lockedMaxWidth);
            newHeight = clamp(newHeight, lockedMinHeight, lockedMaxHeight);
        }
        else {
            newWidth = clamp(newWidth, computedMinWidth, computedMaxWidth);
            newHeight = clamp(newHeight, computedMinHeight, computedMaxHeight);
        }
        return { newWidth: newWidth, newHeight: newHeight };
    };
    Resizable.prototype.setBoundingClientRect = function () {
        // For parent boundary
        if (this.props.bounds === 'parent') {
            var parent_2 = this.parentNode;
            if (parent_2) {
                var parentRect = parent_2.getBoundingClientRect();
                this.parentLeft = parentRect.left;
                this.parentTop = parentRect.top;
            }
        }
        // For target(html element) boundary
        if (this.props.bounds && typeof this.props.bounds !== 'string') {
            var targetRect = this.props.bounds.getBoundingClientRect();
            this.targetLeft = targetRect.left;
            this.targetTop = targetRect.top;
        }
        // For boundary
        if (this.resizable) {
            var _a = this.resizable.getBoundingClientRect(), left = _a.left, top_1 = _a.top, right = _a.right, bottom = _a.bottom;
            this.resizableLeft = left;
            this.resizableRight = right;
            this.resizableTop = top_1;
            this.resizableBottom = bottom;
        }
    };
    Resizable.prototype.onResizeStart = function (event, direction) {
        if (!this.resizable || !this.window) {
            return;
        }
        var clientX = 0;
        var clientY = 0;
        if (event.nativeEvent && isMouseEvent(event.nativeEvent)) {
            clientX = event.nativeEvent.clientX;
            clientY = event.nativeEvent.clientY;
        }
        else if (event.nativeEvent && isTouchEvent(event.nativeEvent)) {
            clientX = event.nativeEvent.touches[0].clientX;
            clientY = event.nativeEvent.touches[0].clientY;
        }
        if (this.props.onResizeStart) {
            if (this.resizable) {
                var startResize = this.props.onResizeStart(event, direction, this.resizable);
                if (startResize === false) {
                    return;
                }
            }
        }
        // Fix #168
        if (this.props.size) {
            if (typeof this.props.size.height !== 'undefined' && this.props.size.height !== this.state.height) {
                this.setState({ height: this.props.size.height });
            }
            if (typeof this.props.size.width !== 'undefined' && this.props.size.width !== this.state.width) {
                this.setState({ width: this.props.size.width });
            }
        }
        // For lockAspectRatio case
        this.ratio =
            typeof this.props.lockAspectRatio === 'number' ? this.props.lockAspectRatio : this.size.width / this.size.height;
        var flexBasis;
        var computedStyle = this.window.getComputedStyle(this.resizable);
        if (computedStyle.flexBasis !== 'auto') {
            var parent_3 = this.parentNode;
            if (parent_3) {
                var dir = this.window.getComputedStyle(parent_3).flexDirection;
                this.flexDir = dir.startsWith('row') ? 'row' : 'column';
                flexBasis = computedStyle.flexBasis;
            }
        }
        // For boundary
        this.setBoundingClientRect();
        this.bindEvents();
        var state = {
            original: {
                x: clientX,
                y: clientY,
                width: this.size.width,
                height: this.size.height,
            },
            isResizing: true,
            backgroundStyle: lib_assign(lib_assign({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(event.target).cursor || 'auto' }),
            direction: direction,
            flexBasis: flexBasis,
        };
        this.setState(state);
    };
    Resizable.prototype.onMouseMove = function (event) {
        var _this = this;
        if (!this.state.isResizing || !this.resizable || !this.window) {
            return;
        }
        if (this.window.TouchEvent && isTouchEvent(event)) {
            try {
                event.preventDefault();
                event.stopPropagation();
            }
            catch (e) {
                // Ignore on fail
            }
        }
        var _a = this.props, maxWidth = _a.maxWidth, maxHeight = _a.maxHeight, minWidth = _a.minWidth, minHeight = _a.minHeight;
        var clientX = isTouchEvent(event) ? event.touches[0].clientX : event.clientX;
        var clientY = isTouchEvent(event) ? event.touches[0].clientY : event.clientY;
        var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height = _b.height;
        var parentSize = this.getParentSize();
        var max = calculateNewMax(parentSize, this.window.innerWidth, this.window.innerHeight, maxWidth, maxHeight, minWidth, minHeight);
        maxWidth = max.maxWidth;
        maxHeight = max.maxHeight;
        minWidth = max.minWidth;
        minHeight = max.minHeight;
        // Calculate new size
        var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;
        // Calculate max size from boundary settings
        var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);
        if (this.props.snap && this.props.snap.x) {
            newWidth = findClosestSnap(newWidth, this.props.snap.x, this.props.snapGap);
        }
        if (this.props.snap && this.props.snap.y) {
            newHeight = findClosestSnap(newHeight, this.props.snap.y, this.props.snapGap);
        }
        // Calculate new size from aspect ratio
        var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });
        newWidth = newSize.newWidth;
        newHeight = newSize.newHeight;
        if (this.props.grid) {
            var newGridWidth = snap(newWidth, this.props.grid[0]);
            var newGridHeight = snap(newHeight, this.props.grid[1]);
            var gap = this.props.snapGap || 0;
            newWidth = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;
            newHeight = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;
        }
        var delta = {
            width: newWidth - original.width,
            height: newHeight - original.height,
        };
        if (width && typeof width === 'string') {
            if (width.endsWith('%')) {
                var percent = (newWidth / parentSize.width) * 100;
                newWidth = percent + "%";
            }
            else if (width.endsWith('vw')) {
                var vw = (newWidth / this.window.innerWidth) * 100;
                newWidth = vw + "vw";
            }
            else if (width.endsWith('vh')) {
                var vh = (newWidth / this.window.innerHeight) * 100;
                newWidth = vh + "vh";
            }
        }
        if (height && typeof height === 'string') {
            if (height.endsWith('%')) {
                var percent = (newHeight / parentSize.height) * 100;
                newHeight = percent + "%";
            }
            else if (height.endsWith('vw')) {
                var vw = (newHeight / this.window.innerWidth) * 100;
                newHeight = vw + "vw";
            }
            else if (height.endsWith('vh')) {
                var vh = (newHeight / this.window.innerHeight) * 100;
                newHeight = vh + "vh";
            }
        }
        var newState = {
            width: this.createSizeForCssProperty(newWidth, 'width'),
            height: this.createSizeForCssProperty(newHeight, 'height'),
        };
        if (this.flexDir === 'row') {
            newState.flexBasis = newState.width;
        }
        else if (this.flexDir === 'column') {
            newState.flexBasis = newState.height;
        }
        // For v18, update state sync
        (0,react_dom.flushSync)(function () {
            _this.setState(newState);
        });
        if (this.props.onResize) {
            this.props.onResize(event, direction, this.resizable, delta);
        }
    };
    Resizable.prototype.onMouseUp = function (event) {
        var _a = this.state, isResizing = _a.isResizing, direction = _a.direction, original = _a.original;
        if (!isResizing || !this.resizable) {
            return;
        }
        var delta = {
            width: this.size.width - original.width,
            height: this.size.height - original.height,
        };
        if (this.props.onResizeStop) {
            this.props.onResizeStop(event, direction, this.resizable, delta);
        }
        if (this.props.size) {
            this.setState(this.props.size);
        }
        this.unbindEvents();
        this.setState({
            isResizing: false,
            backgroundStyle: lib_assign(lib_assign({}, this.state.backgroundStyle), { cursor: 'auto' }),
        });
    };
    Resizable.prototype.updateSize = function (size) {
        this.setState({ width: size.width, height: size.height });
    };
    Resizable.prototype.renderResizer = function () {
        var _this = this;
        var _a = this.props, enable = _a.enable, handleStyles = _a.handleStyles, handleClasses = _a.handleClasses, handleWrapperStyle = _a.handleWrapperStyle, handleWrapperClass = _a.handleWrapperClass, handleComponent = _a.handleComponent;
        if (!enable) {
            return null;
        }
        var resizers = Object.keys(enable).map(function (dir) {
            if (enable[dir] !== false) {
                return (react.createElement(Resizer, { key: dir, direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir] }, handleComponent && handleComponent[dir] ? handleComponent[dir] : null));
            }
            return null;
        });
        // #93 Wrap the resize box in span (will not break 100% width/height)
        return (react.createElement("div", { className: handleWrapperClass, style: handleWrapperStyle }, resizers));
    };
    Resizable.prototype.render = function () {
        var _this = this;
        var extendsProps = Object.keys(this.props).reduce(function (acc, key) {
            if (definedProps.indexOf(key) !== -1) {
                return acc;
            }
            acc[key] = _this.props[key];
            return acc;
        }, {});
        var style = lib_assign(lib_assign(lib_assign({ position: 'relative', userSelect: this.state.isResizing ? 'none' : 'auto' }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: 'border-box', flexShrink: 0 });
        if (this.state.flexBasis) {
            style.flexBasis = this.state.flexBasis;
        }
        var Wrapper = this.props.as || 'div';
        return (react.createElement(Wrapper, lib_assign({ ref: this.ref, style: style, className: this.props.className }, extendsProps),
            this.state.isResizing && react.createElement("div", { style: this.state.backgroundStyle }),
            this.props.children,
            this.renderResizer()));
    };
    Resizable.defaultProps = {
        as: 'div',
        onResizeStart: function () { },
        onResize: function () { },
        onResizeStop: function () { },
        enable: {
            top: true,
            right: true,
            bottom: true,
            left: true,
            topRight: true,
            bottomRight: true,
            bottomLeft: true,
            topLeft: true,
        },
        style: {},
        grid: [1, 1],
        lockAspectRatio: false,
        lockAspectRatioExtraWidth: 0,
        lockAspectRatioExtraHeight: 0,
        scale: 1,
        resizeRatio: 1,
        snapGap: 0,
    };
    return Resizable;
}(react.PureComponent));


;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-resize-observer/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


// This of course could've been more streamlined with internal state instead of
// refs, but then host hooks / components could not opt out of renders.
// This could've been exported to its own module, but the current build doesn't
// seem to work with module imports and I had no more time to spend on this...
function useResolvedElement(subscriber, refOrElement) {
  const callbackRefElement = (0,react.useRef)(null);
  const lastReportRef = (0,react.useRef)(null);
  const cleanupRef = (0,react.useRef)();
  const callSubscriber = (0,react.useCallback)(() => {
    let element = null;
    if (callbackRefElement.current) {
      element = callbackRefElement.current;
    } else if (refOrElement) {
      if (refOrElement instanceof HTMLElement) {
        element = refOrElement;
      } else {
        element = refOrElement.current;
      }
    }
    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.reporter === callSubscriber) {
      return;
    }
    if (cleanupRef.current) {
      cleanupRef.current();
      // Making sure the cleanup is not called accidentally multiple times.
      cleanupRef.current = null;
    }
    lastReportRef.current = {
      reporter: callSubscriber,
      element
    };

    // Only calling the subscriber, if there's an actual element to report.
    if (element) {
      cleanupRef.current = subscriber(element);
    }
  }, [refOrElement, subscriber]);

  // On each render, we check whether a ref changed, or if we got a new raw
  // element.
  (0,react.useEffect)(() => {
    // With this we're *technically* supporting cases where ref objects' current value changes, but only if there's a
    // render accompanying that change as well.
    // To guarantee we always have the right element, one must use the ref callback provided instead, but we support
    // RefObjects to make the hook API more convenient in certain cases.
    callSubscriber();
  }, [callSubscriber]);
  return (0,react.useCallback)(element => {
    callbackRefElement.current = element;
    callSubscriber();
  }, [callSubscriber]);
}

// Declaring my own type here instead of using the one provided by TS (available since 4.2.2), because this way I'm not
// forcing consumers to use a specific TS version.

// We're only using the first element of the size sequences, until future versions of the spec solidify on how
// exactly it'll be used for fragments in multi-column scenarios:
// From the spec:
// > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,
// > which occur in multi-column scenarios. However the current definitions of content rect and border box do not
// > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single
// > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.
// > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.
// (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)
//
// Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,
// regardless of the "box" option.
// The spec states the following on this:
// > This does not have any impact on which box dimensions are returned to the defined callback when the event
// > is fired, it solely defines which box the author wishes to observe layout changes on.
// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)
// I'm not exactly clear on what this means, especially when you consider a later section stating the following:
// > This section is non-normative. An author may desire to observe more than one CSS box.
// > In this case, author will need to use multiple ResizeObservers.
// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)
// Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.
// For this reason I decided to only return the requested size,
// even though it seems we have access to results for all box types.
// This also means that we get to keep the current api, being able to return a simple { width, height } pair,
// regardless of box option.
const extractSize = (entry, boxProp, sizeType) => {
  if (!entry[boxProp]) {
    if (boxProp === 'contentBoxSize') {
      // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.
      // See the 6th step in the description for the RO algorithm:
      // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h
      // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of "content-box".
      // In real browser implementations of course these objects differ, but the width/height values should be equivalent.
      return entry.contentRect[sizeType === 'inlineSize' ? 'width' : 'height'];
    }
    return undefined;
  }

  // A couple bytes smaller than calling Array.isArray() and just as effective here.
  return entry[boxProp][0] ? entry[boxProp][0][sizeType] :
  // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current
  // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.
  // @ts-ignore
  entry[boxProp][sizeType];
};
function useResizeObserver(opts = {}) {
  // Saving the callback as a ref. With this, I don't need to put onResize in the
  // effect dep array, and just passing in an anonymous function without memoising
  // will not reinstantiate the hook's ResizeObserver.
  const onResize = opts.onResize;
  const onResizeRef = (0,react.useRef)(undefined);
  onResizeRef.current = onResize;
  const round = opts.round || Math.round;

  // Using a single instance throughout the hook's lifetime
  const resizeObserverRef = (0,react.useRef)();
  const [size, setSize] = (0,react.useState)({
    width: undefined,
    height: undefined
  });

  // In certain edge cases the RO might want to report a size change just after
  // the component unmounted.
  const didUnmount = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    didUnmount.current = false;
    return () => {
      didUnmount.current = true;
    };
  }, []);

  // Using a ref to track the previous width / height to avoid unnecessary renders.
  const previous = (0,react.useRef)({
    width: undefined,
    height: undefined
  });

  // This block is kinda like a useEffect, only it's called whenever a new
  // element could be resolved based on the ref option. It also has a cleanup
  // function.
  const refCallback = useResolvedElement((0,react.useCallback)(element => {
    // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.
    // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.
    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {
      resizeObserverRef.current = {
        box: opts.box,
        round,
        instance: new ResizeObserver(entries => {
          const entry = entries[0];
          let boxProp = 'borderBoxSize';
          if (opts.box === 'border-box') {
            boxProp = 'borderBoxSize';
          } else {
            boxProp = opts.box === 'device-pixel-content-box' ? 'devicePixelContentBoxSize' : 'contentBoxSize';
          }
          const reportedWidth = extractSize(entry, boxProp, 'inlineSize');
          const reportedHeight = extractSize(entry, boxProp, 'blockSize');
          const newWidth = reportedWidth ? round(reportedWidth) : undefined;
          const newHeight = reportedHeight ? round(reportedHeight) : undefined;
          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
            const newSize = {
              width: newWidth,
              height: newHeight
            };
            previous.current.width = newWidth;
            previous.current.height = newHeight;
            if (onResizeRef.current) {
              onResizeRef.current(newSize);
            } else if (!didUnmount.current) {
              setSize(newSize);
            }
          }
        })
      };
    }
    resizeObserverRef.current.instance.observe(element, {
      box: opts.box
    });
    return () => {
      if (resizeObserverRef.current) {
        resizeObserverRef.current.instance.unobserve(element);
      }
    };
  }, [opts.box, round]), opts.ref);
  return (0,react.useMemo)(() => ({
    ref: refCallback,
    width: size.width,
    height: size.height
  }), [refCallback, size ? size.width : null, size ? size.height : null]);
}

/**
 * Hook which allows to listen the resize event of any target element when it changes sizes.
 * _Note: `useResizeObserver` will report `null` until after first render.
 *
 * @example
 *
 * ```js
 * const App = () => {
 * 	const [ resizeListener, sizes ] = useResizeObserver();
 *
 * 	return (
 * 		<div>
 * 			{ resizeListener }
 * 			Your content here
 * 		</div>
 * 	);
 * };
 * ```
 */
function useResizeAware() {
  const {
    ref,
    width,
    height
  } = useResizeObserver();
  const sizes = (0,react.useMemo)(() => {
    return {
      width: width !== null && width !== void 0 ? width : null,
      height: height !== null && height !== void 0 ? height : null
    };
  }, [width, height]);
  const resizeListener = /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    style: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      pointerEvents: 'none',
      opacity: 0,
      overflow: 'hidden',
      zIndex: -1
    },
    "aria-hidden": "true",
    ref: ref
  });
  return [resizeListener, sizes];
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/resizable-box/resize-tooltip/utils.js
/**
 * WordPress dependencies
 */


const utils_noop = () => {};
const POSITIONS = {
  bottom: 'bottom',
  corner: 'corner'
};
/**
 * Custom hook that manages resize listener events. It also provides a label
 * based on current resize width x height values.
 *
 * @param props
 * @param props.axis        Only shows the label corresponding to the axis.
 * @param props.fadeTimeout Duration (ms) before deactivating the resize label.
 * @param props.onResize    Callback when a resize occurs. Provides { width, height } callback.
 * @param props.position    Adjusts label value.
 * @param props.showPx      Whether to add `PX` to the label.
 *
 * @return Properties for hook.
 */
function useResizeLabel({
  axis,
  fadeTimeout = 180,
  onResize = utils_noop,
  position = POSITIONS.bottom,
  showPx = false
}) {
  /*
   * The width/height values derive from this special useResizeObserver hook.
   * This custom hook uses the ResizeObserver API to listen for resize events.
   */
  const [resizeListener, sizes] = useResizeAware();

  /*
   * Indicates if the x/y axis is preferred.
   * If set, we will avoid resetting the moveX and moveY values.
   * This will allow for the preferred axis values to persist in the label.
   */
  const isAxisControlled = !!axis;

  /*
   * The moveX and moveY values are used to track whether the label should
   * display width, height, or width x height.
   */
  const [moveX, setMoveX] = (0,react.useState)(false);
  const [moveY, setMoveY] = (0,react.useState)(false);

  /*
   * Cached dimension values to check for width/height updates from the
   * sizes property from useResizeAware()
   */
  const {
    width,
    height
  } = sizes;
  const heightRef = (0,react.useRef)(height);
  const widthRef = (0,react.useRef)(width);

  /*
   * This timeout is used with setMoveX and setMoveY to determine of
   * both width and height values have changed at (roughly) the same time.
   */
  const moveTimeoutRef = (0,react.useRef)();
  const debounceUnsetMoveXY = (0,react.useCallback)(() => {
    const unsetMoveXY = () => {
      /*
       * If axis is controlled, we will avoid resetting the moveX and moveY values.
       * This will allow for the preferred axis values to persist in the label.
       */
      if (isAxisControlled) {
        return;
      }
      setMoveX(false);
      setMoveY(false);
    };
    if (moveTimeoutRef.current) {
      window.clearTimeout(moveTimeoutRef.current);
    }
    moveTimeoutRef.current = window.setTimeout(unsetMoveXY, fadeTimeout);
  }, [fadeTimeout, isAxisControlled]);
  (0,react.useEffect)(() => {
    /*
     * On the initial render of useResizeAware, the height and width values are
     * null. They are calculated then set using via an internal useEffect hook.
     */
    const isRendered = width !== null || height !== null;
    if (!isRendered) {
      return;
    }
    const didWidthChange = width !== widthRef.current;
    const didHeightChange = height !== heightRef.current;
    if (!didWidthChange && !didHeightChange) {
      return;
    }

    /*
     * After the initial render, the useResizeAware will set the first
     * width and height values. We'll sync those values with our
     * width and height refs. However, we shouldn't render our Tooltip
     * label on this first cycle.
     */
    if (width && !widthRef.current && height && !heightRef.current) {
      widthRef.current = width;
      heightRef.current = height;
      return;
    }

    /*
     * After the first cycle, we can track width and height changes.
     */
    if (didWidthChange) {
      setMoveX(true);
      widthRef.current = width;
    }
    if (didHeightChange) {
      setMoveY(true);
      heightRef.current = height;
    }
    onResize({
      width,
      height
    });
    debounceUnsetMoveXY();
  }, [width, height, onResize, debounceUnsetMoveXY]);
  const label = getSizeLabel({
    axis,
    height,
    moveX,
    moveY,
    position,
    showPx,
    width
  });
  return {
    label,
    resizeListener
  };
}
/**
 * Gets the resize label based on width and height values (as well as recent changes).
 *
 * @param props
 * @param props.axis     Only shows the label corresponding to the axis.
 * @param props.height   Height value.
 * @param props.moveX    Recent width (x axis) changes.
 * @param props.moveY    Recent width (y axis) changes.
 * @param props.position Adjusts label value.
 * @param props.showPx   Whether to add `PX` to the label.
 * @param props.width    Width value.
 *
 * @return The rendered label.
 */
function getSizeLabel({
  axis,
  height,
  moveX = false,
  moveY = false,
  position = POSITIONS.bottom,
  showPx = false,
  width
}) {
  if (!moveX && !moveY) {
    return undefined;
  }

  /*
   * Corner position...
   * We want the label to appear like width x height.
   */
  if (position === POSITIONS.corner) {
    return `${width} x ${height}`;
  }

  /*
   * Other POSITIONS...
   * The label will combine both width x height values if both
   * values have recently been changed.
   *
   * Otherwise, only width or height will be displayed.
   * The `PX` unit will be added, if specified by the `showPx` prop.
   */
  const labelUnit = showPx ? ' px' : '';
  if (axis) {
    if (axis === 'x' && moveX) {
      return `${width}${labelUnit}`;
    }
    if (axis === 'y' && moveY) {
      return `${height}${labelUnit}`;
    }
  }
  if (moveX && moveY) {
    return `${width} x ${height}`;
  }
  if (moveX) {
    return `${width}${labelUnit}`;
  }
  if (moveY) {
    return `${height}${labelUnit}`;
  }
  return undefined;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/resizable-box/resize-tooltip/styles/resize-tooltip.styles.js

function resize_tooltip_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


const resize_tooltip_styles_Root = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1wq7y4k3"
} : 0)( true ? {
  name: "1cd7zoc",
  styles: "bottom:0;box-sizing:border-box;left:0;pointer-events:none;position:absolute;right:0;top:0"
} : 0);
const TooltipWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1wq7y4k2"
} : 0)( true ? {
  name: "ajymcs",
  styles: "align-items:center;box-sizing:border-box;display:inline-flex;justify-content:center;opacity:0;pointer-events:none;transition:opacity 120ms linear"
} : 0);
const resize_tooltip_styles_Tooltip = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1wq7y4k1"
} : 0)("background:", colors_values/* COLORS */.l.theme.foreground, ";border-radius:2px;box-sizing:border-box;font-family:", (0,font/* font */.g)('default.fontFamily'), ";font-size:12px;color:", colors_values/* COLORS */.l.theme.foregroundInverted, ";padding:4px 8px;position:relative;" + ( true ? "" : 0));

// TODO: Resolve need to use &&& to increase specificity
// https://github.com/WordPress/gutenberg/issues/18483

const LabelText = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(text_component/* default */.A,  true ? {
  target: "e1wq7y4k0"
} : 0)("&&&{color:", colors_values/* COLORS */.l.theme.foregroundInverted, ";display:block;font-size:13px;line-height:1.4;white-space:nowrap;}" + ( true ? "" : 0));
//# sourceMappingURL=resize-tooltip.styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/resizable-box/resize-tooltip/label.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const CORNER_OFFSET = 4;
const CURSOR_OFFSET_TOP = CORNER_OFFSET * 2.5;
function Label({
  label,
  position = POSITIONS.corner,
  zIndex = 1000,
  ...props
}, ref) {
  const showLabel = !!label;
  const isBottom = position === POSITIONS.bottom;
  const isCorner = position === POSITIONS.corner;
  if (!showLabel) {
    return null;
  }
  let style = {
    opacity: showLabel ? 1 : undefined,
    zIndex
  };
  let labelStyle = {};
  if (isBottom) {
    style = {
      ...style,
      position: 'absolute',
      bottom: CURSOR_OFFSET_TOP * -1,
      left: '50%',
      transform: 'translate(-50%, 0)'
    };
    labelStyle = {
      transform: `translate(0, 100%)`
    };
  }
  if (isCorner) {
    style = {
      ...style,
      position: 'absolute',
      top: CORNER_OFFSET,
      right: (0,i18n_build_module/* isRTL */.V8)() ? undefined : CORNER_OFFSET,
      left: (0,i18n_build_module/* isRTL */.V8)() ? CORNER_OFFSET : undefined
    };
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(TooltipWrapper, {
    "aria-hidden": "true",
    className: "components-resizable-tooltip__tooltip-wrapper",
    ref: ref,
    style: style,
    ...props,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(resize_tooltip_styles_Tooltip, {
      className: "components-resizable-tooltip__tooltip",
      style: labelStyle,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(LabelText, {
        as: "span",
        children: label
      })
    })
  });
}
const label_ForwardedComponent = (0,react.forwardRef)(Label);
/* harmony default export */ const resize_tooltip_label = (label_ForwardedComponent);
//# sourceMappingURL=label.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/resizable-box/resize-tooltip/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





const resize_tooltip_noop = () => {};
function ResizeTooltip({
  axis,
  className,
  fadeTimeout = 180,
  isVisible = true,
  labelRef,
  onResize = resize_tooltip_noop,
  position = POSITIONS.bottom,
  showPx = true,
  zIndex = 1000,
  ...props
}, ref) {
  const {
    label,
    resizeListener
  } = useResizeLabel({
    axis,
    fadeTimeout,
    onResize,
    showPx,
    position
  });
  if (!isVisible) {
    return null;
  }
  const classes = (0,dist_clsx/* default */.A)('components-resize-tooltip', className);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(resize_tooltip_styles_Root, {
    "aria-hidden": "true",
    className: classes,
    ref: ref,
    ...props,
    children: [resizeListener, /*#__PURE__*/(0,jsx_runtime.jsx)(resize_tooltip_label, {
      "aria-hidden": props['aria-hidden'],
      label: label,
      position: position,
      ref: labelRef,
      zIndex: zIndex
    })]
  });
}
const resize_tooltip_ForwardedComponent = (0,react.forwardRef)(ResizeTooltip);
/* harmony default export */ const resize_tooltip = (resize_tooltip_ForwardedComponent);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/resizable-box/index.js
/**
 * WordPress dependencies
 */


/**
 * External dependencies
 */


/**
 * Internal dependencies
 */



const HANDLE_CLASS_NAME = 'components-resizable-box__handle';
const SIDE_HANDLE_CLASS_NAME = 'components-resizable-box__side-handle';
const CORNER_HANDLE_CLASS_NAME = 'components-resizable-box__corner-handle';
const HANDLE_CLASSES = {
  top: (0,dist_clsx/* default */.A)(HANDLE_CLASS_NAME, SIDE_HANDLE_CLASS_NAME, 'components-resizable-box__handle-top'),
  right: (0,dist_clsx/* default */.A)(HANDLE_CLASS_NAME, SIDE_HANDLE_CLASS_NAME, 'components-resizable-box__handle-right'),
  bottom: (0,dist_clsx/* default */.A)(HANDLE_CLASS_NAME, SIDE_HANDLE_CLASS_NAME, 'components-resizable-box__handle-bottom'),
  left: (0,dist_clsx/* default */.A)(HANDLE_CLASS_NAME, SIDE_HANDLE_CLASS_NAME, 'components-resizable-box__handle-left'),
  topLeft: (0,dist_clsx/* default */.A)(HANDLE_CLASS_NAME, CORNER_HANDLE_CLASS_NAME, 'components-resizable-box__handle-top', 'components-resizable-box__handle-left'),
  topRight: (0,dist_clsx/* default */.A)(HANDLE_CLASS_NAME, CORNER_HANDLE_CLASS_NAME, 'components-resizable-box__handle-top', 'components-resizable-box__handle-right'),
  bottomRight: (0,dist_clsx/* default */.A)(HANDLE_CLASS_NAME, CORNER_HANDLE_CLASS_NAME, 'components-resizable-box__handle-bottom', 'components-resizable-box__handle-right'),
  bottomLeft: (0,dist_clsx/* default */.A)(HANDLE_CLASS_NAME, CORNER_HANDLE_CLASS_NAME, 'components-resizable-box__handle-bottom', 'components-resizable-box__handle-left')
};

// Removes the inline styles in the drag handles.
const HANDLE_STYLES_OVERRIDES = {
  width: undefined,
  height: undefined,
  top: undefined,
  right: undefined,
  bottom: undefined,
  left: undefined
};
const HANDLE_STYLES = {
  top: HANDLE_STYLES_OVERRIDES,
  right: HANDLE_STYLES_OVERRIDES,
  bottom: HANDLE_STYLES_OVERRIDES,
  left: HANDLE_STYLES_OVERRIDES,
  topLeft: HANDLE_STYLES_OVERRIDES,
  topRight: HANDLE_STYLES_OVERRIDES,
  bottomRight: HANDLE_STYLES_OVERRIDES,
  bottomLeft: HANDLE_STYLES_OVERRIDES
};
function UnforwardedResizableBox({
  className,
  children,
  showHandle = true,
  __experimentalShowTooltip: showTooltip = false,
  __experimentalTooltipProps: tooltipProps = {},
  ...props
}, ref) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Resizable, {
    className: (0,dist_clsx/* default */.A)('components-resizable-box__container', showHandle && 'has-show-handle', className),
    handleClasses: HANDLE_CLASSES,
    handleStyles: HANDLE_STYLES,
    ref: ref,
    ...props,
    children: [children, showTooltip && /*#__PURE__*/(0,jsx_runtime.jsx)(resize_tooltip, {
      ...tooltipProps
    })]
  });
}
const ResizableBox = (0,react.forwardRef)(UnforwardedResizableBox);
/* harmony default export */ const resizable_box = (ResizableBox);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/grid-visualizer/grid-item-resizer.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function GridItemResizer({
  clientId,
  bounds,
  onChange
}) {
  const blockElement = useBlockElement(clientId);
  const rootBlockElement = blockElement?.parentElement;
  if (!blockElement || !rootBlockElement) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(GridItemResizerInner, {
    clientId: clientId,
    bounds: bounds,
    blockElement: blockElement,
    rootBlockElement: rootBlockElement,
    onChange: onChange
  });
}
function GridItemResizerInner({
  clientId,
  bounds,
  blockElement,
  rootBlockElement,
  onChange
}) {
  const [resizeDirection, setResizeDirection] = (0,react.useState)(null);
  const [enableSide, setEnableSide] = (0,react.useState)({
    top: false,
    bottom: false,
    left: false,
    right: false
  });
  (0,react.useEffect)(() => {
    const observer = new window.ResizeObserver(() => {
      const blockClientRect = blockElement.getBoundingClientRect();
      const rootBlockClientRect = rootBlockElement.getBoundingClientRect();
      setEnableSide({
        top: blockClientRect.top > rootBlockClientRect.top,
        bottom: blockClientRect.bottom < rootBlockClientRect.bottom,
        left: blockClientRect.left > rootBlockClientRect.left,
        right: blockClientRect.right < rootBlockClientRect.right
      });
    });
    observer.observe(blockElement);
    return () => observer.disconnect();
  }, [blockElement, rootBlockElement]);
  const justification = {
    right: 'flex-start',
    left: 'flex-end'
  };
  const alignment = {
    top: 'flex-end',
    bottom: 'flex-start'
  };
  const styles = {
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    ...(justification[resizeDirection] && {
      justifyContent: justification[resizeDirection]
    }),
    ...(alignment[resizeDirection] && {
      alignItems: alignment[resizeDirection]
    })
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(cover, {
    className: "block-editor-grid-item-resizer",
    clientId: clientId,
    __unstablePopoverSlot: "block-toolbar",
    additionalStyles: styles,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(resizable_box, {
      className: "block-editor-grid-item-resizer__box",
      size: {
        width: '100%',
        height: '100%'
      },
      enable: {
        bottom: enableSide.bottom,
        bottomLeft: false,
        bottomRight: false,
        left: enableSide.left,
        right: enableSide.right,
        top: enableSide.top,
        topLeft: false,
        topRight: false
      },
      bounds: bounds,
      boundsByDirection: true,
      onResizeStart: (event, direction) => {
        /*
         * The container justification and alignment need to be set
         * according to the direction the resizer is being dragged in,
         * so that it resizes in the right direction.
         */
        setResizeDirection(direction);

        /*
         * The mouseup event on the resize handle doesn't trigger if the mouse
         * isn't directly above the handle, so we try to detect if it happens
         * outside the grid and dispatch a mouseup event on the handle.
         */
        blockElement.ownerDocument.addEventListener('mouseup', () => {
          event.target.dispatchEvent(new Event('mouseup', {
            bubbles: true
          }));
        }, {
          once: true
        });
      },
      onResizeStop: (event, direction, boxElement) => {
        const columnGap = parseFloat(getComputedCSS(rootBlockElement, 'column-gap'));
        const rowGap = parseFloat(getComputedCSS(rootBlockElement, 'row-gap'));
        const gridColumnTracks = getGridTracks(getComputedCSS(rootBlockElement, 'grid-template-columns'), columnGap);
        const gridRowTracks = getGridTracks(getComputedCSS(rootBlockElement, 'grid-template-rows'), rowGap);
        const rect = new window.DOMRect(blockElement.offsetLeft + boxElement.offsetLeft, blockElement.offsetTop + boxElement.offsetTop, boxElement.offsetWidth, boxElement.offsetHeight);
        const columnStart = getClosestTrack(gridColumnTracks, rect.left) + 1;
        const rowStart = getClosestTrack(gridRowTracks, rect.top) + 1;
        const columnEnd = getClosestTrack(gridColumnTracks, rect.right, 'end') + 1;
        const rowEnd = getClosestTrack(gridRowTracks, rect.bottom, 'end') + 1;
        onChange({
          columnSpan: columnEnd - columnStart + 1,
          rowSpan: rowEnd - rowStart + 1
        });
      }
    })
  });
}

/**
 * Given a grid-template-columns or grid-template-rows CSS property value, gets the start and end
 * position in pixels of each grid track.
 *
 * https://css-tricks.com/snippets/css/complete-guide-grid/#aa-grid-track
 *
 * @param {string} template The grid-template-columns or grid-template-rows CSS property value.
 *                          Only supports fixed sizes in pixels.
 * @param {number} gap      The gap between grid tracks in pixels.
 *
 * @return {Array<{start: number, end: number}>} An array of objects with the start and end
 *                                               position in pixels of each grid track.
 */
function getGridTracks(template, gap) {
  const tracks = [];
  for (const size of template.split(' ')) {
    const previousTrack = tracks[tracks.length - 1];
    const start = previousTrack ? previousTrack.end + gap : 0;
    const end = start + parseFloat(size);
    tracks.push({
      start,
      end
    });
  }
  return tracks;
}

/**
 * Given an array of grid tracks and a position in pixels, gets the index of the closest track to
 * that position.
 *
 * https://css-tricks.com/snippets/css/complete-guide-grid/#aa-grid-track
 *
 * @param {Array<{start: number, end: number}>} tracks   An array of objects with the start and end
 *                                                       position in pixels of each grid track.
 * @param {number}                              position The position in pixels.
 * @param {string}                              edge     The edge of the track to compare the
 *                                                       position to. Either 'start' or 'end'.
 *
 * @return {number} The index of the closest track to the position. 0-based, unlike CSS grid which
 *                  is 1-based.
 */
function getClosestTrack(tracks, position, edge = 'start') {
  return tracks.reduce((closest, track, index) => Math.abs(track[edge] - position) < Math.abs(tracks[closest][edge] - position) ? index : closest, 0);
}
//# sourceMappingURL=grid-item-resizer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/layout-child.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







function useBlockPropsChildLayoutStyles({
  style
}) {
  var _style$layout;
  const shouldRenderChildLayoutStyles = (0,use_select/* default */.A)(select => {
    return !select(store_store).getSettings().disableLayoutStyles;
  });
  const layout = (_style$layout = style?.layout) !== null && _style$layout !== void 0 ? _style$layout : {};
  const {
    selfStretch,
    flexSize,
    columnStart,
    rowStart,
    columnSpan,
    rowSpan
  } = layout;
  const parentLayout = useLayout() || {};
  const {
    columnCount,
    minimumColumnWidth
  } = parentLayout;
  const id = (0,use_instance_id/* default */.A)(useBlockPropsChildLayoutStyles);
  const selector = `.wp-container-content-${id}`;
  let css = '';
  if (shouldRenderChildLayoutStyles) {
    if (selfStretch === 'fixed' && flexSize) {
      css = `${selector} {
				flex-basis: ${flexSize};
				box-sizing: border-box;
			}`;
    } else if (selfStretch === 'fill') {
      css = `${selector} {
				flex-grow: 1;
			}`;
    } else if (columnStart && columnSpan) {
      css = `${selector} {
				grid-column: ${columnStart} / span ${columnSpan};
			}`;
    } else if (columnStart) {
      css = `${selector} {
				grid-column: ${columnStart};
			}`;
    } else if (columnSpan) {
      css = `${selector} {
				grid-column: span ${columnSpan};
			}`;
    }
    /**
     * If minimumColumnWidth is set on the parent, or if no
     * columnCount is set, the grid is responsive so a
     * container query is needed for the span to resize.
     */
    if ((columnSpan || columnStart) && (minimumColumnWidth || !columnCount)) {
      // Check if columnSpan and columnStart are numbers so Math.max doesn't break.
      const columnSpanNumber = columnSpan ? parseInt(columnSpan) : null;
      const columnStartNumber = columnStart ? parseInt(columnStart) : null;
      const highestNumber = Math.max(columnSpanNumber, columnStartNumber);
      let parentColumnValue = parseFloat(minimumColumnWidth);
      /**
       * 12rem is the default minimumColumnWidth value.
       * If parentColumnValue is not a number, default to 12.
       */
      if (isNaN(parentColumnValue)) {
        parentColumnValue = 12;
      }
      let parentColumnUnit = minimumColumnWidth?.replace(parentColumnValue, '');
      /**
       * Check that parent column unit is either 'px', 'rem' or 'em'.
       * If not, default to 'rem'.
       */
      if (!['px', 'rem', 'em'].includes(parentColumnUnit)) {
        parentColumnUnit = 'rem';
      }
      const defaultGapValue = parentColumnUnit === 'px' ? 24 : 1.5;
      const containerQueryValue = highestNumber * parentColumnValue + (highestNumber - 1) * defaultGapValue;
      // If a span is set we want to preserve it as long as possible, otherwise we just reset the value.
      const gridColumnValue = columnSpan ? '1/-1' : 'auto';
      css += `@container (max-width: ${containerQueryValue}${parentColumnUnit}) {
				${selector} {
					grid-column: ${gridColumnValue};
				}
			}`;
    }
    if (rowStart && rowSpan) {
      css += `${selector} {
				grid-row: ${rowStart} / span ${rowSpan};
			}`;
    } else if (rowStart) {
      css += `${selector} {
				grid-row: ${rowStart};
			}`;
    } else if (rowSpan) {
      css += `${selector} {
				grid-row: span ${rowSpan};
			}`;
    }
  }
  utils_useStyleOverride({
    css
  });

  // Only attach a container class if there is generated CSS to be attached.
  if (!css) {
    return;
  }

  // Attach a `wp-container-content` id-based classname.
  return {
    className: `wp-container-content-${id}`
  };
}
function ChildLayoutControlsPure({
  clientId,
  style,
  setAttributes
}) {
  const {
    type: parentLayoutType = 'default',
    allowSizingOnChildren = false
  } = useLayout() || {};
  const rootClientId = (0,use_select/* default */.A)(select => {
    return select(store_store).getBlockRootClientId(clientId);
  }, [clientId]);

  // Use useState() instead of useRef() so that GridItemResizer updates when ref is set.
  const [resizerBounds, setResizerBounds] = (0,react.useState)();
  if (parentLayoutType !== 'grid') {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(GridVisualizer, {
      clientId: rootClientId,
      contentRef: setResizerBounds
    }), allowSizingOnChildren && /*#__PURE__*/(0,jsx_runtime.jsx)(GridItemResizer, {
      clientId: clientId
      // Don't allow resizing beyond the grid visualizer.
      ,
      bounds: resizerBounds,
      onChange: ({
        columnSpan,
        rowSpan
      }) => {
        setAttributes({
          style: {
            ...style,
            layout: {
              ...style?.layout,
              columnSpan,
              rowSpan
            }
          }
        });
      }
    })]
  });
}
/* harmony default export */ const layout_child = ({
  useBlockProps: useBlockPropsChildLayoutStyles,
  edit: ChildLayoutControlsPure,
  attributeKeys: ['style'],
  hasSupport() {
    return true;
  }
});
//# sourceMappingURL=layout-child.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/use-convert-to-group-button-props.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Contains the properties `ConvertToGroupButton` component needs.
 *
 * @typedef {Object} ConvertToGroupButtonProps
 * @property {string[]}  clientIds         An array of the selected client ids.
 * @property {boolean}   isGroupable       Indicates if the selected blocks can be grouped.
 * @property {boolean}   isUngroupable     Indicates if the selected blocks can be ungrouped.
 * @property {WPBlock[]} blocksSelection   An array of the selected blocks.
 * @property {string}    groupingBlockName The name of block used for handling grouping interactions.
 */

/**
 * Returns the properties `ConvertToGroupButton` component needs to work properly.
 * It is used in `BlockSettingsMenuControls` to know if `ConvertToGroupButton`
 * should be rendered, to avoid ending up with an empty MenuGroup.
 *
 * @param {?string[]} selectedClientIds An optional array of clientIds to group. The selected blocks
 *                                      from the block editor store are used if this is not provided.
 *
 * @return {ConvertToGroupButtonProps} Returns the properties needed by `ConvertToGroupButton`.
 */
function useConvertToGroupButtonProps(selectedClientIds) {
  return (0,use_select/* default */.A)(select => {
    const {
      getBlocksByClientId,
      getSelectedBlockClientIds,
      isUngroupable,
      isGroupable
    } = select(store_store);
    const {
      getGroupingBlockName,
      getBlockType
    } = select(build_module/* store */.M_);
    const clientIds = selectedClientIds?.length ? selectedClientIds : getSelectedBlockClientIds();
    const blocksSelection = getBlocksByClientId(clientIds);
    const [firstSelectedBlock] = blocksSelection;
    const _isUngroupable = clientIds.length === 1 && isUngroupable(clientIds[0]);
    return {
      clientIds,
      isGroupable: isGroupable(clientIds),
      isUngroupable: _isUngroupable,
      blocksSelection,
      groupingBlockName: getGroupingBlockName(),
      onUngroup: _isUngroupable && getBlockType(firstSelectedBlock.name)?.transforms?.ungroup
    };
  }, [selectedClientIds]);
}
//# sourceMappingURL=use-convert-to-group-button-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/index.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */






function ConvertToGroupButton({
  clientIds,
  isGroupable,
  isUngroupable,
  onUngroup,
  blocksSelection,
  groupingBlockName,
  onClose = () => {}
}) {
  const {
    getSelectedBlockClientIds
  } = (0,use_select/* default */.A)(store_store);
  const {
    replaceBlocks
  } = (0,use_dispatch/* default */.A)(store_store);
  const onConvertToGroup = () => {
    // Activate the `transform` on the Grouping Block which does the conversion.
    const newBlocks = (0,build_module/* switchToBlockType */.bh)(blocksSelection, groupingBlockName);
    if (newBlocks) {
      replaceBlocks(clientIds, newBlocks);
    }
  };
  const onConvertFromGroup = () => {
    let innerBlocks = blocksSelection[0].innerBlocks;
    if (!innerBlocks.length) {
      return;
    }
    if (onUngroup) {
      innerBlocks = onUngroup(blocksSelection[0].attributes, blocksSelection[0].innerBlocks);
    }
    replaceBlocks(clientIds, innerBlocks);
  };
  if (!isGroupable && !isUngroupable) {
    return null;
  }
  const selectedBlockClientIds = getSelectedBlockClientIds();
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [isGroupable && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
      shortcut: selectedBlockClientIds.length > 1 ? keycodes_build_module/* displayShortcut */.dz.primary('g') : undefined,
      onClick: () => {
        onConvertToGroup();
        onClose();
      },
      children: (0,i18n_build_module._x)('Group', 'verb')
    }), isUngroupable && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
      onClick: () => {
        onConvertFromGroup();
        onClose();
      },
      children: (0,i18n_build_module._x)('Ungroup', 'Ungrouping blocks from within a grouping block back into individual blocks within the Editor ')
    })]
  });
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-lock/use-block-lock.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Return details about the block lock status.
 *
 * @param {string} clientId The block client Id.
 *
 * @return {Object} Block lock status
 */
function useBlockLock(clientId) {
  return (0,use_select/* default */.A)(select => {
    const {
      canEditBlock,
      canMoveBlock,
      canRemoveBlock,
      canLockBlockType,
      getBlockName,
      getTemplateLock
    } = select(store_store);
    const canEdit = canEditBlock(clientId);
    const canMove = canMoveBlock(clientId);
    const canRemove = canRemoveBlock(clientId);
    return {
      canEdit,
      canMove,
      canRemove,
      canLock: canLockBlockType(getBlockName(clientId)),
      isContentLocked: getTemplateLock(clientId) === 'contentOnly',
      isLocked: !canEdit || !canMove || !canRemove
    };
  }, [clientId]);
}
//# sourceMappingURL=use-block-lock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/unlock.js
/**
 * WordPress dependencies
 */


const unlock_unlock = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8h1.5c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1z"
  })
});
/* harmony default export */ const library_unlock = (unlock_unlock);
//# sourceMappingURL=unlock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/lock-outline.js
/**
 * WordPress dependencies
 */


const lockOutline = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zM9.8 7c0-1.2 1-2.2 2.2-2.2 1.2 0 2.2 1 2.2 2.2v3H9.8V7zm6.7 11.5h-9v-7h9v7z"
  })
});
/* harmony default export */ const lock_outline = (lockOutline);
//# sourceMappingURL=lock-outline.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/modal/index.js + 1 modules
var modal = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/modal/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/lock.js
/**
 * WordPress dependencies
 */


const lock_lock = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zm-2.8 0H9.8V7c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3z"
  })
});
/* harmony default export */ const library_lock = (lock_lock);
//# sourceMappingURL=lock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-lock/modal.js
/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */




// Entity based blocks which allow edit locking


const ALLOWS_EDIT_LOCKING = ['core/block', 'core/navigation'];
function getTemplateLockValue(lock) {
  // Prevents all operations.
  if (lock.remove && lock.move) {
    return 'all';
  }

  // Prevents inserting or removing blocks, but allows moving existing blocks.
  if (lock.remove && !lock.move) {
    return 'insert';
  }
  return false;
}
function BlockLockModal({
  clientId,
  onClose
}) {
  const [lock, setLock] = (0,react.useState)({
    move: false,
    remove: false
  });
  const {
    canEdit,
    canMove,
    canRemove
  } = useBlockLock(clientId);
  const {
    allowsEditLocking,
    templateLock,
    hasTemplateLock
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockName,
      getBlockAttributes
    } = select(store_store);
    const blockName = getBlockName(clientId);
    const blockType = (0,build_module/* getBlockType */.E7)(blockName);
    return {
      allowsEditLocking: ALLOWS_EDIT_LOCKING.includes(blockName),
      templateLock: getBlockAttributes(clientId)?.templateLock,
      hasTemplateLock: !!blockType?.attributes?.templateLock
    };
  }, [clientId]);
  const [applyTemplateLock, setApplyTemplateLock] = (0,react.useState)(!!templateLock);
  const {
    updateBlockAttributes
  } = (0,use_dispatch/* default */.A)(store_store);
  const blockInformation = useBlockDisplayInformation(clientId);
  const instanceId = (0,use_instance_id/* default */.A)(BlockLockModal, 'block-editor-block-lock-modal__options-title');
  (0,react.useEffect)(() => {
    setLock({
      move: !canMove,
      remove: !canRemove,
      ...(allowsEditLocking ? {
        edit: !canEdit
      } : {})
    });
  }, [canEdit, canMove, canRemove, allowsEditLocking]);
  const isAllChecked = Object.values(lock).every(Boolean);
  const isMixed = Object.values(lock).some(Boolean) && !isAllChecked;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(modal/* default */.A, {
    title: (0,i18n_build_module/* sprintf */.nv)( /* translators: %s: Name of the block. */
    (0,i18n_build_module.__)('Lock %s'), blockInformation.title),
    overlayClassName: "block-editor-block-lock-modal",
    onRequestClose: onClose,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("p", {
      children: (0,i18n_build_module.__)('Choose specific attributes to restrict or lock all available options.')
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("form", {
      onSubmit: event => {
        event.preventDefault();
        updateBlockAttributes([clientId], {
          lock,
          templateLock: applyTemplateLock ? getTemplateLockValue(lock) : undefined
        });
        onClose();
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        role: "group",
        "aria-labelledby": instanceId,
        className: "block-editor-block-lock-modal__options",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_control/* default */.A, {
          __nextHasNoMarginBottom: true,
          className: "block-editor-block-lock-modal__options-title",
          label: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            id: instanceId,
            children: (0,i18n_build_module.__)('Lock all')
          }),
          checked: isAllChecked,
          indeterminate: isMixed,
          onChange: newValue => setLock({
            move: newValue,
            remove: newValue,
            ...(allowsEditLocking ? {
              edit: newValue
            } : {})
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsxs)("ul", {
          className: "block-editor-block-lock-modal__checklist",
          children: [allowsEditLocking && /*#__PURE__*/(0,jsx_runtime.jsxs)("li", {
            className: "block-editor-block-lock-modal__checklist-item",
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_control/* default */.A, {
              __nextHasNoMarginBottom: true,
              label: (0,i18n_build_module.__)('Restrict editing'),
              checked: !!lock.edit,
              onChange: edit => setLock(prevLock => ({
                ...prevLock,
                edit
              }))
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
              className: "block-editor-block-lock-modal__lock-icon",
              icon: lock.edit ? library_lock : library_unlock
            })]
          }), /*#__PURE__*/(0,jsx_runtime.jsxs)("li", {
            className: "block-editor-block-lock-modal__checklist-item",
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_control/* default */.A, {
              __nextHasNoMarginBottom: true,
              label: (0,i18n_build_module.__)('Disable movement'),
              checked: lock.move,
              onChange: move => setLock(prevLock => ({
                ...prevLock,
                move
              }))
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
              className: "block-editor-block-lock-modal__lock-icon",
              icon: lock.move ? library_lock : library_unlock
            })]
          }), /*#__PURE__*/(0,jsx_runtime.jsxs)("li", {
            className: "block-editor-block-lock-modal__checklist-item",
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(checkbox_control/* default */.A, {
              __nextHasNoMarginBottom: true,
              label: (0,i18n_build_module.__)('Prevent removal'),
              checked: lock.remove,
              onChange: remove => setLock(prevLock => ({
                ...prevLock,
                remove
              }))
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
              className: "block-editor-block-lock-modal__lock-icon",
              icon: lock.remove ? library_lock : library_unlock
            })]
          })]
        }), hasTemplateLock && /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_control/* default */.A, {
          __nextHasNoMarginBottom: true,
          className: "block-editor-block-lock-modal__template-lock",
          label: (0,i18n_build_module.__)('Apply to all blocks inside'),
          checked: applyTemplateLock,
          disabled: lock.move && !lock.remove,
          onChange: () => setApplyTemplateLock(!applyTemplateLock)
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
        className: "block-editor-block-lock-modal__actions",
        justify: "flex-end",
        expanded: false,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
            variant: "tertiary",
            onClick: onClose,
            children: (0,i18n_build_module.__)('Cancel')
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
            variant: "primary",
            type: "submit",
            children: (0,i18n_build_module.__)('Apply')
          })
        })]
      })]
    })]
  });
}
//# sourceMappingURL=modal.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-lock/menu-item.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





function BlockLockMenuItem({
  clientId
}) {
  const {
    canLock,
    isLocked
  } = useBlockLock(clientId);
  const [isModalOpen, toggleModal] = (0,react.useReducer)(isActive => !isActive, false);
  if (!canLock) {
    return null;
  }
  const label = isLocked ? (0,i18n_build_module.__)('Unlock') : (0,i18n_build_module.__)('Lock');
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
      icon: isLocked ? library_unlock : lock_outline,
      onClick: toggleModal,
      "aria-expanded": isModalOpen,
      "aria-haspopup": "dialog",
      children: label
    }), isModalOpen && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockLockModal, {
      clientId: clientId,
      onClose: toggleModal
    })]
  });
}
//# sourceMappingURL=menu-item.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-mode-toggle.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


const block_mode_toggle_noop = () => {};
function BlockModeToggle({
  blockType,
  mode,
  onToggleMode,
  small = false,
  isCodeEditingEnabled = true
}) {
  if (!blockType || !(0,build_module/* hasBlockSupport */.pN)(blockType, 'html', true) || !isCodeEditingEnabled) {
    return null;
  }
  const label = mode === 'visual' ? (0,i18n_build_module.__)('Edit as HTML') : (0,i18n_build_module.__)('Edit visually');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
    onClick: onToggleMode,
    children: !small && label
  });
}
/* harmony default export */ const block_mode_toggle = ((0,compose/* default */.A)([with_select((select, {
  clientId
}) => {
  const {
    getBlock,
    getBlockMode,
    getSettings
  } = select(store_store);
  const block = getBlock(clientId);
  const isCodeEditingEnabled = getSettings().codeEditingEnabled;
  return {
    mode: getBlockMode(clientId),
    blockType: block ? (0,build_module/* getBlockType */.E7)(block.name) : null,
    isCodeEditingEnabled
  };
}), with_dispatch((dispatch, {
  onToggle = block_mode_toggle_noop,
  clientId
}) => ({
  onToggleMode() {
    dispatch(store_store).toggleBlockMode(clientId);
    onToggle();
  }
}))])(BlockModeToggle));
//# sourceMappingURL=block-mode-toggle.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-rename/use-block-rename.js
/**
 * WordPress dependencies
 */

function useBlockRename(name) {
  return {
    canRename: (0,build_module/* getBlockSupport */.bI)(name, 'renaming', true)
  };
}
//# sourceMappingURL=use-block-rename.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-rename/is-empty-string.js
function isEmptyString(testString) {
  return testString?.trim()?.length === 0;
}
//# sourceMappingURL=is-empty-string.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-rename/modal.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



function BlockRenameModal({
  blockName,
  originalBlockName,
  onClose,
  onSave,
  // Pattern Overrides is a WordPress-only feature but it also uses the Block Binding API.
  // Ideally this should not be inside the block editor package, but we keep it here for simplicity.
  hasOverridesWarning
}) {
  const [editedBlockName, setEditedBlockName] = (0,react.useState)(blockName);
  const descriptionId = (0,react.useId)();
  const nameHasChanged = editedBlockName !== blockName;
  const nameIsOriginal = editedBlockName === originalBlockName;
  const nameIsEmpty = isEmptyString(editedBlockName);
  const isNameValid = nameHasChanged || nameIsOriginal;
  const autoSelectInputText = event => event.target.select();
  const handleSubmit = () => {
    const message = nameIsOriginal || nameIsEmpty ? (0,i18n_build_module/* sprintf */.nv)( /* translators: %s: new name/label for the block */
    (0,i18n_build_module.__)('Block name reset to: "%s".'), editedBlockName) : (0,i18n_build_module/* sprintf */.nv)( /* translators: %s: new name/label for the block */
    (0,i18n_build_module.__)('Block name changed to: "%s".'), editedBlockName);

    // Must be assertive to immediately announce change.
    (0,a11y_build_module/* speak */.L)(message, 'assertive');
    onSave(editedBlockName);

    // Immediate close avoids ability to hit save multiple times.
    onClose();
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(modal/* default */.A, {
    title: (0,i18n_build_module.__)('Rename'),
    onRequestClose: onClose,
    overlayClassName: "block-editor-block-rename-modal",
    focusOnMount: "firstContentElement",
    aria: {
      describedby: descriptionId
    },
    size: "small",
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("form", {
      onSubmit: e => {
        e.preventDefault();
        if (!isNameValid) {
          return;
        }
        handleSubmit();
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("p", {
        id: descriptionId,
        children: (0,i18n_build_module.__)('Enter a custom name for this block.')
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
        spacing: "3",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_control/* default */.A, {
          __nextHasNoMarginBottom: true,
          __next40pxDefaultSize: true,
          value: editedBlockName,
          label: (0,i18n_build_module.__)('Block name'),
          hideLabelFromVision: true,
          help: hasOverridesWarning ? (0,i18n_build_module.__)('This block allows overrides. Changing the name can cause problems with content entered into instances of this pattern.') : undefined,
          placeholder: originalBlockName,
          onChange: setEditedBlockName,
          onFocus: autoSelectInputText
        }), /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
          justify: "right",
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
            __next40pxDefaultSize: true,
            variant: "tertiary",
            onClick: onClose,
            children: (0,i18n_build_module.__)('Cancel')
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
            __next40pxDefaultSize: true,
            "aria-disabled": !isNameValid,
            variant: "primary",
            type: "submit",
            children: (0,i18n_build_module.__)('Save')
          })]
        })]
      })]
    })
  });
}
//# sourceMappingURL=modal.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-rename/rename-control.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







function BlockRenameControl({
  clientId
}) {
  const [renamingBlock, setRenamingBlock] = (0,react.useState)(false);
  const {
    metadata
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockAttributes
    } = select(store_store);
    const _metadata = getBlockAttributes(clientId)?.metadata;
    return {
      metadata: _metadata
    };
  }, [clientId]);
  const {
    updateBlockAttributes
  } = (0,use_dispatch/* default */.A)(store_store);
  const customName = metadata?.name;
  const hasPatternOverrides = !!customName && !!metadata?.bindings && Object.values(metadata.bindings).some(binding => binding.source === 'core/pattern-overrides');
  function onChange(newName) {
    updateBlockAttributes([clientId], {
      metadata: {
        ...metadata,
        name: newName
      }
    });
  }
  const blockInformation = useBlockDisplayInformation(clientId);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
      onClick: () => {
        setRenamingBlock(true);
      },
      "aria-expanded": renamingBlock,
      "aria-haspopup": "dialog",
      children: (0,i18n_build_module.__)('Rename')
    }), renamingBlock && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockRenameModal, {
      blockName: customName || '',
      originalBlockName: blockInformation?.title,
      hasOverridesWarning: hasPatternOverrides,
      onClose: () => setRenamingBlock(false),
      onSave: newName => {
        // If the new value is the block's original name (e.g. `Group`)
        // or it is an empty string then assume the intent is to reset
        // the value. Therefore reset the metadata.
        if (newName === blockInformation?.title || isEmptyString(newName)) {
          newName = undefined;
        }
        onChange(newName);
      }
    })]
  });
}
//# sourceMappingURL=rename-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu-controls/index.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







const {
  Fill,
  Slot
} = (0,slot_fill/* createSlotFill */.QJ)('BlockSettingsMenuControls');
const BlockSettingsMenuControlsSlot = ({
  fillProps,
  clientIds = null
}) => {
  const {
    selectedBlocks,
    selectedClientIds,
    isContentOnly
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockNamesByClientId,
      getSelectedBlockClientIds,
      getBlockEditingMode
    } = select(store_store);
    const ids = clientIds !== null ? clientIds : getSelectedBlockClientIds();
    return {
      selectedBlocks: getBlockNamesByClientId(ids),
      selectedClientIds: ids,
      isContentOnly: getBlockEditingMode(ids[0]) === 'contentOnly'
    };
  }, [clientIds]);
  const {
    canLock
  } = useBlockLock(selectedClientIds[0]);
  const {
    canRename
  } = useBlockRename(selectedBlocks[0]);
  const showLockButton = selectedClientIds.length === 1 && canLock && !isContentOnly;
  const showRenameButton = selectedClientIds.length === 1 && canRename && !isContentOnly;

  // Check if current selection of blocks is Groupable or Ungroupable
  // and pass this props down to ConvertToGroupButton.
  const convertToGroupButtonProps = useConvertToGroupButtonProps(selectedClientIds);
  const {
    isGroupable,
    isUngroupable
  } = convertToGroupButtonProps;
  const showConvertToGroupButton = isGroupable || isUngroupable;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Slot, {
    fillProps: {
      ...fillProps,
      selectedBlocks,
      selectedClientIds
    },
    children: fills => {
      if (!fills?.length > 0 && !showConvertToGroupButton && !showLockButton) {
        return null;
      }
      return /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_group/* default */.A, {
        children: [showConvertToGroupButton && /*#__PURE__*/(0,jsx_runtime.jsx)(ConvertToGroupButton, {
          ...convertToGroupButtonProps,
          onClose: fillProps?.onClose
        }), showLockButton && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockLockMenuItem, {
          clientId: selectedClientIds[0]
        }), showRenameButton && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockRenameControl, {
          clientId: selectedClientIds[0]
        }), fills, fillProps?.canMove && !fillProps?.onlyBlock && !isContentOnly && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
          onClick: (0,pipe/* default */.h)(fillProps?.onClose, fillProps?.onMoveTo),
          children: (0,i18n_build_module.__)('Move to')
        }), fillProps?.count === 1 && !isContentOnly && /*#__PURE__*/(0,jsx_runtime.jsx)(block_mode_toggle, {
          clientId: fillProps?.firstBlockClientId,
          onToggle: fillProps?.onClose
        })]
      });
    }
  });
};

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-settings-menu-controls/README.md
 *
 * @param {Object} props Fill props.
 * @return {Element} Element.
 */
function BlockSettingsMenuControls({
  ...props
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(style_provider/* default */.A, {
    document: document,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Fill, {
      ...props
    })
  });
}
BlockSettingsMenuControls.Slot = BlockSettingsMenuControlsSlot;
/* harmony default export */ const block_settings_menu_controls = (BlockSettingsMenuControls);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/content-lock-ui.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




// The implementation of content locking is mainly in this file, although the mechanism
// to stop temporarily editing as blocks when an outside block is selected is on component StopEditingAsBlocksOnOutsideSelect
// at block-editor/src/components/block-list/index.js.
// Besides the components on this file and the file referenced above the implementation
// also includes artifacts on the store (actions, reducers, and selector).



function ContentLockControlsPure({
  clientId,
  isSelected
}) {
  const {
    templateLock,
    isLockedByParent,
    isEditingAsBlocks
  } = (0,use_select/* default */.A)(select => {
    const {
      getContentLockingParent,
      getTemplateLock,
      getTemporarilyEditingAsBlocks
    } = lock_unlock_unlock(select(store_store));
    return {
      templateLock: getTemplateLock(clientId),
      isLockedByParent: !!getContentLockingParent(clientId),
      isEditingAsBlocks: getTemporarilyEditingAsBlocks() === clientId
    };
  }, [clientId]);
  const {
    stopEditingAsBlocks,
    modifyContentLockBlock
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  const isContentLocked = !isLockedByParent && templateLock === 'contentOnly';
  const stopEditingAsBlockCallback = (0,react.useCallback)(() => {
    stopEditingAsBlocks(clientId);
  }, [clientId, stopEditingAsBlocks]);
  if (!isContentLocked && !isEditingAsBlocks) {
    return null;
  }
  const showStopEditingAsBlocks = isEditingAsBlocks && !isContentLocked;
  const showStartEditingAsBlocks = !isEditingAsBlocks && isContentLocked && isSelected;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [showStopEditingAsBlocks && /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_controls, {
        group: "other",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
          onClick: stopEditingAsBlockCallback,
          children: (0,i18n_build_module.__)('Done')
        })
      })
    }), showStartEditingAsBlocks && /*#__PURE__*/(0,jsx_runtime.jsx)(block_settings_menu_controls, {
      children: ({
        selectedClientIds,
        onClose
      }) => selectedClientIds.length === 1 && selectedClientIds[0] === clientId && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
        onClick: () => {
          modifyContentLockBlock(clientId);
          onClose();
        },
        children: (0,i18n_build_module.__)('Modify')
      })
    })]
  });
}
/* harmony default export */ const content_lock_ui = ({
  edit: ContentLockControlsPure,
  hasSupport() {
    return true;
  }
});
//# sourceMappingURL=content-lock-ui.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/metadata.js
/**
 * WordPress dependencies
 */

const META_ATTRIBUTE_NAME = 'metadata';

/**
 * Filters registered block settings, extending attributes to include `metadata`.
 *
 * see: https://github.com/WordPress/gutenberg/pull/40393/files#r864632012
 *
 * @param {Object} blockTypeSettings Original block settings.
 * @return {Object} Filtered block settings.
 */
function addMetaAttribute(blockTypeSettings) {
  // Allow blocks to specify their own attribute definition with default values if needed.
  if (blockTypeSettings?.attributes?.[META_ATTRIBUTE_NAME]?.type) {
    return blockTypeSettings;
  }
  blockTypeSettings.attributes = {
    ...blockTypeSettings.attributes,
    [META_ATTRIBUTE_NAME]: {
      type: 'object'
    }
  };
  return blockTypeSettings;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/metadata/addMetaAttribute', addMetaAttribute);
//# sourceMappingURL=metadata.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/block-default.js
/**
 * WordPress dependencies
 */


const blockDefault = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M19 8h-1V6h-5v2h-2V6H6v2H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8c0-1.1-.9-2-2-2zm.5 10c0 .3-.2.5-.5.5H5c-.3 0-.5-.2-.5-.5v-8c0-.3.2-.5.5-.5h14c.3 0 .5.2.5.5v8z"
  })
});
/* harmony default export */ const block_default = (blockDefault);
//# sourceMappingURL=block-default.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-icon/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




function BlockIcon({
  icon,
  showColors = false,
  className,
  context
}) {
  if (icon?.src === 'block-default') {
    icon = {
      src: block_default
    };
  }
  const renderedIcon = /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
    icon: icon && icon.src ? icon.src : icon,
    context: context
  });
  const style = showColors ? {
    backgroundColor: icon && icon.background,
    color: icon && icon.foreground
  } : {};
  return /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
    style: style,
    className: (0,dist_clsx/* default */.A)('block-editor-block-icon', className, {
      'has-colors': showColors
    }),
    children: renderedIcon
  });
}

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-icon/README.md
 */
/* harmony default export */ const block_icon = ((0,react.memo)(BlockIcon));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/block-hooks.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




const block_hooks_EMPTY_OBJECT = {};
function BlockHooksControlPure({
  name,
  clientId,
  metadata: {
    ignoredHookedBlocks = []
  } = {}
}) {
  const blockTypes = (0,use_select/* default */.A)(select => select(build_module/* store */.M_).getBlockTypes(), []);

  // A hooked block added via a filter will not be exposed through a block
  // type's `blockHooks` property; however, if the containing layout has been
  // modified, it will be present in the anchor block's `ignoredHookedBlocks`
  // metadata.
  const hookedBlocksForCurrentBlock = (0,react.useMemo)(() => blockTypes?.filter(({
    name: blockName,
    blockHooks
  }) => blockHooks && name in blockHooks || ignoredHookedBlocks.includes(blockName)), [blockTypes, name, ignoredHookedBlocks]);
  const {
    blockIndex,
    rootClientId,
    innerBlocksLength
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlocks,
      getBlockIndex,
      getBlockRootClientId
    } = select(store_store);
    return {
      blockIndex: getBlockIndex(clientId),
      innerBlocksLength: getBlocks(clientId)?.length,
      rootClientId: getBlockRootClientId(clientId)
    };
  }, [clientId]);
  const hookedBlockClientIds = (0,use_select/* default */.A)(select => {
    const {
      getBlocks,
      getGlobalBlockCount
    } = select(store_store);
    const _hookedBlockClientIds = hookedBlocksForCurrentBlock.reduce((clientIds, block) => {
      // If the block doesn't exist anywhere in the block tree,
      // we know that we have to set the toggle to disabled.
      if (getGlobalBlockCount(block.name) === 0) {
        return clientIds;
      }
      const relativePosition = block?.blockHooks?.[name];
      let candidates;
      switch (relativePosition) {
        case 'before':
        case 'after':
          // Any of the current block's siblings (with the right block type) qualifies
          // as a hooked block (inserted `before` or `after` the current one), as the block
          // might've been automatically inserted and then moved around a bit by the user.
          candidates = getBlocks(rootClientId);
          break;
        case 'first_child':
        case 'last_child':
          // Any of the current block's child blocks (with the right block type) qualifies
          // as a hooked first or last child block, as the block might've been automatically
          // inserted and then moved around a bit by the user.
          candidates = getBlocks(clientId);
          break;
        case undefined:
          // If we haven't found a blockHooks field with a relative position for the hooked
          // block, it means that it was added by a filter. In this case, we look for the block
          // both among the current block's siblings and its children.
          candidates = [...getBlocks(rootClientId), ...getBlocks(clientId)];
          break;
      }
      const hookedBlock = candidates?.find(candidate => candidate.name === block.name);

      // If the block exists in the designated location, we consider it hooked
      // and show the toggle as enabled.
      if (hookedBlock) {
        return {
          ...clientIds,
          [block.name]: hookedBlock.clientId
        };
      }

      // If no hooked block was found in any of its designated locations,
      // we set the toggle to disabled.
      return clientIds;
    }, {});
    if (Object.values(_hookedBlockClientIds).length > 0) {
      return _hookedBlockClientIds;
    }
    return block_hooks_EMPTY_OBJECT;
  }, [hookedBlocksForCurrentBlock, name, clientId, rootClientId]);
  const {
    insertBlock,
    removeBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  if (!hookedBlocksForCurrentBlock.length) {
    return null;
  }

  // Group by block namespace (i.e. prefix before the slash).
  const groupedHookedBlocks = hookedBlocksForCurrentBlock.reduce((groups, block) => {
    const [namespace] = block.name.split('/');
    if (!groups[namespace]) {
      groups[namespace] = [];
    }
    groups[namespace].push(block);
    return groups;
  }, {});
  const insertBlockIntoDesignatedLocation = (block, relativePosition) => {
    switch (relativePosition) {
      case 'before':
      case 'after':
        insertBlock(block, relativePosition === 'after' ? blockIndex + 1 : blockIndex, rootClientId,
        // Insert as a child of the current block's parent
        false);
        break;
      case 'first_child':
      case 'last_child':
        insertBlock(block,
        // TODO: It'd be great if insertBlock() would accept negative indices for insertion.
        relativePosition === 'first_child' ? 0 : innerBlocksLength, clientId,
        // Insert as a child of the current block.
        false);
        break;
      case undefined:
        // If we do not know the relative position, it is because the block was
        // added via a filter. In this case, we default to inserting it after the
        // current block.
        insertBlock(block, blockIndex + 1, rootClientId,
        // Insert as a child of the current block's parent
        false);
        break;
    }
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(body, {
      className: "block-editor-hooks__block-hooks",
      title: (0,i18n_build_module.__)('Plugins'),
      initialOpen: true,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("p", {
        className: "block-editor-hooks__block-hooks-helptext",
        children: (0,i18n_build_module.__)('Manage the inclusion of blocks added automatically by plugins.')
      }), Object.keys(groupedHookedBlocks).map(vendor => {
        return /*#__PURE__*/(0,jsx_runtime.jsxs)(react.Fragment, {
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h3", {
            children: vendor
          }), groupedHookedBlocks[vendor].map(block => {
            const checked = (block.name in hookedBlockClientIds);
            return /*#__PURE__*/(0,jsx_runtime.jsx)(toggle_control/* default */.A, {
              checked: checked,
              label: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
                justify: "flex-start",
                children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
                  icon: block.icon
                }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
                  children: block.title
                })]
              }),
              onChange: () => {
                if (!checked) {
                  // Create and insert block.
                  const relativePosition = block.blockHooks[name];
                  insertBlockIntoDesignatedLocation((0,build_module/* createBlock */.Wv)(block.name), relativePosition);
                  return;
                }

                // Remove block.
                removeBlock(hookedBlockClientIds[block.name], false);
              }
            }, block.title);
          })]
        }, vendor);
      })]
    })
  });
}
/* harmony default export */ const block_hooks = ({
  edit: BlockHooksControlPure,
  attributeKeys: ['metadata'],
  hasSupport() {
    return true;
  }
});
//# sourceMappingURL=block-hooks.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/item-group/item/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





function useItem(props) {
  const {
    as: asProp,
    className,
    onClick,
    role = 'listitem',
    size: sizeProp,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'Item');
  const {
    spacedAround,
    size: contextSize
  } = useItemGroupContext();
  const size = sizeProp || contextSize;
  const as = asProp || (typeof onClick !== 'undefined' ? 'button' : 'div');
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => cx((as === 'button' || as === 'a') && unstyledButton(as), itemSizes[size] || itemSizes.medium, item, spacedAround && styles_spacedAround, className), [as, className, cx, size, spacedAround]);
  const wrapperClassName = cx(itemWrapper);
  return {
    as,
    className: classes,
    onClick,
    wrapperClassName,
    role,
    ...otherProps
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/item-group/item/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function UnconnectedItem(props, forwardedRef) {
  const {
    role,
    wrapperClassName,
    ...otherProps
  } = useItem(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    role: role,
    className: wrapperClassName,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
      ...otherProps,
      ref: forwardedRef
    })
  });
}

/**
 * `Item` is used in combination with `ItemGroup` to display a list of items
 * grouped and styled together.
 *
 * ```jsx
 * import {
 *   __experimentalItemGroup as ItemGroup,
 *   __experimentalItem as Item,
 * } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ItemGroup>
 *       <Item>Code</Item>
 *       <Item>is</Item>
 *       <Item>Poetry</Item>
 *     </ItemGroup>
 *   );
 * }
 * ```
 */
const Item = (0,context_connect/* contextConnect */.KZ)(UnconnectedItem, 'Item');
/* harmony default export */ const item_component = (Item);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/use-bindings-attributes.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/compose').WPHigherOrderComponent} WPHigherOrderComponent */
/** @typedef {import('@wordpress/blocks').WPBlockSettings} WPBlockSettings */

/**
 * Given a binding of block attributes, returns a higher order component that
 * overrides its `attributes` and `setAttributes` props to sync any changes needed.
 *
 * @return {WPHigherOrderComponent} Higher-order component.
 */


const BLOCK_BINDINGS_ALLOWED_BLOCKS = {
  'core/paragraph': ['content'],
  'core/heading': ['content'],
  'core/image': ['id', 'url', 'title', 'alt'],
  'core/button': ['url', 'text', 'linkTarget', 'rel']
};
const DEFAULT_ATTRIBUTE = '__default';

/**
 * Returns the bindings with the `__default` binding for pattern overrides
 * replaced with the full-set of supported attributes. e.g.:
 *
 * bindings passed in: `{ __default: { source: 'core/pattern-overrides' } }`
 * bindings returned: `{ content: { source: 'core/pattern-overrides' } }`
 *
 * @param {string} blockName The block name (e.g. 'core/paragraph').
 * @param {Object} bindings  A block's bindings from the metadata attribute.
 *
 * @return {Object} The bindings with default replaced for pattern overrides.
 */
function replacePatternOverrideDefaultBindings(blockName, bindings) {
  // The `__default` binding currently only works for pattern overrides.
  if (bindings?.[DEFAULT_ATTRIBUTE]?.source === 'core/pattern-overrides') {
    const supportedAttributes = BLOCK_BINDINGS_ALLOWED_BLOCKS[blockName];
    const bindingsWithDefaults = {};
    for (const attributeName of supportedAttributes) {
      // If the block has mixed binding sources, retain any non pattern override bindings.
      const bindingSource = bindings[attributeName] ? bindings[attributeName] : {
        source: 'core/pattern-overrides'
      };
      bindingsWithDefaults[attributeName] = bindingSource;
    }
    return bindingsWithDefaults;
  }
  return bindings;
}

/**
 * Based on the given block name,
 * check if it is possible to bind the block.
 *
 * @param {string} blockName - The block name.
 * @return {boolean} Whether it is possible to bind the block to sources.
 */
function canBindBlock(blockName) {
  return blockName in BLOCK_BINDINGS_ALLOWED_BLOCKS;
}

/**
 * Based on the given block name and attribute name,
 * check if it is possible to bind the block attribute.
 *
 * @param {string} blockName     - The block name.
 * @param {string} attributeName - The attribute name.
 * @return {boolean} Whether it is possible to bind the block attribute.
 */
function canBindAttribute(blockName, attributeName) {
  return canBindBlock(blockName) && BLOCK_BINDINGS_ALLOWED_BLOCKS[blockName].includes(attributeName);
}
const withBlockBindingSupport = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockEdit => props => {
  const registry = (0,use_registry/* default */.A)();
  const sources = (0,use_select/* default */.A)(select => lock_unlock_unlock(select(build_module/* store */.M_)).getAllBlockBindingsSources());
  const {
    name,
    clientId,
    context
  } = props;
  const hasParentPattern = !!props.context['pattern/overrides'];
  const hasPatternOverridesDefaultBinding = props.attributes.metadata?.bindings?.[DEFAULT_ATTRIBUTE]?.source === 'core/pattern-overrides';
  const bindings = (0,react.useMemo)(() => replacePatternOverrideDefaultBindings(name, props.attributes.metadata?.bindings), [props.attributes.metadata?.bindings, name]);
  const boundAttributes = (0,use_select/* default */.A)(() => {
    if (!bindings) {
      return;
    }
    const attributes = {};
    for (const [attributeName, boundAttribute] of Object.entries(bindings)) {
      const source = sources[boundAttribute.source];
      if (!source?.getValue || !canBindAttribute(name, attributeName)) {
        continue;
      }
      const args = {
        registry,
        context,
        clientId,
        attributeName,
        args: boundAttribute.args
      };
      attributes[attributeName] = source.getValue(args);
      if (attributes[attributeName] === undefined) {
        if (attributeName === 'url') {
          attributes[attributeName] = null;
        } else {
          attributes[attributeName] = source.getPlaceholder?.(args);
        }
      }
    }
    return attributes;
  }, [bindings, name, clientId, context, registry, sources]);
  const {
    setAttributes
  } = props;
  const _setAttributes = (0,react.useCallback)(nextAttributes => {
    registry.batch(() => {
      if (!bindings) {
        setAttributes(nextAttributes);
        return;
      }
      const keptAttributes = {
        ...nextAttributes
      };
      const updatesBySource = new Map();

      // Loop only over the updated attributes to avoid modifying the bound ones that haven't changed.
      for (const [attributeName, newValue] of Object.entries(keptAttributes)) {
        if (!bindings[attributeName] || !canBindAttribute(name, attributeName)) {
          continue;
        }
        const binding = bindings[attributeName];
        const source = sources[binding?.source];
        if (!source?.setValue && !source?.setValues) {
          continue;
        }
        updatesBySource.set(source, {
          ...updatesBySource.get(source),
          [attributeName]: newValue
        });
        delete keptAttributes[attributeName];
      }
      if (updatesBySource.size) {
        for (const [source, attributes] of updatesBySource) {
          if (source.setValues) {
            source.setValues({
              registry,
              context,
              clientId,
              attributes
            });
          } else {
            for (const [attributeName, value] of Object.entries(attributes)) {
              const binding = bindings[attributeName];
              source.setValue({
                registry,
                context,
                clientId,
                attributeName,
                args: binding.args,
                value
              });
            }
          }
        }
      }
      if (
      // Don't update non-connected attributes if the block is using pattern overrides
      // and the editing is happening while overriding the pattern (not editing the original).
      !(hasPatternOverridesDefaultBinding && hasParentPattern) && Object.keys(keptAttributes).length) {
        // Don't update caption and href until they are supported.
        if (hasPatternOverridesDefaultBinding) {
          delete keptAttributes?.caption;
          delete keptAttributes?.href;
        }
        setAttributes(keptAttributes);
      }
    });
  }, [registry, bindings, name, clientId, context, setAttributes, sources, hasPatternOverridesDefaultBinding, hasParentPattern]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(BlockEdit, {
      ...props,
      attributes: {
        ...props.attributes,
        ...boundAttributes
      },
      setAttributes: _setAttributes
    })
  });
}, 'withBlockBindingSupport');

/**
 * Filters a registered block's settings to enhance a block's `edit` component
 * to upgrade bound attributes.
 *
 * @param {WPBlockSettings} settings - Registered block settings.
 * @param {string}          name     - Block name.
 * @return {WPBlockSettings} Filtered block settings.
 */
function shimAttributeSource(settings, name) {
  if (!canBindBlock(name)) {
    return settings;
  }
  return {
    ...settings,
    edit: withBlockBindingSupport(settings.edit)
  };
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/editor/custom-sources-backwards-compatibility/shim-attribute-source', shimAttributeSource);
//# sourceMappingURL=use-bindings-attributes.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/block-bindings.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





const BlockBindingsPanel = ({
  name,
  metadata
}) => {
  const {
    bindings
  } = metadata || {};
  const {
    sources
  } = (0,use_select/* default */.A)(select => {
    const _sources = lock_unlock_unlock(select(build_module/* store */.M_)).getAllBlockBindingsSources();
    return {
      sources: _sources
    };
  }, []);
  if (!bindings) {
    return null;
  }

  // Don't show not allowed attributes.
  // Don't show the bindings connected to pattern overrides in the inspectors panel.
  // TODO: Explore if this should be abstracted to let other sources decide.
  const filteredBindings = {
    ...bindings
  };
  Object.keys(filteredBindings).forEach(key => {
    if (!canBindAttribute(name, key) || filteredBindings[key].source === 'core/pattern-overrides') {
      delete filteredBindings[key];
    }
  });
  if (Object.keys(filteredBindings).length === 0) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inspector_controls, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(body, {
      title: (0,i18n_build_module.__)('Attributes'),
      className: "components-panel__block-bindings-panel",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default */.Ay, {
        help: (0,i18n_build_module.__)('Attributes connected to various sources.'),
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(item_group_component, {
          isBordered: true,
          isSeparated: true,
          size: "large",
          children: Object.keys(filteredBindings).map(key => {
            return /*#__PURE__*/(0,jsx_runtime.jsx)(item_component, {
              children: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
                children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
                  children: key
                }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
                  className: "components-item__block-bindings-source",
                  children: sources[filteredBindings[key].source] ? sources[filteredBindings[key].source].label : filteredBindings[key].source
                })]
              })
            }, key);
          })
        })
      })
    })
  });
};
/* harmony default export */ const block_bindings = ({
  edit: BlockBindingsPanel,
  attributeKeys: ['metadata'],
  hasSupport() {
    return true;
  }
});
//# sourceMappingURL=block-bindings.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/block-renaming.js
/**
 * WordPress dependencies
 */



/**
 * Filters registered block settings, adding an `__experimentalLabel` callback if one does not already exist.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function addLabelCallback(settings) {
  // If blocks provide their own label callback, do not override it.
  if (settings.__experimentalLabel) {
    return settings;
  }
  const supportsBlockNaming = (0,build_module/* hasBlockSupport */.pN)(settings, 'renaming', true // default value
  );

  // Check whether block metadata is supported before using it.
  if (supportsBlockNaming) {
    settings.__experimentalLabel = (attributes, {
      context
    }) => {
      const {
        metadata
      } = attributes;

      // In the list view, use the block's name attribute as the label.
      if (context === 'list-view' && metadata?.name) {
        return metadata.name;
      }
    };
  }
  return settings;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/metadata/addLabelCallback', addLabelCallback);
//# sourceMappingURL=block-renaming.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/use-border-props.js
/**
 * Internal dependencies
 */




// This utility is intended to assist where the serialization of the border
// block support is being skipped for a block but the border related CSS classes
// & styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's border support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 * @return {Object} Border block support derived CSS classes & styles.
 */
function getBorderClassesAndStyles(attributes) {
  const border = attributes.style?.border || {};
  const className = getBorderClasses(attributes);
  return {
    className: className || undefined,
    style: getInlineStyles({
      border
    })
  };
}

/**
 * Derives the border related props for a block from its border block support
 * attributes.
 *
 * Inline styles are forced for named colors to ensure these selections are
 * reflected when themes do not load their color stylesheets in the editor.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} ClassName & style props from border block support.
 */
function useBorderProps(attributes) {
  const {
    colors
  } = useMultipleOriginColorsAndGradients();
  const borderProps = getBorderClassesAndStyles(attributes);
  const {
    borderColor
  } = attributes;

  // Force inline styles to apply named border colors when themes do not load
  // their color stylesheets in the editor.
  if (borderColor) {
    const borderColorObject = getMultiOriginColor({
      colors,
      namedColor: borderColor
    });
    borderProps.style.borderColor = borderColorObject.color;
  }
  return borderProps;
}
//# sourceMappingURL=use-border-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/use-shadow-props.js
/**
 * Internal dependencies
 */


// This utility is intended to assist where the serialization of the shadow
// block support is being skipped for a block but the shadow related CSS classes
// & styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's shadow support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 * @return {Object} Shadow block support derived CSS classes & styles.
 */
function getShadowClassesAndStyles(attributes) {
  const shadow = attributes.style?.shadow || '';
  return {
    style: getInlineStyles({
      shadow
    })
  };
}
//# sourceMappingURL=use-shadow-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/use-color-props.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





// The code in this file has largely been lifted from the color block support
// hook.
//
// This utility is intended to assist where the serialization of the colors
// block support is being skipped for a block but the color related CSS classes
// & styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's color support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Color block support derived CSS classes & styles.
 */
function getColorClassesAndStyles(attributes) {
  const {
    backgroundColor,
    textColor,
    gradient,
    style
  } = attributes;

  // Collect color CSS classes.
  const backgroundClass = getColorClassName('background-color', backgroundColor);
  const textClass = getColorClassName('color', textColor);
  const gradientClass = __experimentalGetGradientClass(gradient);
  const hasGradient = gradientClass || style?.color?.gradient;

  // Determine color CSS class name list.
  const className = clsx(textClass, gradientClass, {
    // Don't apply the background class if there's a gradient.
    [backgroundClass]: !hasGradient && !!backgroundClass,
    'has-text-color': textColor || style?.color?.text,
    'has-background': backgroundColor || style?.color?.background || gradient || style?.color?.gradient,
    'has-link-color': style?.elements?.link?.color
  });

  // Collect inline styles for colors.
  const colorStyles = style?.color || {};
  const styleProp = getInlineStyles({
    color: colorStyles
  });
  return {
    className: className || undefined,
    style: styleProp
  };
}

/**
 * Determines the color related props for a block derived from its color block
 * support attributes.
 *
 * Inline styles are forced for named colors to ensure these selections are
 * reflected when themes do not load their color stylesheets in the editor.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} ClassName & style props from colors block support.
 */
function useColorProps(attributes) {
  const {
    backgroundColor,
    textColor,
    gradient
  } = attributes;
  const [userPalette, themePalette, defaultPalette, userGradients, themeGradients, defaultGradients] = useSettings('color.palette.custom', 'color.palette.theme', 'color.palette.default', 'color.gradients.custom', 'color.gradients.theme', 'color.gradients.default');
  const colors = useMemo(() => [...(userPalette || []), ...(themePalette || []), ...(defaultPalette || [])], [userPalette, themePalette, defaultPalette]);
  const gradients = useMemo(() => [...(userGradients || []), ...(themeGradients || []), ...(defaultGradients || [])], [userGradients, themeGradients, defaultGradients]);
  const colorProps = getColorClassesAndStyles(attributes);

  // Force inline styles to apply colors when themes do not load their color
  // stylesheets in the editor.
  if (backgroundColor) {
    const backgroundColorObject = getColorObjectByAttributeValues(colors, backgroundColor);
    colorProps.style.backgroundColor = backgroundColorObject.color;
  }
  if (gradient) {
    colorProps.style.background = getGradientValueBySlug(gradients, gradient);
  }
  if (textColor) {
    const textColorObject = getColorObjectByAttributeValues(colors, textColor);
    colorProps.style.color = textColorObject.color;
  }
  return colorProps;
}
//# sourceMappingURL=use-color-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/use-spacing-props.js
/**
 * Internal dependencies
 */


// This utility is intended to assist where the serialization of the spacing
// block support is being skipped for a block but the spacing related CSS
// styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's spacing support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Spacing block support derived CSS classes & styles.
 */
function getSpacingClassesAndStyles(attributes) {
  const {
    style
  } = attributes;

  // Collect inline styles for spacing.
  const spacingStyles = style?.spacing || {};
  const styleProp = getInlineStyles({
    spacing: spacingStyles
  });
  return {
    style: styleProp
  };
}
//# sourceMappingURL=use-spacing-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/use-typography-props.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




const {
  kebabCase: use_typography_props_kebabCase
} = lock_unlock_unlock(privateApis);

/*
 * This utility is intended to assist where the serialization of the typography
 * block support is being skipped for a block but the typography related CSS
 * styles still need to be generated so they can be applied to inner elements.
 */
/**
 * Provides the CSS class names and inline styles for a block's typography support
 * attributes.
 *
 * @param {Object}         attributes Block attributes.
 * @param {Object|boolean} settings   Merged theme.json settings
 *
 * @return {Object} Typography block support derived CSS classes & styles.
 */
function getTypographyClassesAndStyles(attributes, settings) {
  let typographyStyles = attributes?.style?.typography || {};
  typographyStyles = {
    ...typographyStyles,
    fontSize: getTypographyFontSizeValue({
      size: attributes?.style?.typography?.fontSize
    }, settings)
  };
  const style = getInlineStyles({
    typography: typographyStyles
  });
  const fontFamilyClassName = !!attributes?.fontFamily ? `has-${use_typography_props_kebabCase(attributes.fontFamily)}-font-family` : '';
  const textAlignClassName = !!attributes?.style?.typography?.textAlign ? `has-text-align-${attributes?.style?.typography?.textAlign}` : '';
  const className = clsx(fontFamilyClassName, textAlignClassName, getFontSizeClass(attributes?.fontSize));
  return {
    className,
    style
  };
}
//# sourceMappingURL=use-typography-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/use-cached-truthy.js
/**
 * WordPress dependencies
 */


/**
 * Keeps an up-to-date copy of the passed value and returns it. If value becomes falsy, it will return the last truthy copy.
 *
 * @param {any} value
 * @return {any} value
 */
function useCachedTruthy(value) {
  const [cachedValue, setCachedValue] = useState(value);
  useEffect(() => {
    if (value) {
      setCachedValue(value);
    }
  }, [value]);
  return cachedValue;
}
//# sourceMappingURL=use-cached-truthy.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/use-zoom-out.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * A hook used to set the editor mode to zoomed out mode, invoking the hook sets the mode.
 *
 * @param {boolean} zoomOut If we should enter into zoomOut mode or not
 */
function useZoomOut(zoomOut = true) {
  const {
    __unstableSetEditorMode
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    __unstableGetEditorMode
  } = (0,use_select/* default */.A)(store_store);
  const originalEditingMode = (0,react.useRef)(null);
  const mode = __unstableGetEditorMode();
  (0,react.useEffect)(() => {
    // Only set this on mount so we know what to return to when we unmount.
    if (!originalEditingMode.current) {
      originalEditingMode.current = mode;
    }
    return () => {
      // We need to use  __unstableGetEditorMode() here and not `mode`, as mode may not update on unmount
      if (__unstableGetEditorMode() === 'zoom-out' && __unstableGetEditorMode() !== originalEditingMode.current) {
        __unstableSetEditorMode(originalEditingMode.current);
      }
    };
  }, []);

  // The effect opens the zoom-out view if we want it open and it's not currently in zoom-out mode.
  (0,react.useEffect)(() => {
    if (zoomOut && mode !== 'zoom-out') {
      __unstableSetEditorMode('zoom-out');
    } else if (!zoomOut && __unstableGetEditorMode() === 'zoom-out' && originalEditingMode.current !== mode) {
      __unstableSetEditorMode(originalEditingMode.current);
    }
  }, [__unstableSetEditorMode, zoomOut, mode]);
}
//# sourceMappingURL=use-zoom-out.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/index.js
/**
 * Internal dependencies
 */




























createBlockEditFilter([block_bindings, align, text_align, hooks_anchor, custom_class_name, style, duotone, position, layout, content_lock_ui, block_hooks, layout_child].filter(Boolean));
createBlockListBlockFilter([align, text_align, hooks_background, style, hooks_color, hooks_dimensions, duotone, font_family, font_size, hooks_border, position, block_style_variation, layout_child]);
createBlockSaveFilter([align, text_align, hooks_anchor, aria_label, custom_class_name, hooks_border, hooks_color, style, font_family, font_size]);











//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/async-mode-provider/context.js
var async_mode_provider_context = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/async-mode-provider/context.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/raw-html.js
var raw_html = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/raw-html.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/safe-html.js
var safe_html = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/safe-html.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-context/index.js
/**
 * WordPress dependencies
 */


/** @typedef {import('react').ReactNode} ReactNode */

/**
 * @typedef BlockContextProviderProps
 *
 * @property {Record<string,*>} value    Context value to merge with current
 *                                       value.
 * @property {ReactNode}        children Component children.
 */

/** @type {import('react').Context<Record<string,*>>} */

const block_context_Context = (0,react.createContext)({});

/**
 * Component which merges passed value with current consumed block context.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-context/README.md
 *
 * @param {BlockContextProviderProps} props
 */
function BlockContextProvider({
  value,
  children
}) {
  const context = (0,react.useContext)(block_context_Context);
  const nextValue = (0,react.useMemo)(() => ({
    ...context,
    ...value
  }), [context, value]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(block_context_Context.Provider, {
    value: nextValue,
    children: children
  });
}
/* harmony default export */ const block_context = (block_context_Context);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-edit/edit.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Default value used for blocks which do not define their own context needs,
 * used to guarantee that a block's `context` prop will always be an object. It
 * is assigned as a constant since it is always expected to be an empty object,
 * and in order to avoid unnecessary React reconciliations of a changing object.
 *
 * @type {{}}
 */

const DEFAULT_BLOCK_CONTEXT = {};
const Edit = props => {
  const {
    name
  } = props;
  const blockType = (0,build_module/* getBlockType */.E7)(name);
  if (!blockType) {
    return null;
  }

  // `edit` and `save` are functions or components describing the markup
  // with which a block is displayed. If `blockType` is valid, assign
  // them preferentially as the render value for the block.
  const Component = blockType.edit || blockType.save;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Component, {
    ...props
  });
};
const EditWithFilters = withFilters('editor.BlockEdit')(Edit);
const EditWithGeneratedProps = props => {
  const {
    attributes = {},
    name
  } = props;
  const blockType = (0,build_module/* getBlockType */.E7)(name);
  const blockContext = (0,react.useContext)(block_context);

  // Assign context values using the block type's declared context needs.
  const context = (0,react.useMemo)(() => {
    return blockType && blockType.usesContext ? Object.fromEntries(Object.entries(blockContext).filter(([key]) => blockType.usesContext.includes(key))) : DEFAULT_BLOCK_CONTEXT;
  }, [blockType, blockContext]);
  if (!blockType) {
    return null;
  }
  if (blockType.apiVersion > 1) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(EditWithFilters, {
      ...props,
      context: context
    });
  }

  // Generate a class name for the block's editable form.
  const generatedClassName = (0,build_module/* hasBlockSupport */.pN)(blockType, 'className', true) ? (0,build_module/* getBlockDefaultClassName */.KW)(name) : null;
  const className = (0,dist_clsx/* default */.A)(generatedClassName, attributes.className, props.className);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(EditWithFilters, {
    ...props,
    context: context,
    className: className
  });
};
/* harmony default export */ const block_edit_edit = (EditWithGeneratedProps);
//# sourceMappingURL=edit.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/warning/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






function Warning({
  className,
  actions,
  children,
  secondaryActions
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    style: {
      display: 'contents',
      all: 'initial'
    },
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: (0,dist_clsx/* default */.A)(className, 'block-editor-warning'),
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        className: "block-editor-warning__contents",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("p", {
          className: "block-editor-warning__message",
          children: children
        }), (react.Children.count(actions) > 0 || secondaryActions) && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          className: "block-editor-warning__actions",
          children: [react.Children.count(actions) > 0 && react.Children.map(actions, (action, i) => /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            className: "block-editor-warning__action",
            children: action
          }, i)), secondaryActions && /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_menu/* default */.A, {
            className: "block-editor-warning__secondary",
            icon: more_vertical/* default */.A,
            label: (0,i18n_build_module.__)('More options'),
            popoverProps: {
              position: 'bottom left',
              className: 'block-editor-warning__dropdown'
            },
            noIcons: true,
            children: () => /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
              children: secondaryActions.map((item, pos) => /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
                onClick: item.onClick,
                children: item.title
              }, pos))
            })
          })]
        })]
      })
    })
  });
}

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/warning/README.md
 */
/* harmony default export */ const warning = (Warning);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-edit/multiple-usage-warning.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function MultipleUsageWarning({
  originalBlockClientId,
  name,
  onReplace
}) {
  const {
    selectBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const blockType = (0,build_module/* getBlockType */.E7)(name);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(warning, {
    actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      variant: "secondary",
      onClick: () => selectBlock(originalBlockClientId),
      children: (0,i18n_build_module.__)('Find original')
    }, "find-original"), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      variant: "secondary",
      onClick: () => onReplace([]),
      children: (0,i18n_build_module.__)('Remove')
    }, "remove")],
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("strong", {
      children: [blockType?.title, ": "]
    }), (0,i18n_build_module.__)('This block can only be used once.')]
  });
}
//# sourceMappingURL=multiple-usage-warning.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/private-block-context.js
/**
 * WordPress dependencies
 */

const PrivateBlockContext = (0,react.createContext)({});
//# sourceMappingURL=private-block-context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-edit/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





/**
 * The `useBlockEditContext` hook provides information about the block this hook is being used in.
 * It returns an object with the `name`, `isSelected` state, and the `clientId` of the block.
 * It is useful if you want to create custom hooks that need access to the current blocks clientId
 * but don't want to rely on the data getting passed in as a parameter.
 *
 * @return {Object} Block edit context
 */



function BlockEdit({
  mayDisplayControls,
  mayDisplayParentControls,
  blockEditingMode,
  isPreviewMode,
  // The remaining props are passed through the BlockEdit filters and are thus
  // public API!
  ...props
}) {
  const {
    name,
    isSelected,
    clientId,
    attributes = {},
    __unstableLayoutClassNames
  } = props;
  const {
    layout = null,
    metadata = {}
  } = attributes;
  const {
    bindings
  } = metadata;
  const layoutSupport = (0,build_module/* hasBlockSupport */.pN)(name, 'layout', false) || (0,build_module/* hasBlockSupport */.pN)(name, '__experimentalLayout', false);
  const {
    originalBlockClientId
  } = (0,react.useContext)(PrivateBlockContext);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(Provider
  // It is important to return the same object if props haven't
  // changed to avoid  unnecessary rerenders.
  // See https://reactjs.org/docs/context.html#caveats.
  , {
    value: (0,react.useMemo)(() => ({
      name,
      isSelected,
      clientId,
      layout: layoutSupport ? layout : null,
      __unstableLayoutClassNames,
      // We use symbols in favour of an __unstable prefix to avoid
      // usage outside of the package (this context is exposed).
      [mayDisplayControlsKey]: mayDisplayControls,
      [mayDisplayParentControlsKey]: mayDisplayParentControls,
      [blockEditingModeKey]: blockEditingMode,
      [blockBindingsKey]: bindings,
      [isPreviewModeKey]: isPreviewMode
    }), [name, isSelected, clientId, layoutSupport, layout, __unstableLayoutClassNames, mayDisplayControls, mayDisplayParentControls, blockEditingMode, bindings, isPreviewMode]),
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_edit_edit, {
      ...props
    }), originalBlockClientId && /*#__PURE__*/(0,jsx_runtime.jsx)(MultipleUsageWarning, {
      originalBlockClientId: originalBlockClientId,
      name: name,
      onReplace: props.onReplace
    })]
  });
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/character.js
var character = __webpack_require__("../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/character.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-compare/block-view.js
/**
 * WordPress dependencies
 */





function BlockView({
  title,
  rawContent,
  renderedContent,
  action,
  actionText,
  className
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: className,
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "block-editor-block-compare__content",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h2", {
        className: "block-editor-block-compare__heading",
        children: title
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "block-editor-block-compare__html",
        children: rawContent
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "block-editor-block-compare__preview edit-post-visual-editor",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(raw_html/* default */.A, {
          children: (0,safe_html/* default */.A)(renderedContent)
        })
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-block-compare__action",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        variant: "secondary",
        tabIndex: "0",
        onClick: action,
        children: actionText
      })
    })]
  });
}
//# sourceMappingURL=block-view.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-compare/index.js
/**
 * External dependencies
 */

// diff doesn't tree-shake correctly, so we import from the individual
// module here, to avoid including too much of the library


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockCompare({
  block,
  onKeep,
  onConvert,
  convertor,
  convertButtonText
}) {
  function getDifference(originalContent, newContent) {
    const difference = (0,character/* diffChars */.JJ)(originalContent, newContent);
    return difference.map((item, pos) => {
      const classes = (0,dist_clsx/* default */.A)({
        'block-editor-block-compare__added': item.added,
        'block-editor-block-compare__removed': item.removed
      });
      return /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
        className: classes,
        children: item.value
      }, pos);
    });
  }
  function getConvertedContent(convertedBlock) {
    // The convertor may return an array of items or a single item.
    const newBlocks = Array.isArray(convertedBlock) ? convertedBlock : [convertedBlock];

    // Get converted block details.
    const newContent = newBlocks.map(item => (0,build_module/* getSaveContent */.Z9)(item.name, item.attributes, item.innerBlocks));
    return newContent.join('');
  }
  const converted = getConvertedContent(convertor(block));
  const difference = getDifference(block.originalContent, converted);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "block-editor-block-compare__wrapper",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(BlockView, {
      title: (0,i18n_build_module.__)('Current'),
      className: "block-editor-block-compare__current",
      action: onKeep,
      actionText: (0,i18n_build_module.__)('Convert to HTML'),
      rawContent: block.originalContent,
      renderedContent: block.originalContent
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(BlockView, {
      title: (0,i18n_build_module.__)('After Conversion'),
      className: "block-editor-block-compare__converted",
      action: onConvert,
      actionText: convertButtonText,
      rawContent: difference,
      renderedContent: converted
    })]
  });
}
/* harmony default export */ const block_compare = (BlockCompare);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/block-invalid-warning.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */






const blockToBlocks = block => (0,build_module/* rawHandler */.lh)({
  HTML: block.originalContent
});
function BlockInvalidWarning({
  clientId
}) {
  const {
    block,
    canInsertHTMLBlock,
    canInsertClassicBlock
  } = (0,use_select/* default */.A)(select => {
    const {
      canInsertBlockType,
      getBlock,
      getBlockRootClientId
    } = select(store_store);
    const rootClientId = getBlockRootClientId(clientId);
    return {
      block: getBlock(clientId),
      canInsertHTMLBlock: canInsertBlockType('core/html', rootClientId),
      canInsertClassicBlock: canInsertBlockType('core/freeform', rootClientId)
    };
  }, [clientId]);
  const {
    replaceBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const [compare, setCompare] = (0,react.useState)(false);
  const onCompareClose = (0,react.useCallback)(() => setCompare(false), []);
  const convert = (0,react.useMemo)(() => ({
    toClassic() {
      const classicBlock = (0,build_module/* createBlock */.Wv)('core/freeform', {
        content: block.originalContent
      });
      return replaceBlock(block.clientId, classicBlock);
    },
    toHTML() {
      const htmlBlock = (0,build_module/* createBlock */.Wv)('core/html', {
        content: block.originalContent
      });
      return replaceBlock(block.clientId, htmlBlock);
    },
    toBlocks() {
      const newBlocks = blockToBlocks(block);
      return replaceBlock(block.clientId, newBlocks);
    },
    toRecoveredBlock() {
      const recoveredBlock = (0,build_module/* createBlock */.Wv)(block.name, block.attributes, block.innerBlocks);
      return replaceBlock(block.clientId, recoveredBlock);
    }
  }), [block, replaceBlock]);
  const secondaryActions = (0,react.useMemo)(() => [{
    // translators: Button to fix block content
    title: (0,i18n_build_module._x)('Resolve', 'imperative verb'),
    onClick: () => setCompare(true)
  }, canInsertHTMLBlock && {
    title: (0,i18n_build_module.__)('Convert to HTML'),
    onClick: convert.toHTML
  }, canInsertClassicBlock && {
    title: (0,i18n_build_module.__)('Convert to Classic Block'),
    onClick: convert.toClassic
  }].filter(Boolean), [canInsertHTMLBlock, canInsertClassicBlock, convert]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(warning, {
      actions: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        onClick: convert.toRecoveredBlock,
        variant: "primary",
        children: (0,i18n_build_module.__)('Attempt Block Recovery')
      }, "recover")],
      secondaryActions: secondaryActions,
      children: (0,i18n_build_module.__)('This block contains unexpected or invalid content.')
    }), compare && /*#__PURE__*/(0,jsx_runtime.jsx)(modal/* default */.A, {
      title:
      // translators: Dialog title to fix block content
      (0,i18n_build_module.__)('Resolve Block'),
      onRequestClose: onCompareClose,
      className: "block-editor-block-compare",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_compare, {
        block: block,
        onKeep: convert.toHTML,
        onConvert: convert.toBlocks,
        convertor: blockToBlocks,
        convertButtonText: (0,i18n_build_module.__)('Convert to Blocks')
      })
    })]
  });
}
//# sourceMappingURL=block-invalid-warning.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-warning.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const block_crash_warning_warning = /*#__PURE__*/(0,jsx_runtime.jsx)(warning, {
  className: "block-editor-block-list__block-crash-warning",
  children: (0,i18n_build_module.__)('This block has encountered an error and cannot be previewed.')
});
/* harmony default export */ const block_crash_warning = (() => block_crash_warning_warning);
//# sourceMappingURL=block-crash-warning.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-boundary.js
/**
 * WordPress dependencies
 */

class BlockCrashBoundary extends react.Component {
  constructor() {
    super(...arguments);
    this.state = {
      hasError: false
    };
  }
  componentDidCatch() {
    this.setState({
      hasError: true
    });
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}
/* harmony default export */ const block_crash_boundary = (BlockCrashBoundary);
//# sourceMappingURL=block-crash-boundary.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-autosize-textarea/lib/index.js
var lib = __webpack_require__("../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-autosize-textarea/lib/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/block-html.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function BlockHTML({
  clientId
}) {
  const [html, setHtml] = (0,react.useState)('');
  const block = (0,use_select/* default */.A)(select => select(store_store).getBlock(clientId), [clientId]);
  const {
    updateBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const onChange = () => {
    const blockType = (0,build_module/* getBlockType */.E7)(block.name);
    if (!blockType) {
      return;
    }
    const attributes = (0,build_module/* getBlockAttributes */.Ph)(blockType, html, block.attributes);

    // If html is empty  we reset the block to the default HTML and mark it as valid to avoid triggering an error
    const content = html ? html : (0,build_module/* getSaveContent */.Z9)(blockType, attributes);
    const [isValid] = html ? (0,build_module/* validateBlock */.YV)({
      ...block,
      attributes,
      originalContent: content
    }) : [true];
    updateBlock(clientId, {
      attributes,
      originalContent: content,
      isValid
    });

    // Ensure the state is updated if we reset so it displays the default content.
    if (!html) {
      setHtml(content);
    }
  };
  (0,react.useEffect)(() => {
    setHtml((0,build_module/* getBlockContent */.F8)(block));
  }, [block]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(lib/* default */.A, {
    className: "block-editor-block-list__block-html-textarea",
    value: html,
    onBlur: onChange,
    onChange: event => setHtml(event.target.value)
  });
}
/* harmony default export */ const block_html = (BlockHTML);
//# sourceMappingURL=block-html.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-disabled/index.js
/**
 * Internal dependencies
 */



/**
 * In some circumstances, such as block previews, all focusable DOM elements
 * (input fields, links, buttons, etc.) need to be disabled. This hook adds the
 * behavior to disable nested DOM elements to the returned ref.
 *
 * If you can, prefer the use of the inert HTML attribute.
 *
 * @param {Object}   config            Configuration object.
 * @param {boolean=} config.isDisabled Whether the element should be disabled.
 * @return {import('react').RefCallback<HTMLElement>} Element Ref.
 *
 * @example
 * ```js
 * import { useDisabled } from '@wordpress/compose';
 *
 * const DisabledExample = () => {
 * 	const disabledRef = useDisabled();
 *	return (
 *		<div ref={ disabledRef }>
 *			<a href="#">This link will have tabindex set to -1</a>
 *			<input placeholder="This input will have the disabled attribute added to it." type="text" />
 *		</div>
 *	);
 * };
 * ```
 */
function use_disabled_useDisabled({
  isDisabled: isDisabledProp = false
} = {}) {
  return (0,use_ref_effect/* default */.A)(node => {
    if (isDisabledProp) {
      return;
    }
    const defaultView = node?.ownerDocument?.defaultView;
    if (!defaultView) {
      return;
    }

    /** A variable keeping track of the previous updates in order to restore them. */
    const updates = [];
    const disable = () => {
      node.childNodes.forEach(child => {
        if (!(child instanceof defaultView.HTMLElement)) {
          return;
        }
        if (!child.getAttribute('inert')) {
          child.setAttribute('inert', 'true');
          updates.push(() => {
            child.removeAttribute('inert');
          });
        }
      });
    };

    // Debounce re-disable since disabling process itself will incur
    // additional mutations which should be ignored.
    const debouncedDisable = (0,debounce/* debounce */.s)(disable, 0, {
      leading: true
    });
    disable();

    /** @type {MutationObserver | undefined} */
    const observer = new window.MutationObserver(debouncedDisable);
    observer.observe(node, {
      childList: true
    });
    return () => {
      if (observer) {
        observer.disconnect();
      }
      debouncedDisable.cancel();
      updates.forEach(update => update());
    };
  }, [isDisabledProp]);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@react-spring+shared@9.7.3_react@18.3.1/node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/globals.ts
var globals_exports = {};
__export(globals_exports, {
  assign: () => react_spring_shared_modern_assign,
  colors: () => colors,
  createStringInterpolator: () => createStringInterpolator,
  skipAnimation: () => skipAnimation,
  to: () => to,
  willAdvance: () => willAdvance
});

// ../rafz/dist/react-spring_rafz.modern.mjs
var updateQueue = makeQueue();
var raf = (fn) => schedule(fn, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn) => schedule(fn, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn) => schedule(fn, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn) => schedule(fn, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn) => schedule(fn, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  const time = raf.now() + ms;
  const cancel = () => {
    const i = timeouts.findIndex((t) => t.cancel == cancel);
    if (~i)
      timeouts.splice(i, 1);
    pendingCount -= ~i ? 1 : 0;
  };
  const timeout = { time, handler, cancel };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);
raf.cancel = (fn) => {
  onStartQueue.delete(fn);
  onFrameQueue.delete(fn);
  onFinishQueue.delete(fn);
  updateQueue.delete(fn);
  writeQueue.delete(fn);
};
raf.sync = (fn) => {
  sync = true;
  raf.batchedUpdates(fn);
  sync = false;
};
raf.throttle = (fn) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {
  }
);
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn) => fn();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn(
      "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
    );
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn, queue) {
  if (sync) {
    queue.delete(fn);
    fn(0);
  } else {
    queue.add(fn);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  const prevTs = ts;
  ts = raf.now();
  const count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t) => t.handler());
    pendingCount -= count;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn) {
      pendingCount += current == next && !next.has(fn) ? 1 : 0;
      next.add(fn);
    },
    delete(fn) {
      pendingCount -= current == next && next.has(fn) ? 1 : 0;
      return next.delete(fn);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn) => fn(arg) && next.add(fn));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e) {
      raf.catch(e);
    }
  });
}

// src/helpers.ts
function react_spring_shared_modern_noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
var is = {
  arr: Array.isArray,
  obj: (a) => !!a && a.constructor.name === "Object",
  fun: (a) => typeof a === "function",
  str: (a) => typeof a === "string",
  num: (a) => typeof a === "number",
  und: (a) => a === void 0
};
function isEqual(a, b) {
  if (is.arr(a)) {
    if (!is.arr(b) || a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  return a === b;
}
var react_spring_shared_modern_each = (obj, fn) => obj.forEach(fn);
function eachProp(obj, fn, ctx) {
  if (is.arr(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn.call(ctx, obj[i], `${i}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx, obj[key], key);
    }
  }
}
var toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    react_spring_shared_modern_each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);

// src/globals.ts
var createStringInterpolator;
var to;
var colors = null;
var skipAnimation = false;
var willAdvance = react_spring_shared_modern_noop;
var react_spring_shared_modern_assign = (globals) => {
  if (globals.to)
    to = globals.to;
  if (globals.now)
    raf.now = globals.now;
  if (globals.colors !== void 0)
    colors = globals.colors;
  if (globals.skipAnimation != null)
    skipAnimation = globals.skipAnimation;
  if (globals.createStringInterpolator)
    createStringInterpolator = globals.createStringInterpolator;
  if (globals.requestAnimationFrame)
    raf.use(globals.requestAnimationFrame);
  if (globals.batchedUpdates)
    raf.batchedUpdates = globals.batchedUpdates;
  if (globals.willAdvance)
    willAdvance = globals.willAdvance;
  if (globals.frameLoop)
    raf.frameLoop = globals.frameLoop;
};

// src/FrameLoop.ts
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  /** Advance all animations by the given time. */
  advance,
  /** Call this when an animation's priority changes. */
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   * ☠️ Never call this from within the frameloop.
   */
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(
    findIndex(currentFrame, (other) => other.priority > animation.priority),
    0,
    animation
  );
}
function advance(dt) {
  const nextFrame = prevFrame;
  for (let i = 0; i < currentFrame.length; i++) {
    const animation = currentFrame[i];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}

// src/clamp.ts
var react_spring_shared_modern_clamp = (min, max, v) => Math.min(Math.max(v, min), max);

// src/colors.ts
var colors2 = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};

// src/colorMatchers.ts
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp(
  "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
);
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;

// src/normalizeColor.ts
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors && colors[color] !== void 0) {
    return colors[color];
  }
  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = hex8.exec(color))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}

// src/colorToRgba.ts
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  const r = (int32Color & 4278190080) >>> 24;
  const g = (int32Color & 16711680) >>> 16;
  const b = (int32Color & 65280) >>> 8;
  const a = (int32Color & 255) / 255;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}

// src/createInterpolator.ts
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator(range);
  }
  const config = range;
  const outputRange = config.output;
  const inputRange = config.range || [0, 1];
  const extrapolateLeft = config.extrapolateLeft || config.extrapolate || "extend";
  const extrapolateRight = config.extrapolateRight || config.extrapolate || "extend";
  const easing = config.easing || ((t) => t);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(
      input,
      inputRange[range2],
      inputRange[range2 + 1],
      outputRange[range2],
      outputRange[range2 + 1],
      easing,
      extrapolateLeft,
      extrapolateRight,
      config.map
    );
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i)
    if (inputRange[i] >= input)
      break;
  return i - 1;
}

// src/easings.ts
var steps = (steps2, direction = "end") => (progress2) => {
  progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
  const expanded = progress2 * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return react_spring_shared_modern_clamp(0, 1, rounded / steps2);
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x < 1 / d1) {
    return n1 * x * x;
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75;
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375;
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375;
  }
};
var easings = {
  linear: (x) => x,
  easeInQuad: (x) => x * x,
  easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
  easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
  easeInCubic: (x) => x * x * x,
  easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
  easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
  easeInQuart: (x) => x * x * x * x,
  easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
  easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
  easeInQuint: (x) => x * x * x * x * x,
  easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
  easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
  easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
  easeOutSine: (x) => Math.sin(x * Math.PI / 2),
  easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
  easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
  easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
  easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
  easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
  easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
  easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
  easeInBack: (x) => c3 * x * x * x - c1 * x * x,
  easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
  easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
  easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
  easeInBounce: (x) => 1 - bounceOut(1 - x),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
  steps
};

// src/fluids.ts
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer2, event) {
  if (observer2.eventObserved) {
    observer2.eventObserved(event);
  } else {
    observer2(event);
  }
}
function callFluidObservers(target, event) {
  const observers = target[$observers];
  if (observers) {
    observers.forEach((observer2) => {
      callFluidObserver(observer2, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
$get, $observers;
var setFluidGetter = (target, get) => setHidden(target, $get, get);
function addFluidObserver(target, observer2) {
  if (target[$get]) {
    let observers = target[$observers];
    if (!observers) {
      setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
    }
    if (!observers.has(observer2)) {
      observers.add(observer2);
      if (target.observerAdded) {
        target.observerAdded(observers.size, observer2);
      }
    }
  }
  return observer2;
}
function removeFluidObserver(target, observer2) {
  const observers = target[$observers];
  if (observers && observers.has(observer2)) {
    const count = observers.size - 1;
    if (count) {
      observers.delete(observer2);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count, observer2);
    }
  }
}
var setHidden = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
});

// src/regexs.ts
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;

// src/variableToRgba.ts
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (value2) {
      return value2;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};

// src/stringInterpolation.ts
var namedColorRegex;
var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator2 = (config) => {
  if (!namedColorRegex)
    namedColorRegex = colors ? (
      // match color names, ignore partial matches
      new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
    ) : (
      // never match
      /^\b$/
    );
  const output = config.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map(
    (_, i) => keyframes.map((values) => {
      if (!(i in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i];
    })
  );
  const interpolators = outputRanges.map(
    (output2) => createInterpolator({ ...config, output: output2 })
  );
  return (input) => {
    const missingUnit = !unitRegex.test(output[0]) && output.find((value) => unitRegex.test(value))?.replace(numberRegex, "");
    let i = 0;
    return output[0].replace(
      numberRegex,
      () => `${interpolators[i++](input)}${missingUnit || ""}`
    ).replace(rgbaRegex, rgbaRound);
  };
};

// src/deprecations.ts
var prefix = "react-spring: ";
var once = (fn) => {
  const func = fn;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(
    `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var warnDirectCall = once(console.warn);
function react_spring_shared_modern_deprecateDirectCall() {
  warnDirectCall(
    `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}

// src/isAnimatedString.ts
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
}

// src/dom-events/resize/resizeElement.ts
var observer;
var resizeHandlers = /* @__PURE__ */ new WeakMap();
var handleObservation = (entries) => entries.forEach(({ target, contentRect }) => {
  return resizeHandlers.get(target)?.forEach((handler) => handler(contentRect));
});
function resizeElement(handler, target) {
  if (!observer) {
    if (typeof ResizeObserver !== "undefined") {
      observer = new ResizeObserver(handleObservation);
    }
  }
  let elementHandlers = resizeHandlers.get(target);
  if (!elementHandlers) {
    elementHandlers = /* @__PURE__ */ new Set();
    resizeHandlers.set(target, elementHandlers);
  }
  elementHandlers.add(handler);
  if (observer) {
    observer.observe(target);
  }
  return () => {
    const elementHandlers2 = resizeHandlers.get(target);
    if (!elementHandlers2)
      return;
    elementHandlers2.delete(handler);
    if (!elementHandlers2.size && observer) {
      observer.unobserve(target);
    }
  };
}

// src/dom-events/resize/resizeWindow.ts
var listeners = /* @__PURE__ */ new Set();
var cleanupWindowResizeHandler;
var createResizeHandler = () => {
  const handleResize = () => {
    listeners.forEach(
      (callback) => callback({
        width: window.innerWidth,
        height: window.innerHeight
      })
    );
  };
  window.addEventListener("resize", handleResize);
  return () => {
    window.removeEventListener("resize", handleResize);
  };
};
var resizeWindow = (callback) => {
  listeners.add(callback);
  if (!cleanupWindowResizeHandler) {
    cleanupWindowResizeHandler = createResizeHandler();
  }
  return () => {
    listeners.delete(callback);
    if (!listeners.size && cleanupWindowResizeHandler) {
      cleanupWindowResizeHandler();
      cleanupWindowResizeHandler = void 0;
    }
  };
};

// src/dom-events/resize/index.ts
var react_spring_shared_modern_onResize = (callback, { container = document.documentElement } = {}) => {
  if (container === document.documentElement) {
    return resizeWindow(callback);
  } else {
    return resizeElement(callback, container);
  }
};

// src/progress.ts
var progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);

// src/dom-events/scroll/ScrollHandler.ts
var SCROLL_KEYS = {
  x: {
    length: "Width",
    position: "Left"
  },
  y: {
    length: "Height",
    position: "Top"
  }
};
var ScrollHandler = class {
  constructor(callback, container) {
    this.createAxis = () => ({
      current: 0,
      progress: 0,
      scrollLength: 0
    });
    this.updateAxis = (axisName) => {
      const axis = this.info[axisName];
      const { length, position } = SCROLL_KEYS[axisName];
      axis.current = this.container[`scroll${position}`];
      axis.scrollLength = this.container["scroll" + length] - this.container["client" + length];
      axis.progress = progress(0, axis.scrollLength, axis.current);
    };
    this.update = () => {
      this.updateAxis("x");
      this.updateAxis("y");
    };
    this.sendEvent = () => {
      this.callback(this.info);
    };
    this.advance = () => {
      this.update();
      this.sendEvent();
    };
    this.callback = callback;
    this.container = container;
    this.info = {
      time: 0,
      x: this.createAxis(),
      y: this.createAxis()
    };
  }
};

// src/dom-events/scroll/index.ts
var scrollListeners = /* @__PURE__ */ new WeakMap();
var resizeListeners = /* @__PURE__ */ new WeakMap();
var onScrollHandlers = /* @__PURE__ */ new WeakMap();
var getTarget = (container) => container === document.documentElement ? window : container;
var react_spring_shared_modern_onScroll = (callback, { container = document.documentElement } = {}) => {
  let containerHandlers = onScrollHandlers.get(container);
  if (!containerHandlers) {
    containerHandlers = /* @__PURE__ */ new Set();
    onScrollHandlers.set(container, containerHandlers);
  }
  const containerHandler = new ScrollHandler(callback, container);
  containerHandlers.add(containerHandler);
  if (!scrollListeners.has(container)) {
    const listener = () => {
      containerHandlers?.forEach((handler) => handler.advance());
      return true;
    };
    scrollListeners.set(container, listener);
    const target = getTarget(container);
    window.addEventListener("resize", listener, { passive: true });
    if (container !== document.documentElement) {
      resizeListeners.set(container, react_spring_shared_modern_onResize(listener, { container }));
    }
    target.addEventListener("scroll", listener, { passive: true });
  }
  const animateScroll = scrollListeners.get(container);
  raf(animateScroll);
  return () => {
    raf.cancel(animateScroll);
    const containerHandlers2 = onScrollHandlers.get(container);
    if (!containerHandlers2)
      return;
    containerHandlers2.delete(containerHandler);
    if (containerHandlers2.size)
      return;
    const listener = scrollListeners.get(container);
    scrollListeners.delete(container);
    if (listener) {
      getTarget(container).removeEventListener("scroll", listener);
      window.removeEventListener("resize", listener);
      resizeListeners.get(container)?.();
    }
  };
};

// src/hooks/useConstant.ts

function react_spring_shared_modern_useConstant(init) {
  const ref = useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// src/hooks/useForceUpdate.ts


// src/hooks/useIsMounted.ts


// src/hooks/useIsomorphicLayoutEffect.ts

var react_spring_shared_modern_useIsomorphicLayoutEffect = isSSR() ? react.useEffect : react.useLayoutEffect;

// src/hooks/useIsMounted.ts
var react_spring_shared_modern_useIsMounted = () => {
  const isMounted = (0,react.useRef)(false);
  react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};

// src/hooks/useForceUpdate.ts
function react_spring_shared_modern_useForceUpdate() {
  const update2 = (0,react.useState)()[1];
  const isMounted = react_spring_shared_modern_useIsMounted();
  return () => {
    if (isMounted.current) {
      update2(Math.random());
    }
  };
}

// src/hooks/useMemoOne.ts

function useMemoOne(getResult, inputs) {
  const [initial] = (0,react.useState)(
    () => ({
      inputs,
      result: getResult()
    })
  );
  const committed = (0,react.useRef)();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(
      inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
    );
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  (0,react.useEffect)(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i = 0; i < next.length; i++) {
    if (next[i] !== prev[i]) {
      return false;
    }
  }
  return true;
}

// src/hooks/useOnce.ts

var react_spring_shared_modern_useOnce = (effect) => (0,react.useEffect)(effect, emptyDeps);
var emptyDeps = [];

// src/hooks/usePrev.ts

function react_spring_shared_modern_usePrev(value) {
  const prevRef = useRef4();
  useEffect4(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}

// src/hooks/useReducedMotion.ts

var useReducedMotion = () => {
  const [reducedMotion, setReducedMotion] = useState3(null);
  react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
    const mql = window.matchMedia("(prefers-reduced-motion)");
    const handleMediaChange = (e) => {
      setReducedMotion(e.matches);
      react_spring_shared_modern_assign({
        skipAnimation: e.matches
      });
    };
    handleMediaChange(mql);
    mql.addEventListener("change", handleMediaChange);
    return () => {
      mql.removeEventListener("change", handleMediaChange);
    };
  }, []);
  return reducedMotion;
};

//# sourceMappingURL=react-spring_shared.modern.mjs.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@react-spring+animated@9.7.3_react@18.3.1/node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs
// src/Animated.ts

var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    setAnimated(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
};

// src/AnimatedValue.ts

var AnimatedValue = class extends Animated {
  constructor(_value) {
    super();
    this._value = _value;
    this.done = true;
    this.durationProgress = 0;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  /** @internal */
  static create(value) {
    return new AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const { done } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};

// src/AnimatedString.ts

var AnimatedString = class extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  /** @internal */
  static create(value) {
    return new AnimatedString(value);
  }
  getValue() {
    const value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};

// src/AnimatedArray.ts


// src/AnimatedObject.ts


// src/context.ts
var TreeContext = { dependencies: null };

// src/AnimatedObject.ts
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      react_spring_shared_modern_each(this.payload, (node) => node.reset());
    }
  }
  /** Create a payload set. */
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      react_spring_shared_modern_each(payload, (node) => this.add(node));
    }
  }
};

// src/AnimatedArray.ts
var AnimatedArray = class extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  /** @internal */
  static create(source) {
    return new AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}

// src/getAnimatedType.ts

function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}

// src/createHost.ts


// src/withAnimated.tsx



var withAnimated = (Component, host) => {
  const hasInstance = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
  );
  return (0,react.forwardRef)((givenProps, givenRef) => {
    const instanceRef = (0,react.useRef)(null);
    const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
    (0,react.useCallback)(
      (value) => {
        instanceRef.current = updateRef(givenRef, value);
      },
      [givenRef]
    );
    const [props, deps] = getAnimatedState(givenProps, host);
    const forceUpdate = react_spring_shared_modern_useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0,react.useRef)();
    react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      react_spring_shared_modern_each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          react_spring_shared_modern_each(
            observerRef.current.deps,
            (dep) => removeFluidObserver(dep, observerRef.current)
          );
          raf.cancel(observerRef.current.update);
        }
      };
    });
    (0,react.useEffect)(callback, []);
    react_spring_shared_modern_useOnce(() => () => {
      const observer2 = observerRef.current;
      react_spring_shared_modern_each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host.getComponentProps(props.getValue());
    return /* @__PURE__ */ react.createElement(Component, { ...usedProps, ref });
  });
};
var PropsObserver = class {
  constructor(update, deps) {
    this.update = update;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = {
      ...props,
      style: host.createAnimatedStyle(props.style)
    };
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref))
      ref(value);
    else
      ref.current = value;
  }
  return value;
}

// src/createHost.ts
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues = () => false,
  createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues,
    createAnimatedStyle,
    getComponentProps
  };
  const animated = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated[key] = animated(Component);
  });
  return {
    animated
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

//# sourceMappingURL=react-spring_animated.modern.mjs.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@react-spring+core@9.7.3_react@18.3.1/node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
// src/hooks/useChain.ts


// src/helpers.ts

function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to2 = getForwardProps(props);
  if (to2) {
    const out = { to: to2 };
    eachProp(props, (val, key) => key in to2 || (out[key] = val));
    return out;
  }
  return { ...props };
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _ in props)
    return true;
  return false;
}
function isAsyncTo(to2) {
  return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
}
function detachRefs(ctrl, ref) {
  ctrl.ref?.delete(ctrl);
  ref?.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  if (ref && ctrl.ref !== ref) {
    ctrl.ref?.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}

// src/hooks/useChain.ts
function useChain(refs, timeSteps, timeFrame = 1e3) {
  useIsomorphicLayoutEffect(() => {
    if (timeSteps) {
      let prevDelay = 0;
      each(refs, (ref, i) => {
        const controllers = ref.current;
        if (controllers.length) {
          let delay = timeFrame * timeSteps[i];
          if (isNaN(delay))
            delay = prevDelay;
          else
            prevDelay = delay;
          each(controllers, (ctrl) => {
            each(ctrl.queue, (props) => {
              const memoizedDelayProp = props.delay;
              props.delay = (key) => delay + callProp(memoizedDelayProp || 0, key);
            });
          });
          ref.start();
        }
      });
    } else {
      let p = Promise.resolve();
      each(refs, (ref) => {
        const controllers = ref.current;
        if (controllers.length) {
          const queues = controllers.map((ctrl) => {
            const q = ctrl.queue;
            ctrl.queue = [];
            return q;
          });
          p = p.then(() => {
            each(
              controllers,
              (ctrl, i) => each(queues[i] || [], (update2) => ctrl.queue.push(update2))
            );
            return Promise.all(ref.start());
          });
        }
      });
    }
  });
}

// src/hooks/useSpring.ts


// src/hooks/useSprings.ts



// src/SpringValue.ts



// src/AnimationConfig.ts


// src/constants.ts
var config = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
};

// src/AnimationConfig.ts
var react_spring_core_modern_defaults = {
  ...config.default,
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
};
var AnimationConfig = class {
  constructor() {
    /**
     * The initial velocity of one or more values.
     *
     * @default 0
     */
    this.velocity = 0;
    Object.assign(this, react_spring_core_modern_defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = { ...defaultConfig };
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = { ...defaultConfig, ...newConfig };
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in react_spring_core_modern_defaults) {
    if (config2[key] == null) {
      config2[key] = react_spring_core_modern_defaults[key];
    }
  }
  let { frequency, damping } = config2;
  const { mass } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}

// src/Animation.ts
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};

// src/scheduleProps.ts

function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
  return new Promise((resolve, reject) => {
    let delay;
    let timeout;
    let cancel = matchProp(props.cancel ?? defaultProps?.cancel, key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps?.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals_exports.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start({ ...props, callId, cancel }, resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}

// src/runAsync.ts


// src/AnimationResult.ts
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
  target.get(),
  results.every((result) => result.finished)
);
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});

// src/runAsync.ts
function runAsync(to2, props, state, target) {
  const { callId, parentId, onRest } = props;
  const { asyncTo: prevTo, promise: prevPromise } = state;
  if (!parentId && to2 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to2;
    const defaultProps = getDefaultProps(
      props,
      (value, key) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        key === "onRest" ? void 0 : value
      )
    );
    let preventBail;
    let bail;
    const bailPromise = new Promise(
      (resolve, reject) => (preventBail = resolve, bail = reject)
    );
    const bailIfEnded = (bailSignal) => {
      const bailResult = (
        // The `cancel` prop or `stop` method was used.
        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
        callId !== state.asyncId && getFinishedResult(target, false)
      );
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAnimationSignal();
      return (async () => {
        if (globals_exports.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals_exports.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to2)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to2);
      } else {
        animating = Promise.resolve(to2(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAnimationSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t) => t.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
};
var SkipAnimationSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
};

// src/FrameValue.ts


var isFrameValue = (value) => value instanceof FrameValue;
var nextId = 1;
var FrameValue = class extends FluidValue {
  constructor() {
    super(...arguments);
    this.id = nextId++;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority) {
    if (this._priority != priority) {
      this._priority = priority;
      this._onPriorityChange(priority);
    }
  }
  /** Get the current value */
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...args) {
    return globals_exports.to(this, args);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...args) {
    deprecateInterpolate();
    return globals_exports.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1)
      this._attach();
  }
  observerRemoved(count) {
    if (count == 0)
      this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(priority) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority
    });
  }
};

// src/SpringPhase.ts
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;

// src/SpringValue.ts
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    /** The animation state */
    this.animation = new Animation();
    /** Some props have customizable default values */
    this.defaultProps = {};
    /** The state for `runAsync` calls */
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    /** The promise resolvers of pending `start` calls */
    this._pendingCalls = /* @__PURE__ */ new Set();
    /** The counter for tracking `scheduleProps` calls */
    this._lastCallId = 0;
    /** The last `scheduleProps` call that changed the `to` prop */
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return hasAnimated(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return isAnimating(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return isPaused(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(dt) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let { toValues } = anim;
    const { config: config2 } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i) => {
      if (node2.done)
        return;
      const to2 = (
        // Animated strings always go from 0 to 1.
        node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]
      );
      let finished = anim.immediate;
      let position = to2;
      if (!finished) {
        position = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt;
        const from = anim.fromValues[i];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
        if (!is.und(config2.duration)) {
          let p = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt;
              }
            }
            p = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p = p > 1 ? 1 : p < 0 ? 0 : p;
            node2.durationProgress = p;
          }
          position = from + config2.easing(p) * (to2 - from);
          velocity = (position - node2.lastPosition) / dt;
          finished = p == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e);
          finished = Math.abs(node2.lastPosition - position) <= precision;
          velocity = v0 * e;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt / step);
          for (let n = 0; n < numSteps; ++n) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to2 - position) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position == to2 || position > to2 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position = to2;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position - to2);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position = position + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  /** Set the current value, while stopping the current animation */
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: true });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: false });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (isAnimating(this)) {
      const { to: to2, config: config2 } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to2, false);
        }
        this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to2, arg2) {
    let queue;
    if (!is.und(to2)) {
      queue = [is.obj(to2) ? to2 : { ...arg2, to: to2 }];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(
      queue.map((props) => {
        const up = this._update(props);
        return up;
      })
    ).then((results) => getCombinedResult(this, results));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(cancel) {
    const { to: to2 } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to2, cancel));
    return this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: true });
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(props) {
    const key = this.key || "";
    let { to: to2, from } = props;
    to2 = is.obj(to2) ? to2[key] : to2;
    if (to2 == null || isAsyncTo(to2)) {
      to2 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = { to: to2, from };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to2, from] = [from, to2];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to2);
      }
    }
    return range;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...props }, isLoop) {
    const { key, defaultProps } = this;
    if (props.default)
      Object.assign(
        defaultProps,
        getDefaultProps(
          props,
          (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
        )
      );
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(
              this,
              "onPause",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(
              this,
              "onResume",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  /** Merge props into the current animation */
  _merge(range, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const { key, defaultProps, animation: anim } = this;
    const { to: prevTo, from: prevFrom } = anim;
    let { to: to2 = prevTo, from = prevFrom } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
      to2 = from;
    }
    if (props.reverse)
      [to2, from] = [from, to2];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to2, prevTo);
    if (hasToChanged) {
      this._focus(to2);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const { config: config2 } = anim;
    const { decay, velocity } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(
        config2,
        callProp(props.config, key),
        // Avoid calling the same "config" prop twice.
        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
      );
    }
    let node = getAnimated(this);
    if (!node || is.und(to2)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key)
    );
    const value = reset ? from : this.get();
    const goal = computeGoal(to2);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to2);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(
            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
          );
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to2);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const { onRest } = anim;
        react_spring_shared_modern_each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed)
          raf.batchedUpdates(() => {
            anim.changed = !reset;
            onRest?.(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              anim.onStart?.(result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value));
    }
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority = 0;
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      addFluidObserver(to2, this);
      if (isFrameValue(to2)) {
        priority = to2.priority + 1;
      }
    }
    this.priority = priority;
  }
  _detach() {
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      removeFluidObserver(to2, this);
    }
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(
        this,
        "onStart",
        getFinishedResult(this, checkFinished(this, anim.to)),
        this
      );
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals_exports.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      react_spring_shared_modern_each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to2) {
  const goal = computeGoal(to2);
  const value = computeGoal(target.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop = props.loop, to2 = props.to) {
  const loopRet = callProp(loop);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate({
      ...props,
      loop,
      // Avoid updating default props when looping.
      default: false,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !reverse || isAsyncTo(to2) ? to2 : void 0,
      // Ignore the "from" prop except on reset.
      from: reset ? props.from : void 0,
      reset,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...overrides
    });
  }
}
function createUpdate(props) {
  const { to: to2, from } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to2))
    findDefined(to2, keys);
  if (is.obj(from))
    findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update2 = createUpdate(props);
  if (is5.und(update2.default)) {
    update2.default = getDefaultProps(update2);
  }
  return update2;
}
function findDefined(values, keys) {
  eachProp(values, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function mergeActiveFn(target, props, type) {
  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
}
function sendEvent(target, type, ...args) {
  target.animation[type]?.(...args);
  target.defaultProps[type]?.(...args);
}

// src/Controller.ts

var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId2 = 1;
var Controller = class {
  constructor(props, flush3) {
    this.id = nextId2++;
    /** The animated values */
    this.springs = {};
    /** The queue of props passed to the `update` method. */
    this.queue = [];
    /** The counter for tracking `scheduleProps` calls */
    this._lastAsyncId = 0;
    /** The values currently being animated */
    this._active = /* @__PURE__ */ new Set();
    /** The values that changed recently */
    this._changed = /* @__PURE__ */ new Set();
    /** Equals false when `onStart` listeners can be called */
    this._started = false;
    /** State used by the `runAsync` function */
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    /** The event queues that are flushed once per frame maximum */
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush3) {
      this._flush = flush3;
    }
    if (props) {
      this.start({ default: true, ...props });
    }
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  /** Get the current values of our springs */
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  /** Set the current values without animating. */
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  /** Push an update onto the queue of each value. */
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(props) {
    let { queue } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  /** @internal */
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      react_spring_shared_modern_each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  /** Freeze the active animation in time */
  pause(keys) {
    if (is.und(keys)) {
      this.start({ pause: true });
    } else {
      const springs = this.springs;
      react_spring_shared_modern_each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(keys) {
    if (is.und(keys)) {
      this.start({ pause: false });
    } else {
      const springs = this.springs;
      react_spring_shared_modern_each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart, onChange, onRest } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
    (results) => getCombinedResult(ctrl, results)
  );
}
async function flushUpdate(ctrl, props, isLoop) {
  const { keys, to: to2, from, loop, onRest, onResolve } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop) {
    props.loop = false;
  }
  if (to2 === false)
    props.to = null;
  if (from === false)
    props.from = null;
  const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    react_spring_shared_modern_each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({ finished, cancelled }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map(
    (key) => ctrl.springs[key].start(props)
  );
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(
      scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: react_spring_shared_modern_noop,
          resume: react_spring_shared_modern_noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(
                runAsync(
                  asyncTo,
                  props2,
                  state,
                  ctrl
                )
              );
            }
          }
        }
      })
    );
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop, to2);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = { ...ctrl.springs };
  if (props) {
    each3(toArray3(props), (props2) => {
      if (is6.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is6.obj(props2.to)) {
        props2 = { ...props2, to: void 0 };
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp4(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver2(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create) {
  if (props.keys) {
    react_spring_shared_modern_each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  react_spring_shared_modern_each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}

// src/SpringContext.tsx



var SpringContext = ({
  children,
  ...props
}) => {
  const inherited = (0,react.useContext)(react_spring_core_modern_ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({ pause, immediate }), [pause, immediate]);
  const { Provider } = react_spring_core_modern_ctx;
  return /* @__PURE__ */ react.createElement(Provider, { value: props }, children);
};
var react_spring_core_modern_ctx = makeContext(SpringContext, {});
SpringContext.Provider = react_spring_core_modern_ctx.Provider;
SpringContext.Consumer = react_spring_core_modern_ctx.Consumer;
function makeContext(target, init) {
  Object.assign(target, react.createContext(init));
  target.Provider._context = target;
  target.Consumer._context = target;
  return target;
}

// src/SpringRef.ts

var SpringRef = () => {
  const current = [];
  const SpringRef2 = function(props) {
    deprecateDirectCall();
    const results = [];
    each4(current, (ctrl, i) => {
      if (is7.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = _getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i = current.indexOf(ctrl);
    if (~i)
      current.splice(i, 1);
  };
  SpringRef2.pause = function() {
    each4(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each4(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    each4(current, (ctrl, i) => {
      const update2 = is7.fun(values) ? values(i, ctrl) : values;
      if (update2) {
        ctrl.set(update2);
      }
    });
  };
  SpringRef2.start = function(props) {
    const results = [];
    each4(current, (ctrl, i) => {
      if (is7.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = this._getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each4(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each4(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
    return this;
  };
  const _getProps = function(arg, ctrl, index) {
    return is7.fun(arg) ? arg(index, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};

// src/hooks/useSprings.ts
function useSprings(length, props, deps) {
  const propsFn = is8.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref = useMemo(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const layoutId = useRef(0);
  const forceUpdate = useForceUpdate();
  const state = useMemo(
    () => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }),
    []
  );
  const ctrls = useRef([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  useMemo(() => {
    each5(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  useMemo(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i = startIndex; i < endIndex; i++) {
      const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));
      const update2 = propsFn ? propsFn(i, ctrl) : props[i];
      if (update2) {
        updates[i] = declareUpdate(update2);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
  const context = useContext2(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect2(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const { queue } = state;
    if (queue.length) {
      state.queue = [];
      each5(queue, (cb) => cb());
    }
    each5(ctrls.current, (ctrl, i) => {
      ref?.add(ctrl);
      if (hasContext) {
        ctrl.start({ default: context });
      }
      const update2 = updates[i];
      if (update2) {
        replaceRef(ctrl, update2.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update2);
        } else {
          ctrl.start(update2);
        }
      }
    });
  });
  useOnce(() => () => {
    each5(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x) => ({ ...x }));
  return ref ? [values, ref] : values;
}

// src/hooks/useSpring.ts
function useSpring(props, deps) {
  const isFn = is9.fun(props);
  const [[values], ref] = useSprings(
    1,
    isFn ? props : [props],
    isFn ? deps || [] : deps
  );
  return isFn || arguments.length == 2 ? [values, ref] : values;
}

// src/hooks/useSpringRef.ts

var initSpringRef = () => SpringRef();
var useSpringRef = () => useState(initSpringRef)[0];

// src/hooks/useSpringValue.ts

var useSpringValue = (initial, props) => {
  const springValue = useConstant(() => new SpringValue(initial, props));
  useOnce2(() => () => {
    springValue.stop();
  });
  return springValue;
};

// src/hooks/useTrail.ts

function useTrail(length, propsArg, deps) {
  const propsFn = is10.fun(propsArg) && propsArg;
  if (propsFn && !deps)
    deps = [];
  let reverse = true;
  let passedRef = void 0;
  const result = useSprings(
    length,
    (i, ctrl) => {
      const props = propsFn ? propsFn(i, ctrl) : propsArg;
      passedRef = props.ref;
      reverse = reverse && props.reverse;
      return props;
    },
    // Ensure the props function is called when no deps exist.
    // This works around the 3 argument rule.
    deps || [{}]
  );
  useIsomorphicLayoutEffect3(() => {
    each6(result[1].current, (ctrl, i) => {
      const parent = result[1].current[i + (reverse ? 1 : -1)];
      replaceRef(ctrl, passedRef);
      if (ctrl.ref) {
        if (parent) {
          ctrl.update({ to: parent.springs });
        }
        return;
      }
      if (parent) {
        ctrl.start({ to: parent.springs });
      } else {
        ctrl.start();
      }
    });
  }, deps);
  if (propsFn || arguments.length == 3) {
    const ref = passedRef ?? result[1];
    ref["_getProps"] = (propsArg2, ctrl, i) => {
      const props = is10.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;
      if (props) {
        const parent = ref.current[i + (props.reverse ? 1 : -1)];
        if (parent)
          props.to = parent.springs;
        return props;
      }
    };
    return result;
  }
  return result[0];
}

// src/hooks/useTransition.tsx



function useTransition(data, props, deps) {
  const propsFn = is11.fun(props) && props;
  const {
    reset,
    sort,
    trail = 0,
    expires = true,
    exitBeforeEnter = false,
    onDestroyed,
    ref: propsRef,
    config: propsConfig
  } = propsFn ? propsFn() : props;
  const ref = useMemo2(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const items = toArray4(data);
  const transitions = [];
  const usedTransitions = useRef2(null);
  const prevTransitions = reset ? null : usedTransitions.current;
  useIsomorphicLayoutEffect4(() => {
    usedTransitions.current = transitions;
  });
  useOnce3(() => {
    each7(transitions, (t) => {
      ref?.add(t.ctrl);
      t.ctrl.ref = ref;
    });
    return () => {
      each7(usedTransitions.current, (t) => {
        if (t.expired) {
          clearTimeout(t.expirationId);
        }
        detachRefs(t.ctrl, ref);
        t.ctrl.stop(true);
      });
    };
  });
  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
  const expired = reset && usedTransitions.current || [];
  useIsomorphicLayoutEffect4(
    () => each7(expired, ({ ctrl, item, key }) => {
      detachRefs(ctrl, ref);
      callProp(onDestroyed, item, key);
    })
  );
  const reused = [];
  if (prevTransitions)
    each7(prevTransitions, (t, i) => {
      if (t.expired) {
        clearTimeout(t.expirationId);
        expired.push(t);
      } else {
        i = reused[i] = keys.indexOf(t.key);
        if (~i)
          transitions[i] = t;
      }
    });
  each7(items, (item, i) => {
    if (!transitions[i]) {
      transitions[i] = {
        key: keys[i],
        item,
        phase: "mount" /* MOUNT */,
        ctrl: new Controller()
      };
      transitions[i].ctrl.item = item;
    }
  });
  if (reused.length) {
    let i = -1;
    const { leave } = propsFn ? propsFn() : props;
    each7(reused, (keyIndex, prevIndex) => {
      const t = prevTransitions[prevIndex];
      if (~keyIndex) {
        i = transitions.indexOf(t);
        transitions[i] = { ...t, item: items[keyIndex] };
      } else if (leave) {
        transitions.splice(++i, 0, t);
      }
    });
  }
  if (is11.fun(sort)) {
    transitions.sort((a, b) => sort(a.item, b.item));
  }
  let delay = -trail;
  const forceUpdate = useForceUpdate2();
  const defaultProps = getDefaultProps(props);
  const changes = /* @__PURE__ */ new Map();
  const exitingTransitions = useRef2(/* @__PURE__ */ new Map());
  const forceChange = useRef2(false);
  each7(transitions, (t, i) => {
    const key = t.key;
    const prevPhase = t.phase;
    const p = propsFn ? propsFn() : props;
    let to2;
    let phase;
    const propsDelay = callProp(p.delay || 0, key);
    if (prevPhase == "mount" /* MOUNT */) {
      to2 = p.enter;
      phase = "enter" /* ENTER */;
    } else {
      const isLeave = keys.indexOf(key) < 0;
      if (prevPhase != "leave" /* LEAVE */) {
        if (isLeave) {
          to2 = p.leave;
          phase = "leave" /* LEAVE */;
        } else if (to2 = p.update) {
          phase = "update" /* UPDATE */;
        } else
          return;
      } else if (!isLeave) {
        to2 = p.enter;
        phase = "enter" /* ENTER */;
      } else
        return;
    }
    to2 = callProp(to2, t.item, i);
    to2 = is11.obj(to2) ? inferTo(to2) : { to: to2 };
    if (!to2.config) {
      const config2 = propsConfig || defaultProps.config;
      to2.config = callProp(config2, t.item, i, phase);
    }
    delay += trail;
    const payload = {
      ...defaultProps,
      // we need to add our props.delay value you here.
      delay: propsDelay + delay,
      ref: propsRef,
      immediate: p.immediate,
      // This prevents implied resets.
      reset: false,
      // Merge any phase-specific props.
      ...to2
    };
    if (phase == "enter" /* ENTER */ && is11.und(payload.from)) {
      const p2 = propsFn ? propsFn() : props;
      const from = is11.und(p2.initial) || prevTransitions ? p2.from : p2.initial;
      payload.from = callProp(from, t.item, i);
    }
    const { onResolve } = payload;
    payload.onResolve = (result) => {
      callProp(onResolve, result);
      const transitions2 = usedTransitions.current;
      const t2 = transitions2.find((t3) => t3.key === key);
      if (!t2)
        return;
      if (result.cancelled && t2.phase != "update" /* UPDATE */) {
        return;
      }
      if (t2.ctrl.idle) {
        const idle = transitions2.every((t3) => t3.ctrl.idle);
        if (t2.phase == "leave" /* LEAVE */) {
          const expiry = callProp(expires, t2.item);
          if (expiry !== false) {
            const expiryMs = expiry === true ? 0 : expiry;
            t2.expired = true;
            if (!idle && expiryMs > 0) {
              if (expiryMs <= 2147483647)
                t2.expirationId = setTimeout(forceUpdate, expiryMs);
              return;
            }
          }
        }
        if (idle && transitions2.some((t3) => t3.expired)) {
          exitingTransitions.current.delete(t2);
          if (exitBeforeEnter) {
            forceChange.current = true;
          }
          forceUpdate();
        }
      }
    };
    const springs = getSprings(t.ctrl, payload);
    if (phase === "leave" /* LEAVE */ && exitBeforeEnter) {
      exitingTransitions.current.set(t, { phase, springs, payload });
    } else {
      changes.set(t, { phase, springs, payload });
    }
  });
  const context = useContext3(SpringContext);
  const prevContext = usePrev2(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect4(() => {
    if (hasContext) {
      each7(transitions, (t) => {
        t.ctrl.start({ default: context });
      });
    }
  }, [context]);
  each7(changes, (_, t) => {
    if (exitingTransitions.current.size) {
      const ind = transitions.findIndex((state) => state.key === t.key);
      transitions.splice(ind, 1);
    }
  });
  useIsomorphicLayoutEffect4(
    () => {
      each7(
        exitingTransitions.current.size ? exitingTransitions.current : changes,
        ({ phase, payload }, t) => {
          const { ctrl } = t;
          t.phase = phase;
          ref?.add(ctrl);
          if (hasContext && phase == "enter" /* ENTER */) {
            ctrl.start({ default: context });
          }
          if (payload) {
            replaceRef(ctrl, payload.ref);
            if ((ctrl.ref || ref) && !forceChange.current) {
              ctrl.update(payload);
            } else {
              ctrl.start(payload);
              if (forceChange.current) {
                forceChange.current = false;
              }
            }
          }
        }
      );
    },
    reset ? void 0 : deps
  );
  const renderTransitions = (render) => /* @__PURE__ */ React2.createElement(React2.Fragment, null, transitions.map((t, i) => {
    const { springs } = changes.get(t) || t.ctrl;
    const elem = render({ ...springs }, t.item, t, i);
    return elem && elem.type ? /* @__PURE__ */ React2.createElement(
      elem.type,
      {
        ...elem.props,
        key: is11.str(t.key) || is11.num(t.key) ? t.key : t.ctrl.id,
        ref: elem.ref
      }
    ) : elem;
  }));
  return ref ? [renderTransitions, ref] : renderTransitions;
}
var nextKey = 1;
function getKeys(items, { key, keys = key }, prevTransitions) {
  if (keys === null) {
    const reused = /* @__PURE__ */ new Set();
    return items.map((item) => {
      const t = prevTransitions && prevTransitions.find(
        (t2) => t2.item === item && t2.phase !== "leave" /* LEAVE */ && !reused.has(t2)
      );
      if (t) {
        reused.add(t);
        return t.key;
      }
      return nextKey++;
    });
  }
  return is11.und(keys) ? items : is11.fun(keys) ? items.map(keys) : toArray4(keys);
}

// src/hooks/useScroll.ts

var useScroll = ({
  container,
  ...springOptions
} = {}) => {
  const [scrollValues, api] = useSpring(
    () => ({
      scrollX: 0,
      scrollY: 0,
      scrollXProgress: 0,
      scrollYProgress: 0,
      ...springOptions
    }),
    []
  );
  useIsomorphicLayoutEffect5(() => {
    const cleanupScroll = onScroll(
      ({ x, y }) => {
        api.start({
          scrollX: x.current,
          scrollXProgress: x.progress,
          scrollY: y.current,
          scrollYProgress: y.progress
        });
      },
      { container: container?.current || void 0 }
    );
    return () => {
      each8(Object.values(scrollValues), (value) => value.stop());
      cleanupScroll();
    };
  }, []);
  return scrollValues;
};

// src/hooks/useResize.ts

var useResize = ({
  container,
  ...springOptions
}) => {
  const [sizeValues, api] = useSpring(
    () => ({
      width: 0,
      height: 0,
      ...springOptions
    }),
    []
  );
  useIsomorphicLayoutEffect6(() => {
    const cleanupScroll = onResize(
      ({ width, height }) => {
        api.start({
          width,
          height,
          immediate: sizeValues.width.get() === 0 || sizeValues.height.get() === 0
        });
      },
      { container: container?.current || void 0 }
    );
    return () => {
      each9(Object.values(sizeValues), (value) => value.stop());
      cleanupScroll();
    };
  }, []);
  return sizeValues;
};

// src/hooks/useInView.ts


var defaultThresholdOptions = {
  any: 0,
  all: 1
};
function useInView(props, args) {
  const [isInView, setIsInView] = useState2(false);
  const ref = useRef3();
  const propsFn = is12.fun(props) && props;
  const springsProps = propsFn ? propsFn() : {};
  const { to: to2 = {}, from = {}, ...restSpringProps } = springsProps;
  const intersectionArguments = propsFn ? args : props;
  const [springs, api] = useSpring(() => ({ from, ...restSpringProps }), []);
  useIsomorphicLayoutEffect7(() => {
    const element = ref.current;
    const {
      root,
      once,
      amount = "any",
      ...restArgs
    } = intersectionArguments ?? {};
    if (!element || once && isInView || typeof IntersectionObserver === "undefined")
      return;
    const activeIntersections = /* @__PURE__ */ new WeakMap();
    const onEnter = () => {
      if (to2) {
        api.start(to2);
      }
      setIsInView(true);
      const cleanup = () => {
        if (from) {
          api.start(from);
        }
        setIsInView(false);
      };
      return once ? void 0 : cleanup;
    };
    const handleIntersection = (entries) => {
      entries.forEach((entry) => {
        const onLeave = activeIntersections.get(entry.target);
        if (entry.isIntersecting === Boolean(onLeave)) {
          return;
        }
        if (entry.isIntersecting) {
          const newOnLeave = onEnter();
          if (is12.fun(newOnLeave)) {
            activeIntersections.set(entry.target, newOnLeave);
          } else {
            observer.unobserve(entry.target);
          }
        } else if (onLeave) {
          onLeave();
          activeIntersections.delete(entry.target);
        }
      });
    };
    const observer = new IntersectionObserver(handleIntersection, {
      root: root && root.current || void 0,
      threshold: typeof amount === "number" || Array.isArray(amount) ? amount : defaultThresholdOptions[amount],
      ...restArgs
    });
    observer.observe(element);
    return () => observer.unobserve(element);
  }, [intersectionArguments]);
  if (propsFn) {
    return [ref, springs];
  }
  return [ref, isInView];
}

// src/components/Spring.tsx
function Spring({ children, ...props }) {
  return children(useSpring(props));
}

// src/components/Trail.tsx

function Trail({
  items,
  children,
  ...props
}) {
  const trails = useTrail(items.length, props);
  return items.map((item, index) => {
    const result = children(item, index);
    return is13.fun(result) ? result(trails[index]) : result;
  });
}

// src/components/Transition.tsx
function Transition({
  items,
  children,
  ...props
}) {
  return useTransition(items, props)(children);
}

// src/interpolate.ts


// src/Interpolation.ts


var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.source = source;
    /** Equals false when in the frameloop */
    this.idle = true;
    /** The inputs which are currently animating */
    this._active = /* @__PURE__ */ new Set();
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      react_spring_shared_modern_each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals_exports.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  // Observe our sources only when we're observed.
  _attach() {
    let priority = 1;
    react_spring_shared_modern_each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority = Math.max(priority, source.priority + 1);
      }
    });
    this.priority = priority;
    this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    react_spring_shared_modern_each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce(
        (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
        0
      );
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self) {
  if (!self.idle) {
    self.idle = true;
    react_spring_shared_modern_each(getPayload(self), (node) => {
      node.done = true;
    });
    callFluidObservers(self, {
      type: "idle",
      parent: self
    });
  }
}

// src/interpolate.ts
var react_spring_core_modern_to = (source, ...args) => new Interpolation(source, args);
var react_spring_core_modern_interpolate = (source, ...args) => (deprecateInterpolate2(), new Interpolation(source, args));

// src/globals.ts

globals_exports.assign({
  createStringInterpolator: createStringInterpolator2,
  to: (source, args) => new Interpolation(source, args)
});
var react_spring_core_modern_update = frameLoop.advance;

// src/index.ts



//# sourceMappingURL=react-spring_core.modern.mjs.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@react-spring+web@9.7.3_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
// src/index.ts





// src/applyAnimatedValues.ts
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const { style, children, scrollTop, scrollLeft, viewBox, ...attributes } = props;
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map(
    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n) => "-" + n.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i) => {
    instance.setAttribute(name, values[i]);
  });
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);

// src/AnimatedStyle.ts


var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x, y, z, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x || y || z) {
      inputs.push([x || 0, y || 0, z || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(
          key === "rotate3d" ? ([x2, y2, z2, deg]) => [
            `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    react_spring_shared_modern_each(this.inputs, (input, i) => {
      const arg1 = getFluidValue(input[0]);
      const [t, id] = this.transforms[i](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform += " " + t;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count) {
    if (count == 1)
      react_spring_shared_modern_each(
        this.inputs,
        (input) => react_spring_shared_modern_each(
          input,
          (value) => hasFluidValue(value) && addFluidObserver(value, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count) {
    if (count == 0)
      react_spring_shared_modern_each(
        this.inputs,
        (input) => react_spring_shared_modern_each(
          input,
          (value) => hasFluidValue(value) && removeFluidObserver(value, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};

// src/primitives.ts
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];

// src/index.ts

globals_exports.assign({
  batchedUpdates: react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;

//# sourceMappingURL=react-spring_web.modern.mjs.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/get-scroll-container.js
var get_scroll_container = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/get-scroll-container.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/use-moving-animation/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * If the block count exceeds the threshold, we disable the reordering animation
 * to avoid laginess.
 */
const BLOCK_ANIMATION_THRESHOLD = 200;
function getAbsolutePosition(element) {
  return {
    top: element.offsetTop,
    left: element.offsetLeft
  };
}

/**
 * Hook used to compute the styles required to move a div into a new position.
 *
 * The way this animation works is the following:
 *  - It first renders the element as if there was no animation.
 *  - It takes a snapshot of the position of the block to use it
 *    as a destination point for the animation.
 *  - It restores the element to the previous position using a CSS transform
 *  - It uses the "resetAnimation" flag to reset the animation
 *    from the beginning in order to animate to the new destination point.
 *
 * @param {Object} $1                          Options
 * @param {*}      $1.triggerAnimationOnChange Variable used to trigger the animation if it changes.
 * @param {string} $1.clientId
 */
function useMovingAnimation({
  triggerAnimationOnChange,
  clientId
}) {
  const ref = (0,react.useRef)();
  const {
    isTyping,
    getGlobalBlockCount,
    isBlockSelected,
    isFirstMultiSelectedBlock,
    isBlockMultiSelected,
    isAncestorMultiSelected
  } = (0,use_select/* default */.A)(store_store);

  // Whenever the trigger changes, we need to take a snapshot of the current
  // position of the block to use it as a destination point for the animation.
  const {
    previous,
    prevRect
  } = (0,react.useMemo)(() => ({
    previous: ref.current && getAbsolutePosition(ref.current),
    prevRect: ref.current && ref.current.getBoundingClientRect()
  }),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [triggerAnimationOnChange]);
  (0,react.useLayoutEffect)(() => {
    if (!previous || !ref.current) {
      return;
    }
    const scrollContainer = (0,get_scroll_container/* default */.A)(ref.current);
    const isSelected = isBlockSelected(clientId);
    const adjustScrolling = isSelected || isFirstMultiSelectedBlock(clientId);
    function preserveScrollPosition() {
      if (adjustScrolling && prevRect) {
        const blockRect = ref.current.getBoundingClientRect();
        const diff = blockRect.top - prevRect.top;
        if (diff) {
          scrollContainer.scrollTop += diff;
        }
      }
    }

    // We disable the animation if the user has a preference for reduced
    // motion, if the user is typing (insertion by Enter), or if the block
    // count exceeds the threshold (insertion caused all the blocks that
    // follow to animate).
    // To do: consider enableing the _moving_ animation even for large
    // posts, while only disabling the _insertion_ animation?
    const disableAnimation = window.matchMedia('(prefers-reduced-motion: reduce)').matches || isTyping() || getGlobalBlockCount() > BLOCK_ANIMATION_THRESHOLD;
    if (disableAnimation) {
      // If the animation is disabled and the scroll needs to be adjusted,
      // just move directly to the final scroll position.
      preserveScrollPosition();
      return;
    }
    const isPartOfSelection = isSelected || isBlockMultiSelected(clientId) || isAncestorMultiSelected(clientId);
    // Make sure the other blocks move under the selected block(s).
    const zIndex = isPartOfSelection ? '1' : '';
    const controller = new Controller({
      x: 0,
      y: 0,
      config: {
        mass: 5,
        tension: 2000,
        friction: 200
      },
      onChange({
        value
      }) {
        if (!ref.current) {
          return;
        }
        let {
          x,
          y
        } = value;
        x = Math.round(x);
        y = Math.round(y);
        const finishedMoving = x === 0 && y === 0;
        ref.current.style.transformOrigin = 'center center';
        ref.current.style.transform = finishedMoving ? null // Set to `null` to explicitly remove the transform.
        : `translate3d(${x}px,${y}px,0)`;
        ref.current.style.zIndex = zIndex;
        preserveScrollPosition();
      }
    });
    ref.current.style.transform = undefined;
    const destination = getAbsolutePosition(ref.current);
    const x = Math.round(previous.left - destination.left);
    const y = Math.round(previous.top - destination.top);
    controller.start({
      x: 0,
      y: 0,
      from: {
        x,
        y
      }
    });
    return () => {
      controller.stop();
      controller.set({
        x: 0,
        y: 0
      });
    };
  }, [previous, prevRect, clientId, isTyping, getGlobalBlockCount, isBlockSelected, isFirstMultiSelectedBlock, isBlockMultiSelected, isAncestorMultiSelected]);
  return ref;
}
/* harmony default export */ const use_moving_animation = (useMovingAnimation);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-html-input-element.js
/* eslint-disable jsdoc/valid-types */
/**
 * @param {Node} node
 * @return {node is HTMLInputElement} Whether the node is an HTMLInputElement.
 */
function isHTMLInputElement(node) {
  /* eslint-enable jsdoc/valid-types */
  return node?.nodeName === 'INPUT';
}
//# sourceMappingURL=is-html-input-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-text-field.js
/**
 * Internal dependencies
 */


/* eslint-disable jsdoc/valid-types */
/**
 * Check whether the given element is a text field, where text field is defined
 * by the ability to select within the input, or that it is contenteditable.
 *
 * See: https://html.spec.whatwg.org/#textFieldSelection
 *
 * @param {Node} node The HTML element.
 * @return {node is HTMLElement} True if the element is an text field, false if not.
 */
function isTextField(node) {
  /* eslint-enable jsdoc/valid-types */
  const nonTextInputs = ['button', 'checkbox', 'hidden', 'file', 'radio', 'image', 'range', 'reset', 'submit', 'number', 'email', 'time'];
  return isHTMLInputElement(node) && node.type && !nonTextInputs.includes(node.type) || node.nodeName === 'TEXTAREA' || /** @type {HTMLElement} */node.contentEditable === 'true';
}
//# sourceMappingURL=is-text-field.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-input-or-text-area.js
/* eslint-disable jsdoc/valid-types */
/**
 * @param {Element} element
 * @return {element is HTMLInputElement | HTMLTextAreaElement} Whether the element is an input or textarea
 */
function isInputOrTextArea(element) {
  /* eslint-enable jsdoc/valid-types */
  return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';
}
//# sourceMappingURL=is-input-or-text-area.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-form-element.js
/**
 * Internal dependencies
 */


/**
 *
 * Detects if element is a form element.
 *
 * @param {Element} element The element to check.
 *
 * @return {boolean} True if form element and false otherwise.
 */
function isFormElement(element) {
  if (!element) {
    return false;
  }
  const {
    tagName
  } = element;
  const checkForInputTextarea = isInputOrTextArea(element);
  return checkForInputTextarea || tagName === 'BUTTON' || tagName === 'SELECT';
}
//# sourceMappingURL=is-form-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/caret-range-from-point.js
/**
 * Polyfill.
 * Get a collapsed range for a given point.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint
 *
 * @param {DocumentMaybeWithCaretPositionFromPoint} doc The document of the range.
 * @param {number}                                  x   Horizontal position within the current viewport.
 * @param {number}                                  y   Vertical position within the current viewport.
 *
 * @return {Range | null} The best range for the given point.
 */
function caretRangeFromPoint(doc, x, y) {
  if (doc.caretRangeFromPoint) {
    return doc.caretRangeFromPoint(x, y);
  }
  if (!doc.caretPositionFromPoint) {
    return null;
  }
  const point = doc.caretPositionFromPoint(x, y);

  // If x or y are negative, outside viewport, or there is no text entry node.
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint
  if (!point) {
    return null;
  }
  const range = doc.createRange();
  range.setStart(point.offsetNode, point.offset);
  range.collapse(true);
  return range;
}

/**
 * @typedef {{caretPositionFromPoint?: (x: number, y: number)=> CaretPosition | null} & Document } DocumentMaybeWithCaretPositionFromPoint
 * @typedef {{ readonly offset: number; readonly offsetNode: Node; getClientRect(): DOMRect | null; }} CaretPosition
 */
//# sourceMappingURL=caret-range-from-point.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/get-computed-style.js
var get_computed_style = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/get-computed-style.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/hidden-caret-range-from-point.js
/**
 * Internal dependencies
 */



/**
 * Get a collapsed range for a given point.
 * Gives the container a temporary high z-index (above any UI).
 * This is preferred over getting the UI nodes and set styles there.
 *
 * @param {Document}    doc       The document of the range.
 * @param {number}      x         Horizontal position within the current viewport.
 * @param {number}      y         Vertical position within the current viewport.
 * @param {HTMLElement} container Container in which the range is expected to be found.
 *
 * @return {?Range} The best range for the given point.
 */
function hiddenCaretRangeFromPoint(doc, x, y, container) {
  const originalZIndex = container.style.zIndex;
  const originalPosition = container.style.position;
  const {
    position = 'static'
  } = (0,get_computed_style/* default */.A)(container);

  // A z-index only works if the element position is not static.
  if (position === 'static') {
    container.style.position = 'relative';
  }
  container.style.zIndex = '10000';
  const range = caretRangeFromPoint(doc, x, y);
  container.style.zIndex = originalZIndex;
  container.style.position = originalPosition;
  return range;
}
//# sourceMappingURL=hidden-caret-range-from-point.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js
var assert_is_defined = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-rtl.js
/**
 * Internal dependencies
 */


/**
 * Whether the element's text direction is right-to-left.
 *
 * @param {Element} element The element to check.
 *
 * @return {boolean} True if rtl, false if ltr.
 */
function isRTL(element) {
  return (0,get_computed_style/* default */.A)(element).direction === 'rtl';
}
//# sourceMappingURL=is-rtl.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/scroll-if-no-range.js
/**
 * If no range range can be created or it is outside the container, the element
 * may be out of view, so scroll it into view and try again.
 *
 * @param {HTMLElement} container  The container to scroll.
 * @param {boolean}     alignToTop True to align to top, false to bottom.
 * @param {Function}    callback   The callback to create the range.
 *
 * @return {?Range} The range returned by the callback.
 */
function scrollIfNoRange(container, alignToTop, callback) {
  let range = callback();

  // If no range range can be created or it is outside the container, the
  // element may be out of view.
  if (!range || !range.startContainer || !container.contains(range.startContainer)) {
    container.scrollIntoView(alignToTop);
    range = callback();
    if (!range || !range.startContainer || !container.contains(range.startContainer)) {
      return null;
    }
  }
  return range;
}
//# sourceMappingURL=scroll-if-no-range.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/place-caret-at-edge.js
/**
 * Internal dependencies
 */






/**
 * Gets the range to place.
 *
 * @param {HTMLElement}      container Focusable element.
 * @param {boolean}          isReverse True for end, false for start.
 * @param {number|undefined} x         X coordinate to vertically position.
 *
 * @return {Range|null} The range to place.
 */
function getRange(container, isReverse, x) {
  const {
    ownerDocument
  } = container;
  // In the case of RTL scripts, the horizontal edge is at the opposite side.
  const isReverseDir = isRTL(container) ? !isReverse : isReverse;
  const containerRect = container.getBoundingClientRect();
  // When placing at the end (isReverse), find the closest range to the bottom
  // right corner. When placing at the start, to the top left corner.
  // Ensure x is defined and within the container's boundaries. When it's
  // exactly at the boundary, it's not considered within the boundaries.
  if (x === undefined) {
    x = isReverse ? containerRect.right - 1 : containerRect.left + 1;
  } else if (x <= containerRect.left) {
    x = containerRect.left + 1;
  } else if (x >= containerRect.right) {
    x = containerRect.right - 1;
  }
  const y = isReverseDir ? containerRect.bottom - 1 : containerRect.top + 1;
  return hiddenCaretRangeFromPoint(ownerDocument, x, y, container);
}

/**
 * Places the caret at start or end of a given element.
 *
 * @param {HTMLElement}      container Focusable element.
 * @param {boolean}          isReverse True for end, false for start.
 * @param {number|undefined} x         X coordinate to vertically position.
 */
function placeCaretAtEdge(container, isReverse, x) {
  if (!container) {
    return;
  }
  container.focus();
  if (isInputOrTextArea(container)) {
    // The element may not support selection setting.
    if (typeof container.selectionStart !== 'number') {
      return;
    }
    if (isReverse) {
      container.selectionStart = container.value.length;
      container.selectionEnd = container.value.length;
    } else {
      container.selectionStart = 0;
      container.selectionEnd = 0;
    }
    return;
  }
  if (!container.isContentEditable) {
    return;
  }
  const range = scrollIfNoRange(container, isReverse, () => getRange(container, isReverse, x));
  if (!range) {
    return;
  }
  const {
    ownerDocument
  } = container;
  const {
    defaultView
  } = ownerDocument;
  (0,assert_is_defined/* assertIsDefined */.e)(defaultView, 'defaultView');
  const selection = defaultView.getSelection();
  (0,assert_is_defined/* assertIsDefined */.e)(selection, 'selection');
  selection.removeAllRanges();
  selection.addRange(range);
}
//# sourceMappingURL=place-caret-at-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/place-caret-at-horizontal-edge.js
/**
 * Internal dependencies
 */


/**
 * Places the caret at start or end of a given element.
 *
 * @param {HTMLElement} container Focusable element.
 * @param {boolean}     isReverse True for end, false for start.
 */
function placeCaretAtHorizontalEdge(container, isReverse) {
  return placeCaretAtEdge(container, isReverse, undefined);
}
//# sourceMappingURL=place-caret-at-horizontal-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/utils/dom.js
const BLOCK_SELECTOR = '.block-editor-block-list__block';
const APPENDER_SELECTOR = '.block-list-appender';
const BLOCK_APPENDER_CLASS = '.block-editor-button-block-appender';

/**
 * Returns true if two elements are contained within the same block.
 *
 * @param {Element} a First element.
 * @param {Element} b Second element.
 *
 * @return {boolean} Whether elements are in the same block.
 */
function isInSameBlock(a, b) {
  return a.closest(BLOCK_SELECTOR) === b.closest(BLOCK_SELECTOR);
}

/**
 * Returns true if an element is considered part of the block and not its inner
 * blocks or appender.
 *
 * @param {Element} blockElement Block container element.
 * @param {Element} element      Element.
 *
 * @return {boolean} Whether an element is considered part of the block and not
 *                   its inner blocks or appender.
 */
function isInsideRootBlock(blockElement, element) {
  const parentBlock = element.closest([BLOCK_SELECTOR, APPENDER_SELECTOR, BLOCK_APPENDER_CLASS].join(','));
  return parentBlock === blockElement;
}

/**
 * Finds the block client ID given any DOM node inside the block.
 *
 * @param {Node?} node DOM node.
 *
 * @return {string|undefined} Client ID or undefined if the node is not part of
 *                            a block.
 */
function getBlockClientId(node) {
  while (node && node.nodeType !== node.ELEMENT_NODE) {
    node = node.parentNode;
  }
  if (!node) {
    return;
  }
  const elementNode = /** @type {Element} */node;
  const blockNode = elementNode.closest(BLOCK_SELECTOR);
  if (!blockNode) {
    return;
  }
  return blockNode.id.slice('block-'.length);
}
//# sourceMappingURL=dom.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-first-element.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/** @typedef {import('@wordpress/element').RefObject} RefObject */

/**
 * Transitions focus to the block or inner tabbable when the block becomes
 * selected and an initial position is set.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {RefObject} React ref with the block element.
 */
function useFocusFirstElement({
  clientId,
  initialPosition
}) {
  const ref = (0,react.useRef)();
  const {
    isBlockSelected,
    isMultiSelecting,
    __unstableGetEditorMode
  } = (0,use_select/* default */.A)(store_store);
  (0,react.useEffect)(() => {
    // Check if the block is still selected at the time this effect runs.
    if (!isBlockSelected(clientId) || isMultiSelecting() || __unstableGetEditorMode() === 'zoom-out') {
      return;
    }
    if (initialPosition === undefined || initialPosition === null) {
      return;
    }
    if (!ref.current) {
      return;
    }
    const {
      ownerDocument
    } = ref.current;

    // Do not focus the block if it already contains the active element.
    if (isInsideRootBlock(ref.current, ownerDocument.activeElement)) {
      return;
    }

    // Find all tabbables within node.
    const textInputs = dom_build_module/* focus */.XC.tabbable.find(ref.current).filter(node => isTextField(node));

    // If reversed (e.g. merge via backspace), use the last in the set of
    // tabbables.
    const isReverse = -1 === initialPosition;
    const target = textInputs[isReverse ? textInputs.length - 1 : 0] || ref.current;
    if (!isInsideRootBlock(ref.current, target)) {
      ref.current.focus();
      return;
    }

    // Check to see if element is focussable before a generic caret insert.
    if (!ref.current.getAttribute('contenteditable')) {
      const focusElement = dom_build_module/* focus */.XC.tabbable.findNext(ref.current);
      // Make sure focusElement is valid, contained in the same block, and a form field.
      if (focusElement && isInsideRootBlock(ref.current, focusElement) && isFormElement(focusElement)) {
        focusElement.focus();
        return;
      }
    }
    placeCaretAtHorizontalEdge(target, isReverse);
  }, [initialPosition, clientId]);
  return ref;
}
//# sourceMappingURL=use-focus-first-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-is-hovered.js
/**
 * WordPress dependencies
 */

function listener(event) {
  if (event.defaultPrevented) {
    return;
  }
  const action = event.type === 'mouseover' ? 'add' : 'remove';
  event.preventDefault();
  event.currentTarget.classList[action]('is-hovered');
}

/*
 * Adds `is-hovered` class when the block is hovered and in navigation or
 * outline mode.
 */
function useIsHovered() {
  return (0,use_ref_effect/* default */.A)(node => {
    node.addEventListener('mouseout', listener);
    node.addEventListener('mouseover', listener);
    return () => {
      node.removeEventListener('mouseout', listener);
      node.removeEventListener('mouseover', listener);

      // Remove class in case it lingers.
      node.classList.remove('is-hovered');
    };
  }, []);
}
//# sourceMappingURL=use-is-hovered.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-handler.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * Selects the block if it receives focus.
 *
 * @param {string} clientId Block client ID.
 */
function useFocusHandler(clientId) {
  const {
    isBlockSelected
  } = (0,use_select/* default */.A)(store_store);
  const {
    selectBlock,
    selectionChange
  } = (0,use_dispatch/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    /**
     * Marks the block as selected when focused and not already
     * selected. This specifically handles the case where block does not
     * set focus on its own (via `setFocus`), typically if there is no
     * focusable input in the block.
     *
     * @param {FocusEvent} event Focus event.
     */
    function onFocus(event) {
      // When the whole editor is editable, let writing flow handle
      // selection.
      if (node.parentElement.closest('[contenteditable="true"]')) {
        return;
      }

      // Check synchronously because a non-selected block might be
      // getting data through `useSelect` asynchronously.
      if (isBlockSelected(clientId)) {
        // Potentially change selection away from rich text.
        if (!event.target.isContentEditable) {
          selectionChange(clientId);
        }
        return;
      }

      // If an inner block is focussed, that block is resposible for
      // setting the selected block.
      if (!isInsideRootBlock(node, event.target)) {
        return;
      }
      selectBlock(clientId);
    }
    node.addEventListener('focusin', onFocus);
    return () => {
      node.removeEventListener('focusin', onFocus);
    };
  }, [isBlockSelected, selectBlock]);
}
//# sourceMappingURL=use-focus-handler.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-selected-block-event-handlers.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


/**
 * Adds block behaviour:
 *   - Removes the block on BACKSPACE.
 *   - Inserts a default block on ENTER.
 *   - Disables dragging of block contents.
 *
 * @param {string} clientId Block client ID.
 */
function useEventHandlers({
  clientId,
  isSelected
}) {
  const {
    getBlockRootClientId,
    getBlockIndex
  } = (0,use_select/* default */.A)(store_store);
  const {
    insertAfterBlock,
    removeBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    if (!isSelected) {
      return;
    }

    /**
     * Interprets keydown event intent to remove or insert after block if
     * key event occurs on wrapper node. This can occur when the block has
     * no text fields of its own, particularly after initial insertion, to
     * allow for easy deletion and continuous writing flow to add additional
     * content.
     *
     * @param {KeyboardEvent} event Keydown event.
     */
    function onKeyDown(event) {
      const {
        keyCode,
        target
      } = event;
      if (keyCode !== keycodes_build_module/* ENTER */.Fm && keyCode !== keycodes_build_module/* BACKSPACE */.G_ && keyCode !== keycodes_build_module/* DELETE */.SJ) {
        return;
      }
      if (target !== node || isTextField(target)) {
        return;
      }
      event.preventDefault();
      if (keyCode === keycodes_build_module/* ENTER */.Fm) {
        insertAfterBlock(clientId);
      } else {
        removeBlock(clientId);
      }
    }

    /**
     * Prevents default dragging behavior within a block. To do: we must
     * handle this in the future and clean up the drag target.
     *
     * @param {DragEvent} event Drag event.
     */
    function onDragStart(event) {
      event.preventDefault();
    }
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('dragstart', onDragStart);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('dragstart', onDragStart);
    };
  }, [clientId, isSelected, getBlockRootClientId, getBlockIndex, insertAfterBlock, removeBlock]);
}
//# sourceMappingURL=use-selected-block-event-handlers.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-nav-mode-exit.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Allows navigation mode to be exited by clicking in the selected block.
 *
 * @param {string} clientId Block client ID.
 */
function useNavModeExit(clientId) {
  const {
    isNavigationMode,
    isBlockSelected
  } = (0,use_select/* default */.A)(store_store);
  const {
    setNavigationMode,
    selectBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    function onMouseDown(event) {
      // Don't select a block if it's already handled by a child
      // block.
      if (isNavigationMode() && !event.defaultPrevented) {
        // Prevent focus from moving to the block.
        event.preventDefault();

        // When clicking on a selected block, exit navigation mode.
        if (isBlockSelected(clientId)) {
          setNavigationMode(false);
        } else {
          selectBlock(clientId);
        }
      }
    }
    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
    };
  }, [clientId, isNavigationMode, isBlockSelected, setNavigationMode]);
}
//# sourceMappingURL=use-nav-mode-exit.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-intersection-observer.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */

function useIntersectionObserver() {
  const observer = (0,react.useContext)(block_list_IntersectionObserver);
  return (0,use_ref_effect/* default */.A)(node => {
    if (observer) {
      observer.observe(node);
      return () => {
        observer.unobserve(node);
      };
    }
  }, [observer]);
}
//# sourceMappingURL=use-intersection-observer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-scroll-into-view.js
/**
 * WordPress dependencies
 */

function useScrollIntoView({
  isSelected
}) {
  const prefersReducedMotion = (0,use_reduced_motion/* default */.A)();
  return (0,use_ref_effect/* default */.A)(node => {
    if (isSelected) {
      const {
        ownerDocument
      } = node;
      const {
        defaultView
      } = ownerDocument;
      if (!defaultView.IntersectionObserver) {
        return;
      }
      const observer = new defaultView.IntersectionObserver(entries => {
        // Once observing starts, we always get an initial
        // entry with the intersecting state.
        if (!entries[0].isIntersecting) {
          node.scrollIntoView({
            behavior: prefersReducedMotion ? 'instant' : 'smooth'
          });
        }
        observer.disconnect();
      });
      observer.observe(node);
      return () => {
        observer.disconnect();
      };
    }
  }, [isSelected]);
}
//# sourceMappingURL=use-scroll-into-view.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/use-flash-editable-blocks/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function useFlashEditableBlocks({
  clientId = '',
  isEnabled = true
} = {}) {
  const {
    getEnabledClientIdsTree
  } = lock_unlock_unlock((0,use_select/* default */.A)(store_store));
  return (0,use_ref_effect/* default */.A)(element => {
    if (!isEnabled) {
      return;
    }
    const flashEditableBlocks = () => {
      getEnabledClientIdsTree(clientId).forEach(({
        clientId: id
      }) => {
        const block = element.querySelector(`[data-block="${id}"]`);
        if (!block) {
          return;
        }
        block.classList.remove('has-editable-outline');
        // Force reflow to trigger the animation.
        // eslint-disable-next-line no-unused-expressions
        block.offsetWidth;
        block.classList.add('has-editable-outline');
      });
    };
    const handleClick = event => {
      const shouldFlash = event.target === element || event.target.classList.contains('is-root-container');
      if (!shouldFlash) {
        return;
      }
      if (event.defaultPrevented) {
        return;
      }
      event.preventDefault();
      flashEditableBlocks();
    };
    element.addEventListener('click', handleClick);
    return () => element.removeEventListener('click', handleClick);
  }, [isEnabled]);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */














/**
 * This hook is used to lightly mark an element as a block element. The element
 * should be the outermost element of a block. Call this hook and pass the
 * returned props to the element to mark as a block. If you define a ref for the
 * element, it is important to pass the ref to this hook, which the hook in turn
 * will pass to the component through the props it returns. Optionally, you can
 * also pass any other props through this hook, and they will be merged and
 * returned.
 *
 * Use of this hook on the outermost element of a block is required if using API >= v2.
 *
 * @example
 * ```js
 * import { useBlockProps } from '@wordpress/block-editor';
 *
 * export default function Edit() {
 *
 *   const blockProps = useBlockProps(
 *     className: 'my-custom-class',
 *     style: {
 *       color: '#222222',
 *       backgroundColor: '#eeeeee'
 *     }
 *   )
 *
 *   return (
 *	    <div { ...blockProps }>
 *
 *     </div>
 *   )
 * }
 *
 * ```
 *
 *
 * @param {Object}  props                    Optional. Props to pass to the element. Must contain
 *                                           the ref if one is defined.
 * @param {Object}  options                  Options for internal use only.
 * @param {boolean} options.__unstableIsHtml
 *
 * @return {Object} Props to pass to the element to mark as a block.
 */
function use_block_props_useBlockProps(props = {}, {
  __unstableIsHtml
} = {}) {
  const {
    clientId,
    className,
    wrapperProps = {},
    isAligned,
    index,
    mode,
    name,
    blockApiVersion,
    blockTitle,
    isSelected,
    isSubtreeDisabled,
    hasOverlay,
    initialPosition,
    blockEditingMode,
    isHighlighted,
    isMultiSelected,
    isPartiallySelected,
    isReusable,
    isDragging,
    hasChildSelected,
    isBlockMovingMode,
    canInsertMovingBlock,
    isEditingDisabled,
    hasEditableOutline,
    isTemporarilyEditingAsBlocks,
    defaultClassName,
    templateLock
  } = (0,react.useContext)(PrivateBlockContext);

  // translators: %s: Type of block (i.e. Text, Image etc)
  const blockLabel = (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Block: %s'), blockTitle);
  const htmlSuffix = mode === 'html' && !__unstableIsHtml ? '-visual' : '';
  const mergedRefs = (0,use_merge_refs/* default */.A)([props.ref, useFocusFirstElement({
    clientId,
    initialPosition
  }), useBlockRefProvider(clientId), useFocusHandler(clientId), useEventHandlers({
    clientId,
    isSelected
  }), useNavModeExit(clientId), useIsHovered(), useIntersectionObserver(), use_moving_animation({
    triggerAnimationOnChange: index,
    clientId
  }), use_disabled_useDisabled({
    isDisabled: !hasOverlay
  }), useFlashEditableBlocks({
    clientId,
    isEnabled: name === 'core/block' || templateLock === 'contentOnly'
  }), useScrollIntoView({
    isSelected
  })]);
  const blockEditContext = context_useBlockEditContext();
  const hasBlockBindings = !!blockEditContext[blockBindingsKey];
  const bindingsStyle = hasBlockBindings && canBindBlock(name) ? {
    '--wp-admin-theme-color': 'var(--wp-block-synced-color)',
    '--wp-admin-theme-color--rgb': 'var(--wp-block-synced-color--rgb)'
  } : {};

  // Ensures it warns only inside the `edit` implementation for the block.
  if (blockApiVersion < 2 && clientId === blockEditContext.clientId) {
    globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)(`Block type "${name}" must support API version 2 or higher to work correctly with "useBlockProps" method.`) : void 0;
  }
  let hasNegativeMargin = false;
  if (wrapperProps?.style?.marginTop?.charAt(0) === '-' || wrapperProps?.style?.marginBottom?.charAt(0) === '-' || wrapperProps?.style?.marginLeft?.charAt(0) === '-' || wrapperProps?.style?.marginRight?.charAt(0) === '-') {
    hasNegativeMargin = true;
  }
  return {
    tabIndex: blockEditingMode === 'disabled' ? -1 : 0,
    ...wrapperProps,
    ...props,
    ref: mergedRefs,
    id: `block-${clientId}${htmlSuffix}`,
    role: 'document',
    'aria-label': blockLabel,
    'data-block': clientId,
    'data-type': name,
    'data-title': blockTitle,
    inert: isSubtreeDisabled ? 'true' : undefined,
    className: (0,dist_clsx/* default */.A)('block-editor-block-list__block', {
      // The wp-block className is important for editor styles.
      'wp-block': !isAligned,
      'has-block-overlay': hasOverlay,
      'is-selected': isSelected,
      'is-highlighted': isHighlighted,
      'is-multi-selected': isMultiSelected,
      'is-partially-selected': isPartiallySelected,
      'is-reusable': isReusable,
      'is-dragging': isDragging,
      'has-child-selected': hasChildSelected,
      'is-block-moving-mode': isBlockMovingMode,
      'can-insert-moving-block': canInsertMovingBlock,
      'is-editing-disabled': isEditingDisabled,
      'has-editable-outline': hasEditableOutline,
      'has-negative-margin': hasNegativeMargin,
      'is-content-locked-temporarily-editing-as-blocks': isTemporarilyEditingAsBlocks
    }, className, props.className, wrapperProps.className, defaultClassName),
    style: {
      ...wrapperProps.style,
      ...props.style,
      ...bindingsStyle
    }
  };
}

/**
 * Call within a save function to get the props for the block wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */
use_block_props_useBlockProps.save = build_module/* __unstableGetBlockProps */.cV;
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/block.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */











/**
 * Merges wrapper props with special handling for classNames and styles.
 *
 * @param {Object} propsA
 * @param {Object} propsB
 *
 * @return {Object} Merged props.
 */



function mergeWrapperProps(propsA, propsB) {
  const newProps = {
    ...propsA,
    ...propsB
  };

  // May be set to undefined, so check if the property is set!
  if (propsA?.hasOwnProperty('className') && propsB?.hasOwnProperty('className')) {
    newProps.className = (0,dist_clsx/* default */.A)(propsA.className, propsB.className);
  }
  if (propsA?.hasOwnProperty('style') && propsB?.hasOwnProperty('style')) {
    newProps.style = {
      ...propsA.style,
      ...propsB.style
    };
  }
  return newProps;
}
function Block({
  children,
  isHtml,
  ...props
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ...use_block_props_useBlockProps(props, {
      __unstableIsHtml: isHtml
    }),
    children: children
  });
}
function BlockListBlock({
  block: {
    __unstableBlockSource
  },
  mode,
  isLocked,
  canRemove,
  clientId,
  isSelected,
  isSelectionEnabled,
  className,
  __unstableLayoutClassNames: layoutClassNames,
  name,
  isValid,
  attributes,
  wrapperProps,
  setAttributes,
  onReplace,
  onInsertBlocksAfter,
  onMerge,
  toggleSelection
}) {
  var _wrapperProps;
  const {
    mayDisplayControls,
    mayDisplayParentControls,
    themeSupportsLayout,
    ...context
  } = (0,react.useContext)(PrivateBlockContext);
  const {
    removeBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const onRemove = (0,react.useCallback)(() => removeBlock(clientId), [clientId, removeBlock]);
  const parentLayout = useLayout() || {};

  // We wrap the BlockEdit component in a div that hides it when editing in
  // HTML mode. This allows us to render all of the ancillary pieces
  // (InspectorControls, etc.) which are inside `BlockEdit` but not
  // `BlockHTML`, even in HTML mode.
  let blockEdit = /*#__PURE__*/(0,jsx_runtime.jsx)(BlockEdit, {
    name: name,
    isSelected: isSelected,
    attributes: attributes,
    setAttributes: setAttributes,
    insertBlocksAfter: isLocked ? undefined : onInsertBlocksAfter,
    onReplace: canRemove ? onReplace : undefined,
    onRemove: canRemove ? onRemove : undefined,
    mergeBlocks: canRemove ? onMerge : undefined,
    clientId: clientId,
    isSelectionEnabled: isSelectionEnabled,
    toggleSelection: toggleSelection,
    __unstableLayoutClassNames: layoutClassNames,
    __unstableParentLayout: Object.keys(parentLayout).length ? parentLayout : undefined,
    mayDisplayControls: mayDisplayControls,
    mayDisplayParentControls: mayDisplayParentControls,
    blockEditingMode: context.blockEditingMode,
    isPreviewMode: context.isPreviewMode
  });
  const blockType = (0,build_module/* getBlockType */.E7)(name);

  // Determine whether the block has props to apply to the wrapper.
  if (blockType?.getEditWrapperProps) {
    wrapperProps = mergeWrapperProps(wrapperProps, blockType.getEditWrapperProps(attributes));
  }
  const isAligned = wrapperProps && !!wrapperProps['data-align'] && !themeSupportsLayout;

  // Support for sticky position in classic themes with alignment wrappers.

  const isSticky = className?.includes('is-position-sticky');

  // For aligned blocks, provide a wrapper element so the block can be
  // positioned relative to the block column.
  // This is only kept for classic themes that don't support layout
  // Historically we used to rely on extra divs and data-align to
  // provide the alignments styles in the editor.
  // Due to the differences between frontend and backend, we migrated
  // to the layout feature, and we're now aligning the markup of frontend
  // and backend.
  if (isAligned) {
    blockEdit = /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: (0,dist_clsx/* default */.A)('wp-block', isSticky && className),
      "data-align": wrapperProps['data-align'],
      children: blockEdit
    });
  }
  let block;
  if (!isValid) {
    const saveContent = __unstableBlockSource ? (0,build_module/* serializeRawBlock */.Kx)(__unstableBlockSource) : (0,build_module/* getSaveContent */.Z9)(blockType, attributes);
    block = /*#__PURE__*/(0,jsx_runtime.jsxs)(Block, {
      className: "has-warning",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(BlockInvalidWarning, {
        clientId: clientId
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(raw_html/* default */.A, {
        children: (0,safe_html/* default */.A)(saveContent)
      })]
    });
  } else if (mode === 'html') {
    // Render blockEdit so the inspector controls don't disappear.
    // See #8969.
    block = /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        style: {
          display: 'none'
        },
        children: blockEdit
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Block, {
        isHtml: true,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_html, {
          clientId: clientId
        })
      })]
    });
  } else if (blockType?.apiVersion > 1) {
    block = blockEdit;
  } else {
    block = /*#__PURE__*/(0,jsx_runtime.jsx)(Block, {
      children: blockEdit
    });
  }
  const {
    'data-align': dataAlign,
    ...restWrapperProps
  } = (_wrapperProps = wrapperProps) !== null && _wrapperProps !== void 0 ? _wrapperProps : {};
  const updatedWrapperProps = {
    ...restWrapperProps,
    className: (0,dist_clsx/* default */.A)(restWrapperProps.className, dataAlign && themeSupportsLayout && `align${dataAlign}`, !(dataAlign && isSticky) && className)
  };

  // We set a new context with the adjusted and filtered wrapperProps (through
  // `editor.BlockListBlock`), which the `BlockListBlockProvider` did not have
  // access to.
  // Note that the context value doesn't have to be memoized in this case
  // because when it changes, this component will be re-rendered anyway, and
  // none of the consumers (BlockListBlock and useBlockProps) are memoized or
  // "pure". This is different from the public BlockEditContext, where
  // consumers might be memoized or "pure".
  return /*#__PURE__*/(0,jsx_runtime.jsx)(PrivateBlockContext.Provider, {
    value: {
      wrapperProps: updatedWrapperProps,
      isAligned,
      ...context
    },
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_crash_boundary, {
      fallback: /*#__PURE__*/(0,jsx_runtime.jsx)(Block, {
        className: "has-warning",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_crash_warning, {})
      }),
      children: block
    })
  });
}
const applyWithDispatch = with_dispatch((dispatch, ownProps, registry) => {
  const {
    updateBlockAttributes,
    insertBlocks,
    mergeBlocks,
    replaceBlocks,
    toggleSelection,
    __unstableMarkLastChangeAsPersistent,
    moveBlocksToPosition,
    removeBlock,
    selectBlock
  } = dispatch(store_store);

  // Do not add new properties here, use `useDispatch` instead to avoid
  // leaking new props to the public API (editor.BlockListBlock filter).
  return {
    setAttributes(newAttributes) {
      const {
        getMultiSelectedBlockClientIds
      } = registry.select(store_store);
      const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds();
      const {
        clientId
      } = ownProps;
      const clientIds = multiSelectedBlockClientIds.length ? multiSelectedBlockClientIds : [clientId];
      updateBlockAttributes(clientIds, newAttributes);
    },
    onInsertBlocks(blocks, index) {
      const {
        rootClientId
      } = ownProps;
      insertBlocks(blocks, index, rootClientId);
    },
    onInsertBlocksAfter(blocks) {
      const {
        clientId,
        rootClientId
      } = ownProps;
      const {
        getBlockIndex
      } = registry.select(store_store);
      const index = getBlockIndex(clientId);
      insertBlocks(blocks, index + 1, rootClientId);
    },
    onMerge(forward) {
      const {
        clientId,
        rootClientId
      } = ownProps;
      const {
        getPreviousBlockClientId,
        getNextBlockClientId,
        getBlock,
        getBlockAttributes,
        getBlockName,
        getBlockOrder,
        getBlockIndex,
        getBlockRootClientId,
        canInsertBlockType
      } = registry.select(store_store);
      function switchToDefaultOrRemove() {
        const block = getBlock(clientId);
        const defaultBlockName = (0,build_module/* getDefaultBlockName */.K$)();
        if (getBlockName(clientId) !== defaultBlockName) {
          const replacement = (0,build_module/* switchToBlockType */.bh)(block, defaultBlockName);
          if (replacement && replacement.length) {
            replaceBlocks(clientId, replacement);
          }
        } else if ((0,build_module/* isUnmodifiedDefaultBlock */.Xw)(block)) {
          const nextBlockClientId = getNextBlockClientId(clientId);
          if (nextBlockClientId) {
            registry.batch(() => {
              removeBlock(clientId);
              selectBlock(nextBlockClientId);
            });
          }
        }
      }

      /**
       * Moves the block with clientId up one level. If the block type
       * cannot be inserted at the new location, it will be attempted to
       * convert to the default block type.
       *
       * @param {string}  _clientId       The block to move.
       * @param {boolean} changeSelection Whether to change the selection
       *                                  to the moved block.
       */
      function moveFirstItemUp(_clientId, changeSelection = true) {
        const targetRootClientId = getBlockRootClientId(_clientId);
        const blockOrder = getBlockOrder(_clientId);
        const [firstClientId] = blockOrder;
        if (blockOrder.length === 1 && (0,build_module/* isUnmodifiedBlock */.C5)(getBlock(firstClientId))) {
          removeBlock(_clientId);
        } else {
          registry.batch(() => {
            if (canInsertBlockType(getBlockName(firstClientId), targetRootClientId)) {
              moveBlocksToPosition([firstClientId], _clientId, targetRootClientId, getBlockIndex(_clientId));
            } else {
              const replacement = (0,build_module/* switchToBlockType */.bh)(getBlock(firstClientId), (0,build_module/* getDefaultBlockName */.K$)());
              if (replacement && replacement.length && replacement.every(block => canInsertBlockType(block.name, targetRootClientId))) {
                insertBlocks(replacement, getBlockIndex(_clientId), targetRootClientId, changeSelection);
                removeBlock(firstClientId, false);
              } else {
                switchToDefaultOrRemove();
              }
            }
            if (!getBlockOrder(_clientId).length && (0,build_module/* isUnmodifiedBlock */.C5)(getBlock(_clientId))) {
              removeBlock(_clientId, false);
            }
          });
        }
      }

      // For `Delete` or forward merge, we should do the exact same thing
      // as `Backspace`, but from the other block.
      if (forward) {
        if (rootClientId) {
          const nextRootClientId = getNextBlockClientId(rootClientId);
          if (nextRootClientId) {
            // If there is a block that follows with the same parent
            // block name and the same attributes, merge the inner
            // blocks.
            if (getBlockName(rootClientId) === getBlockName(nextRootClientId)) {
              const rootAttributes = getBlockAttributes(rootClientId);
              const previousRootAttributes = getBlockAttributes(nextRootClientId);
              if (Object.keys(rootAttributes).every(key => rootAttributes[key] === previousRootAttributes[key])) {
                registry.batch(() => {
                  moveBlocksToPosition(getBlockOrder(nextRootClientId), nextRootClientId, rootClientId);
                  removeBlock(nextRootClientId, false);
                });
                return;
              }
            } else {
              mergeBlocks(rootClientId, nextRootClientId);
              return;
            }
          }
        }
        const nextBlockClientId = getNextBlockClientId(clientId);
        if (!nextBlockClientId) {
          return;
        }
        if (getBlockOrder(nextBlockClientId).length) {
          moveFirstItemUp(nextBlockClientId, false);
        } else {
          mergeBlocks(clientId, nextBlockClientId);
        }
      } else {
        const previousBlockClientId = getPreviousBlockClientId(clientId);
        if (previousBlockClientId) {
          mergeBlocks(previousBlockClientId, clientId);
        } else if (rootClientId) {
          const previousRootClientId = getPreviousBlockClientId(rootClientId);

          // If there is a preceding block with the same parent block
          // name and the same attributes, merge the inner blocks.
          if (previousRootClientId && getBlockName(rootClientId) === getBlockName(previousRootClientId)) {
            const rootAttributes = getBlockAttributes(rootClientId);
            const previousRootAttributes = getBlockAttributes(previousRootClientId);
            if (Object.keys(rootAttributes).every(key => rootAttributes[key] === previousRootAttributes[key])) {
              registry.batch(() => {
                moveBlocksToPosition(getBlockOrder(rootClientId), rootClientId, previousRootClientId);
                removeBlock(rootClientId, false);
              });
              return;
            }
          }
          moveFirstItemUp(rootClientId);
        } else {
          switchToDefaultOrRemove();
        }
      }
    },
    onReplace(blocks, indexToSelect, initialPosition) {
      if (blocks.length && !(0,build_module/* isUnmodifiedDefaultBlock */.Xw)(blocks[blocks.length - 1])) {
        __unstableMarkLastChangeAsPersistent();
      }
      //Unsynced patterns are nested in an array so we need to flatten them.
      const replacementBlocks = blocks?.length === 1 && Array.isArray(blocks[0]) ? blocks[0] : blocks;
      replaceBlocks([ownProps.clientId], replacementBlocks, indexToSelect, initialPosition);
    },
    toggleSelection(selectionEnabled) {
      toggleSelection(selectionEnabled);
    }
  };
});

// This component is used by the BlockListBlockProvider component below. It will
// add the props necessary for the `editor.BlockListBlock` filters.
BlockListBlock = (0,compose/* default */.A)(applyWithDispatch, withFilters('editor.BlockListBlock'))(BlockListBlock);

// This component provides all the information we need through a single store
// subscription (useSelect mapping). Only the necessary props are passed down
// to the BlockListBlock component, which is a filtered component, so these
// props are public API. To avoid adding to the public API, we use a private
// context to pass the rest of the information to the filtered BlockListBlock
// component, and useBlockProps.
function BlockListBlockProvider(props) {
  const {
    clientId,
    rootClientId
  } = props;
  const selectedProps = (0,use_select/* default */.A)(select => {
    const {
      isBlockSelected,
      getBlockMode,
      isSelectionEnabled,
      getTemplateLock,
      getBlockWithoutAttributes,
      getBlockAttributes,
      canRemoveBlock,
      canMoveBlock,
      getSettings,
      getTemporarilyEditingAsBlocks,
      getBlockEditingMode,
      getBlockName,
      isFirstMultiSelectedBlock,
      getMultiSelectedBlockClientIds,
      hasSelectedInnerBlock,
      getBlocksByName,
      getBlockIndex,
      isBlockMultiSelected,
      isBlockSubtreeDisabled,
      isBlockHighlighted,
      __unstableIsFullySelected,
      __unstableSelectionHasUnmergeableBlock,
      isBlockBeingDragged,
      isDragging,
      hasBlockMovingClientId,
      canInsertBlockType,
      __unstableHasActiveBlockOverlayActive,
      __unstableGetEditorMode,
      getSelectedBlocksInitialCaretPosition
    } = lock_unlock_unlock(select(store_store));
    const blockWithoutAttributes = getBlockWithoutAttributes(clientId);

    // This is a temporary fix.
    // This function should never be called when a block is not
    // present in the state. It happens now because the order in
    // withSelect rendering is not correct.
    if (!blockWithoutAttributes) {
      return;
    }
    const {
      hasBlockSupport: _hasBlockSupport,
      getActiveBlockVariation
    } = select(build_module/* store */.M_);
    const attributes = getBlockAttributes(clientId);
    const {
      name: blockName,
      isValid
    } = blockWithoutAttributes;
    const blockType = (0,build_module/* getBlockType */.E7)(blockName);
    const {
      supportsLayout,
      __unstableIsPreviewMode: isPreviewMode
    } = getSettings();
    const hasLightBlockWrapper = blockType?.apiVersion > 1;
    const previewContext = {
      isPreviewMode,
      blockWithoutAttributes,
      name: blockName,
      attributes,
      isValid,
      themeSupportsLayout: supportsLayout,
      index: getBlockIndex(clientId),
      isReusable: (0,build_module/* isReusableBlock */.tk)(blockType),
      className: hasLightBlockWrapper ? attributes.className : undefined,
      defaultClassName: hasLightBlockWrapper ? (0,build_module/* getBlockDefaultClassName */.KW)(blockName) : undefined,
      blockTitle: blockType?.title
    };

    // When in preview mode, we can avoid a lot of selection and
    // editing related selectors.
    if (isPreviewMode) {
      return previewContext;
    }
    const _isSelected = isBlockSelected(clientId);
    const canRemove = canRemoveBlock(clientId);
    const canMove = canMoveBlock(clientId);
    const match = getActiveBlockVariation(blockName, attributes);
    const isMultiSelected = isBlockMultiSelected(clientId);
    const checkDeep = true;
    const isAncestorOfSelectedBlock = hasSelectedInnerBlock(clientId, checkDeep);
    const movingClientId = hasBlockMovingClientId();
    const blockEditingMode = getBlockEditingMode(clientId);
    const multiple = (0,build_module/* hasBlockSupport */.pN)(blockName, 'multiple', true);

    // For block types with `multiple` support, there is no "original
    // block" to be found in the content, as the block itself is valid.
    const blocksWithSameName = multiple ? [] : getBlocksByName(blockName);
    const isInvalid = blocksWithSameName.length && blocksWithSameName[0] !== clientId;
    return {
      ...previewContext,
      mode: getBlockMode(clientId),
      isSelectionEnabled: isSelectionEnabled(),
      isLocked: !!getTemplateLock(rootClientId),
      templateLock: getTemplateLock(clientId),
      canRemove,
      canMove,
      isSelected: _isSelected,
      isTemporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks() === clientId,
      blockEditingMode,
      mayDisplayControls: _isSelected || isFirstMultiSelectedBlock(clientId) && getMultiSelectedBlockClientIds().every(id => getBlockName(id) === blockName),
      mayDisplayParentControls: _hasBlockSupport(getBlockName(clientId), '__experimentalExposeControlsToChildren', false) && hasSelectedInnerBlock(clientId),
      blockApiVersion: blockType?.apiVersion || 1,
      blockTitle: match?.title || blockType?.title,
      isSubtreeDisabled: blockEditingMode === 'disabled' && isBlockSubtreeDisabled(clientId),
      hasOverlay: __unstableHasActiveBlockOverlayActive(clientId) && !isDragging(),
      initialPosition: _isSelected && (__unstableGetEditorMode() === 'edit' || __unstableGetEditorMode() === 'zoom-out') // Don't recalculate the initialPosition when toggling in/out of zoom-out mode
      ? getSelectedBlocksInitialCaretPosition() : undefined,
      isHighlighted: isBlockHighlighted(clientId),
      isMultiSelected,
      isPartiallySelected: isMultiSelected && !__unstableIsFullySelected() && !__unstableSelectionHasUnmergeableBlock(),
      isDragging: isBlockBeingDragged(clientId),
      hasChildSelected: isAncestorOfSelectedBlock,
      isBlockMovingMode: !!movingClientId,
      canInsertMovingBlock: movingClientId && canInsertBlockType(getBlockName(movingClientId), rootClientId),
      isEditingDisabled: blockEditingMode === 'disabled',
      hasEditableOutline: blockEditingMode !== 'disabled' && getBlockEditingMode(rootClientId) === 'disabled',
      originalBlockClientId: isInvalid ? blocksWithSameName[0] : false
    };
  }, [clientId, rootClientId]);
  const {
    isPreviewMode,
    // Fill values that end up as a public API and may not be defined in
    // preview mode.
    mode = 'visual',
    isSelectionEnabled = false,
    isLocked = false,
    canRemove = false,
    canMove = false,
    blockWithoutAttributes,
    name,
    attributes,
    isValid,
    isSelected = false,
    themeSupportsLayout,
    isTemporarilyEditingAsBlocks,
    blockEditingMode,
    mayDisplayControls,
    mayDisplayParentControls,
    index,
    blockApiVersion,
    blockTitle,
    isSubtreeDisabled,
    hasOverlay,
    initialPosition,
    isHighlighted,
    isMultiSelected,
    isPartiallySelected,
    isReusable,
    isDragging,
    hasChildSelected,
    isBlockMovingMode,
    canInsertMovingBlock,
    templateLock,
    isEditingDisabled,
    hasEditableOutline,
    className,
    defaultClassName,
    originalBlockClientId
  } = selectedProps;

  // Users of the editor.BlockListBlock filter used to be able to
  // access the block prop.
  // Ideally these blocks would rely on the clientId prop only.
  // This is kept for backward compatibility reasons.
  const block = (0,react.useMemo)(() => ({
    ...blockWithoutAttributes,
    attributes
  }), [blockWithoutAttributes, attributes]);

  // Block is sometimes not mounted at the right time, causing it be
  // undefined see issue for more info
  // https://github.com/WordPress/gutenberg/issues/17013
  if (!selectedProps) {
    return null;
  }
  const privateContext = {
    isPreviewMode,
    clientId,
    className,
    index,
    mode,
    name,
    blockApiVersion,
    blockTitle,
    isSelected,
    isSubtreeDisabled,
    hasOverlay,
    initialPosition,
    blockEditingMode,
    isHighlighted,
    isMultiSelected,
    isPartiallySelected,
    isReusable,
    isDragging,
    hasChildSelected,
    isBlockMovingMode,
    canInsertMovingBlock,
    templateLock,
    isEditingDisabled,
    hasEditableOutline,
    isTemporarilyEditingAsBlocks,
    defaultClassName,
    mayDisplayControls,
    mayDisplayParentControls,
    originalBlockClientId,
    themeSupportsLayout
  };

  // Here we separate between the props passed to BlockListBlock and any other
  // information we selected for internal use. BlockListBlock is a filtered
  // component and thus ALL the props are PUBLIC API.

  // Note that the context value doesn't have to be memoized in this case
  // because when it changes, this component will be re-rendered anyway, and
  // none of the consumers (BlockListBlock and useBlockProps) are memoized or
  // "pure". This is different from the public BlockEditContext, where
  // consumers might be memoized or "pure".
  return /*#__PURE__*/(0,jsx_runtime.jsx)(PrivateBlockContext.Provider, {
    value: privateContext,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(BlockListBlock, {
      ...props,
      mode,
      isSelectionEnabled,
      isLocked,
      canRemove,
      canMove,
      // Users of the editor.BlockListBlock filter used to be able
      // to access the block prop. Ideally these blocks would rely
      // on the clientId prop only. This is kept for backward
      // compatibility reasons.
      block,
      name,
      attributes,
      isValid,
      isSelected
    })
  });
}
/* harmony default export */ const block_list_block = ((0,react.memo)(BlockListBlockProvider));
//# sourceMappingURL=block.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+html-entities@4.0.1/node_modules/@wordpress/html-entities/build-module/index.js
var html_entities_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+html-entities@4.0.1/node_modules/@wordpress/html-entities/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/if-condition/index.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Higher-order component creator, creating a new component which renders if
 * the given condition is satisfied or with the given optional prop name.
 *
 * @example
 * ```ts
 * type Props = { foo: string };
 * const Component = ( props: Props ) => <div>{ props.foo }</div>;
 * const ConditionalComponent = ifCondition( ( props: Props ) => props.foo.length !== 0 )( Component );
 * <ConditionalComponent foo="" />; // => null
 * <ConditionalComponent foo="bar" />; // => <div>bar</div>;
 * ```
 *
 * @param predicate Function to test condition.
 *
 * @return Higher-order component.
 */

function ifCondition(predicate) {
  return (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => props => {
    if (!predicate(props)) {
      return null;
    }
    return /*#__PURE__*/(0,jsx_runtime.jsx)(WrappedComponent, {
      ...props
    });
  }, 'ifCondition');
}
/* harmony default export */ const if_condition = (ifCondition);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/search.js
var search = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/search.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/search-control/styles.js

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



const inlinePadding = ({
  size
}) => {
  return (0,space/* space */.x)(size === 'compact' ? 1 : 2);
};
const SuffixItemWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "effl84m1"
} : 0)("display:flex;padding-inline-end:", inlinePadding, ";svg{fill:currentColor;}" + ( true ? "" : 0));
const StyledInputControl = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(input_control/* default */.Ay,  true ? {
  target: "effl84m0"
} : 0)("input[type='search']{&::-webkit-search-decoration,&::-webkit-search-cancel-button,&::-webkit-search-results-button,&::-webkit-search-results-decoration{-webkit-appearance:none;}}&:not( :focus-within ){--wp-components-color-background:", colors_values/* COLORS */.l.theme.gray[100], ";}" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/search-control/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function SuffixItem({
  searchRef,
  value,
  onChange,
  onClose
}) {
  if (!onClose && !value) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
      icon: search/* default */.A
    });
  }
  const onReset = () => {
    onChange('');
    searchRef.current?.focus();
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
    size: "small",
    icon: close_small/* default */.A,
    label: onClose ? (0,i18n_build_module.__)('Close search') : (0,i18n_build_module.__)('Reset search'),
    onClick: onClose !== null && onClose !== void 0 ? onClose : onReset
  });
}
function UnforwardedSearchControl({
  __nextHasNoMarginBottom = false,
  className,
  onChange,
  value,
  label = (0,i18n_build_module.__)('Search'),
  placeholder = (0,i18n_build_module.__)('Search'),
  hideLabelFromVision = true,
  onClose,
  size = 'default',
  ...restProps
}, forwardedRef) {
  // @ts-expect-error The `disabled` prop is not yet supported in the SearchControl component.
  // Work with the design team (@WordPress/gutenberg-design) if you need this feature.
  delete restProps.disabled;
  const searchRef = (0,react.useRef)(null);
  const instanceId = (0,use_instance_id/* default */.A)(SearchControl, 'components-search-control');
  const contextValue = (0,react.useMemo)(() => ({
    // Overrides the underlying BaseControl `__nextHasNoMarginBottom` via the context system
    // to provide backwards compatibile margin for SearchControl.
    // (In a standard InputControl, the BaseControl `__nextHasNoMarginBottom` is always set to true.)
    BaseControl: {
      _overrides: {
        __nextHasNoMarginBottom
      }
    },
    // `isBorderless` is still experimental and not a public prop for InputControl yet.
    InputBase: {
      isBorderless: true
    }
  }), [__nextHasNoMarginBottom]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(context_system_provider/* ContextSystemProvider */.c7, {
    value: contextValue,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(StyledInputControl, {
      __next40pxDefaultSize: true,
      id: instanceId,
      hideLabelFromVision: hideLabelFromVision,
      label: label,
      ref: (0,use_merge_refs/* default */.A)([searchRef, forwardedRef]),
      type: "search",
      size: size,
      className: (0,dist_clsx/* default */.A)('components-search-control', className),
      onChange: nextValue => onChange(nextValue !== null && nextValue !== void 0 ? nextValue : ''),
      autoComplete: "off",
      placeholder: placeholder,
      value: value !== null && value !== void 0 ? value : '',
      suffix: /*#__PURE__*/(0,jsx_runtime.jsx)(SuffixItemWrapper, {
        size: size,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(SuffixItem, {
          searchRef: searchRef,
          value: value,
          onChange: onChange,
          onClose: onClose
        })
      }),
      ...restProps
    })
  });
}

/**
 * SearchControl components let users display a search control.
 *
 * ```jsx
 * import { SearchControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * function MySearchControl( { className, setState } ) {
 *   const [ searchInput, setSearchInput ] = useState( '' );
 *
 *   return (
 *     <SearchControl
 *       __nextHasNoMarginBottom
 *       value={ searchInput }
 *       onChange={ setSearchInput }
 *     />
 *   );
 * }
 * ```
 */
const SearchControl = (0,react.forwardRef)(UnforwardedSearchControl);
/* harmony default export */ const search_control = (SearchControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-debounced-input/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Helper hook for input fields that need to debounce the value before using it.
 *
 * @param defaultValue The default value to use.
 * @return The input value, the setter and the debounced input value.
 */
function useDebouncedInput(defaultValue = '') {
  const [input, setInput] = (0,react.useState)(defaultValue);
  const [debouncedInput, setDebouncedState] = (0,react.useState)(defaultValue);
  const setDebouncedInput = (0,use_debounce/* default */.A)(setDebouncedState, 250);
  (0,react.useEffect)(() => {
    setDebouncedInput(input);
  }, [input, setDebouncedInput]);
  return [input, setInput, debouncedInput];
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/tip.js
/**
 * WordPress dependencies
 */


const tip = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M12 15.8c-3.7 0-6.8-3-6.8-6.8s3-6.8 6.8-6.8c3.7 0 6.8 3 6.8 6.8s-3.1 6.8-6.8 6.8zm0-12C9.1 3.8 6.8 6.1 6.8 9s2.4 5.2 5.2 5.2c2.9 0 5.2-2.4 5.2-5.2S14.9 3.8 12 3.8zM8 17.5h8V19H8zM10 20.5h4V22h-4z"
  })
});
/* harmony default export */ const library_tip = (tip);
//# sourceMappingURL=tip.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/tip/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function Tip(props) {
  const {
    children
  } = props;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "components-tip",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
      icon: library_tip
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
      children: children
    })]
  });
}
/* harmony default export */ const build_module_tip = (Tip);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/tips.js
/**
 * WordPress dependencies
 */




const globalTips = [(0,create_interpolate_element/* default */.A)((0,i18n_build_module.__)('While writing, you can press <kbd>/</kbd> to quickly insert new blocks.'), {
  kbd: /*#__PURE__*/(0,jsx_runtime.jsx)("kbd", {})
}), (0,create_interpolate_element/* default */.A)((0,i18n_build_module.__)('Indent a list by pressing <kbd>space</kbd> at the beginning of a line.'), {
  kbd: /*#__PURE__*/(0,jsx_runtime.jsx)("kbd", {})
}), (0,create_interpolate_element/* default */.A)((0,i18n_build_module.__)('Outdent a list by pressing <kbd>backspace</kbd> at the beginning of a line.'), {
  kbd: /*#__PURE__*/(0,jsx_runtime.jsx)("kbd", {})
}), (0,i18n_build_module.__)('Drag files into the editor to automatically insert media blocks.'), (0,i18n_build_module.__)("Change a block's type by pressing the block icon on the toolbar.")];
function Tips() {
  const [randomIndex] = (0,react.useState)(
  // Disable Reason: I'm not generating an HTML id.
  // eslint-disable-next-line no-restricted-syntax
  Math.floor(Math.random() * globalTips.length));
  return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_tip, {
    children: globalTips[randomIndex]
  });
}
/* harmony default export */ const tips = (Tips);
//# sourceMappingURL=tips.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-right.js
var chevron_right = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-right.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-left.js
/**
 * WordPress dependencies
 */


const chevronLeft = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M14.6 7l-1.2-1L8 12l5.4 6 1.2-1-4.6-5z"
  })
});
/* harmony default export */ const chevron_left = (chevronLeft);
//# sourceMappingURL=chevron-left.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-card/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function BlockCard({
  title,
  icon,
  description,
  blockType,
  className
}) {
  if (blockType) {
    (0,deprecated_build_module/* default */.A)('`blockType` property in `BlockCard component`', {
      since: '5.7',
      alternative: '`title, icon and description` properties'
    });
    ({
      title,
      icon,
      description
    } = blockType);
  }
  const {
    parentNavBlockClientId
  } = (0,use_select/* default */.A)(select => {
    const {
      getSelectedBlockClientId,
      getBlockParentsByBlockName
    } = select(store_store);
    const _selectedBlockClientId = getSelectedBlockClientId();
    return {
      parentNavBlockClientId: getBlockParentsByBlockName(_selectedBlockClientId, 'core/navigation', true)[0]
    };
  }, []);
  const {
    selectBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: (0,dist_clsx/* default */.A)('block-editor-block-card', className),
    children: [parentNavBlockClientId &&
    /*#__PURE__*/
    // This is only used by the Navigation block for now. It's not ideal having Navigation block specific code here.
    (0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      onClick: () => selectBlock(parentNavBlockClientId),
      label: (0,i18n_build_module.__)('Go to parent Navigation block'),
      style:
      // TODO: This style override is also used in ToolsPanelHeader.
      // It should be supported out-of-the-box by Button.
      {
        minWidth: 24,
        padding: 0
      },
      icon: (0,i18n_build_module/* isRTL */.V8)() ? chevron_right/* default */.A : chevron_left,
      size: "small"
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
      icon: icon,
      showColors: true
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
      spacing: 1,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h2", {
        className: "block-editor-block-card__title",
        children: title
      }), description && /*#__PURE__*/(0,jsx_runtime.jsx)(text_component/* default */.A, {
        className: "block-editor-block-card__description",
        children: description
      })]
    })]
  });
}
/* harmony default export */ const block_card = (BlockCard);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/registry.js + 2 modules
var build_module_registry = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/registry.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/registry-provider/context.js
var registry_provider_context = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/registry-provider/context.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/provider/with-registry-provider.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function getSubRegistry(subRegistries, registry, useSubRegistry) {
  if (!useSubRegistry) {
    return registry;
  }
  let subRegistry = subRegistries.get(registry);
  if (!subRegistry) {
    subRegistry = (0,build_module_registry/* createRegistry */.I)({}, registry);
    subRegistry.registerStore(STORE_NAME, storeConfig);
    subRegistries.set(registry, subRegistry);
  }
  return subRegistry;
}
const withRegistryProvider = (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => ({
  useSubRegistry = true,
  ...props
}) => {
  const registry = (0,use_registry/* default */.A)();
  const [subRegistries] = (0,react.useState)(() => new WeakMap());
  const subRegistry = getSubRegistry(subRegistries, registry, useSubRegistry);
  if (subRegistry === registry) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(WrappedComponent, {
      registry: registry,
      ...props
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(registry_provider_context/* default */.Ay, {
    value: subRegistry,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(WrappedComponent, {
      registry: subRegistry,
      ...props
    })
  });
}, 'withRegistryProvider');
/* harmony default export */ const with_registry_provider = (withRegistryProvider);
//# sourceMappingURL=with-registry-provider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/provider/use-block-sync.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const use_block_sync_noop = () => {};

/**
 * A function to call when the block value has been updated in the block-editor
 * store.
 *
 * @callback onBlockUpdate
 * @param {Object[]} blocks  The updated blocks.
 * @param {Object}   options The updated block options, such as selectionStart
 *                           and selectionEnd.
 */

/**
 * useBlockSync is a side effect which handles bidirectional sync between the
 * block-editor store and a controlling data source which provides blocks. This
 * is most commonly used by the BlockEditorProvider to synchronize the contents
 * of the block-editor store with the root entity, like a post.
 *
 * Another example would be the template part block, which provides blocks from
 * a separate entity data source than a root entity. This hook syncs edits to
 * the template part in the block editor back to the entity and vice-versa.
 *
 * Here are some of its basic functions:
 * - Initalizes the block-editor store for the given clientID to the blocks
 *   given via props.
 * - Adds incoming changes (like undo) to the block-editor store.
 * - Adds outgoing changes (like editing content) to the controlling entity,
 *   determining if a change should be considered persistent or not.
 * - Handles edge cases and race conditions which occur in those operations.
 * - Ignores changes which happen to other entities (like nested inner block
 *   controllers.
 * - Passes selection state from the block-editor store to the controlling entity.
 *
 * @param {Object}        props           Props for the block sync hook
 * @param {string}        props.clientId  The client ID of the inner block controller.
 *                                        If none is passed, then it is assumed to be a
 *                                        root controller rather than an inner block
 *                                        controller.
 * @param {Object[]}      props.value     The control value for the blocks. This value
 *                                        is used to initalize the block-editor store
 *                                        and for resetting the blocks to incoming
 *                                        changes like undo.
 * @param {Object}        props.selection The selection state responsible to restore the selection on undo/redo.
 * @param {onBlockUpdate} props.onChange  Function to call when a persistent
 *                                        change has been made in the block-editor blocks
 *                                        for the given clientId. For example, after
 *                                        this function is called, an entity is marked
 *                                        dirty because it has changes to save.
 * @param {onBlockUpdate} props.onInput   Function to call when a non-persistent
 *                                        change has been made in the block-editor blocks
 *                                        for the given clientId. When this is called,
 *                                        controlling sources do not become dirty.
 */
function useBlockSync({
  clientId = null,
  value: controlledBlocks,
  selection: controlledSelection,
  onChange = use_block_sync_noop,
  onInput = use_block_sync_noop
}) {
  const registry = (0,use_registry/* default */.A)();
  const {
    resetBlocks,
    resetSelection,
    replaceInnerBlocks,
    setHasControlledInnerBlocks,
    __unstableMarkNextChangeAsNotPersistent
  } = registry.dispatch(store_store);
  const {
    getBlockName,
    getBlocks,
    getSelectionStart,
    getSelectionEnd
  } = registry.select(store_store);
  const isControlled = (0,use_select/* default */.A)(select => {
    return !clientId || select(store_store).areInnerBlocksControlled(clientId);
  }, [clientId]);
  const pendingChanges = (0,react.useRef)({
    incoming: null,
    outgoing: []
  });
  const subscribed = (0,react.useRef)(false);
  const setControlledBlocks = () => {
    if (!controlledBlocks) {
      return;
    }

    // We don't need to persist this change because we only replace
    // controlled inner blocks when the change was caused by an entity,
    // and so it would already be persisted.
    __unstableMarkNextChangeAsNotPersistent();
    if (clientId) {
      // It is important to batch here because otherwise,
      // as soon as `setHasControlledInnerBlocks` is called
      // the effect to restore might be triggered
      // before the actual blocks get set properly in state.
      registry.batch(() => {
        setHasControlledInnerBlocks(clientId, true);
        const storeBlocks = controlledBlocks.map(block => (0,build_module/* cloneBlock */.JB)(block));
        if (subscribed.current) {
          pendingChanges.current.incoming = storeBlocks;
        }
        __unstableMarkNextChangeAsNotPersistent();
        replaceInnerBlocks(clientId, storeBlocks);
      });
    } else {
      if (subscribed.current) {
        pendingChanges.current.incoming = controlledBlocks;
      }
      resetBlocks(controlledBlocks);
    }
  };

  // Clean up the changes made by setControlledBlocks() when the component
  // containing useBlockSync() unmounts.
  const unsetControlledBlocks = () => {
    __unstableMarkNextChangeAsNotPersistent();
    if (clientId) {
      setHasControlledInnerBlocks(clientId, false);
      __unstableMarkNextChangeAsNotPersistent();
      replaceInnerBlocks(clientId, []);
    } else {
      resetBlocks([]);
    }
  };

  // Add a subscription to the block-editor registry to detect when changes
  // have been made. This lets us inform the data source of changes. This
  // is an effect so that the subscriber can run synchronously without
  // waiting for React renders for changes.
  const onInputRef = (0,react.useRef)(onInput);
  const onChangeRef = (0,react.useRef)(onChange);
  (0,react.useEffect)(() => {
    onInputRef.current = onInput;
    onChangeRef.current = onChange;
  }, [onInput, onChange]);

  // Determine if blocks need to be reset when they change.
  (0,react.useEffect)(() => {
    if (pendingChanges.current.outgoing.includes(controlledBlocks)) {
      // Skip block reset if the value matches expected outbound sync
      // triggered by this component by a preceding change detection.
      // Only skip if the value matches expectation, since a reset should
      // still occur if the value is modified (not equal by reference),
      // to allow that the consumer may apply modifications to reflect
      // back on the editor.
      if (pendingChanges.current.outgoing[pendingChanges.current.outgoing.length - 1] === controlledBlocks) {
        pendingChanges.current.outgoing = [];
      }
    } else if (getBlocks(clientId) !== controlledBlocks) {
      // Reset changing value in all other cases than the sync described
      // above. Since this can be reached in an update following an out-
      // bound sync, unset the outbound value to avoid considering it in
      // subsequent renders.
      pendingChanges.current.outgoing = [];
      setControlledBlocks();
      if (controlledSelection) {
        resetSelection(controlledSelection.selectionStart, controlledSelection.selectionEnd, controlledSelection.initialPosition);
      }
    }
  }, [controlledBlocks, clientId]);
  const isMounted = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    // On mount, controlled blocks are already set in the effect above.
    if (!isMounted.current) {
      isMounted.current = true;
      return;
    }

    // When the block becomes uncontrolled, it means its inner state has been reset
    // we need to take the blocks again from the external value property.
    if (!isControlled) {
      pendingChanges.current.outgoing = [];
      setControlledBlocks();
    }
  }, [isControlled]);
  (0,react.useEffect)(() => {
    const {
      getSelectedBlocksInitialCaretPosition,
      isLastBlockChangePersistent,
      __unstableIsLastBlockChangeIgnored,
      areInnerBlocksControlled
    } = registry.select(store_store);
    let blocks = getBlocks(clientId);
    let isPersistent = isLastBlockChangePersistent();
    let previousAreBlocksDifferent = false;
    subscribed.current = true;
    const unsubscribe = registry.subscribe(() => {
      // Sometimes, when changing block lists, lingering subscriptions
      // might trigger before they are cleaned up. If the block for which
      // the subscription runs is no longer in the store, this would clear
      // its parent entity's block list. To avoid this, we bail out if
      // the subscription is triggering for a block (`clientId !== null`)
      // and its block name can't be found because it's not on the list.
      // (`getBlockName( clientId ) === null`).
      if (clientId !== null && getBlockName(clientId) === null) {
        return;
      }

      // When RESET_BLOCKS on parent blocks get called, the controlled blocks
      // can reset to uncontrolled, in these situations, it means we need to populate
      // the blocks again from the external blocks (the value property here)
      // and we should stop triggering onChange
      const isStillControlled = !clientId || areInnerBlocksControlled(clientId);
      if (!isStillControlled) {
        return;
      }
      const newIsPersistent = isLastBlockChangePersistent();
      const newBlocks = getBlocks(clientId);
      const areBlocksDifferent = newBlocks !== blocks;
      blocks = newBlocks;
      if (areBlocksDifferent && (pendingChanges.current.incoming || __unstableIsLastBlockChangeIgnored())) {
        pendingChanges.current.incoming = null;
        isPersistent = newIsPersistent;
        return;
      }

      // Since we often dispatch an action to mark the previous action as
      // persistent, we need to make sure that the blocks changed on the
      // previous action before committing the change.
      const didPersistenceChange = previousAreBlocksDifferent && !areBlocksDifferent && newIsPersistent && !isPersistent;
      if (areBlocksDifferent || didPersistenceChange) {
        isPersistent = newIsPersistent;
        // We know that onChange/onInput will update controlledBlocks.
        // We need to be aware that it was caused by an outgoing change
        // so that we do not treat it as an incoming change later on,
        // which would cause a block reset.
        pendingChanges.current.outgoing.push(blocks);

        // Inform the controlling entity that changes have been made to
        // the block-editor store they should be aware about.
        const updateParent = isPersistent ? onChangeRef.current : onInputRef.current;
        const undoIgnore = undoIgnoreBlocks.has(blocks);
        if (undoIgnore) {
          undoIgnoreBlocks.delete(blocks);
        }
        updateParent(blocks, {
          selection: {
            selectionStart: getSelectionStart(),
            selectionEnd: getSelectionEnd(),
            initialPosition: getSelectedBlocksInitialCaretPosition()
          },
          undoIgnore
        });
      }
      previousAreBlocksDifferent = areBlocksDifferent;
    }, store_store);
    return () => {
      subscribed.current = false;
      unsubscribe();
    };
  }, [registry, clientId]);
  (0,react.useEffect)(() => {
    return () => {
      unsetControlledBlocks();
    };
  }, []);
}
//# sourceMappingURL=use-block-sync.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/index.js + 8 modules
var keyboard_shortcuts_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/keyboard-shortcuts/index.js
/**
 * WordPress dependencies
 */




function KeyboardShortcuts() {
  return null;
}
function KeyboardShortcutsRegister() {
  // Registering the shortcuts.
  const {
    registerShortcut
  } = (0,use_dispatch/* default */.A)(keyboard_shortcuts_build_module/* store */.M_);
  (0,react.useEffect)(() => {
    registerShortcut({
      name: 'core/block-editor/duplicate',
      category: 'block',
      description: (0,i18n_build_module.__)('Duplicate the selected block(s).'),
      keyCombination: {
        modifier: 'primaryShift',
        character: 'd'
      }
    });
    registerShortcut({
      name: 'core/block-editor/remove',
      category: 'block',
      description: (0,i18n_build_module.__)('Remove the selected block(s).'),
      keyCombination: {
        modifier: 'access',
        character: 'z'
      }
    });
    registerShortcut({
      name: 'core/block-editor/insert-before',
      category: 'block',
      description: (0,i18n_build_module.__)('Insert a new block before the selected block(s).'),
      keyCombination: {
        modifier: 'primaryAlt',
        character: 't'
      }
    });
    registerShortcut({
      name: 'core/block-editor/insert-after',
      category: 'block',
      description: (0,i18n_build_module.__)('Insert a new block after the selected block(s).'),
      keyCombination: {
        modifier: 'primaryAlt',
        character: 'y'
      }
    });
    registerShortcut({
      name: 'core/block-editor/delete-multi-selection',
      category: 'block',
      description: (0,i18n_build_module.__)('Delete selection.'),
      keyCombination: {
        character: 'del'
      },
      aliases: [{
        character: 'backspace'
      }]
    });
    registerShortcut({
      name: 'core/block-editor/select-all',
      category: 'selection',
      description: (0,i18n_build_module.__)('Select all text when typing. Press again to select all blocks.'),
      keyCombination: {
        modifier: 'primary',
        character: 'a'
      }
    });
    registerShortcut({
      name: 'core/block-editor/unselect',
      category: 'selection',
      description: (0,i18n_build_module.__)('Clear selection.'),
      keyCombination: {
        character: 'escape'
      }
    });
    registerShortcut({
      name: 'core/block-editor/multi-text-selection',
      category: 'selection',
      description: (0,i18n_build_module.__)('Select text across multiple blocks.'),
      keyCombination: {
        modifier: 'shift',
        character: 'arrow'
      }
    });
    registerShortcut({
      name: 'core/block-editor/focus-toolbar',
      category: 'global',
      description: (0,i18n_build_module.__)('Navigate to the nearest toolbar.'),
      keyCombination: {
        modifier: 'alt',
        character: 'F10'
      }
    });
    registerShortcut({
      name: 'core/block-editor/move-up',
      category: 'block',
      description: (0,i18n_build_module.__)('Move the selected block(s) up.'),
      keyCombination: {
        modifier: 'secondary',
        character: 't'
      }
    });
    registerShortcut({
      name: 'core/block-editor/move-down',
      category: 'block',
      description: (0,i18n_build_module.__)('Move the selected block(s) down.'),
      keyCombination: {
        modifier: 'secondary',
        character: 'y'
      }
    });

    // List view shortcuts.
    registerShortcut({
      name: 'core/block-editor/collapse-list-view',
      category: 'list-view',
      description: (0,i18n_build_module.__)('Collapse all other items.'),
      keyCombination: {
        modifier: 'alt',
        character: 'l'
      }
    });
    registerShortcut({
      name: 'core/block-editor/group',
      category: 'block',
      description: (0,i18n_build_module.__)('Create a group block from the selected multiple blocks.'),
      keyCombination: {
        modifier: 'primary',
        character: 'g'
      }
    });
  }, [registerShortcut]);
  return null;
}
KeyboardShortcuts.Register = KeyboardShortcutsRegister;
/* harmony default export */ const keyboard_shortcuts = (KeyboardShortcuts);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/provider/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







/** @typedef {import('@wordpress/data').WPDataRegistry} WPDataRegistry */


const provider_ExperimentalBlockEditorProvider = with_registry_provider(props => {
  const {
    children,
    settings,
    stripExperimentalSettings = false
  } = props;
  const {
    __experimentalUpdateSettings
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  (0,react.useEffect)(() => {
    __experimentalUpdateSettings({
      ...settings,
      __internalIsInitialized: true
    }, {
      stripExperimentalSettings,
      reset: true
    });
  }, [settings, stripExperimentalSettings, __experimentalUpdateSettings]);

  // Syncs the entity provider with changes in the block-editor store.
  useBlockSync(props);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(slot_fill/* Provider */.Kq, {
    passthrough: true,
    children: [!settings?.__unstableIsPreviewMode && /*#__PURE__*/(0,jsx_runtime.jsx)(keyboard_shortcuts.Register, {}), /*#__PURE__*/(0,jsx_runtime.jsx)(BlockRefsProvider, {
      children: children
    })]
  });
});
const BlockEditorProvider = props => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(provider_ExperimentalBlockEditorProvider, {
    ...props,
    stripExperimentalSettings: true,
    children: props.children
  });
};
/* harmony default export */ const provider = (BlockEditorProvider);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/disabled/styles/disabled-styles.js
function disabled_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

const disabledStyles =  true ? {
  name: "u2jump",
  styles: "position:relative;pointer-events:none;&::after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;}*{pointer-events:none;}"
} : 0;
//# sourceMappingURL=disabled-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/disabled/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const disabled_Context = (0,react.createContext)(false);
const {
  Consumer,
  Provider: disabled_Provider
} = disabled_Context;

/**
 * `Disabled` is a component which disables descendant tabbable elements and
 * prevents pointer interaction.
 *
 * _Note: this component may not behave as expected in browsers that don't
 * support the `inert` HTML attribute. We recommend adding the official WICG
 * polyfill when using this component in your project._
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/inert
 *
 * ```jsx
 * import { Button, Disabled, TextControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyDisabled = () => {
 * 	const [ isDisabled, setIsDisabled ] = useState( true );
 *
 * 	let input = <TextControl label="Input" onChange={ () => {} } />;
 * 	if ( isDisabled ) {
 * 		input = <Disabled>{ input }</Disabled>;
 * 	}
 *
 * 	const toggleDisabled = () => {
 * 		setIsDisabled( ( state ) => ! state );
 * 	};
 *
 * 	return (
 * 		<div>
 * 			{ input }
 * 			<Button variant="primary" onClick={ toggleDisabled }>
 * 				Toggle Disabled
 * 			</Button>
 * 		</div>
 * 	);
 * };
 * ```
 */
function Disabled({
  className,
  children,
  isDisabled = true,
  ...props
}) {
  const cx = (0,use_cx/* useCx */.l)();
  return /*#__PURE__*/(0,jsx_runtime.jsx)(disabled_Provider, {
    value: isDisabled,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      // @ts-ignore Reason: inert is a recent HTML attribute
      inert: isDisabled ? 'true' : undefined,
      className: isDisabled ? cx(disabledStyles, className, 'components-disabled') : undefined,
      ...props,
      children: children
    })
  });
}
Disabled.Context = disabled_Context;
Disabled.Consumer = Consumer;
/* harmony default export */ const disabled = (Disabled);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-selection-clearer/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Pass the returned ref callback to an element that should clear block
 * selection. Selection will only be cleared if the element is clicked directly,
 * not if a child element is clicked.
 *
 * @return {import('react').RefCallback} Ref callback.
 */

function useBlockSelectionClearer() {
  const {
    getSettings,
    hasSelectedBlock,
    hasMultiSelection
  } = (0,use_select/* default */.A)(store_store);
  const {
    clearSelectedBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    clearBlockSelection: isEnabled
  } = getSettings();
  return (0,use_ref_effect/* default */.A)(node => {
    if (!isEnabled) {
      return;
    }
    function onMouseDown(event) {
      if (!hasSelectedBlock() && !hasMultiSelection()) {
        return;
      }

      // Only handle clicks on the element, not the children.
      if (event.target !== node) {
        return;
      }
      clearSelectedBlock();
    }
    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
    };
  }, [hasSelectedBlock, hasMultiSelection, clearSelectedBlock, isEnabled]);
}
function BlockSelectionClearer(props) {
  return /*#__PURE__*/_jsx("div", {
    ref: useBlockSelectionClearer(),
    ...props
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-multi-selection.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */

function selector(select) {
  const {
    isMultiSelecting,
    getMultiSelectedBlockClientIds,
    hasMultiSelection,
    getSelectedBlockClientId,
    getSelectedBlocksInitialCaretPosition,
    __unstableIsFullySelected
  } = select(store_store);
  return {
    isMultiSelecting: isMultiSelecting(),
    multiSelectedBlockClientIds: getMultiSelectedBlockClientIds(),
    hasMultiSelection: hasMultiSelection(),
    selectedBlockClientId: getSelectedBlockClientId(),
    initialPosition: getSelectedBlocksInitialCaretPosition(),
    isFullSelection: __unstableIsFullySelected()
  };
}
function useMultiSelection() {
  const {
    initialPosition,
    isMultiSelecting,
    multiSelectedBlockClientIds,
    hasMultiSelection,
    selectedBlockClientId,
    isFullSelection
  } = (0,use_select/* default */.A)(selector, []);

  /**
   * When the component updates, and there is multi selection, we need to
   * select the entire block contents.
   */
  return (0,use_ref_effect/* default */.A)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;

    // Allow initialPosition to bypass focus behavior. This is useful
    // for the list view or other areas where we don't want to transfer
    // focus to the editor canvas.
    if (initialPosition === undefined || initialPosition === null) {
      return;
    }
    if (!hasMultiSelection || isMultiSelecting) {
      return;
    }
    const {
      length
    } = multiSelectedBlockClientIds;
    if (length < 2) {
      return;
    }
    if (!isFullSelection) {
      return;
    }

    // Allow cross contentEditable selection by temporarily making
    // all content editable. We can't rely on using the store and
    // React because re-rending happens too slowly. We need to be
    // able to select across instances immediately.
    node.contentEditable = true;

    // For some browsers, like Safari, it is important that focus
    // happens BEFORE selection removal.
    node.focus();
    defaultView.getSelection().removeAllRanges();
  }, [hasMultiSelection, isMultiSelecting, multiSelectedBlockClientIds, selectedBlockClientId, initialPosition, isFullSelection]);
}
//# sourceMappingURL=use-multi-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-tab-nav.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function useTabNav() {
  const container = (0,react.useRef)();
  const focusCaptureBeforeRef = (0,react.useRef)();
  const focusCaptureAfterRef = (0,react.useRef)();
  const {
    hasMultiSelection,
    getSelectedBlockClientId,
    getBlockCount
  } = (0,use_select/* default */.A)(store_store);
  const {
    setNavigationMode,
    setLastFocus
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  const isNavigationMode = (0,use_select/* default */.A)(select => select(store_store).isNavigationMode(), []);
  const {
    getLastFocus
  } = lock_unlock_unlock((0,use_select/* default */.A)(store_store));

  // Don't allow tabbing to this element in Navigation mode.
  const focusCaptureTabIndex = !isNavigationMode ? '0' : undefined;

  // Reference that holds the a flag for enabling or disabling
  // capturing on the focus capture elements.
  const noCapture = (0,react.useRef)();
  function onFocusCapture(event) {
    // Do not capture incoming focus if set by us in WritingFlow.
    if (noCapture.current) {
      noCapture.current = null;
    } else if (hasMultiSelection()) {
      container.current.focus();
    } else if (getSelectedBlockClientId()) {
      if (getLastFocus()?.current) {
        getLastFocus().current.focus();
      } else {
        // Handles when the last focus has not been set yet, or has been cleared by new blocks being added via the inserter.
        container.current.querySelector(`[data-block="${getSelectedBlockClientId()}"]`).focus();
      }
    } else {
      setNavigationMode(true);
      const canvasElement = container.current.ownerDocument === event.target.ownerDocument ? container.current : container.current.ownerDocument.defaultView.frameElement;
      const isBefore =
      // eslint-disable-next-line no-bitwise
      event.target.compareDocumentPosition(canvasElement) & event.target.DOCUMENT_POSITION_FOLLOWING;
      const tabbables = dom_build_module/* focus */.XC.tabbable.find(container.current);
      if (tabbables.length) {
        const next = isBefore ? tabbables[0] : tabbables[tabbables.length - 1];
        next.focus();
      }
    }
  }
  const before = /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ref: focusCaptureBeforeRef,
    tabIndex: focusCaptureTabIndex,
    onFocus: onFocusCapture
  });
  const after = /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ref: focusCaptureAfterRef,
    tabIndex: focusCaptureTabIndex,
    onFocus: onFocusCapture
  });
  const ref = (0,use_ref_effect/* default */.A)(node => {
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.keyCode === keycodes_build_module/* ESCAPE */._f && !hasMultiSelection()) {
        event.preventDefault();
        setNavigationMode(true);
        return;
      }

      // In Edit mode, Tab should focus the first tabbable element after
      // the content, which is normally the sidebar (with block controls)
      // and Shift+Tab should focus the first tabbable element before the
      // content, which is normally the block toolbar.
      // Arrow keys can be used, and Tab and arrow keys can be used in
      // Navigation mode (press Esc), to navigate through blocks.
      if (event.keyCode !== keycodes_build_module/* TAB */.wn) {
        return;
      }
      const isShift = event.shiftKey;
      const direction = isShift ? 'findPrevious' : 'findNext';
      if (!hasMultiSelection() && !getSelectedBlockClientId()) {
        // Preserve the behaviour of entering navigation mode when
        // tabbing into the content without a block selection.
        // `onFocusCapture` already did this previously, but we need to
        // do it again here because after clearing block selection,
        // focus land on the writing flow container and pressing Tab
        // will no longer send focus through the focus capture element.
        if (event.target === node) {
          setNavigationMode(true);
        }
        return;
      }
      const nextTabbable = dom_build_module/* focus */.XC.tabbable[direction](event.target);

      // We want to constrain the tabbing to the block and its child blocks.
      // If the preceding form element is within a different block,
      // such as two sibling image blocks in the placeholder state,
      // we want shift + tab from the first form element to move to the image
      // block toolbar and not the previous image block's form element.
      const currentBlock = event.target.closest('[data-block]');
      const isElementPartOfSelectedBlock = currentBlock && nextTabbable && (isInSameBlock(currentBlock, nextTabbable) || isInsideRootBlock(currentBlock, nextTabbable));

      // Allow tabbing from the block wrapper to a form element,
      // and between form elements rendered in a block and its child blocks,
      // such as inside a placeholder. Form elements are generally
      // meant to be UI rather than part of the content. Ideally
      // these are not rendered in the content and perhaps in the
      // future they can be rendered in an iframe or shadow DOM.
      if (isFormElement(nextTabbable) && isElementPartOfSelectedBlock) {
        return;
      }
      const next = isShift ? focusCaptureBeforeRef : focusCaptureAfterRef;

      // Disable focus capturing on the focus capture element, so it
      // doesn't refocus this block and so it allows default behaviour
      // (moving focus to the next tabbable element).
      noCapture.current = true;

      // Focusing the focus capture element, which is located above and
      // below the editor, should not scroll the page all the way up or
      // down.
      next.current.focus({
        preventScroll: true
      });
    }
    function onFocusOut(event) {
      setLastFocus({
        ...getLastFocus(),
        current: event.target
      });
      const {
        ownerDocument
      } = node;

      // If focus disappears due to there being no blocks, move focus to
      // the writing flow wrapper.
      if (!event.relatedTarget && ownerDocument.activeElement === ownerDocument.body && getBlockCount() === 0) {
        node.focus();
      }
    }

    // When tabbing back to an element in block list, this event handler prevents scrolling if the
    // focus capture divs (before/after) are outside of the viewport. (For example shift+tab back to a paragraph
    // when focus is on a sidebar element. This prevents the scrollable writing area from jumping either to the
    // top or bottom of the document.
    //
    // Note that it isn't possible to disable scrolling in the onFocus event. We need to intercept this
    // earlier in the keypress handler, and call focus( { preventScroll: true } ) instead.
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus#parameters
    function preventScrollOnTab(event) {
      if (event.keyCode !== keycodes_build_module/* TAB */.wn) {
        return;
      }
      if (event.target?.getAttribute('role') === 'region') {
        return;
      }
      if (container.current === event.target) {
        return;
      }
      const isShift = event.shiftKey;
      const direction = isShift ? 'findPrevious' : 'findNext';
      const target = dom_build_module/* focus */.XC.tabbable[direction](event.target);
      // Only do something when the next tabbable is a focus capture div (before/after)
      if (target === focusCaptureBeforeRef.current || target === focusCaptureAfterRef.current) {
        event.preventDefault();
        target.focus({
          preventScroll: true
        });
      }
    }
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    defaultView.addEventListener('keydown', preventScrollOnTab);
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('focusout', onFocusOut);
    return () => {
      defaultView.removeEventListener('keydown', preventScrollOnTab);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('focusout', onFocusOut);
    };
  }, []);
  const mergedRefs = (0,use_merge_refs/* default */.A)([container, ref]);
  return [before, mergedRefs, after];
}
//# sourceMappingURL=use-tab-nav.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/get-range-height.js
/**
 * Gets the height of the range without ignoring zero width rectangles, which
 * some browsers ignore when creating a union.
 *
 * @param {Range} range The range to check.
 * @return {number | undefined} Height of the range or undefined if the range has no client rectangles.
 */
function getRangeHeight(range) {
  const rects = Array.from(range.getClientRects());
  if (!rects.length) {
    return;
  }
  const highestTop = Math.min(...rects.map(({
    top
  }) => top));
  const lowestBottom = Math.max(...rects.map(({
    bottom
  }) => bottom));
  return lowestBottom - highestTop;
}
//# sourceMappingURL=get-range-height.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/get-rectangle-from-range.js
/**
 * Internal dependencies
 */


/**
 * Get the rectangle of a given Range. Returns `null` if no suitable rectangle
 * can be found.
 *
 * @param {Range} range The range.
 *
 * @return {DOMRect?} The rectangle.
 */
function getRectangleFromRange(range) {
  // For uncollapsed ranges, get the rectangle that bounds the contents of the
  // range; this a rectangle enclosing the union of the bounding rectangles
  // for all the elements in the range.
  if (!range.collapsed) {
    const rects = Array.from(range.getClientRects());

    // If there's just a single rect, return it.
    if (rects.length === 1) {
      return rects[0];
    }

    // Ignore tiny selection at the edge of a range.
    const filteredRects = rects.filter(({
      width
    }) => width > 1);

    // If it's full of tiny selections, return browser default.
    if (filteredRects.length === 0) {
      return range.getBoundingClientRect();
    }
    if (filteredRects.length === 1) {
      return filteredRects[0];
    }
    let {
      top: furthestTop,
      bottom: furthestBottom,
      left: furthestLeft,
      right: furthestRight
    } = filteredRects[0];
    for (const {
      top,
      bottom,
      left,
      right
    } of filteredRects) {
      if (top < furthestTop) {
        furthestTop = top;
      }
      if (bottom > furthestBottom) {
        furthestBottom = bottom;
      }
      if (left < furthestLeft) {
        furthestLeft = left;
      }
      if (right > furthestRight) {
        furthestRight = right;
      }
    }
    return new window.DOMRect(furthestLeft, furthestTop, furthestRight - furthestLeft, furthestBottom - furthestTop);
  }
  const {
    startContainer
  } = range;
  const {
    ownerDocument
  } = startContainer;

  // Correct invalid "BR" ranges. The cannot contain any children.
  if (startContainer.nodeName === 'BR') {
    const {
      parentNode
    } = startContainer;
    (0,assert_is_defined/* assertIsDefined */.e)(parentNode, 'parentNode');
    const index = /** @type {Node[]} */Array.from(parentNode.childNodes).indexOf(startContainer);
    (0,assert_is_defined/* assertIsDefined */.e)(ownerDocument, 'ownerDocument');
    range = ownerDocument.createRange();
    range.setStart(parentNode, index);
    range.setEnd(parentNode, index);
  }
  const rects = range.getClientRects();

  // If we have multiple rectangles for a collapsed range, there's no way to
  // know which it is, so don't return anything.
  if (rects.length > 1) {
    return null;
  }
  let rect = rects[0];

  // If the collapsed range starts (and therefore ends) at an element node,
  // `getClientRects` can be empty in some browsers. This can be resolved
  // by adding a temporary text node with zero-width space to the range.
  //
  // See: https://stackoverflow.com/a/6847328/995445
  if (!rect || rect.height === 0) {
    (0,assert_is_defined/* assertIsDefined */.e)(ownerDocument, 'ownerDocument');
    const padNode = ownerDocument.createTextNode('\u200b');
    // Do not modify the live range.
    range = range.cloneRange();
    range.insertNode(padNode);
    rect = range.getClientRects()[0];
    (0,assert_is_defined/* assertIsDefined */.e)(padNode.parentNode, 'padNode.parentNode');
    padNode.parentNode.removeChild(padNode);
  }
  return rect;
}
//# sourceMappingURL=get-rectangle-from-range.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-selection-forward.js
/**
 * Internal dependencies
 */


/**
 * Returns true if the given selection object is in the forward direction, or
 * false otherwise.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
 *
 * @param {Selection} selection Selection object to check.
 *
 * @return {boolean} Whether the selection is forward.
 */
function isSelectionForward(selection) {
  const {
    anchorNode,
    focusNode,
    anchorOffset,
    focusOffset
  } = selection;
  (0,assert_is_defined/* assertIsDefined */.e)(anchorNode, 'anchorNode');
  (0,assert_is_defined/* assertIsDefined */.e)(focusNode, 'focusNode');
  const position = anchorNode.compareDocumentPosition(focusNode);

  // Disable reason: `Node#compareDocumentPosition` returns a bitmask value,
  // so bitwise operators are intended.
  /* eslint-disable no-bitwise */
  // Compare whether anchor node precedes focus node. If focus node (where
  // end of selection occurs) is after the anchor node, it is forward.
  if (position & anchorNode.DOCUMENT_POSITION_PRECEDING) {
    return false;
  }
  if (position & anchorNode.DOCUMENT_POSITION_FOLLOWING) {
    return true;
  }
  /* eslint-enable no-bitwise */

  // `compareDocumentPosition` returns 0 when passed the same node, in which
  // case compare offsets.
  if (position === 0) {
    return anchorOffset <= focusOffset;
  }

  // This should never be reached, but return true as default case.
  return true;
}
//# sourceMappingURL=is-selection-forward.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-edge.js
/**
 * Internal dependencies
 */









/**
 * Check whether the selection is at the edge of the container. Checks for
 * horizontal position by default. Set `onlyVertical` to true to check only
 * vertically.
 *
 * @param {HTMLElement} container            Focusable element.
 * @param {boolean}     isReverse            Set to true to check left, false to check right.
 * @param {boolean}     [onlyVertical=false] Set to true to check only vertical position.
 *
 * @return {boolean} True if at the edge, false if not.
 */
function isEdge(container, isReverse, onlyVertical = false) {
  if (isInputOrTextArea(container) && typeof container.selectionStart === 'number') {
    if (container.selectionStart !== container.selectionEnd) {
      return false;
    }
    if (isReverse) {
      return container.selectionStart === 0;
    }
    return container.value.length === container.selectionStart;
  }
  if (!container.isContentEditable) {
    return true;
  }
  const {
    ownerDocument
  } = container;
  const {
    defaultView
  } = ownerDocument;
  (0,assert_is_defined/* assertIsDefined */.e)(defaultView, 'defaultView');
  const selection = defaultView.getSelection();
  if (!selection || !selection.rangeCount) {
    return false;
  }
  const range = selection.getRangeAt(0);
  const collapsedRange = range.cloneRange();
  const isForward = isSelectionForward(selection);
  const isCollapsed = selection.isCollapsed;

  // Collapse in direction of selection.
  if (!isCollapsed) {
    collapsedRange.collapse(!isForward);
  }
  const collapsedRangeRect = getRectangleFromRange(collapsedRange);
  const rangeRect = getRectangleFromRange(range);
  if (!collapsedRangeRect || !rangeRect) {
    return false;
  }

  // Only consider the multiline selection at the edge if the direction is
  // towards the edge. The selection is multiline if it is taller than the
  // collapsed  selection.
  const rangeHeight = getRangeHeight(range);
  if (!isCollapsed && rangeHeight && rangeHeight > collapsedRangeRect.height && isForward === isReverse) {
    return false;
  }

  // In the case of RTL scripts, the horizontal edge is at the opposite side.
  const isReverseDir = isRTL(container) ? !isReverse : isReverse;
  const containerRect = container.getBoundingClientRect();

  // To check if a selection is at the edge, we insert a test selection at the
  // edge of the container and check if the selections have the same vertical
  // or horizontal position. If they do, the selection is at the edge.
  // This method proves to be better than a DOM-based calculation for the
  // horizontal edge, since it ignores empty textnodes and a trailing line
  // break element. In other words, we need to check visual positioning, not
  // DOM positioning.
  // It also proves better than using the computed style for the vertical
  // edge, because we cannot know the padding and line height reliably in
  // pixels. `getComputedStyle` may return a value with different units.
  const x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;
  const y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;
  const testRange = scrollIfNoRange(container, isReverse, () => hiddenCaretRangeFromPoint(ownerDocument, x, y, container));
  if (!testRange) {
    return false;
  }
  const testRect = getRectangleFromRange(testRange);
  if (!testRect) {
    return false;
  }
  const verticalSide = isReverse ? 'top' : 'bottom';
  const horizontalSide = isReverseDir ? 'left' : 'right';
  const verticalDiff = testRect[verticalSide] - rangeRect[verticalSide];
  const horizontalDiff = testRect[horizontalSide] - collapsedRangeRect[horizontalSide];

  // Allow the position to be 1px off.
  const hasVerticalDiff = Math.abs(verticalDiff) <= 1;
  const hasHorizontalDiff = Math.abs(horizontalDiff) <= 1;
  return onlyVertical ? hasVerticalDiff : hasVerticalDiff && hasHorizontalDiff;
}
//# sourceMappingURL=is-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-vertical-edge.js
/**
 * Internal dependencies
 */


/**
 * Check whether the selection is vertically at the edge of the container.
 *
 * @param {HTMLElement} container Focusable element.
 * @param {boolean}     isReverse Set to true to check top, false for bottom.
 *
 * @return {boolean} True if at the vertical edge, false if not.
 */
function isVerticalEdge(container, isReverse) {
  return isEdge(container, isReverse, true);
}
//# sourceMappingURL=is-vertical-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-horizontal-edge.js
/**
 * Internal dependencies
 */


/**
 * Check whether the selection is horizontally at the edge of the container.
 *
 * @param {HTMLElement} container Focusable element.
 * @param {boolean}     isReverse Set to true to check left, false for right.
 *
 * @return {boolean} True if at the horizontal edge, false if not.
 */
function isHorizontalEdge(container, isReverse) {
  return isEdge(container, isReverse);
}
//# sourceMappingURL=is-horizontal-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/compute-caret-rect.js
/**
 * Internal dependencies
 */



/**
 * Get the rectangle for the selection in a container.
 *
 * @param {Window} win The window of the selection.
 *
 * @return {DOMRect | null} The rectangle.
 */
function computeCaretRect(win) {
  const selection = win.getSelection();
  (0,assert_is_defined/* assertIsDefined */.e)(selection, 'selection');
  const range = selection.rangeCount ? selection.getRangeAt(0) : null;
  if (!range) {
    return null;
  }
  return getRectangleFromRange(range);
}
//# sourceMappingURL=compute-caret-rect.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/place-caret-at-vertical-edge.js
/**
 * Internal dependencies
 */


/**
 * Places the caret at the top or bottom of a given element.
 *
 * @param {HTMLElement} container Focusable element.
 * @param {boolean}     isReverse True for bottom, false for top.
 * @param {DOMRect}     [rect]    The rectangle to position the caret with.
 */
function placeCaretAtVerticalEdge(container, isReverse, rect) {
  return placeCaretAtEdge(container, isReverse, rect?.left);
}
//# sourceMappingURL=place-caret-at-vertical-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-arrow-nav.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/**
 * Returns true if the element should consider edge navigation upon a keyboard
 * event of the given directional key code, or false otherwise.
 *
 * @param {Element} element     HTML element to test.
 * @param {number}  keyCode     KeyboardEvent keyCode to test.
 * @param {boolean} hasModifier Whether a modifier is pressed.
 *
 * @return {boolean} Whether element should consider edge navigation.
 */
function isNavigationCandidate(element, keyCode, hasModifier) {
  const isVertical = keyCode === keycodes_build_module.UP || keyCode === keycodes_build_module/* DOWN */.PX;
  const {
    tagName
  } = element;
  const elementType = element.getAttribute('type');

  // Native inputs should not navigate vertically, unless they are simple types that don't need up/down arrow keys.
  if (isVertical && !hasModifier) {
    if (tagName === 'INPUT') {
      const verticalInputTypes = ['date', 'datetime-local', 'month', 'number', 'range', 'time', 'week'];
      return !verticalInputTypes.includes(elementType);
    }
    return true;
  }

  // Native inputs should not navigate horizontally, unless they are simple types that don't need left/right arrow keys.
  if (tagName === 'INPUT') {
    const simpleInputTypes = ['button', 'checkbox', 'number', 'color', 'file', 'image', 'radio', 'reset', 'submit'];
    return simpleInputTypes.includes(elementType);
  }

  // Native textareas should not navigate horizontally.
  return tagName !== 'TEXTAREA';
}

/**
 * Returns the optimal tab target from the given focused element in the desired
 * direction. A preference is made toward text fields, falling back to the block
 * focus stop if no other candidates exist for the block.
 *
 * @param {Element} target           Currently focused text field.
 * @param {boolean} isReverse        True if considering as the first field.
 * @param {Element} containerElement Element containing all blocks.
 * @param {boolean} onlyVertical     Whether to only consider tabbable elements
 *                                   that are visually above or under the
 *                                   target.
 *
 * @return {?Element} Optimal tab target, if one exists.
 */
function getClosestTabbable(target, isReverse, containerElement, onlyVertical) {
  // Since the current focus target is not guaranteed to be a text field, find
  // all focusables. Tabbability is considered later.
  let focusableNodes = dom_build_module/* focus */.XC.focusable.find(containerElement);
  if (isReverse) {
    focusableNodes.reverse();
  }

  // Consider as candidates those focusables after the current target. It's
  // assumed this can only be reached if the target is focusable (on its
  // keydown event), so no need to verify it exists in the set.
  focusableNodes = focusableNodes.slice(focusableNodes.indexOf(target) + 1);
  let targetRect;
  if (onlyVertical) {
    targetRect = target.getBoundingClientRect();
  }
  function isTabCandidate(node) {
    if (node.closest('[inert]')) {
      return;
    }

    // Skip if there's only one child that is content editable (and thus a
    // better candidate).
    if (node.children.length === 1 && isInSameBlock(node, node.firstElementChild) && node.firstElementChild.getAttribute('contenteditable') === 'true') {
      return;
    }

    // Not a candidate if the node is not tabbable.
    if (!dom_build_module/* focus */.XC.tabbable.isTabbableIndex(node)) {
      return false;
    }

    // Skip focusable elements such as links within content editable nodes.
    if (node.isContentEditable && node.contentEditable !== 'true') {
      return false;
    }
    if (onlyVertical) {
      const nodeRect = node.getBoundingClientRect();
      if (nodeRect.left >= targetRect.right || nodeRect.right <= targetRect.left) {
        return false;
      }
    }
    return true;
  }
  return focusableNodes.find(isTabCandidate);
}
function useArrowNav() {
  const {
    getMultiSelectedBlocksStartClientId,
    getMultiSelectedBlocksEndClientId,
    getSettings,
    hasMultiSelection,
    __unstableIsFullySelected
  } = (0,use_select/* default */.A)(store_store);
  const {
    selectBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    // Here a DOMRect is stored while moving the caret vertically so
    // vertical position of the start position can be restored. This is to
    // recreate browser behaviour across blocks.
    let verticalRect;
    function onMouseDown() {
      verticalRect = null;
    }
    function isClosestTabbableABlock(target, isReverse) {
      const closestTabbable = getClosestTabbable(target, isReverse, node);
      return closestTabbable && getBlockClientId(closestTabbable);
    }
    function onKeyDown(event) {
      // Abort if navigation has already been handled (e.g. RichText
      // inline boundaries).
      if (event.defaultPrevented) {
        return;
      }
      const {
        keyCode,
        target,
        shiftKey,
        ctrlKey,
        altKey,
        metaKey
      } = event;
      const isUp = keyCode === keycodes_build_module.UP;
      const isDown = keyCode === keycodes_build_module/* DOWN */.PX;
      const isLeft = keyCode === keycodes_build_module/* LEFT */.M3;
      const isRight = keyCode === keycodes_build_module/* RIGHT */.NS;
      const isReverse = isUp || isLeft;
      const isHorizontal = isLeft || isRight;
      const isVertical = isUp || isDown;
      const isNav = isHorizontal || isVertical;
      const hasModifier = shiftKey || ctrlKey || altKey || metaKey;
      const isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;
      const {
        ownerDocument
      } = node;
      const {
        defaultView
      } = ownerDocument;
      if (!isNav) {
        return;
      }

      // If there is a multi-selection, the arrow keys should collapse the
      // selection to the start or end of the selection.
      if (hasMultiSelection()) {
        if (shiftKey) {
          return;
        }

        // Only handle if we have a full selection (not a native partial
        // selection).
        if (!__unstableIsFullySelected()) {
          return;
        }
        event.preventDefault();
        if (isReverse) {
          selectBlock(getMultiSelectedBlocksStartClientId());
        } else {
          selectBlock(getMultiSelectedBlocksEndClientId(), -1);
        }
        return;
      }

      // Abort if our current target is not a candidate for navigation
      // (e.g. preserve native input behaviors).
      if (!isNavigationCandidate(target, keyCode, hasModifier)) {
        return;
      }

      // When presing any key other than up or down, the initial vertical
      // position must ALWAYS be reset. The vertical position is saved so
      // it can be restored as well as possible on sebsequent vertical
      // arrow key presses. It may not always be possible to restore the
      // exact same position (such as at an empty line), so it wouldn't be
      // good to compute the position right before any vertical arrow key
      // press.
      if (!isVertical) {
        verticalRect = null;
      } else if (!verticalRect) {
        verticalRect = computeCaretRect(defaultView);
      }

      // In the case of RTL scripts, right means previous and left means
      // next, which is the exact reverse of LTR.
      const isReverseDir = isRTL(target) ? !isReverse : isReverse;
      const {
        keepCaretInsideBlock
      } = getSettings();
      if (shiftKey) {
        if (isClosestTabbableABlock(target, isReverse) && isNavEdge(target, isReverse)) {
          node.contentEditable = true;
          // Firefox doesn't automatically move focus.
          node.focus();
        }
      } else if (isVertical && isVerticalEdge(target, isReverse) && (
      // When Alt is pressed, only intercept if the caret is also at
      // the horizontal edge.
      altKey ? isHorizontalEdge(target, isReverseDir) : true) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(target, isReverse, node, true);
        if (closestTabbable) {
          placeCaretAtVerticalEdge(closestTabbable,
          // When Alt is pressed, place the caret at the furthest
          // horizontal edge and the furthest vertical edge.
          altKey ? !isReverse : isReverse, altKey ? undefined : verticalRect);
          event.preventDefault();
        }
      } else if (isHorizontal && defaultView.getSelection().isCollapsed && isHorizontalEdge(target, isReverseDir) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(target, isReverseDir, node);
        placeCaretAtHorizontalEdge(closestTabbable, isReverse);
        event.preventDefault();
      }
    }
    node.addEventListener('mousedown', onMouseDown);
    node.addEventListener('keydown', onKeyDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
      node.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}
//# sourceMappingURL=use-arrow-nav.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-entirely-selected.js
/**
 * Internal dependencies
 */



/**
 * Check whether the contents of the element have been entirely selected.
 * Returns true if there is no possibility of selection.
 *
 * @param {HTMLElement} element The element to check.
 *
 * @return {boolean} True if entirely selected, false if not.
 */
function isEntirelySelected(element) {
  if (isInputOrTextArea(element)) {
    return element.selectionStart === 0 && element.value.length === element.selectionEnd;
  }
  if (!element.isContentEditable) {
    return true;
  }
  const {
    ownerDocument
  } = element;
  const {
    defaultView
  } = ownerDocument;
  (0,assert_is_defined/* assertIsDefined */.e)(defaultView, 'defaultView');
  const selection = defaultView.getSelection();
  (0,assert_is_defined/* assertIsDefined */.e)(selection, 'selection');
  const range = selection.rangeCount ? selection.getRangeAt(0) : null;
  if (!range) {
    return true;
  }
  const {
    startContainer,
    endContainer,
    startOffset,
    endOffset
  } = range;
  if (startContainer === element && endContainer === element && startOffset === 0 && endOffset === element.childNodes.length) {
    return true;
  }
  const lastChild = element.lastChild;
  (0,assert_is_defined/* assertIsDefined */.e)(lastChild, 'lastChild');
  const endContainerContentLength = endContainer.nodeType === endContainer.TEXT_NODE ? /** @type {Text} */endContainer.data.length : endContainer.childNodes.length;
  return isDeepChild(startContainer, element, 'firstChild') && isDeepChild(endContainer, element, 'lastChild') && startOffset === 0 && endOffset === endContainerContentLength;
}

/**
 * Check whether the contents of the element have been entirely selected.
 * Returns true if there is no possibility of selection.
 *
 * @param {HTMLElement|Node}         query     The element to check.
 * @param {HTMLElement}              container The container that we suspect "query" may be a first or last child of.
 * @param {"firstChild"|"lastChild"} propName  "firstChild" or "lastChild"
 *
 * @return {boolean} True if query is a deep first/last child of container, false otherwise.
 */
function isDeepChild(query, container, propName) {
  /** @type {HTMLElement | ChildNode | null} */
  let candidate = container;
  do {
    if (query === candidate) {
      return true;
    }
    candidate = candidate[propName];
  } while (candidate);
  return false;
}
//# sourceMappingURL=is-entirely-selected.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-select-all.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */

function useSelectAll() {
  const {
    getBlockOrder,
    getSelectedBlockClientIds,
    getBlockRootClientId
  } = (0,use_select/* default */.A)(store_store);
  const {
    multiSelect,
    selectBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const isMatch = (0,keyboard_shortcuts_build_module/* __unstableUseShortcutEventMatch */.ZK)();
  return (0,use_ref_effect/* default */.A)(node => {
    function onKeyDown(event) {
      if (!isMatch('core/block-editor/select-all', event)) {
        return;
      }
      const selectedClientIds = getSelectedBlockClientIds();
      if (selectedClientIds.length < 2 && !isEntirelySelected(event.target)) {
        return;
      }
      event.preventDefault();
      const [firstSelectedClientId] = selectedClientIds;
      const rootClientId = getBlockRootClientId(firstSelectedClientId);
      const blockClientIds = getBlockOrder(rootClientId);

      // If we have selected all sibling nested blocks, try selecting up a
      // level. See: https://github.com/WordPress/gutenberg/pull/31859/
      if (selectedClientIds.length === blockClientIds.length) {
        if (rootClientId) {
          node.ownerDocument.defaultView.getSelection().removeAllRanges();
          selectBlock(rootClientId);
        }
        return;
      }
      multiSelect(blockClientIds[0], blockClientIds[blockClientIds.length - 1]);
    }
    node.addEventListener('keydown', onKeyDown);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}
//# sourceMappingURL=use-select-all.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-drag-selection.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Sets the `contenteditable` wrapper element to `value`.
 *
 * @param {HTMLElement} node  Block element.
 * @param {boolean}     value `contentEditable` value (true or false)
 */
function setContentEditableWrapper(node, value) {
  node.contentEditable = value;
  // Firefox doesn't automatically move focus.
  if (value) {
    node.focus();
  }
}

/**
 * Sets a multi-selection based on the native selection across blocks.
 */
function useDragSelection() {
  const {
    startMultiSelect,
    stopMultiSelect
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    isSelectionEnabled,
    hasSelectedBlock,
    isDraggingBlocks,
    isMultiSelecting
  } = (0,use_select/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    let anchorElement;
    let rafId;
    function onMouseUp() {
      stopMultiSelect();
      // Equivalent to attaching the listener once.
      defaultView.removeEventListener('mouseup', onMouseUp);
      // The browser selection won't have updated yet at this point,
      // so wait until the next animation frame to get the browser
      // selection.
      rafId = defaultView.requestAnimationFrame(() => {
        if (!hasSelectedBlock()) {
          return;
        }

        // If the selection is complete (on mouse up), and no
        // multiple blocks have been selected, set focus back to the
        // anchor element. if the anchor element contains the
        // selection. Additionally, the contentEditable wrapper can
        // now be disabled again.
        setContentEditableWrapper(node, false);
        const selection = defaultView.getSelection();
        if (selection.rangeCount) {
          const range = selection.getRangeAt(0);
          const {
            commonAncestorContainer
          } = range;
          const clonedRange = range.cloneRange();
          if (anchorElement.contains(commonAncestorContainer)) {
            anchorElement.focus();
            selection.removeAllRanges();
            selection.addRange(clonedRange);
          }
        }
      });
    }
    function onMouseLeave({
      buttons,
      target,
      relatedTarget
    }) {
      // If we're moving into a child element, ignore. We're tracking
      // the mouse leaving the element to a parent, no a child.
      if (target.contains(relatedTarget)) {
        return;
      }

      // Avoid triggering a multi-selection if the user is already
      // dragging blocks.
      if (isDraggingBlocks()) {
        return;
      }

      // The primary button must be pressed to initiate selection.
      // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
      if (buttons !== 1) {
        return;
      }

      // Abort if we are already multi-selecting.
      if (isMultiSelecting()) {
        return;
      }

      // Abort if selection is leaving writing flow.
      if (node === target) {
        return;
      }

      // Check the attribute, not the contentEditable attribute. All
      // child elements of the content editable wrapper are editable
      // and return true for this property. We only want to start
      // multi selecting when the mouse leaves the wrapper.
      if (target.getAttribute('contenteditable') !== 'true') {
        return;
      }
      if (!isSelectionEnabled()) {
        return;
      }

      // Do not rely on the active element because it may change after
      // the mouse leaves for the first time. See
      // https://github.com/WordPress/gutenberg/issues/48747.
      anchorElement = target;
      startMultiSelect();

      // `onSelectionStart` is called after `mousedown` and
      // `mouseleave` (from a block). The selection ends when
      // `mouseup` happens anywhere in the window.
      defaultView.addEventListener('mouseup', onMouseUp);

      // Allow cross contentEditable selection by temporarily making
      // all content editable. We can't rely on using the store and
      // React because re-rending happens too slowly. We need to be
      // able to select across instances immediately.
      setContentEditableWrapper(node, true);
    }
    node.addEventListener('mouseout', onMouseLeave);
    return () => {
      node.removeEventListener('mouseout', onMouseLeave);
      defaultView.removeEventListener('mouseup', onMouseUp);
      defaultView.cancelAnimationFrame(rafId);
    };
  }, [startMultiSelect, stopMultiSelect, isSelectionEnabled, hasSelectedBlock]);
}
//# sourceMappingURL=use-drag-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-selection-observer.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/**
 * Extract the selection start node from the selection. When the anchor node is
 * not a text node, the selection offset is the index of a child node.
 *
 * @param {Selection} selection The selection.
 *
 * @return {Element} The selection start node.
 */
function extractSelectionStartNode(selection) {
  const {
    anchorNode,
    anchorOffset
  } = selection;
  if (anchorNode.nodeType === anchorNode.TEXT_NODE) {
    return anchorNode;
  }
  if (anchorOffset === 0) {
    return anchorNode;
  }
  return anchorNode.childNodes[anchorOffset - 1];
}

/**
 * Extract the selection end node from the selection. When the focus node is not
 * a text node, the selection offset is the index of a child node. The selection
 * reaches up to but excluding that child node.
 *
 * @param {Selection} selection The selection.
 *
 * @return {Element} The selection start node.
 */
function extractSelectionEndNode(selection) {
  const {
    focusNode,
    focusOffset
  } = selection;
  if (focusNode.nodeType === focusNode.TEXT_NODE) {
    return focusNode;
  }
  if (focusOffset === focusNode.childNodes.length) {
    return focusNode;
  }
  return focusNode.childNodes[focusOffset];
}
function findDepth(a, b) {
  let depth = 0;
  while (a[depth] === b[depth]) {
    depth++;
  }
  return depth;
}

/**
 * Sets the `contenteditable` wrapper element to `value`.
 *
 * @param {HTMLElement} node  Block element.
 * @param {boolean}     value `contentEditable` value (true or false)
 */
function use_selection_observer_setContentEditableWrapper(node, value) {
  // Since we are calling this on every selection change, check if the value
  // needs to be updated first because it trigger the browser to recalculate
  // style.
  if (node.contentEditable !== String(value)) {
    node.contentEditable = value;

    // Firefox doesn't automatically move focus.
    if (value) {
      node.focus();
    }
  }
}
function getRichTextElement(node) {
  const element = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;
  return element?.closest('[data-wp-block-attribute-key]');
}

/**
 * Sets a multi-selection based on the native selection across blocks.
 */
function useSelectionObserver() {
  const {
    multiSelect,
    selectBlock,
    selectionChange
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    getBlockParents,
    getBlockSelectionStart,
    isMultiSelecting
  } = (0,use_select/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    function onSelectionChange(event) {
      const selection = defaultView.getSelection();
      if (!selection.rangeCount) {
        return;
      }
      const startNode = extractSelectionStartNode(selection);
      const endNode = extractSelectionEndNode(selection);
      if (!node.contains(startNode) || !node.contains(endNode)) {
        return;
      }

      // If selection is collapsed and we haven't used `shift+click`,
      // end multi selection and disable the contentEditable wrapper.
      // We have to check about `shift+click` case because elements
      // that don't support text selection might be involved, and we might
      // update the clientIds to multi-select blocks.
      // For now we check if the event is a `mouse` event.
      const isClickShift = event.shiftKey && event.type === 'mouseup';
      if (selection.isCollapsed && !isClickShift) {
        if (node.contentEditable === 'true' && !isMultiSelecting()) {
          use_selection_observer_setContentEditableWrapper(node, false);
          let element = startNode.nodeType === startNode.ELEMENT_NODE ? startNode : startNode.parentElement;
          element = element?.closest('[contenteditable]');
          element?.focus();
        }
        return;
      }
      let startClientId = getBlockClientId(startNode);
      let endClientId = getBlockClientId(endNode);

      // If the selection has changed and we had pressed `shift+click`,
      // we need to check if in an element that doesn't support
      // text selection has been clicked.
      if (isClickShift) {
        const selectedClientId = getBlockSelectionStart();
        const clickedClientId = getBlockClientId(event.target);
        // `endClientId` is not defined if we end the selection by clicking a non-selectable block.
        // We need to check if there was already a selection with a non-selectable focusNode.
        const focusNodeIsNonSelectable = clickedClientId !== endClientId;
        if (startClientId === endClientId && selection.isCollapsed || !endClientId || focusNodeIsNonSelectable) {
          endClientId = clickedClientId;
        }
        // Handle the case when we have a non-selectable block
        // selected and click another one.
        if (startClientId !== selectedClientId) {
          startClientId = selectedClientId;
        }
      }

      // If the selection did not involve a block, return.
      if (startClientId === undefined && endClientId === undefined) {
        use_selection_observer_setContentEditableWrapper(node, false);
        return;
      }
      const isSingularSelection = startClientId === endClientId;
      if (isSingularSelection) {
        if (!isMultiSelecting()) {
          selectBlock(startClientId);
        } else {
          multiSelect(startClientId, startClientId);
        }
      } else {
        const startPath = [...getBlockParents(startClientId), startClientId];
        const endPath = [...getBlockParents(endClientId), endClientId];
        const depth = findDepth(startPath, endPath);
        if (startPath[depth] !== startClientId || endPath[depth] !== endClientId) {
          multiSelect(startPath[depth], endPath[depth]);
          return;
        }
        const richTextElementStart = getRichTextElement(startNode);
        const richTextElementEnd = getRichTextElement(endNode);
        if (richTextElementStart && richTextElementEnd) {
          var _richTextDataStart$st, _richTextDataEnd$star;
          const range = selection.getRangeAt(0);
          const richTextDataStart = (0,rich_text_build_module/* create */.vt)({
            element: richTextElementStart,
            range,
            __unstableIsEditableTree: true
          });
          const richTextDataEnd = (0,rich_text_build_module/* create */.vt)({
            element: richTextElementEnd,
            range,
            __unstableIsEditableTree: true
          });
          const startOffset = (_richTextDataStart$st = richTextDataStart.start) !== null && _richTextDataStart$st !== void 0 ? _richTextDataStart$st : richTextDataStart.end;
          const endOffset = (_richTextDataEnd$star = richTextDataEnd.start) !== null && _richTextDataEnd$star !== void 0 ? _richTextDataEnd$star : richTextDataEnd.end;
          selectionChange({
            start: {
              clientId: startClientId,
              attributeKey: richTextElementStart.dataset.wpBlockAttributeKey,
              offset: startOffset
            },
            end: {
              clientId: endClientId,
              attributeKey: richTextElementEnd.dataset.wpBlockAttributeKey,
              offset: endOffset
            }
          });
        } else {
          multiSelect(startClientId, endClientId);
        }
      }
    }
    ownerDocument.addEventListener('selectionchange', onSelectionChange);
    defaultView.addEventListener('mouseup', onSelectionChange);
    return () => {
      ownerDocument.removeEventListener('selectionchange', onSelectionChange);
      defaultView.removeEventListener('mouseup', onSelectionChange);
    };
  }, [multiSelect, selectBlock, selectionChange, getBlockParents]);
}
//# sourceMappingURL=use-selection-observer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-click-selection.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function useClickSelection() {
  const {
    selectBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    isSelectionEnabled,
    getBlockSelectionStart,
    hasMultiSelection
  } = (0,use_select/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    function onMouseDown(event) {
      // The main button.
      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
      if (!isSelectionEnabled() || event.button !== 0) {
        return;
      }
      const startClientId = getBlockSelectionStart();
      const clickedClientId = getBlockClientId(event.target);
      if (event.shiftKey) {
        if (startClientId !== clickedClientId) {
          node.contentEditable = true;
          // Firefox doesn't automatically move focus.
          node.focus();
        }
      } else if (hasMultiSelection()) {
        // Allow user to escape out of a multi-selection to a
        // singular selection of a block via click. This is handled
        // here since focus handling excludes blocks when there is
        // multiselection, as focus can be incurred by starting a
        // multiselection (focus moved to first block's multi-
        // controls).
        selectBlock(clickedClientId);
      }
    }
    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
    };
  }, [selectBlock, isSelectionEnabled, getBlockSelectionStart, hasMultiSelection]);
}
//# sourceMappingURL=use-click-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-input.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


/**
 * Handles input for selections across blocks.
 */
function useInput() {
  const {
    __unstableIsFullySelected,
    getSelectedBlockClientIds,
    getSelectedBlockClientId,
    __unstableIsSelectionMergeable,
    hasMultiSelection,
    getBlockName,
    canInsertBlockType,
    getBlockRootClientId,
    getSelectionStart,
    getSelectionEnd,
    getBlockAttributes
  } = (0,use_select/* default */.A)(store_store);
  const {
    replaceBlocks,
    __unstableSplitSelection,
    removeBlocks,
    __unstableDeleteSelection,
    __unstableExpandSelection,
    __unstableMarkAutomaticChange
  } = (0,use_dispatch/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    function onBeforeInput(event) {
      // If writing flow is editable, NEVER allow the browser to alter the
      // DOM. This will cause React errors (and the DOM should only be
      // altered in a controlled fashion).
      if (node.contentEditable === 'true') {
        event.preventDefault();
      }
    }
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (!hasMultiSelection()) {
        if (event.keyCode === keycodes_build_module/* ENTER */.Fm) {
          if (event.shiftKey || __unstableIsFullySelected()) {
            return;
          }
          const clientId = getSelectedBlockClientId();
          const blockName = getBlockName(clientId);
          const selectionStart = getSelectionStart();
          const selectionEnd = getSelectionEnd();
          if (selectionStart.attributeKey === selectionEnd.attributeKey) {
            const selectedAttributeValue = getBlockAttributes(clientId)[selectionStart.attributeKey];
            const transforms = (0,build_module/* getBlockTransforms */.XD)('from').filter(({
              type
            }) => type === 'enter');
            const transformation = (0,build_module/* findTransform */.wG)(transforms, item => {
              return item.regExp.test(selectedAttributeValue);
            });
            if (transformation) {
              replaceBlocks(clientId, transformation.transform({
                content: selectedAttributeValue
              }));
              __unstableMarkAutomaticChange();
              return;
            }
          }
          if (!(0,build_module/* hasBlockSupport */.pN)(blockName, 'splitting', false) && !event.__deprecatedOnSplit) {
            return;
          }

          // Ensure template is not locked.
          if (canInsertBlockType(blockName, getBlockRootClientId(clientId))) {
            __unstableSplitSelection();
            event.preventDefault();
          }
        }
        return;
      }
      if (event.keyCode === keycodes_build_module/* ENTER */.Fm) {
        node.contentEditable = false;
        event.preventDefault();
        if (__unstableIsFullySelected()) {
          replaceBlocks(getSelectedBlockClientIds(), (0,build_module/* createBlock */.Wv)((0,build_module/* getDefaultBlockName */.K$)()));
        } else {
          __unstableSplitSelection();
        }
      } else if (event.keyCode === keycodes_build_module/* BACKSPACE */.G_ || event.keyCode === keycodes_build_module/* DELETE */.SJ) {
        node.contentEditable = false;
        event.preventDefault();
        if (__unstableIsFullySelected()) {
          removeBlocks(getSelectedBlockClientIds());
        } else if (__unstableIsSelectionMergeable()) {
          __unstableDeleteSelection(event.keyCode === keycodes_build_module/* DELETE */.SJ);
        } else {
          __unstableExpandSelection();
        }
      } else if (
      // If key.length is longer than 1, it's a control key that doesn't
      // input anything.
      event.key.length === 1 && !(event.metaKey || event.ctrlKey)) {
        node.contentEditable = false;
        if (__unstableIsSelectionMergeable()) {
          __unstableDeleteSelection(event.keyCode === keycodes_build_module/* DELETE */.SJ);
        } else {
          event.preventDefault();
          // Safari does not stop default behaviour with either
          // event.preventDefault() or node.contentEditable = false, so
          // remove the selection to stop browser manipulation.
          node.ownerDocument.defaultView.getSelection().removeAllRanges();
        }
      }
    }
    function onCompositionStart(event) {
      if (!hasMultiSelection()) {
        return;
      }
      node.contentEditable = false;
      if (__unstableIsSelectionMergeable()) {
        __unstableDeleteSelection();
      } else {
        event.preventDefault();
        // Safari does not stop default behaviour with either
        // event.preventDefault() or node.contentEditable = false, so
        // remove the selection to stop browser manipulation.
        node.ownerDocument.defaultView.getSelection().removeAllRanges();
      }
    }
    node.addEventListener('beforeinput', onBeforeInput);
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('compositionstart', onCompositionStart);
    return () => {
      node.removeEventListener('beforeinput', onBeforeInput);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('compositionstart', onCompositionStart);
    };
  }, []);
}
//# sourceMappingURL=use-input.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/document-has-text-selection.js
/**
 * Internal dependencies
 */


/**
 * Check whether the current document has selected text. This applies to ranges
 * of text in the document, and not selection inside `<input>` and `<textarea>`
 * elements.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.
 *
 * @param {Document} doc The document to check.
 *
 * @return {boolean} True if there is selection, false if not.
 */
function documentHasTextSelection(doc) {
  (0,assert_is_defined/* assertIsDefined */.e)(doc.defaultView, 'doc.defaultView');
  const selection = doc.defaultView.getSelection();
  (0,assert_is_defined/* assertIsDefined */.e)(selection, 'selection');
  const range = selection.rangeCount ? selection.getRangeAt(0) : null;
  return !!range && !range.collapsed;
}
//# sourceMappingURL=document-has-text-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/input-field-has-uncollapsed-selection.js
/**
 * Internal dependencies
 */



/**
 * Check whether the given input field or textarea contains a (uncollapsed)
 * selection of text.
 *
 * CAVEAT: Only specific text-based HTML inputs support the selection APIs
 * needed to determine whether they have a collapsed or uncollapsed selection.
 * This function defaults to returning `true` when the selection cannot be
 * inspected, such as with `<input type="time">`. The rationale is that this
 * should cause the block editor to defer to the browser's native selection
 * handling (e.g. copying and pasting), thereby reducing friction for the user.
 *
 * See: https://html.spec.whatwg.org/multipage/input.html#do-not-apply
 *
 * @param {Element} element The HTML element.
 *
 * @return {boolean} Whether the input/textareaa element has some "selection".
 */
function inputFieldHasUncollapsedSelection(element) {
  if (!isHTMLInputElement(element) && !isTextField(element)) {
    return false;
  }

  // Safari throws a type error when trying to get `selectionStart` and
  // `selectionEnd` on non-text <input> elements, so a try/catch construct is
  // necessary.
  try {
    const {
      selectionStart,
      selectionEnd
    } = /** @type {HTMLInputElement | HTMLTextAreaElement} */element;
    return (
      // `null` means the input type doesn't implement selection, thus we
      // cannot determine whether the selection is collapsed, so we
      // default to true.
      selectionStart === null ||
      // when not null, compare the two points
      selectionStart !== selectionEnd
    );
  } catch (error) {
    // This is Safari's way of saying that the input type doesn't implement
    // selection, so we default to true.
    return true;
  }
}
//# sourceMappingURL=input-field-has-uncollapsed-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/document-has-uncollapsed-selection.js
/**
 * Internal dependencies
 */



/**
 * Check whether the current document has any sort of (uncollapsed) selection.
 * This includes ranges of text across elements and any selection inside
 * textual `<input>` and `<textarea>` elements.
 *
 * @param {Document} doc The document to check.
 *
 * @return {boolean} Whether there is any recognizable text selection in the document.
 */
function documentHasUncollapsedSelection(doc) {
  return documentHasTextSelection(doc) || !!doc.activeElement && inputFieldHasUncollapsedSelection(doc.activeElement);
}
//# sourceMappingURL=document-has-uncollapsed-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/document-has-selection.js
/**
 * Internal dependencies
 */




/**
 * Check whether the current document has a selection. This includes focus in
 * input fields, textareas, and general rich-text selection.
 *
 * @param {Document} doc The document to check.
 *
 * @return {boolean} True if there is selection, false if not.
 */
function documentHasSelection(doc) {
  return !!doc.activeElement && (isHTMLInputElement(doc.activeElement) || isTextField(doc.activeElement) || documentHasTextSelection(doc));
}
//# sourceMappingURL=document-has-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/utils/use-notify-copy.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */

function useNotifyCopy() {
  const {
    getBlockName
  } = (0,use_select/* default */.A)(store_store);
  const {
    getBlockType
  } = (0,use_select/* default */.A)(build_module/* store */.M_);
  const {
    createSuccessNotice
  } = (0,use_dispatch/* default */.A)(store);
  return (0,react.useCallback)((eventType, selectedBlockClientIds) => {
    let notice = '';
    if (selectedBlockClientIds.length === 1) {
      const clientId = selectedBlockClientIds[0];
      const title = getBlockType(getBlockName(clientId))?.title;
      notice = eventType === 'copy' ? (0,i18n_build_module/* sprintf */.nv)(
      // Translators: Name of the block being copied, e.g. "Paragraph".
      (0,i18n_build_module.__)('Copied "%s" to clipboard.'), title) : (0,i18n_build_module/* sprintf */.nv)(
      // Translators: Name of the block being cut, e.g. "Paragraph".
      (0,i18n_build_module.__)('Moved "%s" to clipboard.'), title);
    } else {
      notice = eventType === 'copy' ? (0,i18n_build_module/* sprintf */.nv)(
      // Translators: %d: Number of blocks being copied.
      (0,i18n_build_module._n)('Copied %d block to clipboard.', 'Copied %d blocks to clipboard.', selectedBlockClientIds.length), selectedBlockClientIds.length) : (0,i18n_build_module/* sprintf */.nv)(
      // Translators: %d: Number of blocks being cut.
      (0,i18n_build_module._n)('Moved %d block to clipboard.', 'Moved %d blocks to clipboard.', selectedBlockClientIds.length), selectedBlockClientIds.length);
    }
    createSuccessNotice(notice, {
      type: 'snackbar'
    });
  }, []);
}
//# sourceMappingURL=use-notify-copy.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/utils.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const requiresWrapperOnCopy = Symbol('requiresWrapperOnCopy');

/**
 * Sets the clipboard data for the provided blocks, with both HTML and plain
 * text representations.
 *
 * @param {ClipboardEvent} event    Clipboard event.
 * @param {WPBlock[]}      blocks   Blocks to set as clipboard data.
 * @param {Object}         registry The registry to select from.
 */
function setClipboardBlocks(event, blocks, registry) {
  let _blocks = blocks;
  const [firstBlock] = blocks;
  if (firstBlock) {
    const firstBlockType = registry.select(build_module/* store */.M_).getBlockType(firstBlock.name);
    if (firstBlockType[requiresWrapperOnCopy]) {
      const {
        getBlockRootClientId,
        getBlockName,
        getBlockAttributes
      } = registry.select(store_store);
      const wrapperBlockClientId = getBlockRootClientId(firstBlock.clientId);
      const wrapperBlockName = getBlockName(wrapperBlockClientId);
      if (wrapperBlockName) {
        _blocks = (0,build_module/* createBlock */.Wv)(wrapperBlockName, getBlockAttributes(wrapperBlockClientId), _blocks);
      }
    }
  }
  const serialized = (0,build_module/* serialize */.lK)(_blocks);
  event.clipboardData.setData('text/plain', toPlainText(serialized));
  event.clipboardData.setData('text/html', serialized);
}

/**
 * Returns the blocks to be pasted from the clipboard event.
 *
 * @param {ClipboardEvent} event                    The clipboard event.
 * @param {boolean}        canUserUseUnfilteredHTML Whether the user can or can't post unfiltered HTML.
 * @return {Array|string} A list of blocks or a string, depending on `handlerMode`.
 */
function getPasteBlocks(event, canUserUseUnfilteredHTML) {
  const {
    plainText,
    html,
    files
  } = getPasteEventData(event);
  let blocks = [];
  if (files.length) {
    const fromTransforms = getBlockTransforms('from');
    blocks = files.reduce((accumulator, file) => {
      const transformation = findTransform(fromTransforms, transform => transform.type === 'files' && transform.isMatch([file]));
      if (transformation) {
        accumulator.push(transformation.transform([file]));
      }
      return accumulator;
    }, []).flat();
  } else {
    blocks = pasteHandler({
      HTML: html,
      plainText,
      mode: 'BLOCKS',
      canUserUseUnfilteredHTML
    });
  }
  return blocks;
}

/**
 * Given a string of HTML representing serialized blocks, returns the plain
 * text extracted after stripping the HTML of any tags and fixing line breaks.
 *
 * @param {string} html Serialized blocks.
 * @return {string} The plain-text content with any html removed.
 */
function toPlainText(html) {
  // Manually handle BR tags as line breaks prior to `stripHTML` call
  html = html.replace(/<br>/g, '\n');
  const plainText = (0,strip_html/* default */.A)(html).trim();

  // Merge any consecutive line breaks
  return plainText.replace(/\n\n+/g, '\n\n');
}
//# sourceMappingURL=utils.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/data-transfer.js
var data_transfer = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/data-transfer.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/utils/pasting.js
/**
 * WordPress dependencies
 */


/**
 * Normalizes a given string of HTML to remove the Windows-specific "Fragment"
 * comments and any preceding and trailing content.
 *
 * @param {string} html the html to be normalized
 * @return {string} the normalized html
 */
function removeWindowsFragments(html) {
  const startStr = '<!--StartFragment-->';
  const startIdx = html.indexOf(startStr);
  if (startIdx > -1) {
    html = html.substring(startIdx + startStr.length);
  } else {
    // No point looking for EndFragment
    return html;
  }
  const endStr = '<!--EndFragment-->';
  const endIdx = html.indexOf(endStr);
  if (endIdx > -1) {
    html = html.substring(0, endIdx);
  }
  return html;
}

/**
 * Removes the charset meta tag inserted by Chromium.
 * See:
 * - https://github.com/WordPress/gutenberg/issues/33585
 * - https://bugs.chromium.org/p/chromium/issues/detail?id=1264616#c4
 *
 * @param {string} html the html to be stripped of the meta tag.
 * @return {string} the cleaned html
 */
function removeCharsetMetaTag(html) {
  const metaTag = `<meta charset='utf-8'>`;
  if (html.startsWith(metaTag)) {
    return html.slice(metaTag.length);
  }
  return html;
}
function pasting_getPasteEventData({
  clipboardData
}) {
  let plainText = '';
  let html = '';

  // IE11 only supports `Text` as an argument for `getData` and will
  // otherwise throw an invalid argument error, so we try the standard
  // arguments first, then fallback to `Text` if they fail.
  try {
    plainText = clipboardData.getData('text/plain');
    html = clipboardData.getData('text/html');
  } catch (error1) {
    try {
      html = clipboardData.getData('Text');
    } catch (error2) {
      // Some browsers like UC Browser paste plain text by default and
      // don't support clipboardData at all, so allow default
      // behaviour.
      return;
    }
  }

  // Remove Windows-specific metadata appended within copied HTML text.
  html = removeWindowsFragments(html);

  // Strip meta tag.
  html = removeCharsetMetaTag(html);
  const files = (0,data_transfer/* getFilesFromDataTransfer */.$)(clipboardData);
  if (files.length && !shouldDismissPastedFiles(files, html)) {
    return {
      files
    };
  }
  return {
    html,
    plainText,
    files: []
  };
}

/**
 * Given a collection of DataTransfer files and HTML and plain text strings,
 * determine whether the files are to be dismissed in favor of the HTML.
 *
 * Certain office-type programs, like Microsoft Word or Apple Numbers,
 * will, upon copy, generate a screenshot of the content being copied and
 * attach it to the clipboard alongside the actual rich text that the user
 * sought to copy. In those cases, we should let Gutenberg handle the rich text
 * content and not the screenshot, since this allows Gutenberg to insert
 * meaningful blocks, like paragraphs, lists or even tables.
 *
 * @param {File[]} files File objects obtained from a paste event
 * @param {string} html  HTML content obtained from a paste event
 * @return {boolean}     True if the files should be dismissed
 */
function shouldDismissPastedFiles(files, html /*, plainText */) {
  // The question is only relevant when there is actual HTML content and when
  // there is exactly one image file.
  if (html && files?.length === 1 && files[0].type.indexOf('image/') === 0) {
    // A single <img> tag found in the HTML source suggests that the
    // content being pasted revolves around an image. Sometimes there are
    // other elements found, like <figure>, but we assume that the user's
    // intention is to paste the actual image file.
    const IMAGE_TAG = /<\s*img\b/gi;
    if (html.match(IMAGE_TAG)?.length !== 1) {
      return true;
    }

    // Even when there is exactly one <img> tag in the HTML payload, we
    // choose to weed out local images, i.e. those whose source starts with
    // "file://". These payloads occur in specific configurations, such as
    // when copying an entire document from Microsoft Word, that contains
    // text and exactly one image, and pasting that content using Google
    // Chrome.
    const IMG_WITH_LOCAL_SRC = /<\s*img\b[^>]*\bsrc="file:\/\//i;
    if (html.match(IMG_WITH_LOCAL_SRC)) {
      return true;
    }
  }
  return false;
}
//# sourceMappingURL=pasting.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-clipboard-handler.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function useClipboardHandler() {
  const registry = (0,use_registry/* default */.A)();
  const {
    getBlocksByClientId,
    getSelectedBlockClientIds,
    hasMultiSelection,
    getSettings,
    getBlockName,
    __unstableIsFullySelected,
    __unstableIsSelectionCollapsed,
    __unstableIsSelectionMergeable,
    __unstableGetSelectedBlocksWithPartialSelection,
    canInsertBlockType,
    getBlockRootClientId
  } = (0,use_select/* default */.A)(store_store);
  const {
    flashBlock,
    removeBlocks,
    replaceBlocks,
    __unstableDeleteSelection,
    __unstableExpandSelection,
    __unstableSplitSelection
  } = (0,use_dispatch/* default */.A)(store_store);
  const notifyCopy = useNotifyCopy();
  return (0,use_ref_effect/* default */.A)(node => {
    function handler(event) {
      if (event.defaultPrevented) {
        // This was likely already handled in rich-text/use-paste-handler.js.
        return;
      }
      const selectedBlockClientIds = getSelectedBlockClientIds();
      if (selectedBlockClientIds.length === 0) {
        return;
      }

      // Let native copy/paste behaviour take over in input fields.
      // But always handle multiple selected blocks.
      if (!hasMultiSelection()) {
        const {
          target
        } = event;
        const {
          ownerDocument
        } = target;
        // If copying, only consider actual text selection as selection.
        // Otherwise, any focus on an input field is considered.
        const hasSelection = event.type === 'copy' || event.type === 'cut' ? documentHasUncollapsedSelection(ownerDocument) : documentHasSelection(ownerDocument) && !ownerDocument.activeElement.isContentEditable;

        // Let native copy behaviour take over in input fields.
        if (hasSelection) {
          return;
        }
      }
      const {
        activeElement
      } = event.target.ownerDocument;
      if (!node.contains(activeElement)) {
        return;
      }
      const isSelectionMergeable = __unstableIsSelectionMergeable();
      const shouldHandleWholeBlocks = __unstableIsSelectionCollapsed() || __unstableIsFullySelected();
      const expandSelectionIsNeeded = !shouldHandleWholeBlocks && !isSelectionMergeable;
      if (event.type === 'copy' || event.type === 'cut') {
        event.preventDefault();
        if (selectedBlockClientIds.length === 1) {
          flashBlock(selectedBlockClientIds[0]);
        }
        // If we have a partial selection that is not mergeable, just
        // expand the selection to the whole blocks.
        if (expandSelectionIsNeeded) {
          __unstableExpandSelection();
        } else {
          notifyCopy(event.type, selectedBlockClientIds);
          let blocks;
          // Check if we have partial selection.
          if (shouldHandleWholeBlocks) {
            blocks = getBlocksByClientId(selectedBlockClientIds);
          } else {
            const [head, tail] = __unstableGetSelectedBlocksWithPartialSelection();
            const inBetweenBlocks = getBlocksByClientId(selectedBlockClientIds.slice(1, selectedBlockClientIds.length - 1));
            blocks = [head, ...inBetweenBlocks, tail];
          }
          setClipboardBlocks(event, blocks, registry);
        }
      }
      if (event.type === 'cut') {
        // We need to also check if at the start we needed to
        // expand the selection, as in this point we might have
        // programmatically fully selected the blocks above.
        if (shouldHandleWholeBlocks && !expandSelectionIsNeeded) {
          removeBlocks(selectedBlockClientIds);
        } else {
          event.target.ownerDocument.activeElement.contentEditable = false;
          __unstableDeleteSelection();
        }
      } else if (event.type === 'paste') {
        const {
          __experimentalCanUserUseUnfilteredHTML: canUserUseUnfilteredHTML
        } = getSettings();
        const isInternal = event.clipboardData.getData('rich-text') === 'true';
        if (isInternal) {
          return;
        }
        const {
          plainText,
          html,
          files
        } = pasting_getPasteEventData(event);
        const isFullySelected = __unstableIsFullySelected();
        let blocks = [];
        if (files.length) {
          const fromTransforms = (0,build_module/* getBlockTransforms */.XD)('from');
          blocks = files.reduce((accumulator, file) => {
            const transformation = (0,build_module/* findTransform */.wG)(fromTransforms, transform => transform.type === 'files' && transform.isMatch([file]));
            if (transformation) {
              accumulator.push(transformation.transform([file]));
            }
            return accumulator;
          }, []).flat();
        } else {
          blocks = (0,build_module/* pasteHandler */.Gk)({
            HTML: html,
            plainText,
            mode: isFullySelected ? 'BLOCKS' : 'AUTO',
            canUserUseUnfilteredHTML
          });
        }

        // Inline paste: let rich text handle it.
        if (typeof blocks === 'string') {
          return;
        }
        if (isFullySelected) {
          replaceBlocks(selectedBlockClientIds, blocks, blocks.length - 1, -1);
          event.preventDefault();
          return;
        }

        // If a block doesn't support splitting, let rich text paste
        // inline.
        if (!hasMultiSelection() && !(0,build_module/* hasBlockSupport */.pN)(getBlockName(selectedBlockClientIds[0]), 'splitting', false) && !event.__deprecatedOnSplit) {
          return;
        }
        const [firstSelectedClientId] = selectedBlockClientIds;
        const rootClientId = getBlockRootClientId(firstSelectedClientId);
        const newBlocks = [];
        for (const block of blocks) {
          if (canInsertBlockType(block.name, rootClientId)) {
            newBlocks.push(block);
          } else {
            // If a block cannot be inserted in a root block, try
            // converting it to that root block type and insert the
            // inner blocks.
            // Example: paragraphs cannot be inserted into a list,
            // so convert the paragraphs to a list for list items.
            const rootBlockName = getBlockName(rootClientId);
            const switchedBlocks = block.name !== rootBlockName ? (0,build_module/* switchToBlockType */.bh)(block, rootBlockName) : [block];
            if (!switchedBlocks) {
              return;
            }
            for (const switchedBlock of switchedBlocks) {
              for (const innerBlock of switchedBlock.innerBlocks) {
                newBlocks.push(innerBlock);
              }
            }
          }
        }
        __unstableSplitSelection(newBlocks);
        event.preventDefault();
      }
    }
    node.ownerDocument.addEventListener('copy', handler);
    node.ownerDocument.addEventListener('cut', handler);
    node.ownerDocument.addEventListener('paste', handler);
    return () => {
      node.ownerDocument.removeEventListener('copy', handler);
      node.ownerDocument.removeEventListener('cut', handler);
      node.ownerDocument.removeEventListener('paste', handler);
    };
  }, []);
}
//# sourceMappingURL=use-clipboard-handler.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/writing-flow/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */













function useWritingFlow() {
  const [before, ref, after] = useTabNav();
  const hasMultiSelection = (0,use_select/* default */.A)(select => select(store_store).hasMultiSelection(), []);
  return [before, (0,use_merge_refs/* default */.A)([ref, useClipboardHandler(), useInput(), useDragSelection(), useSelectionObserver(), useClickSelection(), useMultiSelection(), useSelectAll(), useArrowNav(), (0,use_ref_effect/* default */.A)(node => {
    node.tabIndex = 0;
    if (!hasMultiSelection) {
      return;
    }
    node.classList.add('has-multi-selection');
    node.setAttribute('aria-label', (0,i18n_build_module.__)('Multiple selected blocks'));
    return () => {
      node.classList.remove('has-multi-selection');
      node.removeAttribute('aria-label');
    };
  }, [hasMultiSelection])]), after];
}
function WritingFlow({
  children,
  ...props
}, forwardedRef) {
  const [before, ref, after] = useWritingFlow();
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [before, /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      ...props,
      ref: (0,use_merge_refs/* default */.A)([ref, forwardedRef]),
      className: (0,dist_clsx/* default */.A)(props.className, 'block-editor-writing-flow'),
      children: children
    }), after]
  });
}

/**
 * Handles selection and navigation across blocks. This component should be
 * wrapped around BlockList.
 *
 * @param {Object}  props          Component properties.
 * @param {Element} props.children Children to be rendered.
 */
/* harmony default export */ const writing_flow = ((0,react.forwardRef)(WritingFlow));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/iframe/get-compatibility-styles.js
let compatibilityStyles = null;

/**
 * Returns a list of stylesheets that target the editor canvas. A stylesheet is
 * considered targetting the editor a canvas if it contains the
 * `editor-styles-wrapper`, `wp-block`, or `wp-block-*` class selectors.
 *
 * Ideally, this hook should be removed in the future and styles should be added
 * explicitly as editor styles.
 */
function getCompatibilityStyles() {
  if (compatibilityStyles) {
    return compatibilityStyles;
  }

  // Only memoize the result once on load, since these stylesheets should not
  // change.
  compatibilityStyles = Array.from(document.styleSheets).reduce((accumulator, styleSheet) => {
    try {
      // May fail for external styles.
      // eslint-disable-next-line no-unused-expressions
      styleSheet.cssRules;
    } catch (e) {
      return accumulator;
    }
    const {
      ownerNode,
      cssRules
    } = styleSheet;

    // Stylesheet is added by another stylesheet. See
    // https://developer.mozilla.org/en-US/docs/Web/API/StyleSheet/ownerNode#notes.
    if (ownerNode === null) {
      return accumulator;
    }
    if (!cssRules) {
      return accumulator;
    }

    // Don't try to add the reset styles, which were removed as a dependency
    // from `edit-blocks` for the iframe since we don't need to reset admin
    // styles.
    if (ownerNode.id === 'wp-reset-editor-styles-css') {
      return accumulator;
    }

    // Don't try to add styles without ID. Styles enqueued via the WP dependency system will always have IDs.
    if (!ownerNode.id) {
      return accumulator;
    }
    function matchFromRules(_cssRules) {
      return Array.from(_cssRules).find(({
        selectorText,
        conditionText,
        cssRules: __cssRules
      }) => {
        // If the rule is conditional then it will not have selector text.
        // Recurse into child CSS ruleset to determine selector eligibility.
        if (conditionText) {
          return matchFromRules(__cssRules);
        }
        return selectorText && (selectorText.includes('.editor-styles-wrapper') || selectorText.includes('.wp-block'));
      });
    }
    if (matchFromRules(cssRules)) {
      const isInline = ownerNode.tagName === 'STYLE';
      if (isInline) {
        // If the current target is inline,
        // it could be a dependency of an existing stylesheet.
        // Look for that dependency and add it BEFORE the current target.
        const mainStylesCssId = ownerNode.id.replace('-inline-css', '-css');
        const mainStylesElement = document.getElementById(mainStylesCssId);
        if (mainStylesElement) {
          accumulator.push(mainStylesElement.cloneNode(true));
        }
      }
      accumulator.push(ownerNode.cloneNode(true));
      if (!isInline) {
        // If the current target is not inline,
        // we still look for inline styles that could be relevant for the current target.
        // If they exist, add them AFTER the current target.
        const inlineStylesCssId = ownerNode.id.replace('-css', '-inline-css');
        const inlineStylesElement = document.getElementById(inlineStylesCssId);
        if (inlineStylesElement) {
          accumulator.push(inlineStylesElement.cloneNode(true));
        }
      }
    }
    return accumulator;
  }, []);
  return compatibilityStyles;
}
//# sourceMappingURL=get-compatibility-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/iframe/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */







function bubbleEvent(event, Constructor, frame) {
  const init = {};
  for (const key in event) {
    init[key] = event[key];
  }

  // Check if the event is a MouseEvent generated within the iframe.
  // If so, adjust the coordinates to be relative to the position of
  // the iframe. This ensures that components such as Draggable
  // receive coordinates relative to the window, instead of relative
  // to the iframe. Without this, the Draggable event handler would
  // result in components "jumping" position as soon as the user
  // drags over the iframe.
  if (event instanceof frame.contentDocument.defaultView.MouseEvent) {
    const rect = frame.getBoundingClientRect();
    init.clientX += rect.left;
    init.clientY += rect.top;
  }
  const newEvent = new Constructor(event.type, init);
  if (init.defaultPrevented) {
    newEvent.preventDefault();
  }
  const cancelled = !frame.dispatchEvent(newEvent);
  if (cancelled) {
    event.preventDefault();
  }
}

/**
 * Bubbles some event types (keydown, keypress, and dragover) to parent document
 * document to ensure that the keyboard shortcuts and drag and drop work.
 *
 * Ideally, we should remove event bubbling in the future. Keyboard shortcuts
 * should be context dependent, e.g. actions on blocks like Cmd+A should not
 * work globally outside the block editor.
 *
 * @param {Document} iframeDocument Document to attach listeners to.
 */
function useBubbleEvents(iframeDocument) {
  return (0,use_ref_effect/* default */.A)(() => {
    const {
      defaultView
    } = iframeDocument;
    if (!defaultView) {
      return;
    }
    const {
      frameElement
    } = defaultView;
    const html = iframeDocument.documentElement;
    const eventTypes = ['dragover', 'mousemove'];
    const handlers = {};
    for (const name of eventTypes) {
      handlers[name] = event => {
        const prototype = Object.getPrototypeOf(event);
        const constructorName = prototype.constructor.name;
        const Constructor = window[constructorName];
        bubbleEvent(event, Constructor, frameElement);
      };
      html.addEventListener(name, handlers[name]);
    }
    return () => {
      for (const name of eventTypes) {
        html.removeEventListener(name, handlers[name]);
      }
    };
  });
}
function Iframe({
  contentRef,
  children,
  tabIndex = 0,
  scale = 1,
  frameSize = 0,
  readonly,
  forwardedRef: ref,
  title = (0,i18n_build_module.__)('Editor canvas'),
  ...props
}) {
  const {
    resolvedAssets,
    isPreviewMode
  } = (0,use_select/* default */.A)(select => {
    const {
      getSettings
    } = select(store_store);
    const settings = getSettings();
    return {
      resolvedAssets: settings.__unstableResolvedAssets,
      isPreviewMode: settings.__unstableIsPreviewMode
    };
  }, []);
  const {
    styles = '',
    scripts = ''
  } = resolvedAssets;
  const [iframeDocument, setIframeDocument] = (0,react.useState)();
  const prevContainerWidth = (0,react.useRef)();
  const [bodyClasses, setBodyClasses] = (0,react.useState)([]);
  const clearerRef = useBlockSelectionClearer();
  const [before, writingFlowRef, after] = useWritingFlow();
  const [contentResizeListener, {
    height: contentHeight
  }] = useResizeAware();
  const [containerResizeListener, {
    width: containerWidth
  }] = useResizeAware();
  const setRef = (0,use_ref_effect/* default */.A)(node => {
    node._load = () => {
      setIframeDocument(node.contentDocument);
    };
    let iFrameDocument;
    // Prevent the default browser action for files dropped outside of dropzones.
    function preventFileDropDefault(event) {
      event.preventDefault();
    }
    function onLoad() {
      const {
        contentDocument,
        ownerDocument
      } = node;
      const {
        documentElement
      } = contentDocument;
      iFrameDocument = contentDocument;
      documentElement.classList.add('block-editor-iframe__html');
      clearerRef(documentElement);

      // Ideally ALL classes that are added through get_body_class should
      // be added in the editor too, which we'll somehow have to get from
      // the server in the future (which will run the PHP filters).
      setBodyClasses(Array.from(ownerDocument.body.classList).filter(name => name.startsWith('admin-color-') || name.startsWith('post-type-') || name === 'wp-embed-responsive'));
      contentDocument.dir = ownerDocument.dir;
      for (const compatStyle of getCompatibilityStyles()) {
        if (contentDocument.getElementById(compatStyle.id)) {
          continue;
        }
        contentDocument.head.appendChild(compatStyle.cloneNode(true));
        if (!isPreviewMode) {
          // eslint-disable-next-line no-console
          console.warn(`${compatStyle.id} was added to the iframe incorrectly. Please use block.json or enqueue_block_assets to add styles to the iframe.`, compatStyle);
        }
      }
      iFrameDocument.addEventListener('dragover', preventFileDropDefault, false);
      iFrameDocument.addEventListener('drop', preventFileDropDefault, false);
    }
    node.addEventListener('load', onLoad);
    return () => {
      delete node._load;
      node.removeEventListener('load', onLoad);
      iFrameDocument?.removeEventListener('dragover', preventFileDropDefault);
      iFrameDocument?.removeEventListener('drop', preventFileDropDefault);
    };
  }, []);
  const [iframeWindowInnerHeight, setIframeWindowInnerHeight] = (0,react.useState)();
  const iframeResizeRef = (0,use_ref_effect/* default */.A)(node => {
    const nodeWindow = node.ownerDocument.defaultView;
    setIframeWindowInnerHeight(nodeWindow.innerHeight);
    const onResize = () => {
      setIframeWindowInnerHeight(nodeWindow.innerHeight);
    };
    nodeWindow.addEventListener('resize', onResize);
    return () => {
      nodeWindow.removeEventListener('resize', onResize);
    };
  }, []);
  const [windowInnerWidth, setWindowInnerWidth] = (0,react.useState)();
  const windowResizeRef = (0,use_ref_effect/* default */.A)(node => {
    const nodeWindow = node.ownerDocument.defaultView;
    setWindowInnerWidth(nodeWindow.innerWidth);
    const onResize = () => {
      setWindowInnerWidth(nodeWindow.innerWidth);
    };
    nodeWindow.addEventListener('resize', onResize);
    return () => {
      nodeWindow.removeEventListener('resize', onResize);
    };
  }, []);
  const isZoomedOut = scale !== 1;
  (0,react.useEffect)(() => {
    if (!isZoomedOut) {
      prevContainerWidth.current = containerWidth;
    }
  }, [containerWidth, isZoomedOut]);
  const disabledRef = use_disabled_useDisabled({
    isDisabled: !readonly
  });
  const bodyRef = (0,use_merge_refs/* default */.A)([useBubbleEvents(iframeDocument), contentRef, clearerRef, writingFlowRef, disabledRef,
  // Avoid resize listeners when not needed, these will trigger
  // unnecessary re-renders when animating the iframe width, or when
  // expanding preview iframes.
  isZoomedOut ? iframeResizeRef : null]);

  // Correct doctype is required to enable rendering in standards
  // mode. Also preload the styles to avoid a flash of unstyled
  // content.
  const html = `<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<script>window.frameElement._load()</script>
		<style>
			html{
				height: auto !important;
				min-height: 100%;
			}
			/* Lowest specificity to not override global styles */
			:where(body) {
				margin: 0;
				/* Default background color in case zoom out mode background
				colors the html element */
				background-color: white;
			}
		</style>
		${styles}
		${scripts}
	</head>
	<body>
		<script>document.currentScript.parentElement.remove()</script>
	</body>
</html>`;
  const [src, cleanup] = (0,react.useMemo)(() => {
    const _src = URL.createObjectURL(new window.Blob([html], {
      type: 'text/html'
    }));
    return [_src, () => URL.revokeObjectURL(_src)];
  }, [html]);
  (0,react.useEffect)(() => cleanup, [cleanup]);
  (0,react.useEffect)(() => {
    if (!iframeDocument || !isZoomedOut) {
      return;
    }
    iframeDocument.documentElement.classList.add('is-zoomed-out');
    const maxWidth = 800;
    iframeDocument.documentElement.style.setProperty('--wp-block-editor-iframe-zoom-out-scale', scale === 'default' ? Math.min(containerWidth, maxWidth) / prevContainerWidth.current : scale);
    iframeDocument.documentElement.style.setProperty('--wp-block-editor-iframe-zoom-out-frame-size', typeof frameSize === 'number' ? `${frameSize}px` : frameSize);
    iframeDocument.documentElement.style.setProperty('--wp-block-editor-iframe-zoom-out-content-height', `${contentHeight}px`);
    iframeDocument.documentElement.style.setProperty('--wp-block-editor-iframe-zoom-out-inner-height', `${iframeWindowInnerHeight}px`);
    iframeDocument.documentElement.style.setProperty('--wp-block-editor-iframe-zoom-out-container-width', `${containerWidth}px`);
    iframeDocument.documentElement.style.setProperty('--wp-block-editor-iframe-zoom-out-prev-container-width', `${prevContainerWidth.current}px`);
    return () => {
      iframeDocument.documentElement.classList.remove('is-zoomed-out');
      iframeDocument.documentElement.style.removeProperty('--wp-block-editor-iframe-zoom-out-scale');
      iframeDocument.documentElement.style.removeProperty('--wp-block-editor-iframe-zoom-out-frame-size');
      iframeDocument.documentElement.style.removeProperty('--wp-block-editor-iframe-zoom-out-content-height');
      iframeDocument.documentElement.style.removeProperty('--wp-block-editor-iframe-zoom-out-inner-height');
      iframeDocument.documentElement.style.removeProperty('--wp-block-editor-iframe-zoom-out-container-width');
      iframeDocument.documentElement.style.removeProperty('--wp-block-editor-iframe-zoom-out-prev-container-width');
    };
  }, [scale, frameSize, iframeDocument, iframeWindowInnerHeight, contentHeight, containerWidth, windowInnerWidth, isZoomedOut]);

  // Make sure to not render the before and after focusable div elements in view
  // mode. They're only needed to capture focus in edit mode.
  const shouldRenderFocusCaptureElements = tabIndex >= 0 && !isPreviewMode;
  const iframe = /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [shouldRenderFocusCaptureElements && before, /*#__PURE__*/(0,jsx_runtime.jsx)("iframe", {
      ...props,
      style: {
        border: 0,
        ...props.style,
        height: props.style?.height,
        transition: 'all .3s'
      },
      ref: (0,use_merge_refs/* default */.A)([ref, setRef]),
      tabIndex: tabIndex
      // Correct doctype is required to enable rendering in standards
      // mode. Also preload the styles to avoid a flash of unstyled
      // content.
      ,
      src: src,
      title: title,
      onKeyDown: event => {
        if (props.onKeyDown) {
          props.onKeyDown(event);
        }
        // If the event originates from inside the iframe, it means
        // it bubbled through the portal, but only with React
        // events. We need to to bubble native events as well,
        // though by doing so we also trigger another React event,
        // so we need to stop the propagation of this event to avoid
        // duplication.
        if (event.currentTarget.ownerDocument !== event.target.ownerDocument) {
          // We should only stop propagation of the React event,
          // the native event should further bubble inside the
          // iframe to the document and window.
          // Alternatively, we could consider redispatching the
          // native event in the iframe.
          const {
            stopPropagation
          } = event.nativeEvent;
          event.nativeEvent.stopPropagation = () => {};
          event.stopPropagation();
          event.nativeEvent.stopPropagation = stopPropagation;
          bubbleEvent(event, window.KeyboardEvent, event.currentTarget);
        }
      },
      children: iframeDocument && (0,react_dom.createPortal)(
      /*#__PURE__*/
      // We want to prevent React events from bubbling throught the iframe
      // we bubble these manually.
      /* eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions */
      (0,jsx_runtime.jsxs)("body", {
        ref: bodyRef,
        className: (0,dist_clsx/* default */.A)('block-editor-iframe__body', 'editor-styles-wrapper', ...bodyClasses),
        children: [contentResizeListener, /*#__PURE__*/(0,jsx_runtime.jsx)(style_provider/* default */.A, {
          document: iframeDocument,
          children: children
        })]
      }), iframeDocument.documentElement)
    }), shouldRenderFocusCaptureElements && after]
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "block-editor-iframe__container",
    ref: windowResizeRef,
    children: [containerResizeListener, /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: (0,dist_clsx/* default */.A)('block-editor-iframe__scale-container', isZoomedOut && 'is-zoomed-out'),
      style: {
        '--wp-block-editor-iframe-zoom-out-container-width': isZoomedOut && `${containerWidth}px`,
        '--wp-block-editor-iframe-zoom-out-prev-container-width': isZoomedOut && `${prevContainerWidth.current}px`
      },
      children: iframe
    })]
  });
}
function IframeIfReady(props, ref) {
  const isInitialised = (0,use_select/* default */.A)(select => select(store_store).getSettings().__internalIsInitialized, []);

  // We shouldn't render the iframe until the editor settings are initialised.
  // The initial settings are needed to get the styles for the srcDoc, which
  // cannot be changed after the iframe is mounted. srcDoc is used to to set
  // the initial iframe HTML, which is required to avoid a flash of unstyled
  // content.
  if (!isInitialised) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Iframe, {
    ...props,
    forwardedRef: ref
  });
}
/* harmony default export */ const iframe = ((0,react.forwardRef)(IframeIfReady));
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/postcss.js
var postcss = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/postcss.js");
var postcss_default = /*#__PURE__*/__webpack_require__.n(postcss);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/postcss.mjs


/* harmony default export */ const lib_postcss = ((postcss_default()));

const stringify = (postcss_default()).stringify
const fromJSON = (postcss_default()).fromJSON
const postcss_plugin = (postcss_default()).plugin
const parse = (postcss_default()).parse
const list = (postcss_default()).list

const postcss_document = (postcss_default()).document
const comment = (postcss_default()).comment
const atRule = (postcss_default()).atRule
const rule = (postcss_default()).rule
const decl = (postcss_default()).decl
const root = (postcss_default()).root

const CssSyntaxError = (postcss_default()).CssSyntaxError
const Declaration = (postcss_default()).Declaration
const postcss_Container = (postcss_default()).Container
const Processor = (postcss_default()).Processor
const Document = (postcss_default()).Document
const Comment = (postcss_default()).Comment
const postcss_Warning = (postcss_default()).Warning
const AtRule = (postcss_default()).AtRule
const Result = (postcss_default()).Result
const Input = (postcss_default()).Input
const Rule = (postcss_default()).Rule
const postcss_Root = (postcss_default()).Root
const postcss_Node = (postcss_default()).Node

// EXTERNAL MODULE: ../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/index.js
var build = __webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/index.js");
var build_default = /*#__PURE__*/__webpack_require__.n(build);
// EXTERNAL MODULE: ../../node_modules/.pnpm/postcss-urlrebase@1.4.0_postcss@8.4.32/node_modules/postcss-urlrebase/index.js
var postcss_urlrebase = __webpack_require__("../../node_modules/.pnpm/postcss-urlrebase@1.4.0_postcss@8.4.32/node_modules/postcss-urlrebase/index.js");
var postcss_urlrebase_default = /*#__PURE__*/__webpack_require__.n(postcss_urlrebase);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/index.js
/**
 * External dependencies
 */



const cacheByWrapperSelector = new Map();
function transformStyle({
  css,
  ignoredSelectors = [],
  baseURL
}, wrapperSelector = '') {
  // When there is no wrapper selector or base URL, there is no need
  // to transform the CSS. This is most cases because in the default
  // iframed editor, no wrapping is needed, and not many styles
  // provide a base URL.
  if (!wrapperSelector && !baseURL) {
    return css;
  }
  const postcssFriendlyCSS = css.replace(/:root :where\(body\)/g, 'body').replace(/:where\(body\)/g, 'body');
  try {
    return lib_postcss([wrapperSelector && build_default()(wrapperSelector, {
      ignoredSelectors: [...ignoredSelectors, wrapperSelector]
    }), baseURL && postcss_urlrebase_default()({
      rootUrl: baseURL
    })].filter(Boolean)).process(postcssFriendlyCSS, {}).css; // use sync PostCSS API
  } catch (error) {
    if (error instanceof CssSyntaxError) {
      // eslint-disable-next-line no-console
      console.warn('wp.blockEditor.transformStyles Failed to transform CSS.', error.message + '\n' + error.showSourceCode(false));
    } else {
      // eslint-disable-next-line no-console
      console.warn('wp.blockEditor.transformStyles Failed to transform CSS.', error);
    }
    return null;
  }
}

/**
 * Applies a series of CSS rule transforms to wrap selectors inside a given class and/or rewrite URLs depending on the parameters passed.
 *
 * @typedef {Object} EditorStyle
 * @property {string}        css              the CSS block(s), as a single string.
 * @property {?string}       baseURL          the base URL to be used as the reference when rewritting urls.
 * @property {?string[]}     ignoredSelectors the selectors not to wrap.
 *
 * @param    {EditorStyle[]} styles           CSS rules.
 * @param    {string}        wrapperSelector  Wrapper selector.
 * @return {Array} converted rules.
 */
const transform_styles_transformStyles = (styles, wrapperSelector = '') => {
  let cache = cacheByWrapperSelector.get(wrapperSelector);
  if (!cache) {
    cache = new WeakMap();
    cacheByWrapperSelector.set(wrapperSelector, cache);
  }
  return styles.map(style => {
    let css = cache.get(style);
    if (!css) {
      css = transformStyle(style, wrapperSelector);
      cache.set(style, css);
    }
    return css;
  });
};
/* harmony default export */ const transform_styles = (transform_styles_transformStyles);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/editor-styles/index.js
/**
 * External dependencies
 */




/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);
function useDarkThemeBodyClassName(styles, scope) {
  return (0,react.useCallback)(node => {
    if (!node) {
      return;
    }
    const {
      ownerDocument
    } = node;
    const {
      defaultView,
      body
    } = ownerDocument;
    const canvas = scope ? ownerDocument.querySelector(scope) : body;
    let backgroundColor;
    if (!canvas) {
      // The real .editor-styles-wrapper element might not exist in the
      // DOM, so calculate the background color by creating a fake
      // wrapper.
      const tempCanvas = ownerDocument.createElement('div');
      tempCanvas.classList.add('editor-styles-wrapper');
      body.appendChild(tempCanvas);
      backgroundColor = defaultView?.getComputedStyle(tempCanvas, null).getPropertyValue('background-color');
      body.removeChild(tempCanvas);
    } else {
      backgroundColor = defaultView?.getComputedStyle(canvas, null).getPropertyValue('background-color');
    }
    const colordBackgroundColor = (0,node_modules_colord/* colord */.Mj)(backgroundColor);
    // If background is transparent, it should be treated as light color.
    if (colordBackgroundColor.luminance() > 0.5 || colordBackgroundColor.alpha() === 0) {
      body.classList.remove('is-dark-theme');
    } else {
      body.classList.add('is-dark-theme');
    }
  }, [styles, scope]);
}
function editor_styles_EditorStyles({
  styles,
  scope
}) {
  const overrides = (0,use_select/* default */.A)(select => lock_unlock_unlock(select(store_store)).getStyleOverrides(), []);
  const [transformedStyles, transformedSvgs] = (0,react.useMemo)(() => {
    const _styles = Object.values(styles !== null && styles !== void 0 ? styles : []);
    for (const [id, override] of overrides) {
      const index = _styles.findIndex(({
        id: _id
      }) => id === _id);
      const overrideWithId = {
        ...override,
        id
      };
      if (index === -1) {
        _styles.push(overrideWithId);
      } else {
        _styles[index] = overrideWithId;
      }
    }
    return [transform_styles(_styles.filter(style => style?.css), scope), _styles.filter(style => style.__unstableType === 'svgs').map(style => style.assets).join('')];
  }, [styles, overrides, scope]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("style", {
      ref: useDarkThemeBodyClassName(transformedStyles, scope)
    }), transformedStyles.map((css, index) => /*#__PURE__*/(0,jsx_runtime.jsx)("style", {
      children: css
    }, index)), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* SVG */.t4, {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 0 0",
      width: "0",
      height: "0",
      role: "none",
      style: {
        visibility: 'hidden',
        position: 'absolute',
        left: '-9999px',
        overflow: 'hidden'
      },
      dangerouslySetInnerHTML: {
        __html: transformedSvgs
      }
    })]
  });
}
/* harmony default export */ const editor_styles = ((0,react.memo)(editor_styles_EditorStyles));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-preview/auto.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





// This is used to avoid rendering the block list if the sizes change.



let MemoizedBlockList;
const MAX_HEIGHT = 2000;
const EMPTY_ADDITIONAL_STYLES = [];
function ScaledBlockPreview({
  viewportWidth,
  containerWidth,
  minHeight,
  additionalStyles = EMPTY_ADDITIONAL_STYLES
}) {
  if (!viewportWidth) {
    viewportWidth = containerWidth;
  }
  const [contentResizeListener, {
    height: contentHeight
  }] = useResizeAware();
  const {
    styles
  } = (0,use_select/* default */.A)(select => {
    const settings = select(store_store).getSettings();
    return {
      styles: settings.styles
    };
  }, []);

  // Avoid scrollbars for pattern previews.
  const editorStyles = (0,react.useMemo)(() => {
    if (styles) {
      return [...styles, {
        css: 'body{height:auto;overflow:hidden;border:none;padding:0;}',
        __unstableType: 'presets'
      }, ...additionalStyles];
    }
    return styles;
  }, [styles, additionalStyles]);

  // Initialize on render instead of module top level, to avoid circular dependency issues.
  MemoizedBlockList = MemoizedBlockList || (0,react.memo)(BlockList);
  const scale = containerWidth / viewportWidth;
  const aspectRatio = contentHeight ? containerWidth / (contentHeight * scale) : 0;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(disabled, {
    className: "block-editor-block-preview__content",
    style: {
      transform: `scale(${scale})`,
      // Using width + aspect-ratio instead of height here triggers browsers' native
      // handling of scrollbar's visibility. It prevents the flickering issue seen
      // in https://github.com/WordPress/gutenberg/issues/52027.
      // See https://github.com/WordPress/gutenberg/pull/52921 for more info.
      aspectRatio,
      maxHeight: contentHeight > MAX_HEIGHT ? MAX_HEIGHT * scale : undefined,
      minHeight
    },
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(iframe, {
      contentRef: (0,use_ref_effect/* default */.A)(bodyElement => {
        const {
          ownerDocument: {
            documentElement
          }
        } = bodyElement;
        documentElement.classList.add('block-editor-block-preview__content-iframe');
        documentElement.style.position = 'absolute';
        documentElement.style.width = '100%';

        // Necessary for contentResizeListener to work.
        bodyElement.style.boxSizing = 'border-box';
        bodyElement.style.position = 'absolute';
        bodyElement.style.width = '100%';
      }, []),
      "aria-hidden": true,
      tabIndex: -1,
      style: {
        position: 'absolute',
        width: viewportWidth,
        height: contentHeight,
        pointerEvents: 'none',
        // This is a catch-all max-height for patterns.
        // See: https://github.com/WordPress/gutenberg/pull/38175.
        maxHeight: MAX_HEIGHT,
        minHeight: scale !== 0 && scale < 1 && minHeight ? minHeight / scale : minHeight
      },
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(editor_styles, {
        styles: editorStyles
      }), contentResizeListener, /*#__PURE__*/(0,jsx_runtime.jsx)(MemoizedBlockList, {
        renderAppender: false
      })]
    })
  });
}
function AutoBlockPreview(props) {
  const [containerResizeListener, {
    width: containerWidth
  }] = useResizeAware();
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      style: {
        position: 'relative',
        width: '100%',
        height: 0
      },
      children: containerResizeListener
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-block-preview__container",
      children: !!containerWidth && /*#__PURE__*/(0,jsx_runtime.jsx)(ScaledBlockPreview, {
        ...props,
        containerWidth: containerWidth
      })
    })]
  });
}
//# sourceMappingURL=auto.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-preview/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







const block_preview_EMPTY_ADDITIONAL_STYLES = [];
function BlockPreview({
  blocks,
  viewportWidth = 1200,
  minHeight,
  additionalStyles = block_preview_EMPTY_ADDITIONAL_STYLES,
  // Deprecated props:
  __experimentalMinHeight,
  __experimentalPadding
}) {
  if (__experimentalMinHeight) {
    minHeight = __experimentalMinHeight;
    (0,deprecated_build_module/* default */.A)('The __experimentalMinHeight prop', {
      since: '6.2',
      version: '6.4',
      alternative: 'minHeight'
    });
  }
  if (__experimentalPadding) {
    additionalStyles = [...additionalStyles, {
      css: `body { padding: ${__experimentalPadding}px; }`
    }];
    (0,deprecated_build_module/* default */.A)('The __experimentalPadding prop of BlockPreview', {
      since: '6.2',
      version: '6.4',
      alternative: 'additionalStyles'
    });
  }
  const originalSettings = (0,use_select/* default */.A)(select => select(store_store).getSettings(), []);
  const settings = (0,react.useMemo)(() => ({
    ...originalSettings,
    focusMode: false,
    // Disable "Spotlight mode".
    __unstableIsPreviewMode: true
  }), [originalSettings]);
  const renderedBlocks = (0,react.useMemo)(() => Array.isArray(blocks) ? blocks : [blocks], [blocks]);
  if (!blocks || blocks.length === 0) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(provider_ExperimentalBlockEditorProvider, {
    value: renderedBlocks,
    settings: settings,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(AutoBlockPreview, {
      viewportWidth: viewportWidth,
      minHeight: minHeight,
      additionalStyles: additionalStyles
    })
  });
}

/**
 * BlockPreview renders a preview of a block or array of blocks.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-preview/README.md
 *
 * @param {Object}       preview               options for how the preview should be shown
 * @param {Array|Object} preview.blocks        A block instance (object) or an array of blocks to be previewed.
 * @param {number}       preview.viewportWidth Width of the preview container in pixels. Controls at what size the blocks will be rendered inside the preview. Default: 700.
 *
 * @return {Component} The component to be rendered.
 */
/* harmony default export */ const block_preview = ((0,react.memo)(BlockPreview));

/**
 * This hook is used to lightly mark an element as a block preview wrapper
 * element. Call this hook and pass the returned props to the element to mark as
 * a block preview wrapper, automatically rendering inner blocks as children. If
 * you define a ref for the element, it is important to pass the ref to this
 * hook, which the hook in turn will pass to the component through the props it
 * returns. Optionally, you can also pass any other props through this hook, and
 * they will be merged and returned.
 *
 * @param {Object}    options        Preview options.
 * @param {WPBlock[]} options.blocks Block objects.
 * @param {Object}    options.props  Optional. Props to pass to the element. Must contain
 *                                   the ref if one is defined.
 * @param {Object}    options.layout Layout settings to be used in the preview.
 */
function useBlockPreview({
  blocks,
  props = {},
  layout
}) {
  const originalSettings = useSelect(select => select(blockEditorStore).getSettings(), []);
  const settings = useMemo(() => ({
    ...originalSettings,
    styles: undefined,
    // Clear styles included by the parent settings, as they are already output by the parent's EditorStyles.
    focusMode: false,
    // Disable "Spotlight mode".
    __unstableIsPreviewMode: true
  }), [originalSettings]);
  const disabledRef = useDisabled();
  const ref = useMergeRefs([props.ref, disabledRef]);
  const renderedBlocks = useMemo(() => Array.isArray(blocks) ? blocks : [blocks], [blocks]);
  const children = /*#__PURE__*/_jsxs(ExperimentalBlockEditorProvider, {
    value: renderedBlocks,
    settings: settings,
    children: [/*#__PURE__*/_jsx(EditorStyles, {}), /*#__PURE__*/_jsx(BlockListItems, {
      renderAppender: false,
      layout: layout
    })]
  });
  return {
    ...props,
    ref,
    className: clsx(props.className, 'block-editor-block-preview__live-content', 'components-disabled'),
    children: blocks?.length ? children : null
  };
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/preview-panel.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




function InserterPreviewPanel({
  item
}) {
  var _example$viewportWidt;
  const {
    name,
    title,
    icon,
    description,
    initialAttributes,
    example
  } = item;
  const isReusable = (0,build_module/* isReusableBlock */.tk)(item);
  const blocks = (0,react.useMemo)(() => {
    if (!example) {
      return (0,build_module/* createBlock */.Wv)(name, initialAttributes);
    }
    return (0,build_module/* getBlockFromExample */.KL)(name, {
      attributes: {
        ...example.attributes,
        ...initialAttributes
      },
      innerBlocks: example.innerBlocks
    });
  }, [name, example, initialAttributes]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "block-editor-inserter__preview-container",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-inserter__preview",
      children: isReusable || example ? /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "block-editor-inserter__preview-content",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_preview, {
          blocks: blocks,
          viewportWidth: (_example$viewportWidt = example?.viewportWidth) !== null && _example$viewportWidt !== void 0 ? _example$viewportWidt : 500,
          additionalStyles: [{
            css: 'body { padding: 24px; }'
          }]
        })
      }) : /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "block-editor-inserter__preview-content-missing",
        children: (0,i18n_build_module.__)('No preview available.')
      })
    }), !isReusable && /*#__PURE__*/(0,jsx_runtime.jsx)(block_card, {
      title: title,
      icon: icon,
      description: description
    })]
  });
}
/* harmony default export */ const preview_panel = (InserterPreviewPanel);
//# sourceMappingURL=preview-panel.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+priority-queue@3.10.0/node_modules/@wordpress/priority-queue/build-module/index.js + 1 modules
var priority_queue_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+priority-queue@3.10.0/node_modules/@wordpress/priority-queue/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-async-list/index.js
/**
 * WordPress dependencies
 */


/**
 * Returns the first items from list that are present on state.
 *
 * @param list  New array.
 * @param state Current state.
 * @return First items present iin state.
 */
function getFirstItemsPresentInState(list, state) {
  const firstItems = [];
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    if (!state.includes(item)) {
      break;
    }
    firstItems.push(item);
  }
  return firstItems;
}

/**
 * React hook returns an array which items get asynchronously appended from a source array.
 * This behavior is useful if we want to render a list of items asynchronously for performance reasons.
 *
 * @param list   Source array.
 * @param config Configuration object.
 *
 * @return Async array.
 */
function useAsyncList(list, config = {
  step: 1
}) {
  const {
    step = 1
  } = config;
  const [current, setCurrent] = (0,react.useState)([]);
  (0,react.useEffect)(() => {
    // On reset, we keep the first items that were previously rendered.
    let firstItems = getFirstItemsPresentInState(list, current);
    if (firstItems.length < step) {
      firstItems = firstItems.concat(list.slice(firstItems.length, step));
    }
    setCurrent(firstItems);
    const asyncQueue = (0,priority_queue_build_module/* createQueue */.y)();
    for (let i = firstItems.length; i < list.length; i += step) {
      asyncQueue.add({}, () => {
        (0,react_dom.flushSync)(() => {
          setCurrent(state => [...state, ...list.slice(i, i + step)]);
        });
      });
    }
    return () => asyncQueue.reset();
  }, [list]);
  return current;
}
/* harmony default export */ const use_async_list = (useAsyncList);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+keycodes@4.0.1/node_modules/@wordpress/keycodes/build-module/platform.js
var build_module_platform = __webpack_require__("../../node_modules/.pnpm/@wordpress+keycodes@4.0.1/node_modules/@wordpress/keycodes/build-module/platform.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/item.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const {
  CompositeItemV2: item_CompositeItem
} = lock_unlock_unlock(privateApis);
function InserterListboxItem({
  isFirst,
  as: Component,
  children,
  ...props
}, ref) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(item_CompositeItem, {
    ref: ref,
    role: "option"
    // Use the CompositeItem `accessibleWhenDisabled` prop
    // over Button's `isFocusable`. The latter was shown to
    // cause an issue with tab order in the inserter list.
    ,
    accessibleWhenDisabled: true,
    ...props,
    render: htmlProps => {
      const propsWithTabIndex = {
        ...htmlProps,
        tabIndex: isFirst ? 0 : htmlProps.tabIndex
      };
      if (Component) {
        return /*#__PURE__*/(0,jsx_runtime.jsx)(Component, {
          ...propsWithTabIndex,
          children: children
        });
      }
      if (typeof children === 'function') {
        return children(propsWithTabIndex);
      }
      return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        ...propsWithTabIndex,
        children: children
      });
    }
  });
}
/* harmony default export */ const inserter_listbox_item = ((0,react.forwardRef)(InserterListboxItem));
//# sourceMappingURL=item.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/draggable/index.js
var draggable = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/draggable/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/drag-handle.js
/**
 * WordPress dependencies
 */


const dragHandle = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  width: "24",
  height: "24",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M8 7h2V5H8v2zm0 6h2v-2H8v2zm0 6h2v-2H8v2zm6-14v2h2V5h-2zm0 8h2v-2h-2v2zm0 6h2v-2h-2v2z"
  })
});
/* harmony default export */ const drag_handle = (dragHandle);
//# sourceMappingURL=drag-handle.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-draggable/draggable-chip.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function BlockDraggableChip({
  count,
  icon,
  isPattern,
  fadeWhenDisabled
}) {
  const patternLabel = isPattern && (0,i18n_build_module.__)('Pattern');
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-block-draggable-chip-wrapper",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-block-draggable-chip",
      "data-testid": "block-draggable-chip",
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
        justify: "center",
        className: "block-editor-block-draggable-chip__content",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          children: icon ? /*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
            icon: icon
          }) : patternLabel || (0,i18n_build_module/* sprintf */.nv)( /* translators: %d: Number of blocks. */
          (0,i18n_build_module._n)('%d block', '%d blocks', count), count)
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
            icon: drag_handle
          })
        }), fadeWhenDisabled && /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
          className: "block-editor-block-draggable-chip__disabled",
          children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            className: "block-editor-block-draggable-chip__disabled-icon"
          })
        })]
      })
    })
  });
}
//# sourceMappingURL=draggable-chip.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter-draggable-blocks/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const InserterDraggableBlocks = ({
  isEnabled,
  blocks,
  icon,
  children,
  pattern
}) => {
  const transferData = {
    type: 'inserter',
    blocks
  };
  const blockTypeIcon = (0,use_select/* default */.A)(select => {
    const {
      getBlockType
    } = select(build_module/* store */.M_);
    return blocks.length === 1 && getBlockType(blocks[0].name)?.icon;
  }, [blocks]);
  const {
    startDragging,
    stopDragging
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  return /*#__PURE__*/(0,jsx_runtime.jsx)(draggable/* default */.A, {
    __experimentalTransferDataType: "wp-blocks",
    transferData: transferData,
    onDragStart: event => {
      startDragging();
      const parsedBlocks = pattern?.type === INSERTER_PATTERN_TYPES.user && pattern?.syncStatus !== 'unsynced' ? [(0,build_module/* createBlock */.Wv)('core/block', {
        ref: pattern.id
      })] : blocks;
      event.dataTransfer.setData('text/html', (0,build_module/* serialize */.lK)(parsedBlocks));
    },
    onDragEnd: () => {
      stopDragging();
    },
    __experimentalDragComponent: /*#__PURE__*/(0,jsx_runtime.jsx)(BlockDraggableChip, {
      count: blocks.length,
      icon: icon || !pattern && blockTypeIcon,
      isPattern: !!pattern
    }),
    children: ({
      onDraggableStart,
      onDraggableEnd
    }) => {
      return children({
        draggable: isEnabled,
        onDragStart: isEnabled ? onDraggableStart : undefined,
        onDragEnd: isEnabled ? onDraggableEnd : undefined
      });
    }
  });
};
/* harmony default export */ const inserter_draggable_blocks = (InserterDraggableBlocks);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter-list-item/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





function InserterListItem({
  className,
  isFirst,
  item,
  onSelect,
  onHover,
  isDraggable,
  ...props
}) {
  const isDragging = (0,react.useRef)(false);
  const itemIconStyle = item.icon ? {
    backgroundColor: item.icon.background,
    color: item.icon.foreground
  } : {};
  const blocks = (0,react.useMemo)(() => [(0,build_module/* createBlock */.Wv)(item.name, item.initialAttributes, (0,build_module/* createBlocksFromInnerBlocksTemplate */.to)(item.innerBlocks))], [item.name, item.initialAttributes, item.innerBlocks]);
  const isSynced = (0,build_module/* isReusableBlock */.tk)(item) && item.syncStatus !== 'unsynced' || (0,build_module/* isTemplatePart */.gc)(item);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inserter_draggable_blocks, {
    isEnabled: isDraggable && !item.isDisabled,
    blocks: blocks,
    icon: item.icon,
    children: ({
      draggable,
      onDragStart,
      onDragEnd
    }) => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: (0,dist_clsx/* default */.A)('block-editor-block-types-list__list-item', {
        'is-synced': isSynced
      }),
      draggable: draggable,
      onDragStart: event => {
        isDragging.current = true;
        if (onDragStart) {
          onHover(null);
          onDragStart(event);
        }
      },
      onDragEnd: event => {
        isDragging.current = false;
        if (onDragEnd) {
          onDragEnd(event);
        }
      },
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(inserter_listbox_item, {
        isFirst: isFirst,
        className: (0,dist_clsx/* default */.A)('block-editor-block-types-list__item', className),
        disabled: item.isDisabled,
        onClick: event => {
          event.preventDefault();
          onSelect(item, (0,build_module_platform/* isAppleOS */.H)() ? event.metaKey : event.ctrlKey);
          onHover(null);
        },
        onKeyDown: event => {
          const {
            keyCode
          } = event;
          if (keyCode === keycodes_build_module/* ENTER */.Fm) {
            event.preventDefault();
            onSelect(item, (0,build_module_platform/* isAppleOS */.H)() ? event.metaKey : event.ctrlKey);
            onHover(null);
          }
        },
        onMouseEnter: () => {
          if (isDragging.current) {
            return;
          }
          onHover(item);
        },
        onMouseLeave: () => onHover(null),
        ...props,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          className: "block-editor-block-types-list__item-icon",
          style: itemIconStyle,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
            icon: item.icon,
            showColors: true
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
          className: "block-editor-block-types-list__item-title",
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(truncate_component, {
            numberOfLines: 3,
            children: item.title
          })
        })]
      })
    })
  });
}
/* harmony default export */ const inserter_list_item = ((0,react.memo)(InserterListItem));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/group.js
/**
 * WordPress dependencies
 */




function InserterListboxGroup(props, ref) {
  const [shouldSpeak, setShouldSpeak] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    if (shouldSpeak) {
      (0,a11y_build_module/* speak */.L)((0,i18n_build_module.__)('Use left and right arrow keys to move through blocks'));
    }
  }, [shouldSpeak]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ref: ref,
    role: "listbox",
    "aria-orientation": "horizontal",
    onFocus: () => {
      setShouldSpeak(true);
    },
    onBlur: event => {
      const focusingOutsideGroup = !event.currentTarget.contains(event.relatedTarget);
      if (focusingOutsideGroup) {
        setShouldSpeak(false);
      }
    },
    ...props
  });
}
/* harmony default export */ const group = ((0,react.forwardRef)(InserterListboxGroup));
//# sourceMappingURL=group.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/row.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const {
  CompositeGroupV2: row_CompositeGroup
} = lock_unlock_unlock(privateApis);
function InserterListboxRow(props, ref) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(row_CompositeGroup, {
    role: "presentation",
    ref: ref,
    ...props
  });
}
/* harmony default export */ const inserter_listbox_row = ((0,react.forwardRef)(InserterListboxRow));
//# sourceMappingURL=row.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-types-list/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function chunk(array, size) {
  const chunks = [];
  for (let i = 0, j = array.length; i < j; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
function BlockTypesList({
  items = [],
  onSelect,
  onHover = () => {},
  children,
  label,
  isDraggable = true
}) {
  const className = 'block-editor-block-types-list';
  const listId = (0,use_instance_id/* default */.A)(BlockTypesList, className);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(group, {
    className: className,
    "aria-label": label,
    children: [chunk(items, 3).map((row, i) => /*#__PURE__*/(0,jsx_runtime.jsx)(inserter_listbox_row, {
      children: row.map((item, j) => /*#__PURE__*/(0,jsx_runtime.jsx)(inserter_list_item, {
        item: item,
        className: (0,build_module/* getBlockMenuDefaultClassName */.HK)(item.id),
        onSelect: onSelect,
        onHover: onHover,
        isDraggable: isDraggable && !item.isDisabled,
        isFirst: i === 0 && j === 0,
        rowId: `${listId}-${i}`
      }, item.id))
    }, i)), children]
  });
}
/* harmony default export */ const block_types_list = (BlockTypesList);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/panel.js
/**
 * WordPress dependencies
 */




function InserterPanel({
  title,
  icon,
  children
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "block-editor-inserter__panel-header",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h2", {
        className: "block-editor-inserter__panel-title",
        children: title
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(components_build_module_icon/* default */.A, {
        icon: icon
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-inserter__panel-content",
      children: children
    })]
  });
}
/* harmony default export */ const panel = (InserterPanel);
//# sourceMappingURL=panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-block-types-state.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/**
 * Retrieves the block types inserter state.
 *
 * @param {string=}  rootClientId Insertion's root client ID.
 * @param {Function} onInsert     function called when inserter a list of blocks.
 * @param {boolean}  isQuick
 * @return {Array} Returns the block types state. (block types, categories, collections, onSelect handler)
 */
const useBlockTypesState = (rootClientId, onInsert, isQuick) => {
  const options = (0,react.useMemo)(() => ({
    [withRootClientIdOptionKey]: !isQuick
  }), [isQuick]);
  const [items] = (0,use_select/* default */.A)(select => [select(store_store).getInserterItems(rootClientId, options)], [rootClientId, options]);
  const [categories, collections] = (0,use_select/* default */.A)(select => {
    const {
      getCategories,
      getCollections
    } = select(build_module/* store */.M_);
    return [getCategories(), getCollections()];
  }, []);
  const onSelectItem = (0,react.useCallback)(({
    name,
    initialAttributes,
    innerBlocks,
    syncStatus,
    content,
    rootClientId: _rootClientId
  }, shouldFocusBlock) => {
    const insertedBlock = syncStatus === 'unsynced' ? (0,build_module/* parse */.qg)(content, {
      __unstableSkipMigrationLogs: true
    }) : (0,build_module/* createBlock */.Wv)(name, initialAttributes, (0,build_module/* createBlocksFromInnerBlocksTemplate */.to)(innerBlocks));
    onInsert(insertedBlock, undefined, shouldFocusBlock, _rootClientId);
  }, [onInsert]);
  return [items, categories, collections, onSelectItem];
};
/* harmony default export */ const use_block_types_state = (useBlockTypesState);
//# sourceMappingURL=use-block-types-state.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






const {
  CompositeV2: inserter_listbox_Composite,
  useCompositeStoreV2: inserter_listbox_useCompositeStore
} = lock_unlock_unlock(privateApis);
function InserterListbox({
  children
}) {
  const store = inserter_listbox_useCompositeStore({
    focusShift: true,
    focusWrap: 'horizontal'
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inserter_listbox_Composite, {
    store: store,
    render: /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {}),
    children: children
  });
}
/* harmony default export */ const inserter_listbox = (InserterListbox);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/no-results.js
/**
 * WordPress dependencies
 */




function InserterNoResults() {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "block-editor-inserter__no-results",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
      className: "block-editor-inserter__no-results-icon",
      icon: block_default
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
      children: (0,i18n_build_module.__)('No results found.')
    })]
  });
}
/* harmony default export */ const no_results = (InserterNoResults);
//# sourceMappingURL=no-results.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-types-tab.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */









const getBlockNamespace = item => item.name.split('/')[0];
const MAX_SUGGESTED_ITEMS = 6;

/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation and rerendering the component.
 *
 * @type {Array}
 */
const block_types_tab_EMPTY_ARRAY = [];
function BlockTypesTabPanel({
  items,
  collections,
  categories,
  onSelectItem,
  onHover,
  showMostUsedBlocks,
  className
}) {
  const suggestedItems = (0,react.useMemo)(() => {
    return orderBy(items, 'frecency', 'desc').slice(0, MAX_SUGGESTED_ITEMS);
  }, [items]);
  const uncategorizedItems = (0,react.useMemo)(() => {
    return items.filter(item => !item.category);
  }, [items]);
  const itemsPerCollection = (0,react.useMemo)(() => {
    // Create a new Object to avoid mutating collection.
    const result = {
      ...collections
    };
    Object.keys(collections).forEach(namespace => {
      result[namespace] = items.filter(item => getBlockNamespace(item) === namespace);
      if (result[namespace].length === 0) {
        delete result[namespace];
      }
    });
    return result;
  }, [items, collections]);

  // Hide block preview on unmount.
  (0,react.useEffect)(() => () => onHover(null), []);

  /**
   * The inserter contains a big number of blocks and opening it is a costful operation.
   * The rendering is the most costful part of it, in order to improve the responsiveness
   * of the "opening" action, these lazy lists allow us to render the inserter category per category,
   * once all the categories are rendered, we start rendering the collections and the uncategorized block types.
   */
  const currentlyRenderedCategories = use_async_list(categories);
  const didRenderAllCategories = categories.length === currentlyRenderedCategories.length;

  // Async List requires an array.
  const collectionEntries = (0,react.useMemo)(() => {
    return Object.entries(collections);
  }, [collections]);
  const currentlyRenderedCollections = use_async_list(didRenderAllCategories ? collectionEntries : block_types_tab_EMPTY_ARRAY);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: className,
    children: [showMostUsedBlocks &&
    // Only show the most used blocks if the total amount of block
    // is larger than 1 row, otherwise it is not so useful.
    items.length > 3 && !!suggestedItems.length && /*#__PURE__*/(0,jsx_runtime.jsx)(panel, {
      title: (0,i18n_build_module._x)('Most used', 'blocks'),
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_types_list, {
        items: suggestedItems,
        onSelect: onSelectItem,
        onHover: onHover,
        label: (0,i18n_build_module._x)('Most used', 'blocks')
      })
    }), currentlyRenderedCategories.map(category => {
      const categoryItems = items.filter(item => item.category === category.slug);
      if (!categoryItems || !categoryItems.length) {
        return null;
      }
      return /*#__PURE__*/(0,jsx_runtime.jsx)(panel, {
        title: category.title,
        icon: category.icon,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_types_list, {
          items: categoryItems,
          onSelect: onSelectItem,
          onHover: onHover,
          label: category.title
        })
      }, category.slug);
    }), didRenderAllCategories && uncategorizedItems.length > 0 && /*#__PURE__*/(0,jsx_runtime.jsx)(panel, {
      className: "block-editor-inserter__uncategorized-blocks-panel",
      title: (0,i18n_build_module.__)('Uncategorized'),
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_types_list, {
        items: uncategorizedItems,
        onSelect: onSelectItem,
        onHover: onHover,
        label: (0,i18n_build_module.__)('Uncategorized')
      })
    }), currentlyRenderedCollections.map(([namespace, collection]) => {
      const collectionItems = itemsPerCollection[namespace];
      if (!collectionItems || !collectionItems.length) {
        return null;
      }
      return /*#__PURE__*/(0,jsx_runtime.jsx)(panel, {
        title: collection.title,
        icon: collection.icon,
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_types_list, {
          items: collectionItems,
          onSelect: onSelectItem,
          onHover: onHover,
          label: collection.title
        })
      }, namespace);
    })]
  });
}
function BlockTypesTab({
  rootClientId,
  onInsert,
  onHover,
  showMostUsedBlocks
}, ref) {
  const [items, categories, collections, onSelectItem] = use_block_types_state(rootClientId, onInsert);
  if (!items.length) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(no_results, {});
  }
  const itemsForCurrentRoot = [];
  const itemsRemaining = [];
  for (const item of items) {
    // Skip reusable blocks, they moved to the patterns tab.
    if (item.category === 'reusable') {
      continue;
    }
    if (rootClientId && item.rootClientId === rootClientId) {
      itemsForCurrentRoot.push(item);
    } else {
      itemsRemaining.push(item);
    }
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inserter_listbox, {
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      ref: ref,
      children: [!!itemsForCurrentRoot.length && /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(BlockTypesTabPanel, {
          items: itemsForCurrentRoot,
          categories: categories,
          collections: collections,
          onSelectItem: onSelectItem,
          onHover: onHover,
          showMostUsedBlocks: showMostUsedBlocks,
          className: "block-editor-inserter__insertable-blocks-at-selection"
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(BlockTypesTabPanel, {
        items: itemsRemaining,
        categories: categories,
        collections: collections,
        onSelectItem: onSelectItem,
        onHover: onHover,
        showMostUsedBlocks: showMostUsedBlocks,
        className: "block-editor-inserter__all-blocks"
      })]
    })
  });
}
/* harmony default export */ const block_types_tab = ((0,react.forwardRef)(BlockTypesTab));
//# sourceMappingURL=block-types-tab.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/pattern-explorer-sidebar.js
/**
 * WordPress dependencies
 */




function PatternCategoriesList({
  selectedCategory,
  patternCategories,
  onClickCategory
}) {
  const baseClassName = 'block-editor-block-patterns-explorer__sidebar';
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: `${baseClassName}__categories-list`,
    children: patternCategories.map(({
      name,
      label
    }) => {
      return /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        label: label,
        className: `${baseClassName}__categories-list__item`,
        isPressed: selectedCategory === name,
        onClick: () => {
          onClickCategory(name);
        },
        children: label
      }, name);
    })
  });
}
function PatternsExplorerSearch({
  searchValue,
  setSearchValue
}) {
  const baseClassName = 'block-editor-block-patterns-explorer__search';
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: baseClassName,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(search_control, {
      __nextHasNoMarginBottom: true,
      onChange: setSearchValue,
      value: searchValue,
      label: (0,i18n_build_module.__)('Search for patterns'),
      placeholder: (0,i18n_build_module.__)('Search')
    })
  });
}
function PatternExplorerSidebar({
  selectedCategory,
  patternCategories,
  onClickCategory,
  searchValue,
  setSearchValue
}) {
  const baseClassName = 'block-editor-block-patterns-explorer__sidebar';
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: baseClassName,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(PatternsExplorerSearch, {
      searchValue: searchValue,
      setSearchValue: setSearchValue
    }), !searchValue && /*#__PURE__*/(0,jsx_runtime.jsx)(PatternCategoriesList, {
      selectedCategory: selectedCategory,
      patternCategories: patternCategories,
      onClickCategory: onClickCategory
    })]
  });
}
/* harmony default export */ const pattern_explorer_sidebar = (PatternExplorerSidebar);
//# sourceMappingURL=pattern-explorer-sidebar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-patterns-paging/index.js
/**
 * WordPress dependencies
 */




function Pagination({
  currentPage,
  numPages,
  changePage,
  totalItems
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
    className: "block-editor-patterns__grid-pagination-wrapper",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(text_component/* default */.A, {
      variant: "muted",
      children:
      // translators: %s: Total number of patterns.
      (0,i18n_build_module/* sprintf */.nv)(
      // translators: %s: Total number of patterns.
      (0,i18n_build_module._n)('%s item', '%s items', totalItems), totalItems)
    }), numPages > 1 && /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
      expanded: false,
      spacing: 3,
      justify: "flex-start",
      className: "block-editor-patterns__grid-pagination",
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
        expanded: false,
        spacing: 1,
        className: "block-editor-patterns__grid-pagination-previous",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          variant: "tertiary",
          onClick: () => changePage(1),
          disabled: currentPage === 1,
          "aria-label": (0,i18n_build_module.__)('First page'),
          __experimentalIsFocusable: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            children: "\xAB"
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          variant: "tertiary",
          onClick: () => changePage(currentPage - 1),
          disabled: currentPage === 1,
          "aria-label": (0,i18n_build_module.__)('Previous page'),
          __experimentalIsFocusable: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            children: "\u2039"
          })
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(text_component/* default */.A, {
        variant: "muted",
        children: (0,i18n_build_module/* sprintf */.nv)(
        // translators: %1$s: Current page number, %2$s: Total number of pages.
        (0,i18n_build_module._x)('%1$s of %2$s', 'paging'), currentPage, numPages)
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
        expanded: false,
        spacing: 1,
        className: "block-editor-patterns__grid-pagination-next",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          variant: "tertiary",
          onClick: () => changePage(currentPage + 1),
          disabled: currentPage === numPages,
          "aria-label": (0,i18n_build_module.__)('Next page'),
          __experimentalIsFocusable: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            children: "\u203A"
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          variant: "tertiary",
          onClick: () => changePage(numPages),
          disabled: currentPage === numPages,
          "aria-label": (0,i18n_build_module.__)('Last page'),
          size: "default",
          __experimentalIsFocusable: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            children: "\xBB"
          })
        })]
      })]
    })]
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-patterns-list/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */








const {
  CompositeV2: block_patterns_list_Composite,
  CompositeItemV2: block_patterns_list_CompositeItem,
  useCompositeStoreV2: block_patterns_list_useCompositeStore
} = lock_unlock_unlock(privateApis);
const block_patterns_list_WithToolTip = ({
  showTooltip,
  title,
  children
}) => {
  if (showTooltip) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
      text: title,
      children: children
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: children
  });
};
function BlockPattern({
  id,
  isDraggable,
  pattern,
  onClick,
  onHover,
  showTitle = true,
  showTooltip,
  category
}) {
  const [isDragging, setIsDragging] = (0,react.useState)(false);
  const {
    blocks,
    viewportWidth
  } = pattern;
  const instanceId = (0,use_instance_id/* default */.A)(BlockPattern);
  const descriptionId = `block-editor-block-patterns-list__item-description-${instanceId}`;

  // When we have a selected category and the pattern is draggable, we need to update the
  // pattern's categories in metadata to only contain the selected category, and pass this to
  // InserterDraggableBlocks component. We do that because we use this information for pattern
  // shuffling and it makes more sense to show only the ones from the initially selected category during insertion.
  const patternBlocks = (0,react.useMemo)(() => {
    if (!category || !isDraggable) {
      return blocks;
    }
    return (blocks !== null && blocks !== void 0 ? blocks : []).map(block => {
      const clonedBlock = (0,build_module/* cloneBlock */.JB)(block);
      if (clonedBlock.attributes.metadata?.categories?.includes(category)) {
        clonedBlock.attributes.metadata.categories = [category];
      }
      return clonedBlock;
    });
  }, [blocks, isDraggable, category]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inserter_draggable_blocks, {
    isEnabled: isDraggable,
    blocks: patternBlocks,
    pattern: pattern,
    children: ({
      draggable,
      onDragStart,
      onDragEnd
    }) => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-block-patterns-list__list-item",
      draggable: draggable,
      onDragStart: event => {
        setIsDragging(true);
        if (onDragStart) {
          onHover?.(null);
          onDragStart(event);
        }
      },
      onDragEnd: event => {
        setIsDragging(false);
        if (onDragEnd) {
          onDragEnd(event);
        }
      },
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_patterns_list_WithToolTip, {
        showTooltip: showTooltip && !pattern.type !== INSERTER_PATTERN_TYPES.user,
        title: pattern.title,
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(block_patterns_list_CompositeItem, {
          render: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
            role: "option",
            "aria-label": pattern.title,
            "aria-describedby": pattern.description ? descriptionId : undefined,
            className: (0,dist_clsx/* default */.A)('block-editor-block-patterns-list__item', {
              'block-editor-block-patterns-list__list-item-synced': pattern.type === INSERTER_PATTERN_TYPES.user && !pattern.syncStatus
            })
          }),
          id: id,
          onClick: () => {
            onClick(pattern, blocks);
            onHover?.(null);
          },
          onMouseEnter: () => {
            if (isDragging) {
              return;
            }
            onHover?.(pattern);
          },
          onMouseLeave: () => onHover?.(null),
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_preview, {
            blocks: blocks,
            viewportWidth: viewportWidth
          }), showTitle && /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
            className: "block-editor-patterns__pattern-details",
            spacing: 2,
            children: [pattern.type === INSERTER_PATTERN_TYPES.user && !pattern.syncStatus && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
              className: "block-editor-patterns__pattern-icon-wrapper",
              children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
                className: "block-editor-patterns__pattern-icon",
                icon: library_symbol
              })
            }), (!showTooltip || pattern.type === INSERTER_PATTERN_TYPES.user) && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
              className: "block-editor-block-patterns-list__item-title",
              children: pattern.title
            })]
          }), !!pattern.description && /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
            id: descriptionId,
            children: pattern.description
          })]
        })
      })
    })
  });
}
function BlockPatternPlaceholder() {
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-block-patterns-list__item is-placeholder"
  });
}
function BlockPatternsList({
  isDraggable,
  blockPatterns,
  shownPatterns,
  onHover,
  onClickPattern,
  orientation,
  label = (0,i18n_build_module.__)('Block patterns'),
  category,
  showTitle = true,
  showTitlesAsTooltip,
  pagingProps
}, ref) {
  const compositeStore = block_patterns_list_useCompositeStore({
    orientation
  });
  const {
    setActiveId
  } = compositeStore;
  (0,react.useEffect)(() => {
    // We reset the active composite item whenever the
    // available patterns change, to make sure that
    // focus is put back to the start.
    setActiveId(undefined);
  }, [setActiveId, shownPatterns, blockPatterns]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(block_patterns_list_Composite, {
    store: compositeStore,
    role: "listbox",
    className: "block-editor-block-patterns-list",
    "aria-label": label,
    ref: ref,
    children: [blockPatterns.map(pattern => {
      const isShown = shownPatterns.includes(pattern);
      return isShown ? /*#__PURE__*/(0,jsx_runtime.jsx)(BlockPattern, {
        id: pattern.name,
        pattern: pattern,
        onClick: onClickPattern,
        onHover: onHover,
        isDraggable: isDraggable,
        showTitle: showTitle,
        showTooltip: showTitlesAsTooltip,
        category: category
      }, pattern.name) : /*#__PURE__*/(0,jsx_runtime.jsx)(BlockPatternPlaceholder, {}, pattern.name);
    }), pagingProps && /*#__PURE__*/(0,jsx_runtime.jsx)(Pagination, {
      ...pagingProps
    })]
  });
}
/* harmony default export */ const block_patterns_list = ((0,react.forwardRef)(BlockPatternsList));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-insertion-point.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


function getIndex({
  destinationRootClientId,
  destinationIndex,
  rootClientId,
  registry
}) {
  if (rootClientId === destinationRootClientId) {
    return destinationIndex;
  }
  const parents = ['', ...registry.select(store_store).getBlockParents(destinationRootClientId), destinationRootClientId];
  const parentIndex = parents.indexOf(rootClientId);
  if (parentIndex !== -1) {
    return registry.select(store_store).getBlockIndex(parents[parentIndex + 1]) + 1;
  }
  return registry.select(store_store).getBlockOrder(rootClientId).length;
}

/**
 * @typedef WPInserterConfig
 *
 * @property {string=}   rootClientId   If set, insertion will be into the
 *                                      block with this ID.
 * @property {number=}   insertionIndex If set, insertion will be into this
 *                                      explicit position.
 * @property {string=}   clientId       If set, insertion will be after the
 *                                      block with this ID.
 * @property {boolean=}  isAppender     Whether the inserter is an appender
 *                                      or not.
 * @property {Function=} onSelect       Called after insertion.
 */

/**
 * Returns the insertion point state given the inserter config.
 *
 * @param {WPInserterConfig} config Inserter Config.
 * @return {Array} Insertion Point State (rootClientID, onInsertBlocks and onToggle).
 */
function useInsertionPoint({
  rootClientId = '',
  insertionIndex,
  clientId,
  isAppender,
  onSelect,
  shouldFocusBlock = true,
  selectBlockOnInsert = true
}) {
  const registry = (0,use_registry/* default */.A)();
  const {
    getSelectedBlock
  } = (0,use_select/* default */.A)(store_store);
  const {
    destinationRootClientId,
    destinationIndex
  } = (0,use_select/* default */.A)(select => {
    const {
      getSelectedBlockClientId,
      getBlockRootClientId,
      getBlockIndex,
      getBlockOrder
    } = select(store_store);
    const selectedBlockClientId = getSelectedBlockClientId();
    let _destinationRootClientId = rootClientId;
    let _destinationIndex;
    if (insertionIndex !== undefined) {
      // Insert into a specific index.
      _destinationIndex = insertionIndex;
    } else if (clientId) {
      // Insert after a specific client ID.
      _destinationIndex = getBlockIndex(clientId);
    } else if (!isAppender && selectedBlockClientId) {
      _destinationRootClientId = getBlockRootClientId(selectedBlockClientId);
      _destinationIndex = getBlockIndex(selectedBlockClientId) + 1;
    } else {
      // Insert at the end of the list.
      _destinationIndex = getBlockOrder(_destinationRootClientId).length;
    }
    return {
      destinationRootClientId: _destinationRootClientId,
      destinationIndex: _destinationIndex
    };
  }, [rootClientId, insertionIndex, clientId, isAppender]);
  const {
    replaceBlocks,
    insertBlocks,
    showInsertionPoint,
    hideInsertionPoint,
    setLastFocus
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  const onInsertBlocks = (0,react.useCallback)((blocks, meta, shouldForceFocusBlock = false, _rootClientId) => {
    // When we are trying to move focus or select a new block on insert, we also
    // need to clear the last focus to avoid the focus being set to the wrong block
    // when tabbing back into the canvas if the block was added from outside the
    // editor canvas.
    if (shouldForceFocusBlock || shouldFocusBlock || selectBlockOnInsert) {
      setLastFocus(null);
    }
    const selectedBlock = getSelectedBlock();
    if (!isAppender && selectedBlock && (0,build_module/* isUnmodifiedDefaultBlock */.Xw)(selectedBlock)) {
      replaceBlocks(selectedBlock.clientId, blocks, null, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    } else {
      insertBlocks(blocks, isAppender || _rootClientId === undefined ? destinationIndex : getIndex({
        destinationRootClientId,
        destinationIndex,
        rootClientId: _rootClientId,
        registry
      }), isAppender || _rootClientId === undefined ? destinationRootClientId : _rootClientId, selectBlockOnInsert, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    }
    const blockLength = Array.isArray(blocks) ? blocks.length : 1;
    const message = (0,i18n_build_module/* sprintf */.nv)(
    // translators: %d: the name of the block that has been added
    (0,i18n_build_module._n)('%d block added.', '%d blocks added.', blockLength), blockLength);
    (0,a11y_build_module/* speak */.L)(message);
    if (onSelect) {
      onSelect(blocks);
    }
  }, [isAppender, getSelectedBlock, replaceBlocks, insertBlocks, destinationRootClientId, destinationIndex, onSelect, shouldFocusBlock, selectBlockOnInsert]);
  const onToggleInsertionPoint = (0,react.useCallback)(item => {
    if (item?.hasOwnProperty('rootClientId')) {
      showInsertionPoint(item.rootClientId, getIndex({
        destinationRootClientId,
        destinationIndex,
        rootClientId: item.rootClientId,
        registry
      }));
    } else {
      hideInsertionPoint();
    }
  }, [showInsertionPoint, hideInsertionPoint, destinationRootClientId, destinationIndex]);
  return [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint];
}
/* harmony default export */ const use_insertion_point = (useInsertionPoint);
//# sourceMappingURL=use-insertion-point.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-patterns-state.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



/**
 * Retrieves the block patterns inserter state.
 *
 * @param {Function} onInsert         function called when inserter a list of blocks.
 * @param {string=}  rootClientId     Insertion's root client ID.
 *
 * @param {string}   selectedCategory The selected pattern category.
 * @return {Array} Returns the patterns state. (patterns, categories, onSelect handler)
 */
const usePatternsState = (onInsert, rootClientId, selectedCategory) => {
  const {
    patternCategories,
    patterns,
    userPatternCategories
  } = (0,use_select/* default */.A)(select => {
    const {
      __experimentalGetAllowedPatterns,
      getSettings
    } = select(store_store);
    const {
      __experimentalUserPatternCategories,
      __experimentalBlockPatternCategories
    } = getSettings();
    return {
      patterns: __experimentalGetAllowedPatterns(rootClientId),
      userPatternCategories: __experimentalUserPatternCategories,
      patternCategories: __experimentalBlockPatternCategories
    };
  }, [rootClientId]);
  const allCategories = (0,react.useMemo)(() => {
    const categories = [...patternCategories];
    userPatternCategories?.forEach(userCategory => {
      if (!categories.find(existingCategory => existingCategory.name === userCategory.name)) {
        categories.push(userCategory);
      }
    });
    return categories;
  }, [patternCategories, userPatternCategories]);
  const {
    createSuccessNotice
  } = (0,use_dispatch/* default */.A)(store);
  const onClickPattern = (0,react.useCallback)((pattern, blocks) => {
    const patternBlocks = pattern.type === INSERTER_PATTERN_TYPES.user && pattern.syncStatus !== 'unsynced' ? [(0,build_module/* createBlock */.Wv)('core/block', {
      ref: pattern.id
    })] : blocks;
    onInsert((patternBlocks !== null && patternBlocks !== void 0 ? patternBlocks : []).map(block => {
      const clonedBlock = (0,build_module/* cloneBlock */.JB)(block);
      if (clonedBlock.attributes.metadata?.categories?.includes(selectedCategory)) {
        clonedBlock.attributes.metadata.categories = [selectedCategory];
      }
      return clonedBlock;
    }), pattern.name);
    createSuccessNotice((0,i18n_build_module/* sprintf */.nv)( /* translators: %s: block pattern title. */
    (0,i18n_build_module.__)('Block pattern "%s" inserted.'), pattern.title), {
      type: 'snackbar',
      id: 'block-pattern-inserted-notice'
    });
  }, [createSuccessNotice, onInsert, selectedCategory]);
  return [patterns, allCategories, onClickPattern];
};
/* harmony default export */ const use_patterns_state = (usePatternsState);
//# sourceMappingURL=use-patterns-state.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/remove-accents@0.5.0/node_modules/remove-accents/index.js
var remove_accents = __webpack_require__("../../node_modules/.pnpm/remove-accents@0.5.0/node_modules/remove-accents/index.js");
var remove_accents_default = /*#__PURE__*/__webpack_require__.n(remove_accents);
// EXTERNAL MODULE: ../../node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist.es2015/index.js + 1 modules
var no_case_dist_es2015 = __webpack_require__("../../node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist.es2015/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/search-items.js
/**
 * External dependencies
 */



// Default search helpers.
const defaultGetName = item => item.name || '';
const defaultGetTitle = item => item.title;
const defaultGetDescription = item => item.description || '';
const defaultGetKeywords = item => item.keywords || [];
const defaultGetCategory = item => item.category;
const defaultGetCollection = () => null;

// Normalization regexes
const splitRegexp = [/([\p{Ll}\p{Lo}\p{N}])([\p{Lu}\p{Lt}])/gu,
// One lowercase or digit, followed by one uppercase.
/([\p{Lu}\p{Lt}])([\p{Lu}\p{Lt}][\p{Ll}\p{Lo}])/gu // One uppercase followed by one uppercase and one lowercase.
];
const stripRegexp = /(\p{C}|\p{P}|\p{S})+/giu; // Anything that's not a punctuation, symbol or control/format character.

// Normalization cache
const extractedWords = new Map();
const normalizedStrings = new Map();

/**
 * Extracts words from an input string.
 *
 * @param {string} input The input string.
 *
 * @return {Array} Words, extracted from the input string.
 */
function extractWords(input = '') {
  if (extractedWords.has(input)) {
    return extractedWords.get(input);
  }
  const result = (0,no_case_dist_es2015/* noCase */.W)(input, {
    splitRegexp,
    stripRegexp
  }).split(' ').filter(Boolean);
  extractedWords.set(input, result);
  return result;
}

/**
 * Sanitizes the search input string.
 *
 * @param {string} input The search input to normalize.
 *
 * @return {string} The normalized search input.
 */
function normalizeString(input = '') {
  if (normalizedStrings.has(input)) {
    return normalizedStrings.get(input);
  }

  // Disregard diacritics.
  //  Input: "média"
  let result = remove_accents_default()(input);

  // Accommodate leading slash, matching autocomplete expectations.
  //  Input: "/media"
  result = result.replace(/^\//, '');

  // Lowercase.
  //  Input: "MEDIA"
  result = result.toLowerCase();
  normalizedStrings.set(input, result);
  return result;
}

/**
 * Converts the search term into a list of normalized terms.
 *
 * @param {string} input The search term to normalize.
 *
 * @return {string[]} The normalized list of search terms.
 */
const getNormalizedSearchTerms = (input = '') => {
  return extractWords(normalizeString(input));
};
const removeMatchingTerms = (unmatchedTerms, unprocessedTerms) => {
  return unmatchedTerms.filter(term => !getNormalizedSearchTerms(unprocessedTerms).some(unprocessedTerm => unprocessedTerm.includes(term)));
};
const searchBlockItems = (items, categories, collections, searchInput) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);
  if (normalizedSearchTerms.length === 0) {
    return items;
  }
  const config = {
    getCategory: item => categories.find(({
      slug
    }) => slug === item.category)?.title,
    getCollection: item => collections[item.name.split('/')[0]]?.title
  };
  return searchItems(items, searchInput, config);
};

/**
 * Filters an item list given a search term.
 *
 * @param {Array}  items       Item list
 * @param {string} searchInput Search input.
 * @param {Object} config      Search Config.
 *
 * @return {Array} Filtered item list.
 */
const searchItems = (items = [], searchInput = '', config = {}) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);
  if (normalizedSearchTerms.length === 0) {
    return items;
  }
  const rankedItems = items.map(item => {
    return [item, getItemSearchRank(item, searchInput, config)];
  }).filter(([, rank]) => rank > 0);
  rankedItems.sort(([, rank1], [, rank2]) => rank2 - rank1);
  return rankedItems.map(([item]) => item);
};

/**
 * Get the search rank for a given item and a specific search term.
 * The better the match, the higher the rank.
 * If the rank equals 0, it should be excluded from the results.
 *
 * @param {Object} item       Item to filter.
 * @param {string} searchTerm Search term.
 * @param {Object} config     Search Config.
 *
 * @return {number} Search Rank.
 */
function getItemSearchRank(item, searchTerm, config = {}) {
  const {
    getName = defaultGetName,
    getTitle = defaultGetTitle,
    getDescription = defaultGetDescription,
    getKeywords = defaultGetKeywords,
    getCategory = defaultGetCategory,
    getCollection = defaultGetCollection
  } = config;
  const name = getName(item);
  const title = getTitle(item);
  const description = getDescription(item);
  const keywords = getKeywords(item);
  const category = getCategory(item);
  const collection = getCollection(item);
  const normalizedSearchInput = normalizeString(searchTerm);
  const normalizedTitle = normalizeString(title);
  let rank = 0;

  // Prefers exact matches
  // Then prefers if the beginning of the title matches the search term
  // name, keywords, categories, collection, variations match come later.
  if (normalizedSearchInput === normalizedTitle) {
    rank += 30;
  } else if (normalizedTitle.startsWith(normalizedSearchInput)) {
    rank += 20;
  } else {
    const terms = [name, title, description, ...keywords, category, collection].join(' ');
    const normalizedSearchTerms = extractWords(normalizedSearchInput);
    const unmatchedTerms = removeMatchingTerms(normalizedSearchTerms, terms);
    if (unmatchedTerms.length === 0) {
      rank += 10;
    }
  }

  // Give a better rank to "core" namespaced items.
  if (rank !== 0 && name.startsWith('core/')) {
    const isCoreBlockVariation = name !== item.id;
    // Give a bit better rank to "core" blocks over "core" block variations.
    rank += isCoreBlockVariation ? 1 : 2;
  }
  return rank;
}
//# sourceMappingURL=search-items.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-patterns-paging.js
/**
 * WordPress dependencies
 */



const PAGE_SIZE = 20;
const INITIAL_INSERTER_RESULTS = 5;

/**
 * Supplies values needed to page the patterns list client side.
 *
 * @param {Array}  currentCategoryPatterns An array of the current patterns to display.
 * @param {string} currentCategory         The currently selected category.
 * @param {Object} scrollContainerRef      Ref of container to to find scroll container for when moving between pages.
 * @param {string} currentFilter           The currently search filter.
 *
 * @return {Object} Returns the relevant paging values. (totalItems, categoryPatternsList, numPages, changePage, currentPage)
 */
function usePatternsPaging(currentCategoryPatterns, currentCategory, scrollContainerRef, currentFilter = '') {
  const [currentPage, setCurrentPage] = (0,react.useState)(1);
  const previousCategory = (0,use_previous/* default */.A)(currentCategory);
  const previousFilter = (0,use_previous/* default */.A)(currentFilter);
  if ((previousCategory !== currentCategory || previousFilter !== currentFilter) && currentPage !== 1) {
    setCurrentPage(1);
  }
  const totalItems = currentCategoryPatterns.length;
  const pageIndex = currentPage - 1;
  const categoryPatterns = (0,react.useMemo)(() => {
    return currentCategoryPatterns.slice(pageIndex * PAGE_SIZE, pageIndex * PAGE_SIZE + PAGE_SIZE);
  }, [pageIndex, currentCategoryPatterns]);
  const categoryPatternsAsyncList = use_async_list(categoryPatterns, {
    step: INITIAL_INSERTER_RESULTS
  });
  const numPages = Math.ceil(currentCategoryPatterns.length / PAGE_SIZE);
  const changePage = page => {
    const scrollContainer = (0,get_scroll_container/* default */.A)(scrollContainerRef?.current);
    scrollContainer?.scrollTo(0, 0);
    setCurrentPage(page);
  };
  (0,react.useEffect)(function scrollToTopOnCategoryChange() {
    const scrollContainer = (0,get_scroll_container/* default */.A)(scrollContainerRef?.current);
    scrollContainer?.scrollTo(0, 0);
  }, [currentCategory, scrollContainerRef]);
  return {
    totalItems,
    categoryPatterns,
    categoryPatternsAsyncList,
    numPages,
    changePage,
    currentPage
  };
}
//# sourceMappingURL=use-patterns-paging.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/pattern-list.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */











function PatternsListHeader({
  filterValue,
  filteredBlockPatternsLength
}) {
  if (!filterValue) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(heading_component/* default */.A, {
    level: 2,
    lineHeight: "48px",
    className: "block-editor-block-patterns-explorer__search-results-count",
    children: (0,i18n_build_module/* sprintf */.nv)( /* translators: %d: number of patterns. */
    (0,i18n_build_module._n)('%d pattern found', '%d patterns found', filteredBlockPatternsLength), filteredBlockPatternsLength)
  });
}
function PatternList({
  searchValue,
  selectedCategory,
  patternCategories,
  rootClientId
}) {
  const container = (0,react.useRef)();
  const debouncedSpeak = (0,use_debounce/* default */.A)(a11y_build_module/* speak */.L, 500);
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    rootClientId,
    shouldFocusBlock: true
  });
  const [patterns,, onClickPattern] = use_patterns_state(onInsertBlocks, destinationRootClientId, selectedCategory);
  const registeredPatternCategories = (0,react.useMemo)(() => patternCategories.map(patternCategory => patternCategory.name), [patternCategories]);
  const filteredBlockPatterns = (0,react.useMemo)(() => {
    const filteredPatterns = patterns.filter(pattern => {
      if (selectedCategory === allPatternsCategory.name) {
        return true;
      }
      if (selectedCategory === myPatternsCategory.name && pattern.type === INSERTER_PATTERN_TYPES.user) {
        return true;
      }
      if (selectedCategory === 'uncategorized') {
        const hasKnownCategory = pattern.categories.some(category => registeredPatternCategories.includes(category));
        return !pattern.categories?.length || !hasKnownCategory;
      }
      return pattern.categories?.includes(selectedCategory);
    });
    if (!searchValue) {
      return filteredPatterns;
    }
    return searchItems(filteredPatterns, searchValue);
  }, [searchValue, patterns, selectedCategory, registeredPatternCategories]);

  // Announce search results on change.
  (0,react.useEffect)(() => {
    if (!searchValue) {
      return;
    }
    const count = filteredBlockPatterns.length;
    const resultsFoundMessage = (0,i18n_build_module/* sprintf */.nv)( /* translators: %d: number of results. */
    (0,i18n_build_module._n)('%d result found.', '%d results found.', count), count);
    debouncedSpeak(resultsFoundMessage);
  }, [searchValue, debouncedSpeak, filteredBlockPatterns.length]);
  const pagingProps = usePatternsPaging(filteredBlockPatterns, selectedCategory, container);

  // Reset page when search value changes.
  const [previousSearchValue, setPreviousSearchValue] = (0,react.useState)(searchValue);
  if (searchValue !== previousSearchValue) {
    setPreviousSearchValue(searchValue);
    pagingProps.changePage(1);
  }
  const hasItems = !!filteredBlockPatterns?.length;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "block-editor-block-patterns-explorer__list",
    ref: container,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(PatternsListHeader, {
      filterValue: searchValue,
      filteredBlockPatternsLength: filteredBlockPatterns.length
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(inserter_listbox, {
      children: hasItems && /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_patterns_list, {
          shownPatterns: pagingProps.categoryPatternsAsyncList,
          blockPatterns: pagingProps.categoryPatterns,
          onClickPattern: onClickPattern,
          isDraggable: false
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(Pagination, {
          ...pagingProps
        })]
      })
    })]
  });
}
/* harmony default export */ const pattern_list = (PatternList);
//# sourceMappingURL=pattern-list.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/use-pattern-categories.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function hasRegisteredCategory(pattern, allCategories) {
  if (!pattern.categories || !pattern.categories.length) {
    return false;
  }
  return pattern.categories.some(cat => allCategories.some(category => category.name === cat));
}
function usePatternCategories(rootClientId, sourceFilter = 'all') {
  const [patterns, allCategories] = use_patterns_state(undefined, rootClientId);
  const filteredPatterns = (0,react.useMemo)(() => sourceFilter === 'all' ? patterns : patterns.filter(pattern => !isPatternFiltered(pattern, sourceFilter)), [sourceFilter, patterns]);

  // Remove any empty categories.
  const populatedCategories = (0,react.useMemo)(() => {
    const categories = allCategories.filter(category => filteredPatterns.some(pattern => pattern.categories?.includes(category.name))).sort((a, b) => a.label.localeCompare(b.label));
    if (filteredPatterns.some(pattern => !hasRegisteredCategory(pattern, allCategories)) && !categories.find(category => category.name === 'uncategorized')) {
      categories.push({
        name: 'uncategorized',
        label: (0,i18n_build_module._x)('Uncategorized')
      });
    }
    if (filteredPatterns.some(pattern => pattern.type === INSERTER_PATTERN_TYPES.user)) {
      categories.unshift(myPatternsCategory);
    }
    if (filteredPatterns.length > 0) {
      categories.unshift({
        name: allPatternsCategory.name,
        label: allPatternsCategory.label
      });
    }
    (0,a11y_build_module/* speak */.L)((0,i18n_build_module/* sprintf */.nv)( /* translators: %d: number of categories . */
    (0,i18n_build_module._n)('%d category button displayed.', '%d category buttons displayed.', categories.length), categories.length));
    return categories;
  }, [allCategories, filteredPatterns]);
  return populatedCategories;
}
//# sourceMappingURL=use-pattern-categories.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





function PatternsExplorer({
  initialCategory,
  rootClientId
}) {
  const [searchValue, setSearchValue] = (0,react.useState)('');
  const [selectedCategory, setSelectedCategory] = (0,react.useState)(initialCategory?.name);
  const patternCategories = usePatternCategories(rootClientId);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "block-editor-block-patterns-explorer",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(pattern_explorer_sidebar, {
      selectedCategory: selectedCategory,
      patternCategories: patternCategories,
      onClickCategory: setSelectedCategory,
      searchValue: searchValue,
      setSearchValue: setSearchValue
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(pattern_list, {
      searchValue: searchValue,
      selectedCategory: selectedCategory,
      patternCategories: patternCategories,
      rootClientId: rootClientId
    })]
  });
}
function PatternsExplorerModal({
  onModalClose,
  ...restProps
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(modal/* default */.A, {
    title: (0,i18n_build_module.__)('Patterns'),
    onRequestClose: onModalClose,
    isFullScreen: true,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(PatternsExplorer, {
      ...restProps
    })
  });
}
/* harmony default export */ const block_patterns_explorer = (PatternsExplorerModal);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/context.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

const initialContextValue = {
  location: {},
  goTo: () => {},
  goBack: () => {},
  goToParent: () => {},
  addScreen: () => {},
  removeScreen: () => {},
  params: {}
};
const NavigatorContext = (0,react.createContext)(initialContextValue);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/use-navigator.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

/**
 * Retrieves a `navigator` instance.
 */
function useNavigator() {
  const {
    location,
    params,
    goTo,
    goBack,
    goToParent
  } = (0,react.useContext)(NavigatorContext);
  return {
    location,
    goTo,
    goBack,
    goToParent,
    params
  };
}
/* harmony default export */ const use_navigator = (useNavigator);
//# sourceMappingURL=use-navigator.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/navigator-back-button/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function useNavigatorBackButton(props) {
  const {
    onClick,
    as = build_module_button/* default */.Ay,
    goToParent: goToParentProp = false,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'NavigatorBackButton');
  const {
    goBack,
    goToParent
  } = use_navigator();
  const handleClick = (0,react.useCallback)(e => {
    e.preventDefault();
    if (goToParentProp) {
      goToParent();
    } else {
      goBack();
    }
    onClick?.(e);
  }, [goToParentProp, goToParent, goBack, onClick]);
  return {
    as,
    onClick: handleClick,
    ...otherProps
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/navigator-back-button/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function UnconnectedNavigatorBackButton(props, forwardedRef) {
  const navigatorBackButtonProps = useNavigatorBackButton(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
    ref: forwardedRef,
    ...navigatorBackButtonProps
  });
}

/**
 * The `NavigatorBackButton` component can be used to navigate to a screen and
 * should be used in combination with the `NavigatorProvider`, the
 * `NavigatorScreen` and the `NavigatorButton` components (or the `useNavigator`
 * hook).
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */
const NavigatorBackButton = (0,context_connect/* contextConnect */.KZ)(UnconnectedNavigatorBackButton, 'NavigatorBackButton');
/* harmony default export */ const navigator_back_button_component = (NavigatorBackButton);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/path-to-regexp@6.2.1/node_modules/path-to-regexp/dist.es2015/index.js
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at ".concat(i));
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at ".concat(j));
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at ".concat(j));
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at ".concat(i));
            if (!pattern)
                throw new TypeError("Missing pattern at ".concat(i));
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function dist_es2015_parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
    };
    var consumeText = function () {
        var result = "";
        var value;
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || "",
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || "",
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(dist_es2015_parse(str, options), options);
}
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"".concat(token.name, "\" to not repeat, but got an array"));
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"".concat(token.name, "\" to not be empty"));
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"".concat(token.name, "\" to match \"").concat(token.pattern, "\", but got \"").concat(segment, "\""));
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"".concat(token.name, "\" to match \"").concat(token.pattern, "\", but got \"").concat(segment, "\""));
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"".concat(token.name, "\" to be ").concat(typeOfMessage));
        }
        return path;
    };
}
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
    var index = 0;
    var execResult = groupsRegex.exec(path.source);
    while (execResult) {
        keys.push({
            // Use parenthesized substring match if available, index otherwise
            name: execResult[1] || index++,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: "",
        });
        execResult = groupsRegex.exec(path.source);
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(dist_es2015_parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
    var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
    var delimiterRe = "[".concat(escapeString(delimiter), "]");
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
                    }
                    else {
                        route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
                    }
                }
                else {
                    if (token.modifier === "+" || token.modifier === "*") {
                        route += "((?:".concat(token.pattern, ")").concat(token.modifier, ")");
                    }
                    else {
                        route += "(".concat(token.pattern, ")").concat(token.modifier);
                    }
                }
            }
            else {
                route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
            }
        }
    }
    if (end) {
        if (!strict)
            route += "".concat(delimiterRe, "?");
        route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1
            : endToken === undefined;
        if (!strict) {
            route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
        }
        if (!isEndDelimited) {
            route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
        }
    }
    return new RegExp(route, flags(options));
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/utils/router.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */

function matchPath(path, pattern) {
  const matchingFunction = match(pattern, {
    decode: decodeURIComponent
  });
  return matchingFunction(path);
}
function patternMatch(path, screens) {
  for (const screen of screens) {
    const matched = matchPath(path, screen.path);
    if (matched) {
      return {
        params: matched.params,
        id: screen.id
      };
    }
  }
  return undefined;
}
function findParent(path, screens) {
  if (!path.startsWith('/')) {
    return undefined;
  }
  const pathParts = path.split('/');
  let parentPath;
  while (pathParts.length > 1 && parentPath === undefined) {
    pathParts.pop();
    const potentialParentPath = pathParts.join('/') === '' ? '/' : pathParts.join('/');
    if (screens.find(screen => {
      return matchPath(potentialParentPath, screen.path) !== false;
    })) {
      parentPath = potentialParentPath;
    }
  }
  return parentPath;
}
//# sourceMappingURL=router.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/styles.js
function navigator_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

const navigatorProviderWrapper =  true ? {
  name: "xpkswc",
  styles: "overflow-x:hidden;contain:content"
} : 0;
const fadeInFromRight = (0,emotion_react_browser_esm/* keyframes */.i7)({
  '0%': {
    opacity: 0,
    transform: `translateX( 50px )`
  },
  '100%': {
    opacity: 1,
    transform: 'none'
  }
});
const fadeInFromLeft = (0,emotion_react_browser_esm/* keyframes */.i7)({
  '0%': {
    opacity: 0,
    transform: `translateX( -50px )`
  },
  '100%': {
    opacity: 1,
    transform: 'none'
  }
});
const navigatorScreenAnimation = ({
  isInitial,
  isBack,
  isRTL
}) => {
  if (isInitial && !isBack) {
    return;
  }
  const animationName = isRTL && isBack || !isRTL && !isBack ? fadeInFromRight : fadeInFromLeft;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("animation-duration:0.14s;animation-timing-function:ease-in-out;will-change:transform,opacity;animation-name:", animationName, ";@media ( prefers-reduced-motion ){animation-duration:0s;}" + ( true ? "" : 0),  true ? "" : 0);
};
const navigatorScreen = props => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("overflow-x:auto;max-height:100%;", navigatorScreenAnimation(props), ";" + ( true ? "" : 0),  true ? "" : 0);
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/navigator-provider/component.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */








const MAX_HISTORY_LENGTH = 50;
function addScreen({
  screens
}, screen) {
  return [...screens, screen];
}
function removeScreen({
  screens
}, screen) {
  return screens.filter(s => s.id !== screen.id);
}
function goBack({
  locationHistory
}) {
  if (locationHistory.length <= 1) {
    return locationHistory;
  }
  return [...locationHistory.slice(0, -2), {
    ...locationHistory[locationHistory.length - 2],
    isBack: true,
    hasRestoredFocus: false
  }];
}
function goTo(state, path, options = {}) {
  const {
    locationHistory
  } = state;
  const {
    focusTargetSelector,
    isBack = false,
    skipFocus = false,
    replace = false,
    ...restOptions
  } = options;
  const isNavigatingToSamePath = locationHistory.length > 0 && locationHistory[locationHistory.length - 1].path === path;
  if (isNavigatingToSamePath) {
    return locationHistory;
  }
  const isNavigatingToPreviousPath = isBack && locationHistory.length > 1 && locationHistory[locationHistory.length - 2].path === path;
  if (isNavigatingToPreviousPath) {
    return goBack(state);
  }
  const newLocation = {
    ...restOptions,
    path,
    isBack,
    hasRestoredFocus: false,
    skipFocus
  };
  if (locationHistory.length === 0) {
    return replace ? [] : [newLocation];
  }
  const newLocationHistory = locationHistory.slice(locationHistory.length > MAX_HISTORY_LENGTH - 1 ? 1 : 0, -1);
  if (!replace) {
    newLocationHistory.push(
    // Assign `focusTargetSelector` to the previous location in history
    // (the one we just navigated from).
    {
      ...locationHistory[locationHistory.length - 1],
      focusTargetSelector
    });
  }
  newLocationHistory.push(newLocation);
  return newLocationHistory;
}
function goToParent(state, options = {}) {
  const {
    locationHistory,
    screens
  } = state;
  const currentPath = locationHistory[locationHistory.length - 1].path;
  if (currentPath === undefined) {
    return locationHistory;
  }
  const parentPath = findParent(currentPath, screens);
  if (parentPath === undefined) {
    return locationHistory;
  }
  return goTo(state, parentPath, {
    ...options,
    isBack: true
  });
}
function routerReducer(state, action) {
  let {
    screens,
    locationHistory,
    matchedPath
  } = state;
  switch (action.type) {
    case 'add':
      screens = addScreen(state, action.screen);
      break;
    case 'remove':
      screens = removeScreen(state, action.screen);
      break;
    case 'goback':
      locationHistory = goBack(state);
      break;
    case 'goto':
      locationHistory = goTo(state, action.path, action.options);
      break;
    case 'gotoparent':
      locationHistory = goToParent(state, action.options);
      break;
  }

  // Return early in case there is no change
  if (screens === state.screens && locationHistory === state.locationHistory) {
    return state;
  }

  // Compute the matchedPath
  const currentPath = locationHistory.length > 0 ? locationHistory[locationHistory.length - 1].path : undefined;
  matchedPath = currentPath !== undefined ? patternMatch(currentPath, screens) : undefined;

  // If the new match is the same as the previous match,
  // return the previous one to keep immutability.
  if (matchedPath && state.matchedPath && matchedPath.id === state.matchedPath.id && (0,is_shallow_equal_build_module/* default */.Ay)(matchedPath.params, state.matchedPath.params)) {
    matchedPath = state.matchedPath;
  }
  return {
    screens,
    locationHistory,
    matchedPath
  };
}
function UnconnectedNavigatorProvider(props, forwardedRef) {
  const {
    initialPath,
    children,
    className,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'NavigatorProvider');
  const [routerState, dispatch] = (0,react.useReducer)(routerReducer, initialPath, path => ({
    screens: [],
    locationHistory: [{
      path
    }],
    matchedPath: undefined
  }));

  // The methods are constant forever, create stable references to them.
  const methods = (0,react.useMemo)(() => ({
    goBack: () => dispatch({
      type: 'goback'
    }),
    goTo: (path, options) => dispatch({
      type: 'goto',
      path,
      options
    }),
    goToParent: options => dispatch({
      type: 'gotoparent',
      options
    }),
    addScreen: screen => dispatch({
      type: 'add',
      screen
    }),
    removeScreen: screen => dispatch({
      type: 'remove',
      screen
    })
  }), []);
  const {
    locationHistory,
    matchedPath
  } = routerState;
  const navigatorContextValue = (0,react.useMemo)(() => {
    var _matchedPath$params;
    return {
      location: {
        ...locationHistory[locationHistory.length - 1],
        isInitial: locationHistory.length === 1
      },
      params: (_matchedPath$params = matchedPath?.params) !== null && _matchedPath$params !== void 0 ? _matchedPath$params : {},
      match: matchedPath?.id,
      ...methods
    };
  }, [locationHistory, matchedPath, methods]);
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => cx(navigatorProviderWrapper, className), [className, cx]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
    ref: forwardedRef,
    className: classes,
    ...otherProps,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(NavigatorContext.Provider, {
      value: navigatorContextValue,
      children: children
    })
  });
}

/**
 * The `NavigatorProvider` component allows rendering nested views/panels/menus
 * (via the `NavigatorScreen` component and navigate between these different
 * view (via the `NavigatorButton` and `NavigatorBackButton` components or the
 * `useNavigator` hook).
 *
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */
const NavigatorProvider = (0,context_connect/* contextConnect */.KZ)(UnconnectedNavigatorProvider, 'NavigatorProvider');
/* harmony default export */ const navigator_provider_component = (NavigatorProvider);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+escape-html@3.10.0/node_modules/@wordpress/escape-html/build-module/index.js + 1 modules
var escape_html_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+escape-html@3.10.0/node_modules/@wordpress/escape-html/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/navigator-screen/component.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */







function UnconnectedNavigatorScreen(props, forwardedRef) {
  const screenId = (0,react.useId)();
  const {
    children,
    className,
    path,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'NavigatorScreen');
  const {
    location,
    match,
    addScreen,
    removeScreen
  } = (0,react.useContext)(NavigatorContext);
  const isMatch = match === screenId;
  const wrapperRef = (0,react.useRef)(null);
  (0,react.useEffect)(() => {
    const screen = {
      id: screenId,
      path: (0,escape_html_build_module/* escapeAttribute */.Gj)(path)
    };
    addScreen(screen);
    return () => removeScreen(screen);
  }, [screenId, path, addScreen, removeScreen]);
  const isRTL = (0,i18n_build_module/* isRTL */.V8)();
  const {
    isInitial,
    isBack
  } = location;
  const cx = (0,use_cx/* useCx */.l)();
  const classes = (0,react.useMemo)(() => cx(navigatorScreen({
    isInitial,
    isBack,
    isRTL
  }), className), [className, cx, isInitial, isBack, isRTL]);
  const locationRef = (0,react.useRef)(location);
  (0,react.useEffect)(() => {
    locationRef.current = location;
  }, [location]);

  // Focus restoration
  const isInitialLocation = location.isInitial && !location.isBack;
  (0,react.useEffect)(() => {
    // Only attempt to restore focus:
    // - if the current location is not the initial one (to avoid moving focus on page load)
    // - when the screen becomes visible
    // - if the wrapper ref has been assigned
    // - if focus hasn't already been restored for the current location
    // - if the `skipFocus` option is not set to `true`. This is useful when we trigger the navigation outside of NavigatorScreen.
    if (isInitialLocation || !isMatch || !wrapperRef.current || locationRef.current.hasRestoredFocus || location.skipFocus) {
      return;
    }
    const activeElement = wrapperRef.current.ownerDocument.activeElement;

    // If an element is already focused within the wrapper do not focus the
    // element. This prevents inputs or buttons from losing focus unnecessarily.
    if (wrapperRef.current.contains(activeElement)) {
      return;
    }
    let elementToFocus = null;

    // When navigating back, if a selector is provided, use it to look for the
    // target element (assumed to be a node inside the current NavigatorScreen)
    if (location.isBack && location.focusTargetSelector) {
      elementToFocus = wrapperRef.current.querySelector(location.focusTargetSelector);
    }

    // If the previous query didn't run or find any element to focus, fallback
    // to the first tabbable element in the screen (or the screen itself).
    if (!elementToFocus) {
      const [firstTabbable] = dom_build_module/* focus */.XC.tabbable.find(wrapperRef.current);
      elementToFocus = firstTabbable !== null && firstTabbable !== void 0 ? firstTabbable : wrapperRef.current;
    }
    locationRef.current.hasRestoredFocus = true;
    elementToFocus.focus();
  }, [isInitialLocation, isMatch, location.isBack, location.focusTargetSelector, location.skipFocus]);
  const mergedWrapperRef = (0,use_merge_refs/* default */.A)([forwardedRef, wrapperRef]);
  return isMatch ? /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
    ref: mergedWrapperRef,
    className: classes,
    ...otherProps,
    children: children
  }) : null;
}

/**
 * The `NavigatorScreen` component represents a single view/screen/panel and
 * should be used in combination with the `NavigatorProvider`, the
 * `NavigatorButton` and the `NavigatorBackButton` components (or the `useNavigator`
 * hook).
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */
const NavigatorScreen = (0,context_connect/* contextConnect */.KZ)(UnconnectedNavigatorScreen, 'NavigatorScreen');
/* harmony default export */ const navigator_screen_component = (NavigatorScreen);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/navigator-button/hook.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const cssSelectorForAttribute = (attrName, attrValue) => `[${attrName}="${attrValue}"]`;
function useNavigatorButton(props) {
  const {
    path,
    onClick,
    as = build_module_button/* default */.Ay,
    attributeName = 'id',
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'NavigatorButton');
  const escapedPath = (0,escape_html_build_module/* escapeAttribute */.Gj)(path);
  const {
    goTo
  } = use_navigator();
  const handleClick = (0,react.useCallback)(e => {
    e.preventDefault();
    goTo(escapedPath, {
      focusTargetSelector: cssSelectorForAttribute(attributeName, escapedPath)
    });
    onClick?.(e);
  }, [goTo, onClick, attributeName, escapedPath]);
  return {
    as,
    onClick: handleClick,
    ...otherProps,
    [attributeName]: escapedPath
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/navigator/navigator-button/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function UnconnectedNavigatorButton(props, forwardedRef) {
  const navigatorButtonProps = useNavigatorButton(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
    ref: forwardedRef,
    ...navigatorButtonProps
  });
}

/**
 * The `NavigatorButton` component can be used to navigate to a screen and should
 * be used in combination with the `NavigatorProvider`, the `NavigatorScreen`
 * and the `NavigatorBackButton` components (or the `useNavigator` hook).
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */
const NavigatorButton = (0,context_connect/* contextConnect */.KZ)(UnconnectedNavigatorButton, 'NavigatorButton');
/* harmony default export */ const navigator_button_component = (NavigatorButton);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/mobile-tab-navigation.js
/**
 * WordPress dependencies
 */





function ScreenHeader({
  title
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(v_stack_component/* default */.A, {
    spacing: 0,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(view_component/* default */.A, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
        marginBottom: 0,
        paddingX: 4,
        paddingY: 3,
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
          spacing: 2,
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(navigator_back_button_component, {
            style:
            // TODO: This style override is also used in ToolsPanelHeader.
            // It should be supported out-of-the-box by Button.
            {
              minWidth: 24,
              padding: 0
            },
            icon: (0,i18n_build_module/* isRTL */.V8)() ? chevron_right/* default */.A : chevron_left,
            size: "small",
            label: (0,i18n_build_module.__)('Back')
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
            children: /*#__PURE__*/(0,jsx_runtime.jsx)(heading_component/* default */.A, {
              level: 5,
              children: title
            })
          })]
        })
      })
    })
  });
}
function MobileTabNavigation({
  categories,
  children
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(navigator_provider_component, {
    initialPath: "/",
    className: "block-editor-inserter__mobile-tab-navigation",
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(navigator_screen_component, {
      path: "/",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(item_group_component, {
        children: categories.map(category => /*#__PURE__*/(0,jsx_runtime.jsx)(navigator_button_component, {
          path: `/category/${category.name}`,
          as: item_component,
          isAction: true,
          children: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_block_component/* default */.A, {
              children: category.label
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
              icon: (0,i18n_build_module/* isRTL */.V8)() ? chevron_left : chevron_right/* default */.A
            })]
          })
        }, category.name))
      })
    }), categories.map(category => /*#__PURE__*/(0,jsx_runtime.jsxs)(navigator_screen_component, {
      path: `/category/${category.name}`,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(ScreenHeader, {
        title: (0,i18n_build_module.__)('Back')
      }), children(category)]
    }, category.name))]
  });
}
//# sourceMappingURL=mobile-tab-navigation.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/menu-items-choice/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const menu_items_choice_noop = () => {};

/**
 * `MenuItemsChoice` functions similarly to a set of `MenuItem`s, but allows the user to select one option from a set of multiple choices.
 *
 *
 * ```jsx
 * import { MenuGroup, MenuItemsChoice } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyMenuItemsChoice = () => {
 * 	const [ mode, setMode ] = useState( 'visual' );
 * 	const choices = [
 * 		{
 * 			value: 'visual',
 * 			label: 'Visual editor',
 * 		},
 * 		{
 * 			value: 'text',
 * 			label: 'Code editor',
 * 		},
 * 	];
 *
 * 	return (
 * 		<MenuGroup label="Editor">
 * 			<MenuItemsChoice
 * 				choices={ choices }
 * 				value={ mode }
 * 				onSelect={ ( newMode ) => setMode( newMode ) }
 * 			/>
 * 		</MenuGroup>
 * 	);
 * };
 * ```
 */
function MenuItemsChoice({
  choices = [],
  onHover = menu_items_choice_noop,
  onSelect,
  value
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: choices.map(item => {
      const isSelected = value === item.value;
      return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
        role: "menuitemradio",
        disabled: item.disabled,
        icon: isSelected ? check/* default */.A : null,
        info: item.info,
        isSelected: isSelected,
        shortcut: item.shortcut,
        className: "components-menu-items-choice",
        onClick: () => {
          if (!isSelected) {
            onSelect(item.value);
          }
        },
        onMouseEnter: () => onHover(item.value),
        onMouseLeave: () => onHover(null),
        "aria-label": item['aria-label'],
        children: item.label
      }, item.value);
    })
  });
}
/* harmony default export */ const menu_items_choice = (MenuItemsChoice);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/patterns-filter.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const getShouldDisableSyncFilter = sourceFilter => sourceFilter !== 'all';
const getShouldDisableNonUserSources = category => {
  return category.name === myPatternsCategory.name;
};
function PatternsFilter({
  setPatternSyncFilter,
  setPatternSourceFilter,
  patternSyncFilter,
  patternSourceFilter,
  scrollContainerRef,
  category
}) {
  // If the category is `myPatterns` then we need to set the source filter to `user`, but
  // we do this by deriving from props rather than calling setPatternSourceFilter otherwise
  // the user may be confused when switching to another category if the haven't explicity set
  // this filter themselves.
  const currentPatternSourceFilter = category.name === myPatternsCategory.name ? INSERTER_PATTERN_TYPES.user : patternSourceFilter;

  // We need to disable the sync filter option if the source filter is not 'all' or 'user'
  // otherwise applying them will just result in no patterns being shown.
  const shouldDisableSyncFilter = getShouldDisableSyncFilter(currentPatternSourceFilter);

  // We also need to disable the directory and theme source filter options if the category
  // is `myPatterns` otherwise applying them will also just result in no patterns being shown.
  const shouldDisableNonUserSources = getShouldDisableNonUserSources(category);
  const patternSyncMenuOptions = (0,react.useMemo)(() => [{
    value: 'all',
    label: (0,i18n_build_module._x)('All', 'patterns')
  }, {
    value: INSERTER_SYNC_TYPES.full,
    label: (0,i18n_build_module._x)('Synced', 'patterns'),
    disabled: shouldDisableSyncFilter
  }, {
    value: INSERTER_SYNC_TYPES.unsynced,
    label: (0,i18n_build_module._x)('Not synced', 'patterns'),
    disabled: shouldDisableSyncFilter
  }], [shouldDisableSyncFilter]);
  const patternSourceMenuOptions = (0,react.useMemo)(() => [{
    value: 'all',
    label: (0,i18n_build_module._x)('All', 'patterns'),
    disabled: shouldDisableNonUserSources
  }, {
    value: INSERTER_PATTERN_TYPES.directory,
    label: (0,i18n_build_module.__)('Pattern Directory'),
    disabled: shouldDisableNonUserSources
  }, {
    value: INSERTER_PATTERN_TYPES.theme,
    label: (0,i18n_build_module.__)('Theme & Plugins'),
    disabled: shouldDisableNonUserSources
  }, {
    value: INSERTER_PATTERN_TYPES.user,
    label: (0,i18n_build_module.__)('User')
  }], [shouldDisableNonUserSources]);
  function handleSetSourceFilterChange(newSourceFilter) {
    setPatternSourceFilter(newSourceFilter);
    if (getShouldDisableSyncFilter(newSourceFilter)) {
      setPatternSyncFilter('all');
    }
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_menu/* default */.A, {
      popoverProps: {
        placement: 'right-end'
      },
      label: (0,i18n_build_module.__)('Filter patterns'),
      toggleProps: {
        size: 'compact'
      },
      icon: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
        icon: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* SVG */.t4, {
          width: "24",
          height: "24",
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_svg/* Path */.wA, {
            d: "M10 17.5H14V16H10V17.5ZM6 6V7.5H18V6H6ZM8 12.5H16V11H8V12.5Z",
            fill: "currentColor"
          })
        })
      }),
      children: () => /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
          label: (0,i18n_build_module.__)('Source'),
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(menu_items_choice, {
            choices: patternSourceMenuOptions,
            onSelect: value => {
              handleSetSourceFilterChange(value);
              scrollContainerRef.current?.scrollTo(0, 0);
            },
            value: currentPatternSourceFilter
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
          label: (0,i18n_build_module.__)('Type'),
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(menu_items_choice, {
            choices: patternSyncMenuOptions,
            onSelect: value => {
              setPatternSyncFilter(value);
              scrollContainerRef.current?.scrollTo(0, 0);
            },
            value: patternSyncFilter
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          className: "block-editor-tool-selector__help",
          children: (0,create_interpolate_element/* default */.A)((0,i18n_build_module.__)('Patterns are available from the <Link>WordPress.org Pattern Directory</Link>, bundled in the active theme, or created by users on this site. Only patterns created on this site can be synced.'), {
            Link: /*#__PURE__*/(0,jsx_runtime.jsx)(external_link, {
              href: (0,i18n_build_module.__)('https://wordpress.org/patterns/')
            })
          })
        })]
      })
    })
  });
}
//# sourceMappingURL=patterns-filter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/pattern-category-previews.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */









const pattern_category_previews_noop = () => {};
function PatternCategoryPreviews({
  rootClientId,
  onInsert,
  onHover = pattern_category_previews_noop,
  category,
  showTitlesAsTooltip
}) {
  const [allPatterns,, onClickPattern] = use_patterns_state(onInsert, rootClientId, category?.name);
  const [patternSyncFilter, setPatternSyncFilter] = (0,react.useState)('all');
  const [patternSourceFilter, setPatternSourceFilter] = (0,react.useState)('all');
  const availableCategories = usePatternCategories(rootClientId, patternSourceFilter);
  const scrollContainerRef = (0,react.useRef)();
  const currentCategoryPatterns = (0,react.useMemo)(() => allPatterns.filter(pattern => {
    if (isPatternFiltered(pattern, patternSourceFilter, patternSyncFilter)) {
      return false;
    }
    if (category.name === allPatternsCategory.name) {
      return true;
    }
    if (category.name === myPatternsCategory.name && pattern.type === INSERTER_PATTERN_TYPES.user) {
      return true;
    }
    if (category.name === 'uncategorized') {
      // The uncategorized category should show all the patterns without any category...
      if (!pattern.categories) {
        return true;
      }

      // ...or with no available category.
      return !pattern.categories.some(catName => availableCategories.some(c => c.name === catName));
    }
    return pattern.categories?.includes(category.name);
  }), [allPatterns, availableCategories, category.name, patternSourceFilter, patternSyncFilter]);
  const pagingProps = usePatternsPaging(currentCategoryPatterns, category, scrollContainerRef);
  const {
    changePage
  } = pagingProps;

  // Hide block pattern preview on unmount.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  (0,react.useEffect)(() => () => onHover(null), []);
  const onSetPatternSyncFilter = (0,react.useCallback)(value => {
    setPatternSyncFilter(value);
    changePage(1);
  }, [setPatternSyncFilter, changePage]);
  const onSetPatternSourceFilter = (0,react.useCallback)(value => {
    setPatternSourceFilter(value);
    changePage(1);
  }, [setPatternSourceFilter, changePage]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
      spacing: 2,
      className: "block-editor-inserter__patterns-category-panel-header",
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_block_component/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(heading_component/* default */.A, {
            className: "block-editor-inserter__patterns-category-panel-title",
            size: 13,
            level: 4,
            as: "div",
            children: category.label
          })
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(PatternsFilter, {
          patternSyncFilter: patternSyncFilter,
          patternSourceFilter: patternSourceFilter,
          setPatternSyncFilter: onSetPatternSyncFilter,
          setPatternSourceFilter: onSetPatternSourceFilter,
          scrollContainerRef: scrollContainerRef,
          category: category
        })]
      }), !currentCategoryPatterns.length && /*#__PURE__*/(0,jsx_runtime.jsx)(text_component/* default */.A, {
        variant: "muted",
        className: "block-editor-inserter__patterns-category-no-results",
        children: (0,i18n_build_module.__)('No results found')
      })]
    }), currentCategoryPatterns.length > 0 && /*#__PURE__*/(0,jsx_runtime.jsx)(block_patterns_list, {
      ref: scrollContainerRef,
      shownPatterns: pagingProps.categoryPatternsAsyncList,
      blockPatterns: pagingProps.categoryPatterns,
      onClickPattern: onClickPattern,
      onHover: onHover,
      label: category.label,
      orientation: "vertical",
      category: category.name,
      isDraggable: true,
      showTitlesAsTooltip: showTitlesAsTooltip,
      patternFilter: patternSourceFilter,
      pagingProps: pagingProps
    })]
  });
}
//# sourceMappingURL=pattern-category-previews.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/category-tabs/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const {
  Tabs: category_tabs_Tabs
} = lock_unlock_unlock(privateApis);
function CategoryTabs({
  categories,
  selectedCategory,
  onSelectCategory,
  children
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(category_tabs_Tabs, {
    className: "block-editor-inserter__category-tabs",
    selectOnMove: false,
    selectedTabId: selectedCategory ? selectedCategory.name : null,
    orientation: "vertical",
    onSelect: categoryId => {
      // Pass the full category object
      onSelectCategory(categories.find(category => category.name === categoryId));
    },
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(category_tabs_Tabs.TabList, {
      className: "block-editor-inserter__category-tablist",
      children: categories.map(category => /*#__PURE__*/(0,jsx_runtime.jsx)(category_tabs_Tabs.Tab, {
        tabId: category.name,
        className: "block-editor-inserter__category-tab",
        "aria-label": category.label,
        "aria-current": category === selectedCategory ? 'true' : undefined,
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(h_stack_component/* default */.A, {
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_block_component/* default */.A, {
            children: category.label
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
            icon: (0,i18n_build_module/* isRTL */.V8)() ? chevron_left : chevron_right/* default */.A
          })]
        })
      }, category.name))
    }), categories.map(category => /*#__PURE__*/(0,jsx_runtime.jsx)(category_tabs_Tabs.TabPanel, {
      tabId: category.name,
      focusable: false,
      className: "block-editor-inserter__category-panel",
      children: children
    }, category.name))]
  });
}
/* harmony default export */ const category_tabs = (CategoryTabs);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/index.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */











function BlockPatternsTab({
  onSelectCategory,
  selectedCategory,
  onInsert,
  rootClientId,
  children
}) {
  const [showPatternsExplorer, setShowPatternsExplorer] = (0,react.useState)(false);
  const categories = usePatternCategories(rootClientId);
  const isMobile = (0,use_viewport_match/* default */.A)('medium', '<');
  const isResolvingPatterns = (0,use_select/* default */.A)(select => lock_unlock_unlock(select(store_store)).isResolvingPatterns(), []);
  if (isResolvingPatterns) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-inserter__patterns-loading",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(spinner/* default */.Ay, {})
    });
  }
  if (!categories.length) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(no_results, {});
  }
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [!isMobile && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "block-editor-inserter__block-patterns-tabs-container",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(category_tabs, {
        categories: categories,
        selectedCategory: selectedCategory,
        onSelectCategory: onSelectCategory,
        children: children
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        className: "block-editor-inserter__patterns-explore-button",
        onClick: () => setShowPatternsExplorer(true),
        variant: "secondary",
        children: (0,i18n_build_module.__)('Explore all patterns')
      })]
    }), isMobile && /*#__PURE__*/(0,jsx_runtime.jsx)(MobileTabNavigation, {
      categories: categories,
      children: category => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "block-editor-inserter__category-panel",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(PatternCategoryPreviews, {
          onInsert: onInsert,
          rootClientId: rootClientId,
          category: category,
          showTitlesAsTooltip: false
        }, category.name)
      })
    }), showPatternsExplorer && /*#__PURE__*/(0,jsx_runtime.jsx)(block_patterns_explorer, {
      initialCategory: selectedCategory || categories[0],
      patternCategories: categories,
      onModalClose: () => setShowPatternsExplorer(false),
      rootClientId: rootClientId
    })]
  });
}
/* harmony default export */ const block_patterns_tab = (BlockPatternsTab);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/pattern-category-preview-panel.js
/**
 * Internal dependencies
 */



function PatternCategoryPreviewPanelInner({
  rootClientId,
  onInsert,
  onHover,
  category,
  showTitlesAsTooltip,
  patternFilter
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(PatternCategoryPreviews, {
    rootClientId: rootClientId,
    onInsert: onInsert,
    onHover: onHover,
    category: category,
    showTitlesAsTooltip: showTitlesAsTooltip,
    patternFilter: patternFilter
  }, category.name);
}
function PatternCategoryPreviewPanelWithZoomOut(props) {
  useZoomOut();
  return /*#__PURE__*/(0,jsx_runtime.jsx)(PatternCategoryPreviewPanelInner, {
    ...props
  });
}
function PatternCategoryPreviewPanel(props) {
  // When the pattern panel is showing, we want to use zoom out mode
  if (window.__experimentalEnableZoomedOutPatternsTab) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(PatternCategoryPreviewPanelWithZoomOut, {
      ...props
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(PatternCategoryPreviewPanelInner, {
    ...props
  });
}
//# sourceMappingURL=pattern-category-preview-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/external.js
/**
 * WordPress dependencies
 */


const external = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M19.5 4.5h-7V6h4.44l-5.97 5.97 1.06 1.06L18 7.06v4.44h1.5v-7Zm-13 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3H17v3a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-10a.5.5 0 0 1 .5-.5h3V5.5h-3Z"
  })
});
/* harmony default export */ const library_external = (external);
//# sourceMappingURL=external.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/utils.js
/**
 * WordPress dependencies
 */


const mediaTypeTag = {
  image: 'img',
  video: 'video',
  audio: 'audio'
};

/** @typedef {import('./hooks').InserterMediaItem} InserterMediaItem */

/**
 * Creates a block and a preview element from a media object.
 *
 * @param {InserterMediaItem}         media     The media object to create the block from.
 * @param {('image'|'audio'|'video')} mediaType The media type to create the block for.
 * @return {[WPBlock, JSX.Element]} An array containing the block and the preview element.
 */
function getBlockAndPreviewFromMedia(media, mediaType) {
  // Add the common attributes between the different media types.
  const attributes = {
    id: media.id || undefined,
    caption: media.caption || undefined
  };
  const mediaSrc = media.url;
  const alt = media.alt || undefined;
  if (mediaType === 'image') {
    attributes.url = mediaSrc;
    attributes.alt = alt;
  } else if (['video', 'audio'].includes(mediaType)) {
    attributes.src = mediaSrc;
  }
  const PreviewTag = mediaTypeTag[mediaType];
  const preview = /*#__PURE__*/(0,jsx_runtime.jsx)(PreviewTag, {
    src: media.previewUrl || mediaSrc,
    alt: alt,
    controls: mediaType === 'audio' ? true : undefined,
    inert: "true",
    onError: ({
      currentTarget
    }) => {
      // Fall back to the media source if the preview cannot be loaded.
      if (currentTarget.src === media.previewUrl) {
        currentTarget.src = mediaSrc;
      }
    }
  });
  return [(0,build_module/* createBlock */.Wv)(`core/${mediaType}`, attributes), preview];
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-preview.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */







const ALLOWED_MEDIA_TYPES = ['image'];
const MAXIMUM_TITLE_LENGTH = 25;
const MEDIA_OPTIONS_POPOVER_PROPS = {
  position: 'bottom left',
  className: 'block-editor-inserter__media-list__item-preview-options__popover'
};
const {
  CompositeItemV2: media_preview_CompositeItem
} = lock_unlock_unlock(privateApis);
function MediaPreviewOptions({
  category,
  media
}) {
  if (!category.getReportUrl) {
    return null;
  }
  const reportUrl = category.getReportUrl(media);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_menu/* default */.A, {
    className: "block-editor-inserter__media-list__item-preview-options",
    label: (0,i18n_build_module.__)('Options'),
    popoverProps: MEDIA_OPTIONS_POPOVER_PROPS,
    icon: more_vertical/* default */.A,
    children: () => /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
        onClick: () => window.open(reportUrl, '_blank').focus(),
        icon: library_external,
        children: (0,i18n_build_module/* sprintf */.nv)( /* translators: %s: The media type to report e.g: "image", "video", "audio" */
        (0,i18n_build_module.__)('Report %s'), category.mediaType)
      })
    })
  });
}
function InsertExternalImageModal({
  onClose,
  onSubmit
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(modal/* default */.A, {
    title: (0,i18n_build_module.__)('Insert external image'),
    onRequestClose: onClose,
    className: "block-editor-inserter-media-tab-media-preview-inserter-external-image-modal",
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(v_stack_component/* default */.A, {
      spacing: 3,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("p", {
        children: (0,i18n_build_module.__)('This image cannot be uploaded to your Media Library, but it can still be inserted as an external image.')
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
        children: (0,i18n_build_module.__)('External images can be removed by the external provider without warning and could even have legal compliance issues related to privacy legislation.')
      })]
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
      className: "block-editor-block-lock-modal__actions",
      justify: "flex-end",
      expanded: false,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          variant: "tertiary",
          onClick: onClose,
          children: (0,i18n_build_module.__)('Cancel')
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          variant: "primary",
          onClick: onSubmit,
          children: (0,i18n_build_module.__)('Insert')
        })
      })]
    })]
  });
}
function MediaPreview({
  media,
  onClick,
  category
}) {
  const [showExternalUploadModal, setShowExternalUploadModal] = (0,react.useState)(false);
  const [isHovered, setIsHovered] = (0,react.useState)(false);
  const [isInserting, setIsInserting] = (0,react.useState)(false);
  const [block, preview] = (0,react.useMemo)(() => getBlockAndPreviewFromMedia(media, category.mediaType), [media, category.mediaType]);
  const {
    createErrorNotice,
    createSuccessNotice
  } = (0,use_dispatch/* default */.A)(store);
  const {
    getSettings
  } = (0,use_select/* default */.A)(store_store);
  const onMediaInsert = (0,react.useCallback)(previewBlock => {
    // Prevent multiple uploads when we're in the process of inserting.
    if (isInserting) {
      return;
    }
    const settings = getSettings();
    const clonedBlock = (0,build_module/* cloneBlock */.JB)(previewBlock);
    const {
      id,
      url,
      caption
    } = clonedBlock.attributes;

    // User has no permission to upload media.
    if (!id && !settings.mediaUpload) {
      setShowExternalUploadModal(true);
      return;
    }

    // Media item already exists in library, so just insert it.
    if (!!id) {
      onClick(clonedBlock);
      return;
    }
    setIsInserting(true);
    // Media item does not exist in library, so try to upload it.
    // Fist fetch the image data. This may fail if the image host
    // doesn't allow CORS with the domain.
    // If this happens, we insert the image block using the external
    // URL and let the user know about the possible implications.
    window.fetch(url).then(response => response.blob()).then(blob => {
      settings.mediaUpload({
        filesList: [blob],
        additionalData: {
          caption
        },
        onFileChange([img]) {
          if ((0,blob_build_module/* isBlobURL */.H8)(img.url)) {
            return;
          }
          onClick({
            ...clonedBlock,
            attributes: {
              ...clonedBlock.attributes,
              id: img.id,
              url: img.url
            }
          });
          createSuccessNotice((0,i18n_build_module.__)('Image uploaded and inserted.'), {
            type: 'snackbar'
          });
          setIsInserting(false);
        },
        allowedTypes: ALLOWED_MEDIA_TYPES,
        onError(message) {
          createErrorNotice(message, {
            type: 'snackbar'
          });
          setIsInserting(false);
        }
      });
    }).catch(() => {
      setShowExternalUploadModal(true);
      setIsInserting(false);
    });
  }, [isInserting, getSettings, onClick, createSuccessNotice, createErrorNotice]);
  const title = typeof media.title === 'string' ? media.title : media.title?.rendered || (0,i18n_build_module.__)('no title');
  let truncatedTitle;
  if (title.length > MAXIMUM_TITLE_LENGTH) {
    const omission = '...';
    truncatedTitle = title.slice(0, MAXIMUM_TITLE_LENGTH - omission.length) + omission;
  }
  const onMouseEnter = (0,react.useCallback)(() => setIsHovered(true), []);
  const onMouseLeave = (0,react.useCallback)(() => setIsHovered(false), []);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(inserter_draggable_blocks, {
      isEnabled: true,
      blocks: [block],
      children: ({
        draggable,
        onDragStart,
        onDragEnd
      }) => /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: (0,dist_clsx/* default */.A)('block-editor-inserter__media-list__list-item', {
          'is-hovered': isHovered
        }),
        draggable: draggable,
        onDragStart: onDragStart,
        onDragEnd: onDragEnd,
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          onMouseEnter: onMouseEnter,
          onMouseLeave: onMouseLeave,
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
            text: truncatedTitle || title,
            children: /*#__PURE__*/(0,jsx_runtime.jsx)(media_preview_CompositeItem, {
              render: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
                "aria-label": title,
                role: "option",
                className: "block-editor-inserter__media-list__item"
              }),
              onClick: () => onMediaInsert(block),
              children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
                className: "block-editor-inserter__media-list__item-preview",
                children: [preview, isInserting && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
                  className: "block-editor-inserter__media-list__item-preview-spinner",
                  children: /*#__PURE__*/(0,jsx_runtime.jsx)(spinner/* default */.Ay, {})
                })]
              })
            })
          }), !isInserting && /*#__PURE__*/(0,jsx_runtime.jsx)(MediaPreviewOptions, {
            category: category,
            media: media
          })]
        })
      })
    }), showExternalUploadModal && /*#__PURE__*/(0,jsx_runtime.jsx)(InsertExternalImageModal, {
      onClose: () => setShowExternalUploadModal(false),
      onSubmit: () => {
        onClick((0,build_module/* cloneBlock */.JB)(block));
        createSuccessNotice((0,i18n_build_module.__)('Image inserted.'), {
          type: 'snackbar'
        });
        setShowExternalUploadModal(false);
      }
    })]
  });
}
//# sourceMappingURL=media-preview.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-list.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const {
  CompositeV2: media_list_Composite,
  useCompositeStoreV2: media_list_useCompositeStore
} = lock_unlock_unlock(privateApis);
function MediaList({
  mediaList,
  category,
  onClick,
  label = (0,i18n_build_module.__)('Media List')
}) {
  const compositeStore = media_list_useCompositeStore();
  return /*#__PURE__*/(0,jsx_runtime.jsx)(media_list_Composite, {
    store: compositeStore,
    role: "listbox",
    className: "block-editor-inserter__media-list",
    "aria-label": label,
    children: mediaList.map((media, index) => /*#__PURE__*/(0,jsx_runtime.jsx)(MediaPreview, {
      media: media,
      category: category,
      onClick: onClick
    }, media.id || media.sourceId || index))
  });
}
/* harmony default export */ const media_list = (MediaList);
//# sourceMappingURL=media-list.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/hooks.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/** @typedef {import('../../../store/actions').InserterMediaRequest} InserterMediaRequest */
/** @typedef {import('../../../store/actions').InserterMediaItem} InserterMediaItem */

/**
 * Fetches media items based on the provided category.
 * Each media category is responsible for providing a `fetch` function.
 *
 * @param {Object}               category The media category to fetch results for.
 * @param {InserterMediaRequest} query    The query args to use for the request.
 * @return {InserterMediaItem[]} The media results.
 */
function useMediaResults(category, query = {}) {
  const [mediaList, setMediaList] = (0,react.useState)();
  const [isLoading, setIsLoading] = (0,react.useState)(false);
  // We need to keep track of the last request made because
  // multiple request can be fired without knowing the order
  // of resolution, and we need to ensure we are showing
  // the results of the last request.
  // In the future we could use AbortController to cancel previous
  // requests, but we don't for now as it involves adding support
  // for this to `core-data` package.
  const lastRequest = (0,react.useRef)();
  (0,react.useEffect)(() => {
    (async () => {
      const key = JSON.stringify({
        category: category.name,
        ...query
      });
      lastRequest.current = key;
      setIsLoading(true);
      setMediaList([]); // Empty the previous results.
      const _media = await category.fetch?.(query);
      if (key === lastRequest.current) {
        setMediaList(_media);
        setIsLoading(false);
      }
    })();
  }, [category.name, ...Object.values(query)]);
  return {
    mediaList,
    isLoading
  };
}
function useMediaCategories(rootClientId) {
  const [categories, setCategories] = (0,react.useState)([]);
  const inserterMediaCategories = (0,use_select/* default */.A)(select => lock_unlock_unlock(select(store_store)).getInserterMediaCategories(), []);
  const {
    canInsertImage,
    canInsertVideo,
    canInsertAudio
  } = (0,use_select/* default */.A)(select => {
    const {
      canInsertBlockType
    } = select(store_store);
    return {
      canInsertImage: canInsertBlockType('core/image', rootClientId),
      canInsertVideo: canInsertBlockType('core/video', rootClientId),
      canInsertAudio: canInsertBlockType('core/audio', rootClientId)
    };
  }, [rootClientId]);
  (0,react.useEffect)(() => {
    (async () => {
      const _categories = [];
      // If `inserterMediaCategories` is not defined in
      // block editor settings, do not show any media categories.
      if (!inserterMediaCategories) {
        return;
      }
      // Loop through categories to check if they have at least one media item.
      const categoriesHaveMedia = new Map(await Promise.all(inserterMediaCategories.map(async category => {
        // Some sources are external and we don't need to make a request.
        if (category.isExternalResource) {
          return [category.name, true];
        }
        let results = [];
        try {
          results = await category.fetch({
            per_page: 1
          });
        } catch (e) {
          // If the request fails, we shallow the error and just don't show
          // the category, in order to not break the media tab.
        }
        return [category.name, !!results.length];
      })));
      // We need to filter out categories that don't have any media items or
      // whose corresponding block type is not allowed to be inserted, based
      // on the category's `mediaType`.
      const canInsertMediaType = {
        image: canInsertImage,
        video: canInsertVideo,
        audio: canInsertAudio
      };
      inserterMediaCategories.forEach(category => {
        if (canInsertMediaType[category.mediaType] && categoriesHaveMedia.get(category.name)) {
          _categories.push(category);
        }
      });
      if (!!_categories.length) {
        setCategories(_categories);
      }
    })();
  }, [canInsertImage, canInsertVideo, canInsertAudio, inserterMediaCategories]);
  return categories;
}
//# sourceMappingURL=hooks.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-panel.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const INITIAL_MEDIA_ITEMS_PER_PAGE = 10;
function MediaCategoryPanel({
  rootClientId,
  onInsert,
  category
}) {
  const [search, setSearch, debouncedSearch] = useDebouncedInput();
  const {
    mediaList,
    isLoading
  } = useMediaResults(category, {
    per_page: !!debouncedSearch ? 20 : INITIAL_MEDIA_ITEMS_PER_PAGE,
    search: debouncedSearch
  });
  const baseCssClass = 'block-editor-inserter__media-panel';
  const searchLabel = category.labels.search_items || (0,i18n_build_module.__)('Search');
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: baseCssClass,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(search_control, {
      className: `${baseCssClass}-search`,
      onChange: setSearch,
      value: search,
      label: searchLabel,
      placeholder: searchLabel
    }), isLoading && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: `${baseCssClass}-spinner`,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(spinner/* default */.Ay, {})
    }), !isLoading && !mediaList?.length && /*#__PURE__*/(0,jsx_runtime.jsx)(no_results, {}), !isLoading && !!mediaList?.length && /*#__PURE__*/(0,jsx_runtime.jsx)(media_list, {
      rootClientId: rootClientId,
      onClick: onInsert,
      mediaList: mediaList,
      category: category
    })]
  });
}
//# sourceMappingURL=media-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-tab.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */











const media_tab_ALLOWED_MEDIA_TYPES = ['image', 'video', 'audio'];
function MediaTab({
  rootClientId,
  selectedCategory,
  onSelectCategory,
  onInsert,
  children
}) {
  const mediaCategories = useMediaCategories(rootClientId);
  const isMobile = (0,use_viewport_match/* default */.A)('medium', '<');
  const baseCssClass = 'block-editor-inserter__media-tabs';
  const onSelectMedia = (0,react.useCallback)(media => {
    if (!media?.url) {
      return;
    }
    const [block] = getBlockAndPreviewFromMedia(media, media.type);
    onInsert(block);
  }, [onInsert]);
  const categories = (0,react.useMemo)(() => mediaCategories.map(mediaCategory => ({
    ...mediaCategory,
    label: mediaCategory.labels.name
  })), [mediaCategories]);
  if (!categories.length) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(no_results, {});
  }
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [!isMobile && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: `${baseCssClass}-container`,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(category_tabs, {
        categories: categories,
        selectedCategory: selectedCategory,
        onSelectCategory: onSelectCategory,
        children: children
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(media_upload_check, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(media_upload, {
          multiple: false,
          onSelect: onSelectMedia,
          allowedTypes: media_tab_ALLOWED_MEDIA_TYPES,
          render: ({
            open
          }) => /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
            onClick: event => {
              // Safari doesn't emit a focus event on button elements when
              // clicked and we need to manually focus the button here.
              // The reason is that core's Media Library modal explicitly triggers a
              // focus event and therefore a `blur` event is triggered on a different
              // element, which doesn't contain the `data-unstable-ignore-focus-outside-for-relatedtarget`
              // attribute making the Inserter dialog to close.
              event.target.focus();
              open();
            },
            className: "block-editor-inserter__media-library-button",
            variant: "secondary",
            "data-unstable-ignore-focus-outside-for-relatedtarget": ".media-modal",
            children: (0,i18n_build_module.__)('Open Media Library')
          })
        })
      })]
    }), isMobile && /*#__PURE__*/(0,jsx_runtime.jsx)(MobileTabNavigation, {
      categories: categories,
      children: category => /*#__PURE__*/(0,jsx_runtime.jsx)(MediaCategoryPanel, {
        onInsert: onInsert,
        rootClientId: rootClientId,
        category: category
      })
    })]
  });
}
/* harmony default export */ const media_tab = (MediaTab);
//# sourceMappingURL=media-tab.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter-menu-extension/index.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableInserterMenuExtension,
  Slot: inserter_menu_extension_Slot
} = (0,slot_fill/* createSlotFill */.QJ)('__unstableInserterMenuExtension');
__unstableInserterMenuExtension.Slot = inserter_menu_extension_Slot;
/* harmony default export */ const inserter_menu_extension = (__unstableInserterMenuExtension);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/utils/order-inserter-block-items.js
/** @typedef {import('../store/selectors').WPEditorInserterItem} WPEditorInserterItem */

/**
 * Helper function to order inserter block items according to a provided array of prioritized blocks.
 *
 * @param {WPEditorInserterItem[]} items    The array of editor inserter block items to be sorted.
 * @param {string[]}               priority The array of block names to be prioritized.
 * @return {WPEditorInserterItem[]} The sorted array of editor inserter block items.
 */
const orderInserterBlockItems = (items, priority) => {
  if (!priority) {
    return items;
  }
  items.sort(({
    id: aName
  }, {
    id: bName
  }) => {
    // Sort block items according to `priority`.
    let aIndex = priority.indexOf(aName);
    let bIndex = priority.indexOf(bName);
    // All other block items should come after that.
    if (aIndex < 0) {
      aIndex = priority.length;
    }
    if (bIndex < 0) {
      bIndex = priority.length;
    }
    return aIndex - bIndex;
  });
  return items;
};
//# sourceMappingURL=order-inserter-block-items.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/search-results.js
/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */















const search_results_INITIAL_INSERTER_RESULTS = 9;
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation and rerendering the component.
 *
 * @type {Array}
 */
const search_results_EMPTY_ARRAY = [];
function InserterSearchResults({
  filterValue,
  onSelect,
  onHover,
  onHoverPattern,
  rootClientId,
  clientId,
  isAppender,
  __experimentalInsertionIndex,
  maxBlockPatterns,
  maxBlockTypes,
  showBlockDirectory = false,
  isDraggable = true,
  shouldFocusBlock = true,
  prioritizePatterns,
  selectBlockOnInsert,
  isQuick
}) {
  const debouncedSpeak = (0,use_debounce/* default */.A)(a11y_build_module/* speak */.L, 500);
  const {
    prioritizedBlocks
  } = (0,use_select/* default */.A)(select => {
    const blockListSettings = select(store_store).getBlockListSettings(rootClientId);
    return {
      prioritizedBlocks: blockListSettings?.prioritizedInserterBlocks || search_results_EMPTY_ARRAY
    };
  }, [rootClientId]);
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock,
    selectBlockOnInsert
  });
  const [blockTypes, blockTypeCategories, blockTypeCollections, onSelectBlockType] = use_block_types_state(destinationRootClientId, onInsertBlocks, isQuick);
  const [patterns,, onClickPattern] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const filteredBlockPatterns = (0,react.useMemo)(() => {
    if (maxBlockPatterns === 0) {
      return [];
    }
    const results = searchItems(patterns, filterValue);
    return maxBlockPatterns !== undefined ? results.slice(0, maxBlockPatterns) : results;
  }, [filterValue, patterns, maxBlockPatterns]);
  let maxBlockTypesToShow = maxBlockTypes;
  if (prioritizePatterns && filteredBlockPatterns.length > 2) {
    maxBlockTypesToShow = 0;
  }
  const filteredBlockTypes = (0,react.useMemo)(() => {
    if (maxBlockTypesToShow === 0) {
      return [];
    }
    const nonPatternBlockTypes = blockTypes.filter(blockType => blockType.name !== 'core/block');
    let orderedItems = orderBy(nonPatternBlockTypes, 'frecency', 'desc');
    if (!filterValue && prioritizedBlocks.length) {
      orderedItems = orderInserterBlockItems(orderedItems, prioritizedBlocks);
    }
    const results = searchBlockItems(orderedItems, blockTypeCategories, blockTypeCollections, filterValue);
    return maxBlockTypesToShow !== undefined ? results.slice(0, maxBlockTypesToShow) : results;
  }, [filterValue, blockTypes, blockTypeCategories, blockTypeCollections, maxBlockTypesToShow, prioritizedBlocks]);

  // Announce search results on change.
  (0,react.useEffect)(() => {
    if (!filterValue) {
      return;
    }
    const count = filteredBlockTypes.length + filteredBlockPatterns.length;
    const resultsFoundMessage = (0,i18n_build_module/* sprintf */.nv)( /* translators: %d: number of results. */
    (0,i18n_build_module._n)('%d result found.', '%d results found.', count), count);
    debouncedSpeak(resultsFoundMessage);
  }, [filterValue, debouncedSpeak, filteredBlockTypes, filteredBlockPatterns]);
  const currentShownBlockTypes = use_async_list(filteredBlockTypes, {
    step: search_results_INITIAL_INSERTER_RESULTS
  });
  const currentShownPatterns = use_async_list(currentShownBlockTypes.length === filteredBlockTypes.length ? filteredBlockPatterns : search_results_EMPTY_ARRAY);
  const hasItems = filteredBlockTypes.length > 0 || filteredBlockPatterns.length > 0;
  const blocksUI = !!filteredBlockTypes.length && /*#__PURE__*/(0,jsx_runtime.jsx)(panel, {
    title: /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
      children: (0,i18n_build_module.__)('Blocks')
    }),
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_types_list, {
      items: currentShownBlockTypes,
      onSelect: onSelectBlockType,
      onHover: onHover,
      label: (0,i18n_build_module.__)('Blocks'),
      isDraggable: isDraggable
    })
  });
  const patternsUI = !!filteredBlockPatterns.length && /*#__PURE__*/(0,jsx_runtime.jsx)(panel, {
    title: /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
      children: (0,i18n_build_module.__)('Block patterns')
    }),
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-inserter__quick-inserter-patterns",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_patterns_list, {
        shownPatterns: currentShownPatterns,
        blockPatterns: filteredBlockPatterns,
        onClickPattern: onClickPattern,
        onHover: onHoverPattern,
        isDraggable: isDraggable
      })
    })
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(inserter_listbox, {
    children: [!showBlockDirectory && !hasItems && /*#__PURE__*/(0,jsx_runtime.jsx)(no_results, {}), prioritizePatterns ? patternsUI : blocksUI, !!filteredBlockTypes.length && !!filteredBlockPatterns.length && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-inserter__quick-inserter-separator"
    }), prioritizePatterns ? blocksUI : patternsUI, showBlockDirectory && /*#__PURE__*/(0,jsx_runtime.jsx)(inserter_menu_extension.Slot, {
      fillProps: {
        onSelect: onSelectBlockType,
        onHover,
        filterValue,
        hasItems,
        rootClientId: destinationRootClientId
      },
      children: fills => {
        if (fills.length) {
          return fills;
        }
        if (!hasItems) {
          return /*#__PURE__*/(0,jsx_runtime.jsx)(no_results, {});
        }
        return null;
      }
    })]
  });
}
/* harmony default export */ const search_results = (InserterSearchResults);
//# sourceMappingURL=search-results.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/tabs.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



const {
  Tabs: tabs_Tabs
} = lock_unlock_unlock(privateApis);
const blocksTab = {
  name: 'blocks',
  /* translators: Blocks tab title in the block inserter. */
  title: (0,i18n_build_module.__)('Blocks')
};
const patternsTab = {
  name: 'patterns',
  /* translators: Theme and Directory Patterns tab title in the block inserter. */
  title: (0,i18n_build_module.__)('Patterns')
};
const mediaTab = {
  name: 'media',
  /* translators: Media tab title in the block inserter. */
  title: (0,i18n_build_module.__)('Media')
};
function InserterTabs({
  onSelect,
  children,
  onClose,
  selectedTab
}, ref) {
  const tabs = [blocksTab, patternsTab, mediaTab];
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-inserter__tabs",
    ref: ref,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(tabs_Tabs, {
      onSelect: onSelect,
      selectedTabId: selectedTab,
      children: [/*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        className: "block-editor-inserter__tablist-and-close-button",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          className: "block-editor-inserter__close-button",
          icon: close_small/* default */.A,
          label: (0,i18n_build_module.__)('Close block inserter'),
          onClick: () => onClose(),
          size: "small"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tabs.TabList, {
          className: "block-editor-inserter__tablist",
          children: tabs.map(tab => /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tabs.Tab, {
            tabId: tab.name,
            className: "block-editor-inserter__tab",
            children: tab.title
          }, tab.name))
        })]
      }), tabs.map(tab => /*#__PURE__*/(0,jsx_runtime.jsx)(tabs_Tabs.TabPanel, {
        tabId: tab.name,
        focusable: false,
        className: "block-editor-inserter__tabpanel",
        children: children
      }, tab.name))]
    })
  });
}
/* harmony default export */ const inserter_tabs = ((0,react.forwardRef)(InserterTabs));
//# sourceMappingURL=tabs.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/menu.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */













const NOOP = () => {};
function InserterMenu({
  rootClientId,
  clientId,
  isAppender,
  __experimentalInsertionIndex,
  onSelect,
  showInserterHelpPanel,
  showMostUsedBlocks,
  __experimentalFilterValue = '',
  shouldFocusBlock = true,
  onPatternCategorySelection,
  onClose,
  __experimentalInitialTab,
  __experimentalInitialCategory
}, ref) {
  const isZoomOutMode = (0,use_select/* default */.A)(select => select(store_store).__unstableGetEditorMode() === 'zoom-out', []);
  const [filterValue, setFilterValue, delayedFilterValue] = useDebouncedInput(__experimentalFilterValue);
  const [hoveredItem, setHoveredItem] = (0,react.useState)(null);
  const [selectedPatternCategory, setSelectedPatternCategory] = (0,react.useState)(__experimentalInitialCategory);
  const [patternFilter, setPatternFilter] = (0,react.useState)('all');
  const [selectedMediaCategory, setSelectedMediaCategory] = (0,react.useState)(null);
  const [selectedTab, setSelectedTab] = (0,react.useState)(__experimentalInitialTab);
  const [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint] = use_insertion_point({
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock
  });
  const blockTypesTabRef = (0,react.useRef)();
  const onInsert = (0,react.useCallback)((blocks, meta, shouldForceFocusBlock, _rootClientId) => {
    onInsertBlocks(blocks, meta, shouldForceFocusBlock, _rootClientId);
    onSelect();

    // Check for focus loss due to filtering blocks by selected block type
    window.requestAnimationFrame(() => {
      if (!shouldFocusBlock && !blockTypesTabRef?.current.contains(ref.current.ownerDocument.activeElement)) {
        // There has been a focus loss, so focus the first button in the block types tab
        blockTypesTabRef?.current.querySelector('button').focus();
      }
    });
  }, [onInsertBlocks, onSelect, shouldFocusBlock]);
  const onInsertPattern = (0,react.useCallback)((blocks, patternName) => {
    onInsertBlocks(blocks, {
      patternName
    });
    onSelect();
  }, [onInsertBlocks, onSelect]);
  const onHover = (0,react.useCallback)(item => {
    onToggleInsertionPoint(item);
    setHoveredItem(item);
  }, [onToggleInsertionPoint, setHoveredItem]);
  const onHoverPattern = (0,react.useCallback)(item => {
    onToggleInsertionPoint(!!item);
  }, [onToggleInsertionPoint]);
  const onClickPatternCategory = (0,react.useCallback)((patternCategory, filter) => {
    setSelectedPatternCategory(patternCategory);
    setPatternFilter(filter);
    onPatternCategorySelection?.();
  }, [setSelectedPatternCategory, onPatternCategorySelection]);
  const showPatternPanel = selectedTab === 'patterns' && !delayedFilterValue && !!selectedPatternCategory;
  const showMediaPanel = selectedTab === 'media' && !!selectedMediaCategory;
  const inserterSearch = (0,react.useMemo)(() => {
    if (selectedTab === 'media') {
      return null;
    }
    return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(search_control, {
        __nextHasNoMarginBottom: true,
        className: "block-editor-inserter__search",
        onChange: value => {
          if (hoveredItem) {
            setHoveredItem(null);
          }
          setFilterValue(value);
        },
        value: filterValue,
        label: (0,i18n_build_module.__)('Search for blocks and patterns'),
        placeholder: (0,i18n_build_module.__)('Search')
      }), !!delayedFilterValue && /*#__PURE__*/(0,jsx_runtime.jsx)(search_results, {
        filterValue: delayedFilterValue,
        onSelect: onSelect,
        onHover: onHover,
        onHoverPattern: onHoverPattern,
        rootClientId: rootClientId,
        clientId: clientId,
        isAppender: isAppender,
        __experimentalInsertionIndex: __experimentalInsertionIndex,
        showBlockDirectory: true,
        shouldFocusBlock: shouldFocusBlock,
        prioritizePatterns: selectedTab === 'patterns'
      })]
    });
  }, [selectedTab, hoveredItem, setHoveredItem, setFilterValue, filterValue, delayedFilterValue, onSelect, onHover, onHoverPattern, shouldFocusBlock, clientId, rootClientId, __experimentalInsertionIndex, isAppender]);
  const blocksTab = (0,react.useMemo)(() => {
    return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: "block-editor-inserter__block-list",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_types_tab, {
          ref: blockTypesTabRef,
          rootClientId: destinationRootClientId,
          onInsert: onInsert,
          onHover: onHover,
          showMostUsedBlocks: showMostUsedBlocks
        })
      }), showInserterHelpPanel && /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        className: "block-editor-inserter__tips",
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
          as: "h2",
          children: (0,i18n_build_module.__)('A tip for using the block editor')
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(tips, {})]
      })]
    });
  }, [destinationRootClientId, onInsert, onHover, showMostUsedBlocks, showInserterHelpPanel]);
  const patternsTab = (0,react.useMemo)(() => {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(block_patterns_tab, {
      rootClientId: destinationRootClientId,
      onInsert: onInsertPattern,
      onSelectCategory: onClickPatternCategory,
      selectedCategory: selectedPatternCategory,
      children: showPatternPanel && /*#__PURE__*/(0,jsx_runtime.jsx)(PatternCategoryPreviewPanel, {
        rootClientId: destinationRootClientId,
        onInsert: onInsertPattern,
        onHover: onHoverPattern,
        category: selectedPatternCategory,
        patternFilter: patternFilter,
        showTitlesAsTooltip: true
      })
    });
  }, [destinationRootClientId, onHoverPattern, onInsertPattern, onClickPatternCategory, patternFilter, selectedPatternCategory, showPatternPanel]);
  const mediaTab = (0,react.useMemo)(() => {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(media_tab, {
      rootClientId: destinationRootClientId,
      selectedCategory: selectedMediaCategory,
      onSelectCategory: setSelectedMediaCategory,
      onInsert: onInsert,
      children: showMediaPanel && /*#__PURE__*/(0,jsx_runtime.jsx)(MediaCategoryPanel, {
        rootClientId: destinationRootClientId,
        onInsert: onInsert,
        category: selectedMediaCategory
      })
    });
  }, [destinationRootClientId, onInsert, selectedMediaCategory, setSelectedMediaCategory, showMediaPanel]);
  const handleSetSelectedTab = value => {
    // If no longer on patterns tab remove the category setting.
    if (value !== 'patterns') {
      setSelectedPatternCategory(null);
    }
    setSelectedTab(value);
  };

  // Focus first active tab, if any
  const tabsRef = (0,react.useRef)();
  (0,react.useLayoutEffect)(() => {
    if (tabsRef.current) {
      window.requestAnimationFrame(() => {
        tabsRef.current.querySelector('[role="tab"][aria-selected="true"]')?.focus();
      });
    }
  }, []);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: (0,dist_clsx/* default */.A)('block-editor-inserter__menu', {
      'show-panel': showPatternPanel || showMediaPanel,
      'is-zoom-out': isZoomOutMode
    }),
    ref: ref,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-inserter__main-area",
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(inserter_tabs, {
        ref: tabsRef,
        onSelect: handleSetSelectedTab,
        onClose: onClose,
        selectedTab: selectedTab,
        children: [inserterSearch, selectedTab === 'blocks' && !delayedFilterValue && blocksTab, selectedTab === 'patterns' && !delayedFilterValue && patternsTab, selectedTab === 'media' && mediaTab]
      })
    }), showInserterHelpPanel && hoveredItem && /*#__PURE__*/(0,jsx_runtime.jsx)(popover/* default */.Ay, {
      className: "block-editor-inserter__preview-container__popover",
      placement: "right-start",
      offset: 16,
      focusOnMount: false,
      animate: false,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(preview_panel, {
        item: hoveredItem
      })
    })]
  });
}
const PrivateInserterMenu = (0,react.forwardRef)(InserterMenu);
function PublicInserterMenu(props, ref) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(PrivateInserterMenu, {
    ...props,
    onPatternCategorySelection: NOOP,
    ref: ref
  });
}
/* harmony default export */ const inserter_menu = ((0,react.forwardRef)(PublicInserterMenu));
//# sourceMappingURL=menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/quick-inserter.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







const SEARCH_THRESHOLD = 6;
const SHOWN_BLOCK_TYPES = 6;
const SHOWN_BLOCK_PATTERNS = 2;
const SHOWN_BLOCK_PATTERNS_WITH_PRIORITIZATION = 4;
function QuickInserter({
  onSelect,
  rootClientId,
  clientId,
  isAppender,
  prioritizePatterns,
  selectBlockOnInsert,
  hasSearch = true
}) {
  const [filterValue, setFilterValue] = (0,react.useState)('');
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    selectBlockOnInsert
  });
  const [blockTypes] = use_block_types_state(destinationRootClientId, onInsertBlocks, true);
  const [patterns] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const {
    setInserterIsOpened,
    insertionIndex
  } = (0,use_select/* default */.A)(select => {
    const {
      getSettings,
      getBlockIndex,
      getBlockCount
    } = select(store_store);
    const settings = getSettings();
    const index = getBlockIndex(clientId);
    const blockCount = getBlockCount();
    return {
      setInserterIsOpened: settings.__experimentalSetIsInserterOpened,
      insertionIndex: index === -1 ? blockCount : index
    };
  }, [clientId]);
  const showPatterns = patterns.length && (!!filterValue || prioritizePatterns);
  const showSearch = hasSearch && (showPatterns && patterns.length > SEARCH_THRESHOLD || blockTypes.length > SEARCH_THRESHOLD);
  (0,react.useEffect)(() => {
    if (setInserterIsOpened) {
      setInserterIsOpened(false);
    }
  }, [setInserterIsOpened]);

  // When clicking Browse All select the appropriate block so as
  // the insertion point can work as expected.
  const onBrowseAll = () => {
    setInserterIsOpened({
      rootClientId,
      insertionIndex,
      filterValue
    });
  };
  let maxBlockPatterns = 0;
  if (showPatterns) {
    maxBlockPatterns = prioritizePatterns ? SHOWN_BLOCK_PATTERNS_WITH_PRIORITIZATION : SHOWN_BLOCK_PATTERNS;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: (0,dist_clsx/* default */.A)('block-editor-inserter__quick-inserter', {
      'has-search': showSearch,
      'has-expand': setInserterIsOpened
    }),
    children: [showSearch && /*#__PURE__*/(0,jsx_runtime.jsx)(search_control, {
      __nextHasNoMarginBottom: true,
      className: "block-editor-inserter__search",
      value: filterValue,
      onChange: value => {
        setFilterValue(value);
      },
      label: (0,i18n_build_module.__)('Search for blocks and patterns'),
      placeholder: (0,i18n_build_module.__)('Search')
    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-inserter__quick-inserter-results",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(search_results, {
        filterValue: filterValue,
        onSelect: onSelect,
        rootClientId: rootClientId,
        clientId: clientId,
        isAppender: isAppender,
        maxBlockPatterns: maxBlockPatterns,
        maxBlockTypes: SHOWN_BLOCK_TYPES,
        isDraggable: false,
        prioritizePatterns: prioritizePatterns,
        selectBlockOnInsert: selectBlockOnInsert,
        isQuick: true
      })
    }), setInserterIsOpened && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      className: "block-editor-inserter__quick-inserter-expand",
      onClick: onBrowseAll,
      "aria-label": (0,i18n_build_module.__)('Browse all. This will open the main inserter panel in the editor toolbar.'),
      children: (0,i18n_build_module.__)('Browse all')
    })]
  });
}
//# sourceMappingURL=quick-inserter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inserter/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */




const defaultRenderToggle = ({
  onToggle,
  disabled,
  isOpen,
  blockTitle,
  hasSingleBlockType,
  toggleProps = {},
  prioritizePatterns
}) => {
  const {
    as: Wrapper = build_module_button/* default */.Ay,
    label: labelProp,
    onClick,
    ...rest
  } = toggleProps;
  let label = labelProp;
  if (!label && hasSingleBlockType) {
    label = (0,i18n_build_module/* sprintf */.nv)(
    // translators: %s: the name of the block when there is only one
    (0,i18n_build_module._x)('Add %s', 'directly add the only allowed block'), blockTitle);
  } else if (!label && prioritizePatterns) {
    label = (0,i18n_build_module.__)('Add pattern');
  } else if (!label) {
    label = (0,i18n_build_module._x)('Add block', 'Generic label for block inserter button');
  }

  // Handle both onClick functions from the toggle and the parent component.
  function handleClick(event) {
    if (onToggle) {
      onToggle(event);
    }
    if (onClick) {
      onClick(event);
    }
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Wrapper, {
    icon: plus/* default */.A,
    label: label,
    tooltipPosition: "bottom",
    onClick: handleClick,
    className: "block-editor-inserter__toggle",
    "aria-haspopup": !hasSingleBlockType ? 'true' : false,
    "aria-expanded": !hasSingleBlockType ? isOpen : false,
    disabled: disabled,
    ...rest
  });
};
class PrivateInserter extends react.Component {
  constructor() {
    super(...arguments);
    this.onToggle = this.onToggle.bind(this);
    this.renderToggle = this.renderToggle.bind(this);
    this.renderContent = this.renderContent.bind(this);
  }
  onToggle(isOpen) {
    const {
      onToggle
    } = this.props;

    // Surface toggle callback to parent component.
    if (onToggle) {
      onToggle(isOpen);
    }
  }

  /**
   * Render callback to display Dropdown toggle element.
   *
   * @param {Object}   options
   * @param {Function} options.onToggle Callback to invoke when toggle is
   *                                    pressed.
   * @param {boolean}  options.isOpen   Whether dropdown is currently open.
   *
   * @return {Element} Dropdown toggle element.
   */
  renderToggle({
    onToggle,
    isOpen
  }) {
    const {
      disabled,
      blockTitle,
      hasSingleBlockType,
      directInsertBlock,
      toggleProps,
      hasItems,
      renderToggle = defaultRenderToggle,
      prioritizePatterns
    } = this.props;
    return renderToggle({
      onToggle,
      isOpen,
      disabled: disabled || !hasItems,
      blockTitle,
      hasSingleBlockType,
      directInsertBlock,
      toggleProps,
      prioritizePatterns
    });
  }

  /**
   * Render callback to display Dropdown content element.
   *
   * @param {Object}   options
   * @param {Function} options.onClose Callback to invoke when dropdown is
   *                                   closed.
   *
   * @return {Element} Dropdown content element.
   */
  renderContent({
    onClose
  }) {
    const {
      rootClientId,
      clientId,
      isAppender,
      showInserterHelpPanel,
      // This prop is experimental to give some time for the quick inserter to mature
      // Feel free to make them stable after a few releases.
      __experimentalIsQuick: isQuick,
      prioritizePatterns,
      onSelectOrClose,
      selectBlockOnInsert
    } = this.props;
    if (isQuick) {
      return /*#__PURE__*/(0,jsx_runtime.jsx)(QuickInserter, {
        onSelect: blocks => {
          const firstBlock = Array.isArray(blocks) && blocks?.length ? blocks[0] : blocks;
          if (onSelectOrClose && typeof onSelectOrClose === 'function') {
            onSelectOrClose(firstBlock);
          }
          onClose();
        },
        rootClientId: rootClientId,
        clientId: clientId,
        isAppender: isAppender,
        prioritizePatterns: prioritizePatterns,
        selectBlockOnInsert: selectBlockOnInsert
      });
    }
    return /*#__PURE__*/(0,jsx_runtime.jsx)(inserter_menu, {
      onSelect: () => {
        onClose();
      },
      rootClientId: rootClientId,
      clientId: clientId,
      isAppender: isAppender,
      showInserterHelpPanel: showInserterHelpPanel
    });
  }
  render() {
    const {
      position,
      hasSingleBlockType,
      directInsertBlock,
      insertOnlyAllowedBlock,
      __experimentalIsQuick: isQuick,
      onSelectOrClose
    } = this.props;
    if (hasSingleBlockType || directInsertBlock) {
      return this.renderToggle({
        onToggle: insertOnlyAllowedBlock
      });
    }
    return /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown/* default */.A, {
      className: "block-editor-inserter",
      contentClassName: (0,dist_clsx/* default */.A)('block-editor-inserter__popover', {
        'is-quick': isQuick
      }),
      popoverProps: {
        position,
        shift: true
      },
      onToggle: this.onToggle,
      expandOnMobile: true,
      headerTitle: (0,i18n_build_module.__)('Add a block'),
      renderToggle: this.renderToggle,
      renderContent: this.renderContent,
      onClose: onSelectOrClose
    });
  }
}
const ComposedPrivateInserter = (0,compose/* default */.A)([with_select((select, {
  clientId,
  rootClientId,
  shouldDirectInsert = true
}) => {
  const {
    getBlockRootClientId,
    hasInserterItems,
    getAllowedBlocks,
    getDirectInsertBlock,
    getSettings
  } = select(store_store);
  const {
    getBlockVariations
  } = select(build_module/* store */.M_);
  rootClientId = rootClientId || getBlockRootClientId(clientId) || undefined;
  const allowedBlocks = getAllowedBlocks(rootClientId);
  const directInsertBlock = shouldDirectInsert && getDirectInsertBlock(rootClientId);
  const settings = getSettings();
  const hasSingleBlockType = allowedBlocks?.length === 1 && getBlockVariations(allowedBlocks[0].name, 'inserter')?.length === 0;
  let allowedBlockType = false;
  if (hasSingleBlockType) {
    allowedBlockType = allowedBlocks[0];
  }
  return {
    hasItems: hasInserterItems(rootClientId),
    hasSingleBlockType,
    blockTitle: allowedBlockType ? allowedBlockType.title : '',
    allowedBlockType,
    directInsertBlock,
    rootClientId,
    prioritizePatterns: settings.__experimentalPreferPatternsOnRoot && !rootClientId
  };
}), with_dispatch((dispatch, ownProps, {
  select
}) => {
  return {
    insertOnlyAllowedBlock() {
      const {
        rootClientId,
        clientId,
        isAppender,
        hasSingleBlockType,
        allowedBlockType,
        directInsertBlock,
        onSelectOrClose,
        selectBlockOnInsert
      } = ownProps;
      if (!hasSingleBlockType && !directInsertBlock) {
        return;
      }
      function getAdjacentBlockAttributes(attributesToCopy) {
        const {
          getBlock,
          getPreviousBlockClientId
        } = select(store_store);
        if (!attributesToCopy || !clientId && !rootClientId) {
          return {};
        }
        const result = {};
        let adjacentAttributes = {};

        // If there is no clientId, then attempt to get attributes
        // from the last block within innerBlocks of the root block.
        if (!clientId) {
          const parentBlock = getBlock(rootClientId);
          if (parentBlock?.innerBlocks?.length) {
            const lastInnerBlock = parentBlock.innerBlocks[parentBlock.innerBlocks.length - 1];
            if (directInsertBlock && directInsertBlock?.name === lastInnerBlock.name) {
              adjacentAttributes = lastInnerBlock.attributes;
            }
          }
        } else {
          // Otherwise, attempt to get attributes from the
          // previous block relative to the current clientId.
          const currentBlock = getBlock(clientId);
          const previousBlock = getBlock(getPreviousBlockClientId(clientId));
          if (currentBlock?.name === previousBlock?.name) {
            adjacentAttributes = previousBlock?.attributes || {};
          }
        }

        // Copy over only those attributes flagged to be copied.
        attributesToCopy.forEach(attribute => {
          if (adjacentAttributes.hasOwnProperty(attribute)) {
            result[attribute] = adjacentAttributes[attribute];
          }
        });
        return result;
      }
      function getInsertionIndex() {
        const {
          getBlockIndex,
          getBlockSelectionEnd,
          getBlockOrder,
          getBlockRootClientId
        } = select(store_store);

        // If the clientId is defined, we insert at the position of the block.
        if (clientId) {
          return getBlockIndex(clientId);
        }

        // If there a selected block, we insert after the selected block.
        const end = getBlockSelectionEnd();
        if (!isAppender && end && getBlockRootClientId(end) === rootClientId) {
          return getBlockIndex(end) + 1;
        }

        // Otherwise, we insert at the end of the current rootClientId.
        return getBlockOrder(rootClientId).length;
      }
      const {
        insertBlock
      } = dispatch(store_store);
      let blockToInsert;

      // Attempt to augment the directInsertBlock with attributes from an adjacent block.
      // This ensures styling from nearby blocks is preserved in the newly inserted block.
      // See: https://github.com/WordPress/gutenberg/issues/37904
      if (directInsertBlock) {
        const newAttributes = getAdjacentBlockAttributes(directInsertBlock.attributesToCopy);
        blockToInsert = (0,build_module/* createBlock */.Wv)(directInsertBlock.name, {
          ...(directInsertBlock.attributes || {}),
          ...newAttributes
        });
      } else {
        blockToInsert = (0,build_module/* createBlock */.Wv)(allowedBlockType.name);
      }
      insertBlock(blockToInsert, getInsertionIndex(), rootClientId, selectBlockOnInsert);
      if (onSelectOrClose) {
        onSelectOrClose({
          clientId: blockToInsert?.clientId
        });
      }
      const message = (0,i18n_build_module/* sprintf */.nv)(
      // translators: %s: the name of the block that has been added
      (0,i18n_build_module.__)('%s block added'), allowedBlockType.title);
      (0,a11y_build_module/* speak */.L)(message);
    }
  };
}),
// The global inserter should always be visible, we are using ( ! isAppender && ! rootClientId && ! clientId ) as
// a way to detect the global Inserter.
if_condition(({
  hasItems,
  isAppender,
  rootClientId,
  clientId
}) => hasItems || !isAppender && !rootClientId && !clientId)])(PrivateInserter);
const Inserter = (0,react.forwardRef)((props, ref) => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(ComposedPrivateInserter, {
    ref: ref,
    ...props
  });
});
/* harmony default export */ const inserter = (Inserter);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/default-block-appender/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/**
 * Zero width non-breaking space, used as padding for the paragraph when it is
 * empty.
 */


const ZWNBSP = '\ufeff';
function DefaultBlockAppender({
  rootClientId
}) {
  const {
    showPrompt,
    isLocked,
    placeholder
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockCount,
      getSettings,
      getTemplateLock
    } = select(store_store);
    const isEmpty = !getBlockCount(rootClientId);
    const {
      bodyPlaceholder
    } = getSettings();
    return {
      showPrompt: isEmpty,
      isLocked: !!getTemplateLock(rootClientId),
      placeholder: bodyPlaceholder
    };
  }, [rootClientId]);
  const {
    insertDefaultBlock,
    startTyping
  } = (0,use_dispatch/* default */.A)(store_store);
  if (isLocked) {
    return null;
  }
  const value = (0,html_entities_build_module/* decodeEntities */.S)(placeholder) || (0,i18n_build_module.__)('Type / to choose a block');
  const onAppend = () => {
    insertDefaultBlock(undefined, rootClientId);
    startTyping();
  };
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    "data-root-client-id": rootClientId || '',
    className: (0,dist_clsx/* default */.A)('block-editor-default-block-appender', {
      'has-visible-prompt': showPrompt
    }),
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("p", {
      tabIndex: "0"
      // We want this element to be styled as a paragraph by themes.
      // eslint-disable-next-line jsx-a11y/no-noninteractive-element-to-interactive-role
      ,
      role: "button",
      "aria-label": (0,i18n_build_module.__)('Add default block')
      // A wrapping container for this one already has the wp-block className.
      ,
      className: "block-editor-default-block-appender__content",
      onKeyDown: event => {
        if (keycodes_build_module/* ENTER */.Fm === event.keyCode || keycodes_build_module/* SPACE */.t6 === event.keyCode) {
          onAppend();
        }
      },
      onClick: () => onAppend(),
      onFocus: () => {
        if (showPrompt) {
          onAppend();
        }
      },
      children: showPrompt ? value : ZWNBSP
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(inserter, {
      rootClientId: rootClientId,
      position: "bottom right",
      isAppender: true,
      __experimentalIsQuick: true
    })]
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/button-block-appender/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



function ButtonBlockAppender({
  rootClientId,
  className,
  onFocus,
  tabIndex
}, ref) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inserter, {
    position: "bottom center",
    rootClientId: rootClientId,
    __experimentalIsQuick: true,
    renderToggle: ({
      onToggle,
      disabled,
      isOpen,
      blockTitle,
      hasSingleBlockType
    }) => {
      let label;
      if (hasSingleBlockType) {
        label = (0,i18n_build_module/* sprintf */.nv)(
        // translators: %s: the name of the block when there is only one
        (0,i18n_build_module._x)('Add %s', 'directly add the only allowed block'), blockTitle);
      } else {
        label = (0,i18n_build_module._x)('Add block', 'Generic label for block inserter button');
      }
      const isToggleButton = !hasSingleBlockType;
      let inserterButton = /*#__PURE__*/(0,jsx_runtime.jsxs)(build_module_button/* default */.Ay, {
        ref: ref,
        onFocus: onFocus,
        tabIndex: tabIndex,
        className: (0,dist_clsx/* default */.A)(className, 'block-editor-button-block-appender'),
        onClick: onToggle,
        "aria-haspopup": isToggleButton ? 'true' : undefined,
        "aria-expanded": isToggleButton ? isOpen : undefined
        // Disable reason: There shouldn't be a case where this button is disabled but not visually hidden.
        // eslint-disable-next-line no-restricted-syntax
        ,
        disabled: disabled,
        label: label,
        children: [!hasSingleBlockType && /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
          as: "span",
          children: label
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_icon/* default */.A, {
          icon: plus/* default */.A
        })]
      });
      if (isToggleButton || hasSingleBlockType) {
        inserterButton = /*#__PURE__*/(0,jsx_runtime.jsx)(tooltip/* default */.Ay, {
          text: label,
          children: inserterButton
        });
      }
      return inserterButton;
    },
    isAppender: true
  });
}

/**
 * Use `ButtonBlockAppender` instead.
 *
 * @deprecated
 */
const ButtonBlockerAppender = (0,react.forwardRef)((props, ref) => {
  (0,deprecated_build_module/* default */.A)(`wp.blockEditor.ButtonBlockerAppender`, {
    alternative: 'wp.blockEditor.ButtonBlockAppender',
    since: '5.9'
  });
  return ButtonBlockAppender(props, ref);
});

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/button-block-appender/README.md
 */
/* harmony default export */ const button_block_appender = ((0,react.forwardRef)(ButtonBlockAppender));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list-appender/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function DefaultAppender({
  rootClientId
}) {
  const canInsertDefaultBlock = (0,use_select/* default */.A)(select => select(store_store).canInsertBlockType((0,build_module/* getDefaultBlockName */.K$)(), rootClientId));
  if (canInsertDefaultBlock) {
    // Render the default block appender if the context supports use
    // of the default appender.
    return /*#__PURE__*/(0,jsx_runtime.jsx)(DefaultBlockAppender, {
      rootClientId: rootClientId
    });
  }

  // Fallback in case the default block can't be inserted.
  return /*#__PURE__*/(0,jsx_runtime.jsx)(button_block_appender, {
    rootClientId: rootClientId,
    className: "block-list-appender__toggle"
  });
}
function BlockListAppender({
  rootClientId,
  CustomAppender,
  className,
  tagName: TagName = 'div'
}) {
  const isDragOver = (0,use_select/* default */.A)(select => {
    const {
      getBlockInsertionPoint,
      isBlockInsertionPointVisible,
      getBlockCount
    } = select(store_store);
    const insertionPoint = getBlockInsertionPoint();
    // Ideally we should also check for `isDragging` but currently it
    // requires a lot more setup. We can revisit this once we refactor
    // the DnD utility hooks.
    return isBlockInsertionPointVisible() && rootClientId === insertionPoint?.rootClientId && getBlockCount(rootClientId) === 0;
  }, [rootClientId]);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(TagName
  // A `tabIndex` is used on the wrapping `div` element in order to
  // force a focus event to occur when an appender `button` element
  // is clicked. In some browsers (Firefox, Safari), button clicks do
  // not emit a focus event, which could cause this event to propagate
  // unexpectedly. The `tabIndex` ensures that the interaction is
  // captured as a focus, without also adding an extra tab stop.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
  , {
    tabIndex: -1,
    className: (0,dist_clsx/* default */.A)('block-list-appender wp-block', className, {
      'is-drag-over': isDragOver
    })
    // Needed in case the whole editor is content editable (for multi
    // selection). It fixes an edge case where ArrowDown and ArrowRight
    // should collapse the selection to the end of that selection and
    // not into the appender.
    ,
    contentEditable: false
    // The appender exists to let you add the first Paragraph before
    // any is inserted. To that end, this appender should visually be
    // presented as a block. That means theme CSS should style it as if
    // it were an empty paragraph block. That means a `wp-block` class to
    // ensure the width is correct, and a [data-block] attribute to ensure
    // the correct margin is applied, especially for classic themes which
    // have commonly targeted that attribute for margins.
    ,
    "data-block": true,
    children: CustomAppender ? /*#__PURE__*/(0,jsx_runtime.jsx)(CustomAppender, {}) : /*#__PURE__*/(0,jsx_runtime.jsx)(DefaultAppender, {
      rootClientId: rootClientId
    })
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-popover/inbetween.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const inbetween_MAX_POPOVER_RECOMPUTE_COUNTER = Number.MAX_SAFE_INTEGER;
const InsertionPointOpenRef = (0,react.createContext)();
function BlockPopoverInbetween({
  previousClientId,
  nextClientId,
  children,
  __unstablePopoverSlot,
  __unstableContentRef,
  operation = 'insert',
  nearestSide = 'right',
  ...props
}) {
  // This is a temporary hack to get the inbetween inserter to recompute properly.
  const [popoverRecomputeCounter, forcePopoverRecompute] = (0,react.useReducer)(
  // Module is there to make sure that the counter doesn't overflow.
  s => (s + 1) % inbetween_MAX_POPOVER_RECOMPUTE_COUNTER, 0);
  const {
    orientation,
    rootClientId,
    isVisible
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockListSettings,
      getBlockRootClientId,
      isBlockVisible
    } = select(store_store);
    const _rootClientId = getBlockRootClientId(previousClientId !== null && previousClientId !== void 0 ? previousClientId : nextClientId);
    return {
      orientation: getBlockListSettings(_rootClientId)?.orientation || 'vertical',
      rootClientId: _rootClientId,
      isVisible: isBlockVisible(previousClientId) && isBlockVisible(nextClientId)
    };
  }, [previousClientId, nextClientId]);
  const previousElement = useBlockElement(previousClientId);
  const nextElement = useBlockElement(nextClientId);
  const isVertical = orientation === 'vertical';
  const popoverAnchor = (0,react.useMemo)(() => {
    if (
    // popoverRecomputeCounter is by definition always equal or greater than 0.
    // This check is only there to satisfy the correctness of the
    // exhaustive-deps rule for the `useMemo` hook.
    popoverRecomputeCounter < 0 || !previousElement && !nextElement || !isVisible) {
      return undefined;
    }
    const contextElement = operation === 'group' ? nextElement || previousElement : previousElement || nextElement;
    return {
      contextElement,
      getBoundingClientRect() {
        const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
        const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;
        let left = 0;
        let top = 0;
        let width = 0;
        let height = 0;
        if (operation === 'group') {
          const targetRect = nextRect || previousRect;
          top = targetRect.top;
          // No spacing is likely around blocks in this operation.
          // So width of the inserter containing rect is set to 0.
          width = 0;
          height = targetRect.bottom - targetRect.top;
          // Popover calculates its distance from mid-block so some
          // adjustments are needed to make it appear in the right place.
          left = nearestSide === 'left' ? targetRect.left - 2 : targetRect.right - 2;
        } else if (isVertical) {
          // vertical
          top = previousRect ? previousRect.bottom : nextRect.top;
          width = previousRect ? previousRect.width : nextRect.width;
          height = nextRect && previousRect ? nextRect.top - previousRect.bottom : 0;
          left = previousRect ? previousRect.left : nextRect.left;
        } else {
          top = previousRect ? previousRect.top : nextRect.top;
          height = previousRect ? previousRect.height : nextRect.height;
          if ((0,i18n_build_module/* isRTL */.V8)()) {
            // non vertical, rtl
            left = nextRect ? nextRect.right : previousRect.left;
            width = previousRect && nextRect ? previousRect.left - nextRect.right : 0;
          } else {
            // non vertical, ltr
            left = previousRect ? previousRect.right : nextRect.left;
            width = previousRect && nextRect ? nextRect.left - previousRect.right : 0;
          }
        }
        return new window.DOMRect(left, top, width, height);
      }
    };
  }, [previousElement, nextElement, popoverRecomputeCounter, isVertical, isVisible, operation, nearestSide]);
  const popoverScrollRef = use_popover_scroll(__unstableContentRef);

  // This is only needed for a smooth transition when moving blocks.
  // When blocks are moved up/down, their position can be set by
  // updating the `transform` property manually (i.e. without using CSS
  // transitions or animations). The animation, which can also scroll the block
  // editor, can sometimes cause the position of the Popover to get out of sync.
  // A MutationObserver is therefore used to make sure that changes to the
  // selectedElement's attribute (i.e. `transform`) can be tracked and used to
  // trigger the Popover to rerender.
  (0,react.useLayoutEffect)(() => {
    if (!previousElement) {
      return;
    }
    const observer = new window.MutationObserver(forcePopoverRecompute);
    observer.observe(previousElement, {
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [previousElement]);
  (0,react.useLayoutEffect)(() => {
    if (!nextElement) {
      return;
    }
    const observer = new window.MutationObserver(forcePopoverRecompute);
    observer.observe(nextElement, {
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [nextElement]);
  (0,react.useLayoutEffect)(() => {
    if (!previousElement) {
      return;
    }
    previousElement.ownerDocument.defaultView.addEventListener('resize', forcePopoverRecompute);
    return () => {
      previousElement.ownerDocument.defaultView?.removeEventListener('resize', forcePopoverRecompute);
    };
  }, [previousElement]);

  // If there's either a previous or a next element, show the inbetween popover.
  // Note that drag and drop uses the inbetween popover to show the drop indicator
  // before the first block and after the last block.
  if (!previousElement && !nextElement || !isVisible) {
    return null;
  }

  /* eslint-disable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
  // While ideally it would be enough to capture the
  // bubbling focus event from the Inserter, due to the
  // characteristics of click focusing of `button`s in
  // Firefox and Safari, it is not reliable.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
  return /*#__PURE__*/(0,jsx_runtime.jsx)(popover/* default */.Ay, {
    ref: popoverScrollRef,
    animate: false,
    anchor: popoverAnchor,
    focusOnMount: false
    // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot,
    inline: !__unstablePopoverSlot
    // Forces a remount of the popover when its position changes
    // This makes sure the popover doesn't animate from its previous position.
    ,
    ...props,
    className: (0,dist_clsx/* default */.A)('block-editor-block-popover', 'block-editor-block-popover__inbetween', props.className),
    resize: false,
    flip: false,
    placement: "overlay",
    variant: "unstyled",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-block-popover__inbetween-container",
      children: children
    })
  }, nextClientId + '--' + rootClientId);
  /* eslint-enable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
}
/* harmony default export */ const inbetween = (BlockPopoverInbetween);
//# sourceMappingURL=inbetween.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-popover/drop-zone.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const animateVariants = {
  hide: {
    opacity: 0,
    scaleY: 0.75
  },
  show: {
    opacity: 1,
    scaleY: 1
  },
  exit: {
    opacity: 0,
    scaleY: 0.9
  }
};
function BlockDropZonePopover({
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const {
    clientId
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockOrder,
      getBlockInsertionPoint
    } = select(store_store);
    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);
    if (!order.length) {
      return {};
    }
    return {
      clientId: order[insertionPoint.index]
    };
  }, []);
  const reducedMotion = (0,use_reduced_motion/* default */.A)();
  return /*#__PURE__*/(0,jsx_runtime.jsx)(cover, {
    clientId: clientId,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef,
    className: "block-editor-block-popover__drop-zone",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(motion/* motion */.P.div, {
      "data-testid": "block-popover-drop-zone",
      initial: reducedMotion ? animateVariants.show : animateVariants.hide,
      animate: animateVariants.show,
      exit: reducedMotion ? animateVariants.show : animateVariants.exit,
      className: "block-editor-block-popover__drop-zone-foreground"
    })
  });
}
/* harmony default export */ const block_popover_drop_zone = (BlockDropZonePopover);
//# sourceMappingURL=drop-zone.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/insertion-point.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






const insertion_point_InsertionPointOpenRef = (0,react.createContext)();
function InbetweenInsertionPointPopover({
  __unstablePopoverSlot,
  __unstableContentRef,
  operation = 'insert',
  nearestSide = 'right'
}) {
  const {
    selectBlock,
    hideInsertionPoint
  } = (0,use_dispatch/* default */.A)(store_store);
  const openRef = (0,react.useContext)(insertion_point_InsertionPointOpenRef);
  const ref = (0,react.useRef)();
  const {
    orientation,
    previousClientId,
    nextClientId,
    rootClientId,
    isInserterShown,
    isDistractionFree,
    isNavigationMode
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockOrder,
      getBlockListSettings,
      getBlockInsertionPoint,
      isBlockBeingDragged,
      getPreviousBlockClientId,
      getNextBlockClientId,
      getSettings,
      isNavigationMode: _isNavigationMode
    } = select(store_store);
    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);
    if (!order.length) {
      return {};
    }
    let _previousClientId = order[insertionPoint.index - 1];
    let _nextClientId = order[insertionPoint.index];
    while (isBlockBeingDragged(_previousClientId)) {
      _previousClientId = getPreviousBlockClientId(_previousClientId);
    }
    while (isBlockBeingDragged(_nextClientId)) {
      _nextClientId = getNextBlockClientId(_nextClientId);
    }
    const settings = getSettings();
    return {
      previousClientId: _previousClientId,
      nextClientId: _nextClientId,
      orientation: getBlockListSettings(insertionPoint.rootClientId)?.orientation || 'vertical',
      rootClientId: insertionPoint.rootClientId,
      isNavigationMode: _isNavigationMode(),
      isDistractionFree: settings.isDistractionFree,
      isInserterShown: insertionPoint?.__unstableWithInserter
    };
  }, []);
  const {
    getBlockEditingMode
  } = (0,use_select/* default */.A)(store_store);
  const disableMotion = (0,use_reduced_motion/* default */.A)();
  function onClick(event) {
    if (event.target === ref.current && nextClientId && getBlockEditingMode(nextClientId) !== 'disabled') {
      selectBlock(nextClientId, -1);
    }
  }
  function maybeHideInserterPoint(event) {
    // Only hide the inserter if it's triggered on the wrapper,
    // and the inserter is not open.
    if (event.target === ref.current && !openRef.current) {
      hideInsertionPoint();
    }
  }
  function onFocus(event) {
    // Only handle click on the wrapper specifically, and not an event
    // bubbled from the inserter itself.
    if (event.target !== ref.current) {
      openRef.current = true;
    }
  }
  const lineVariants = {
    // Initial position starts from the center and invisible.
    start: {
      opacity: 0,
      scale: 0
    },
    // The line expands to fill the container. If the inserter is visible it
    // is delayed so it appears orchestrated.
    rest: {
      opacity: 1,
      scale: 1,
      transition: {
        delay: isInserterShown ? 0.5 : 0,
        type: 'tween'
      }
    },
    hover: {
      opacity: 1,
      scale: 1,
      transition: {
        delay: 0.5,
        type: 'tween'
      }
    }
  };
  const inserterVariants = {
    start: {
      scale: disableMotion ? 1 : 0
    },
    rest: {
      scale: 1,
      transition: {
        delay: 0.4,
        type: 'tween'
      }
    }
  };
  if (isDistractionFree && !isNavigationMode) {
    return null;
  }
  const orientationClassname = orientation === 'horizontal' || operation === 'group' ? 'is-horizontal' : 'is-vertical';
  const className = (0,dist_clsx/* default */.A)('block-editor-block-list__insertion-point', orientationClassname);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(inbetween, {
    previousClientId: previousClientId,
    nextClientId: nextClientId,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef,
    operation: operation,
    nearestSide: nearestSide,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(motion/* motion */.P.div, {
      layout: !disableMotion,
      initial: disableMotion ? 'rest' : 'start',
      animate: "rest",
      whileHover: "hover",
      whileTap: "pressed",
      exit: "start",
      ref: ref,
      tabIndex: -1,
      onClick: onClick,
      onFocus: onFocus,
      className: (0,dist_clsx/* default */.A)(className, {
        'is-with-inserter': isInserterShown
      }),
      onHoverEnd: maybeHideInserterPoint,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(motion/* motion */.P.div, {
        variants: lineVariants,
        className: "block-editor-block-list__insertion-point-indicator",
        "data-testid": "block-list-insertion-point-indicator"
      }), isInserterShown && /*#__PURE__*/(0,jsx_runtime.jsx)(motion/* motion */.P.div, {
        variants: inserterVariants,
        className: (0,dist_clsx/* default */.A)('block-editor-block-list__insertion-point-inserter'),
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(inserter, {
          position: "bottom center",
          clientId: nextClientId,
          rootClientId: rootClientId,
          __experimentalIsQuick: true,
          onToggle: isOpen => {
            openRef.current = isOpen;
          },
          onSelectOrClose: () => {
            openRef.current = false;
          }
        })
      })]
    })
  });
}
function InsertionPoint(props) {
  const {
    insertionPoint,
    isVisible,
    isBlockListEmpty
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockInsertionPoint,
      isBlockInsertionPointVisible,
      getBlockCount
    } = select(store_store);
    const blockInsertionPoint = getBlockInsertionPoint();
    return {
      insertionPoint: blockInsertionPoint,
      isVisible: isBlockInsertionPointVisible(),
      isBlockListEmpty: getBlockCount(blockInsertionPoint?.rootClientId) === 0
    };
  }, []);
  if (!isVisible ||
  // Don't render the insertion point if the block list is empty.
  // The insertion point will be represented by the appender instead.
  isBlockListEmpty) {
    return null;
  }

  /**
   * Render a popover that overlays the block when the desired operation is to replace it.
   * Otherwise, render a popover in between blocks for the indication of inserting between them.
   */
  return insertionPoint.operation === 'replace' ? /*#__PURE__*/(0,jsx_runtime.jsx)(block_popover_drop_zone
  // Force remount to trigger the animation.
  , {
    ...props
  }, `${insertionPoint.rootClientId}-${insertionPoint.index}`) : /*#__PURE__*/(0,jsx_runtime.jsx)(InbetweenInsertionPointPopover, {
    operation: insertionPoint.operation,
    nearestSide: insertionPoint.nearestSide,
    ...props
  });
}
//# sourceMappingURL=insertion-point.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/use-in-between-inserter.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


function useInBetweenInserter() {
  const openRef = (0,react.useContext)(insertion_point_InsertionPointOpenRef);
  const isInBetweenInserterDisabled = (0,use_select/* default */.A)(select => select(store_store).getSettings().isDistractionFree || select(store_store).__unstableGetEditorMode() === 'zoom-out', []);
  const {
    getBlockListSettings,
    getBlockIndex,
    isMultiSelecting,
    getSelectedBlockClientIds,
    getTemplateLock,
    __unstableIsWithinBlockOverlay,
    getBlockEditingMode,
    getBlockName
  } = (0,use_select/* default */.A)(store_store);
  const {
    showInsertionPoint,
    hideInsertionPoint
  } = (0,use_dispatch/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    if (isInBetweenInserterDisabled) {
      return;
    }
    function onMouseMove(event) {
      // openRef is the reference to the insertion point between blocks.
      // If the reference is not set or the insertion point is already open, return.
      if (openRef === undefined || openRef.current) {
        return;
      }

      // Ignore text nodes sometimes detected in FireFox.
      if (event.target.nodeType === event.target.TEXT_NODE) {
        return;
      }
      if (isMultiSelecting()) {
        return;
      }
      if (!event.target.classList.contains('block-editor-block-list__layout')) {
        hideInsertionPoint();
        return;
      }
      let rootClientId;
      if (!event.target.classList.contains('is-root-container')) {
        const blockElement = !!event.target.getAttribute('data-block') ? event.target : event.target.closest('[data-block]');
        rootClientId = blockElement.getAttribute('data-block');
      }
      if (getTemplateLock(rootClientId) || getBlockEditingMode(rootClientId) === 'disabled' || getBlockName(rootClientId) === 'core/block') {
        return;
      }
      const orientation = getBlockListSettings(rootClientId)?.orientation || 'vertical';
      const offsetTop = event.clientY;
      const offsetLeft = event.clientX;
      const children = Array.from(event.target.children);
      let element = children.find(blockEl => {
        const blockElRect = blockEl.getBoundingClientRect();
        return blockEl.classList.contains('wp-block') && orientation === 'vertical' && blockElRect.top > offsetTop || blockEl.classList.contains('wp-block') && orientation === 'horizontal' && ((0,i18n_build_module/* isRTL */.V8)() ? blockElRect.right < offsetLeft : blockElRect.left > offsetLeft);
      });
      if (!element) {
        hideInsertionPoint();
        return;
      }

      // The block may be in an alignment wrapper, so check the first direct
      // child if the element has no ID.
      if (!element.id) {
        element = element.firstElementChild;
        if (!element) {
          hideInsertionPoint();
          return;
        }
      }

      // Don't show the insertion point if a parent block has an "overlay"
      // See https://github.com/WordPress/gutenberg/pull/34012#pullrequestreview-727762337
      const clientId = element.id.slice('block-'.length);
      if (!clientId || __unstableIsWithinBlockOverlay(clientId)) {
        return;
      }

      // Don't show the inserter when hovering above (conflicts with
      // block toolbar) or inside selected block(s).
      if (getSelectedBlockClientIds().includes(clientId)) {
        return;
      }
      const elementRect = element.getBoundingClientRect();
      if (orientation === 'horizontal' && (event.clientY > elementRect.bottom || event.clientY < elementRect.top) || orientation === 'vertical' && (event.clientX > elementRect.right || event.clientX < elementRect.left)) {
        hideInsertionPoint();
        return;
      }
      const index = getBlockIndex(clientId);

      // Don't show the in-between inserter before the first block in
      // the list (preserves the original behaviour).
      if (index === 0) {
        hideInsertionPoint();
        return;
      }
      showInsertionPoint(rootClientId, index, {
        __unstableWithInserter: true
      });
    }
    node.addEventListener('mousemove', onMouseMove);
    return () => {
      node.removeEventListener('mousemove', onMouseMove);
    };
  }, [openRef, getBlockListSettings, getBlockIndex, isMultiSelecting, showInsertionPoint, hideInsertionPoint, getSelectedBlockClientIds, isInBetweenInserterDisabled]);
}
//# sourceMappingURL=use-in-between-inserter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/with-client-id.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const withClientId = (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => props => {
  const {
    clientId
  } = context_useBlockEditContext();
  return /*#__PURE__*/(0,jsx_runtime.jsx)(WrappedComponent, {
    ...props,
    clientId: clientId
  });
}, 'withClientId');
/* harmony default export */ const with_client_id = (withClientId);
//# sourceMappingURL=with-client-id.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/button-block-appender.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */



const button_block_appender_ButtonBlockAppender = ({
  clientId,
  showSeparator,
  isFloating,
  onAddBlock,
  isToggle
}) => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(button_block_appender, {
    className: (0,dist_clsx/* default */.A)({
      'block-list-appender__toggle': isToggle
    }),
    rootClientId: clientId,
    showSeparator: showSeparator,
    isFloating: isFloating,
    onAddBlock: onAddBlock
  });
};
/* harmony default export */ const inner_blocks_button_block_appender = (with_client_id(button_block_appender_ButtonBlockAppender));
//# sourceMappingURL=button-block-appender.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/default-block-appender.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const default_block_appender_DefaultBlockAppender = ({
  clientId
}) => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(DefaultBlockAppender, {
    rootClientId: clientId
  });
};
/* harmony default export */ const default_block_appender = ((0,compose/* default */.A)([with_client_id, with_select((select, {
  clientId
}) => {
  const {
    getBlockOrder
  } = select(store_store);
  const blockClientIds = getBlockOrder(clientId);
  return {
    lastBlockClientId: blockClientIds[blockClientIds.length - 1]
  };
})])(default_block_appender_DefaultBlockAppender));
//# sourceMappingURL=default-block-appender.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-nested-settings-update.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/** @typedef {import('../../selectors').WPDirectInsertBlock } WPDirectInsertBlock */

const pendingSettingsUpdates = new WeakMap();
function useShallowMemo(value) {
  const [prevValue, setPrevValue] = (0,react.useState)(value);
  if (!(0,is_shallow_equal_build_module/* default */.Ay)(prevValue, value)) {
    setPrevValue(value);
  }
  return prevValue;
}

/**
 * This hook is a side effect which updates the block-editor store when changes
 * happen to inner block settings. The given props are transformed into a
 * settings object, and if that is different from the current settings object in
 * the block-editor store, then the store is updated with the new settings which
 * came from props.
 *
 * @param {string}               clientId                   The client ID of the block to update.
 * @param {string}               parentLock
 * @param {string[]}             allowedBlocks              An array of block names which are permitted
 *                                                          in inner blocks.
 * @param {string[]}             prioritizedInserterBlocks  Block names and/or block variations to be prioritized in the inserter, in the format {blockName}/{variationName}.
 * @param {?WPDirectInsertBlock} defaultBlock               The default block to insert: [ blockName, { blockAttributes } ].
 * @param {?boolean}             directInsert               If a default block should be inserted directly by the appender.
 *
 * @param {?WPDirectInsertBlock} __experimentalDefaultBlock A deprecated prop for the default block to insert: [ blockName, { blockAttributes } ]. Use `defaultBlock` instead.
 *
 * @param {?boolean}             __experimentalDirectInsert A deprecated prop for whether a default block should be inserted directly by the appender. Use `directInsert` instead.
 *
 * @param {string}               [templateLock]             The template lock specified for the inner
 *                                                          blocks component. (e.g. "all")
 * @param {boolean}              captureToolbars            Whether or children toolbars should be shown
 *                                                          in the inner blocks component rather than on
 *                                                          the child block.
 * @param {string}               orientation                The direction in which the block
 *                                                          should face.
 * @param {Object}               layout                     The layout object for the block container.
 */
function useNestedSettingsUpdate(clientId, parentLock, allowedBlocks, prioritizedInserterBlocks, defaultBlock, directInsert, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, layout) {
  // Instead of adding a useSelect mapping here, please add to the useSelect
  // mapping in InnerBlocks! Every subscription impacts performance.

  const registry = (0,use_registry/* default */.A)();

  // Implementors often pass a new array on every render,
  // and the contents of the arrays are just strings, so the entire array
  // can be passed as dependencies but We need to include the length of the array,
  // otherwise if the arrays change length but the first elements are equal the comparison,
  // does not works as expected.
  const _allowedBlocks = useShallowMemo(allowedBlocks);
  const _prioritizedInserterBlocks = (0,react.useMemo)(() => prioritizedInserterBlocks,
  // eslint-disable-next-line react-hooks/exhaustive-deps
  prioritizedInserterBlocks);
  const _templateLock = templateLock === undefined || parentLock === 'contentOnly' ? parentLock : templateLock;
  (0,react.useLayoutEffect)(() => {
    const newSettings = {
      allowedBlocks: _allowedBlocks,
      prioritizedInserterBlocks: _prioritizedInserterBlocks,
      templateLock: _templateLock
    };

    // These values are not defined for RN, so only include them if they
    // are defined.
    if (captureToolbars !== undefined) {
      newSettings.__experimentalCaptureToolbars = captureToolbars;
    }

    // Orientation depends on layout,
    // ideally the separate orientation prop should be deprecated.
    if (orientation !== undefined) {
      newSettings.orientation = orientation;
    } else {
      const layoutType = layouts_getLayoutType(layout?.type);
      newSettings.orientation = layoutType.getOrientation(layout);
    }
    if (__experimentalDefaultBlock !== undefined) {
      (0,deprecated_build_module/* default */.A)('__experimentalDefaultBlock', {
        alternative: 'defaultBlock',
        since: '6.3',
        version: '6.4'
      });
      newSettings.defaultBlock = __experimentalDefaultBlock;
    }
    if (defaultBlock !== undefined) {
      newSettings.defaultBlock = defaultBlock;
    }
    if (__experimentalDirectInsert !== undefined) {
      (0,deprecated_build_module/* default */.A)('__experimentalDirectInsert', {
        alternative: 'directInsert',
        since: '6.3',
        version: '6.4'
      });
      newSettings.directInsert = __experimentalDirectInsert;
    }
    if (directInsert !== undefined) {
      newSettings.directInsert = directInsert;
    }
    if (newSettings.directInsert !== undefined && typeof newSettings.directInsert !== 'boolean') {
      (0,deprecated_build_module/* default */.A)('Using `Function` as a `directInsert` argument', {
        alternative: '`boolean` values',
        since: '6.5'
      });
    }

    // Batch updates to block list settings to avoid triggering cascading renders
    // for each container block included in a tree and optimize initial render.
    // To avoid triggering updateBlockListSettings for each container block
    // causing X re-renderings for X container blocks,
    // we batch all the updatedBlockListSettings in a single "data" batch
    // which results in a single re-render.
    if (!pendingSettingsUpdates.get(registry)) {
      pendingSettingsUpdates.set(registry, {});
    }
    pendingSettingsUpdates.get(registry)[clientId] = newSettings;
    window.queueMicrotask(() => {
      const settings = pendingSettingsUpdates.get(registry);
      if (Object.keys(settings).length) {
        const {
          updateBlockListSettings
        } = registry.dispatch(store_store);
        updateBlockListSettings(settings);
        pendingSettingsUpdates.set(registry, {});
      }
    });
  }, [clientId, _allowedBlocks, _prioritizedInserterBlocks, _templateLock, defaultBlock, directInsert, __experimentalDefaultBlock, __experimentalDirectInsert, captureToolbars, orientation, layout, registry]);
}
//# sourceMappingURL=use-nested-settings-update.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-inner-block-template-sync.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * This hook makes sure that a block's inner blocks stay in sync with the given
 * block "template". The template is a block hierarchy to which inner blocks must
 * conform. If the blocks get "out of sync" with the template and the template
 * is meant to be locked (e.g. templateLock = "all" or templateLock = "contentOnly"),
 * then we replace the inner blocks with the correct value after synchronizing it with the template.
 *
 * @param {string}  clientId                       The block client ID.
 * @param {Object}  template                       The template to match.
 * @param {string}  templateLock                   The template lock state for the inner blocks. For
 *                                                 example, if the template lock is set to "all",
 *                                                 then the inner blocks will stay in sync with the
 *                                                 template. If not defined or set to false, then
 *                                                 the inner blocks will not be synchronized with
 *                                                 the given template.
 * @param {boolean} templateInsertUpdatesSelection Whether or not to update the
 *                                                 block-editor selection state when inner blocks
 *                                                 are replaced after template synchronization.
 */
function useInnerBlockTemplateSync(clientId, template, templateLock, templateInsertUpdatesSelection) {
  // Instead of adding a useSelect mapping here, please add to the useSelect
  // mapping in InnerBlocks! Every subscription impacts performance.

  const {
    getBlocks,
    getSelectedBlocksInitialCaretPosition,
    isBlockSelected
  } = (0,use_select/* default */.A)(store_store);
  const {
    replaceInnerBlocks,
    __unstableMarkNextChangeAsNotPersistent
  } = (0,use_dispatch/* default */.A)(store_store);

  // Maintain a reference to the previous value so we can do a deep equality check.
  const existingTemplate = (0,react.useRef)(null);
  (0,react.useLayoutEffect)(() => {
    let isCancelled = false;

    // There's an implicit dependency between useInnerBlockTemplateSync and useNestedSettingsUpdate
    // The former needs to happen after the latter and since the latter is using microtasks to batch updates (performance optimization),
    // we need to schedule this one in a microtask as well.
    // Example: If you remove queueMicrotask here, ctrl + click to insert quote block won't close the inserter.
    window.queueMicrotask(() => {
      if (isCancelled) {
        return;
      }

      // Only synchronize innerBlocks with template if innerBlocks are empty
      // or a locking "all" or "contentOnly" exists directly on the block.
      const currentInnerBlocks = getBlocks(clientId);
      const shouldApplyTemplate = currentInnerBlocks.length === 0 || templateLock === 'all' || templateLock === 'contentOnly';
      const hasTemplateChanged = !es6_default()(template, existingTemplate.current);
      if (!shouldApplyTemplate || !hasTemplateChanged) {
        return;
      }
      existingTemplate.current = template;
      const nextBlocks = (0,build_module/* synchronizeBlocksWithTemplate */.Nk)(currentInnerBlocks, template);
      if (!es6_default()(nextBlocks, currentInnerBlocks)) {
        __unstableMarkNextChangeAsNotPersistent();
        replaceInnerBlocks(clientId, nextBlocks, currentInnerBlocks.length === 0 && templateInsertUpdatesSelection && nextBlocks.length !== 0 && isBlockSelected(clientId),
        // This ensures the "initialPosition" doesn't change when applying the template
        // If we're supposed to focus the block, we'll focus the first inner block
        // otherwise, we won't apply any auto-focus.
        // This ensures for instance that the focus stays in the inserter when inserting the "buttons" block.
        getSelectedBlocksInitialCaretPosition());
      }
    });
    return () => {
      isCancelled = true;
    };
  }, [template, templateLock, clientId]);
}
//# sourceMappingURL=use-inner-block-template-sync.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-block-context.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Returns a context object for a given block.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {Record<string,*>} Context value.
 */
function useBlockContext(clientId) {
  return (0,use_select/* default */.A)(select => {
    const block = select(store_store).getBlock(clientId);
    if (!block) {
      return undefined;
    }
    const blockType = select(build_module/* store */.M_).getBlockType(block.name);
    if (!blockType) {
      return undefined;
    }
    if (Object.keys(blockType.providesContext).length === 0) {
      return undefined;
    }
    return Object.fromEntries(Object.entries(blockType.providesContext).map(([contextName, attributeName]) => [contextName, block.attributes[attributeName]]));
  }, [clientId]);
}
//# sourceMappingURL=use-block-context.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/use-memo-one@1.1.3_react@18.3.1/node_modules/use-memo-one/dist/use-memo-one.esm.js
var use_memo_one_esm = __webpack_require__("../../node_modules/.pnpm/use-memo-one@1.1.3_react@18.3.1/node_modules/use-memo-one/dist/use-memo-one.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/throttle/index.js
var throttle = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/throttle/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-throttle/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Throttles a function similar to Lodash's `throttle`. A new throttled function will
 * be returned and any scheduled calls cancelled if any of the arguments change,
 * including the function to throttle, so please wrap functions created on
 * render in components in `useCallback`.
 *
 * @see https://lodash.com/docs/4#throttle
 *
 * @template {(...args: any[]) => void} TFunc
 *
 * @param {TFunc}                                          fn        The function to throttle.
 * @param {number}                                         [wait]    The number of milliseconds to throttle invocations to.
 * @param {import('../../utils/throttle').ThrottleOptions} [options] The options object. See linked documentation for details.
 * @return {import('../../utils/debounce').DebouncedFunc<TFunc>} Throttled function.
 */
function useThrottle(fn, wait, options) {
  const throttled = (0,use_memo_one_esm/* useMemoOne */.MA)(() => (0,throttle/* throttle */.n)(fn, wait !== null && wait !== void 0 ? wait : 0, options), [fn, wait, options]);
  (0,react.useEffect)(() => () => throttled.cancel(), [throttled]);
  return throttled;
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-drop-zone/index.js
var use_drop_zone = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-drop-zone/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/use-on-block-drop/index.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


/** @typedef {import('react').SyntheticEvent} SyntheticEvent */
/** @typedef {import('./types').WPDropOperation} WPDropOperation */

/**
 * Retrieve the data for a block drop event.
 *
 * @param {SyntheticEvent} event The drop event.
 *
 * @return {Object} An object with block drag and drop data.
 */
function parseDropEvent(event) {
  let result = {
    srcRootClientId: null,
    srcClientIds: null,
    srcIndex: null,
    type: null,
    blocks: null
  };
  if (!event.dataTransfer) {
    return result;
  }
  try {
    result = Object.assign(result, JSON.parse(event.dataTransfer.getData('wp-blocks')));
  } catch (err) {
    return result;
  }
  return result;
}

/**
 * A function that returns an event handler function for block drop events.
 *
 * @param {string}   targetRootClientId        The root client id where the block(s) will be inserted.
 * @param {number}   targetBlockIndex          The index where the block(s) will be inserted.
 * @param {Function} getBlockIndex             A function that gets the index of a block.
 * @param {Function} getClientIdsOfDescendants A function that gets the client ids of descendant blocks.
 * @param {Function} moveBlocks                A function that moves blocks.
 * @param {Function} insertOrReplaceBlocks     A function that inserts or replaces blocks.
 * @param {Function} clearSelectedBlock        A function that clears block selection.
 * @param {string}   operation                 The type of operation to perform on drop. Could be `insert` or `replace` or `group`.
 * @param {Function} getBlock                  A function that returns a block given its client id.
 * @return {Function} The event handler for a block drop event.
 */
function onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex, getClientIdsOfDescendants, moveBlocks, insertOrReplaceBlocks, clearSelectedBlock, operation, getBlock) {
  return event => {
    const {
      srcRootClientId: sourceRootClientId,
      srcClientIds: sourceClientIds,
      type: dropType,
      blocks
    } = parseDropEvent(event);

    // If the user is inserting a block.
    if (dropType === 'inserter') {
      clearSelectedBlock();
      const blocksToInsert = blocks.map(block => (0,build_module/* cloneBlock */.JB)(block));
      insertOrReplaceBlocks(blocksToInsert, true, null);
    }

    // If the user is moving a block.
    if (dropType === 'block') {
      const sourceBlockIndex = getBlockIndex(sourceClientIds[0]);

      // If the user is dropping to the same position, return early.
      if (sourceRootClientId === targetRootClientId && sourceBlockIndex === targetBlockIndex) {
        return;
      }

      // If the user is attempting to drop a block within its own
      // nested blocks, return early as this would create infinite
      // recursion.
      if (sourceClientIds.includes(targetRootClientId) || getClientIdsOfDescendants(sourceClientIds).some(id => id === targetRootClientId)) {
        return;
      }

      // If the user is dropping a block over another block, replace both blocks
      // with a group block containing them
      if (operation === 'group') {
        const blocksToInsert = sourceClientIds.map(clientId => getBlock(clientId));
        insertOrReplaceBlocks(blocksToInsert, true, null, sourceClientIds);
        return;
      }
      const isAtSameLevel = sourceRootClientId === targetRootClientId;
      const draggedBlockCount = sourceClientIds.length;

      // If the block is kept at the same level and moved downwards,
      // subtract to take into account that the blocks being dragged
      // were removed from the block list above the insertion point.
      const insertIndex = isAtSameLevel && sourceBlockIndex < targetBlockIndex ? targetBlockIndex - draggedBlockCount : targetBlockIndex;
      moveBlocks(sourceClientIds, sourceRootClientId, insertIndex);
    }
  };
}

/**
 * A function that returns an event handler function for block-related file drop events.
 *
 * @param {string}   targetRootClientId    The root client id where the block(s) will be inserted.
 * @param {Function} getSettings           A function that gets the block editor settings.
 * @param {Function} updateBlockAttributes A function that updates a block's attributes.
 * @param {Function} canInsertBlockType    A function that returns checks whether a block type can be inserted.
 * @param {Function} insertOrReplaceBlocks A function that inserts or replaces blocks.
 *
 * @return {Function} The event handler for a block-related file drop event.
 */
function onFilesDrop(targetRootClientId, getSettings, updateBlockAttributes, canInsertBlockType, insertOrReplaceBlocks) {
  return files => {
    if (!getSettings().mediaUpload) {
      return;
    }
    const transformation = (0,build_module/* findTransform */.wG)((0,build_module/* getBlockTransforms */.XD)('from'), transform => transform.type === 'files' && canInsertBlockType(transform.blockName, targetRootClientId) && transform.isMatch(files));
    if (transformation) {
      const blocks = transformation.transform(files, updateBlockAttributes);
      insertOrReplaceBlocks(blocks);
    }
  };
}

/**
 * A function that returns an event handler function for block-related HTML drop events.
 *
 * @param {Function} insertOrReplaceBlocks A function that inserts or replaces blocks.
 *
 * @return {Function} The event handler for a block-related HTML drop event.
 */
function onHTMLDrop(insertOrReplaceBlocks) {
  return HTML => {
    const blocks = (0,build_module/* pasteHandler */.Gk)({
      HTML,
      mode: 'BLOCKS'
    });
    if (blocks.length) {
      insertOrReplaceBlocks(blocks);
    }
  };
}

/**
 * A React hook for handling block drop events.
 *
 * @param {string}          targetRootClientId  The root client id where the block(s) will be inserted.
 * @param {number}          targetBlockIndex    The index where the block(s) will be inserted.
 * @param {Object}          options             The optional options.
 * @param {WPDropOperation} [options.operation] The type of operation to perform on drop. Could be `insert` or `replace` for now.
 *
 * @return {Function} A function to be passed to the onDrop handler.
 */
function useOnBlockDrop(targetRootClientId, targetBlockIndex, options = {}) {
  const {
    operation = 'insert',
    nearestSide = 'right'
  } = options;
  const {
    canInsertBlockType,
    getBlockIndex,
    getClientIdsOfDescendants,
    getBlockOrder,
    getBlocksByClientId,
    getSettings,
    getBlock,
    isGroupable
  } = (0,use_select/* default */.A)(store_store);
  const {
    getGroupingBlockName
  } = (0,use_select/* default */.A)(build_module/* store */.M_);
  const {
    insertBlocks,
    moveBlocksToPosition,
    updateBlockAttributes,
    clearSelectedBlock,
    replaceBlocks,
    removeBlocks
  } = (0,use_dispatch/* default */.A)(store_store);
  const registry = (0,use_registry/* default */.A)();
  const insertOrReplaceBlocks = (0,react.useCallback)((blocks, updateSelection = true, initialPosition = 0, clientIdsToReplace = []) => {
    if (!Array.isArray(blocks)) {
      blocks = [blocks];
    }
    const clientIds = getBlockOrder(targetRootClientId);
    const clientId = clientIds[targetBlockIndex];
    const blocksClientIds = blocks.map(block => block.clientId);
    const areGroupableBlocks = isGroupable([...blocksClientIds, clientId]);
    if (operation === 'replace') {
      replaceBlocks(clientId, blocks, undefined, initialPosition);
    } else if (operation === 'group' && areGroupableBlocks) {
      const targetBlock = getBlock(clientId);
      if (nearestSide === 'left') {
        blocks.push(targetBlock);
      } else {
        blocks.unshift(targetBlock);
      }
      const groupInnerBlocks = blocks.map(block => {
        return (0,build_module/* createBlock */.Wv)(block.name, block.attributes, block.innerBlocks);
      });
      const areAllImages = blocks.every(block => {
        return block.name === 'core/image';
      });
      const galleryBlock = canInsertBlockType('core/gallery', targetRootClientId);
      const wrappedBlocks = (0,build_module/* createBlock */.Wv)(areAllImages && galleryBlock ? 'core/gallery' : getGroupingBlockName(), {
        layout: {
          type: 'flex',
          flexWrap: areAllImages && galleryBlock ? null : 'nowrap'
        }
      }, groupInnerBlocks);
      // Need to make sure both the target block and the block being dragged are replaced
      // otherwise the dragged block will be duplicated.
      replaceBlocks([clientId, ...clientIdsToReplace], wrappedBlocks, undefined, initialPosition);
    } else {
      insertBlocks(blocks, targetBlockIndex, targetRootClientId, updateSelection, initialPosition);
    }
  }, [getBlockOrder, targetRootClientId, targetBlockIndex, isGroupable, operation, replaceBlocks, getBlock, nearestSide, canInsertBlockType, getGroupingBlockName, insertBlocks]);
  const moveBlocks = (0,react.useCallback)((sourceClientIds, sourceRootClientId, insertIndex) => {
    if (operation === 'replace') {
      const sourceBlocks = getBlocksByClientId(sourceClientIds);
      const targetBlockClientIds = getBlockOrder(targetRootClientId);
      const targetBlockClientId = targetBlockClientIds[targetBlockIndex];
      registry.batch(() => {
        // Remove the source blocks.
        removeBlocks(sourceClientIds, false);
        // Replace the target block with the source blocks.
        replaceBlocks(targetBlockClientId, sourceBlocks, undefined, 0);
      });
    } else {
      moveBlocksToPosition(sourceClientIds, sourceRootClientId, targetRootClientId, insertIndex);
    }
  }, [operation, getBlockOrder, getBlocksByClientId, moveBlocksToPosition, registry, removeBlocks, replaceBlocks, targetBlockIndex, targetRootClientId]);
  const _onDrop = onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex, getClientIdsOfDescendants, moveBlocks, insertOrReplaceBlocks, clearSelectedBlock, operation, getBlock);
  const _onFilesDrop = onFilesDrop(targetRootClientId, getSettings, updateBlockAttributes, canInsertBlockType, insertOrReplaceBlocks);
  const _onHTMLDrop = onHTMLDrop(insertOrReplaceBlocks);
  return event => {
    const files = (0,data_transfer/* getFilesFromDataTransfer */.$)(event.dataTransfer);
    const html = event.dataTransfer.getData('text/html');

    /**
     * From Windows Chrome 96, the `event.dataTransfer` returns both file object and HTML.
     * The order of the checks is important to recognise the HTML drop.
     */
    if (html) {
      _onHTMLDrop(html);
    } else if (files.length) {
      _onFilesDrop(files);
    } else {
      _onDrop(event);
    }
  };
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/utils/math.js
/**
 * A string representing the name of an edge.
 *
 * @typedef {'top'|'right'|'bottom'|'left'} WPEdgeName
 */

/**
 * @typedef  {Object} WPPoint
 * @property {number} x The horizontal position.
 * @property {number} y The vertical position.
 */

/**
 * Given a point, a DOMRect and the name of an edge, returns the distance to
 * that edge of the rect.
 *
 * This function works for edges that are horizontal or vertical (e.g. not
 * rotated), the following terms are used so that the function works in both
 * orientations:
 *
 * - Forward, meaning the axis running horizontally when an edge is vertical
 *   and vertically when an edge is horizontal.
 * - Lateral, meaning the axis running vertically when an edge is vertical
 *   and horizontally when an edge is horizontal.
 *
 * @param {WPPoint}    point The point to measure distance from.
 * @param {DOMRect}    rect  A DOM Rect containing edge positions.
 * @param {WPEdgeName} edge  The edge to measure to.
 */
function getDistanceFromPointToEdge(point, rect, edge) {
  const isHorizontal = edge === 'top' || edge === 'bottom';
  const {
    x,
    y
  } = point;
  const pointLateralPosition = isHorizontal ? x : y;
  const pointForwardPosition = isHorizontal ? y : x;
  const edgeStart = isHorizontal ? rect.left : rect.top;
  const edgeEnd = isHorizontal ? rect.right : rect.bottom;
  const edgeForwardPosition = rect[edge];

  // Measure the straight line distance to the edge of the rect, when the
  // point is adjacent to the edge.
  // Else, if the point is positioned diagonally to the edge of the rect,
  // measure diagonally to the nearest corner that the edge meets.
  let edgeLateralPosition;
  if (pointLateralPosition >= edgeStart && pointLateralPosition <= edgeEnd) {
    edgeLateralPosition = pointLateralPosition;
  } else if (pointLateralPosition < edgeEnd) {
    edgeLateralPosition = edgeStart;
  } else {
    edgeLateralPosition = edgeEnd;
  }
  return Math.sqrt((pointLateralPosition - edgeLateralPosition) ** 2 + (pointForwardPosition - edgeForwardPosition) ** 2);
}

/**
 * Given a point, a DOMRect and a list of allowed edges returns the name of and
 * distance to the nearest edge.
 *
 * @param {WPPoint}      point        The point to measure distance from.
 * @param {DOMRect}      rect         A DOM Rect containing edge positions.
 * @param {WPEdgeName[]} allowedEdges A list of the edges included in the
 *                                    calculation. Defaults to all edges.
 *
 * @return {[number, string]} An array where the first value is the distance
 *                              and a second is the edge name.
 */
function getDistanceToNearestEdge(point, rect, allowedEdges = ['top', 'bottom', 'left', 'right']) {
  let candidateDistance;
  let candidateEdge;
  allowedEdges.forEach(edge => {
    const distance = getDistanceFromPointToEdge(point, rect, edge);
    if (candidateDistance === undefined || distance < candidateDistance) {
      candidateDistance = distance;
      candidateEdge = edge;
    }
  });
  return [candidateDistance, candidateEdge];
}

/**
 * Is the point contained by the rectangle.
 *
 * @param {WPPoint} point The point.
 * @param {DOMRect} rect  The rectangle.
 *
 * @return {boolean} True if the point is contained by the rectangle, false otherwise.
 */
function isPointContainedByRect(point, rect) {
  return rect.left <= point.x && rect.right >= point.x && rect.top <= point.y && rect.bottom >= point.y;
}

/**
 * Is the point within the top and bottom boundaries of the rectangle.
 *
 * @param {WPPoint} point The point.
 * @param {DOMRect} rect  The rectangle.
 *
 * @return {boolean} True if the point is within top and bottom of rectangle, false otherwise.
 */
function isPointWithinTopAndBottomBoundariesOfRect(point, rect) {
  return rect.top <= point.y && rect.bottom >= point.y;
}
//# sourceMappingURL=math.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/use-block-drop-zone/index.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




const THRESHOLD_DISTANCE = 30;
const MINIMUM_HEIGHT_FOR_THRESHOLD = 120;
const MINIMUM_WIDTH_FOR_THRESHOLD = 120;

/** @typedef {import('../../utils/math').WPPoint} WPPoint */
/** @typedef {import('../use-on-block-drop/types').WPDropOperation} WPDropOperation */

/**
 * The orientation of a block list.
 *
 * @typedef {'horizontal'|'vertical'|undefined} WPBlockListOrientation
 */

/**
 * The insert position when dropping a block.
 *
 * @typedef {'before'|'after'} WPInsertPosition
 */

/**
 * @typedef {Object} WPBlockData
 * @property {boolean}       isUnmodifiedDefaultBlock Is the block unmodified default block.
 * @property {() => DOMRect} getBoundingClientRect    Get the bounding client rect of the block.
 * @property {number}        blockIndex               The index of the block.
 */

/**
 * Get the drop target position from a given drop point and the orientation.
 *
 * @param {WPBlockData[]}          blocksData  The block data list.
 * @param {WPPoint}                position    The position of the item being dragged.
 * @param {WPBlockListOrientation} orientation The orientation of the block list.
 * @param {Object}                 options     Additional options.
 * @return {[number, WPDropOperation]} The drop target position.
 */
function getDropTargetPosition(blocksData, position, orientation = 'vertical', options = {}) {
  const allowedEdges = orientation === 'horizontal' ? ['left', 'right'] : ['top', 'bottom'];
  let nearestIndex = 0;
  let insertPosition = 'before';
  let minDistance = Infinity;
  let targetBlockIndex = null;
  let nearestSide = 'right';
  const {
    dropZoneElement,
    parentBlockOrientation,
    rootBlockIndex = 0
  } = options;

  // Allow before/after when dragging over the top/bottom edges of the drop zone.
  if (dropZoneElement && parentBlockOrientation !== 'horizontal') {
    const rect = dropZoneElement.getBoundingClientRect();
    const [distance, edge] = getDistanceToNearestEdge(position, rect, ['top', 'bottom']);

    // If dragging over the top or bottom of the drop zone, insert the block
    // before or after the parent block. This only applies to blocks that use
    // a drop zone element, typically container blocks such as Group or Cover.
    if (rect.height > MINIMUM_HEIGHT_FOR_THRESHOLD && distance < THRESHOLD_DISTANCE) {
      if (edge === 'top') {
        return [rootBlockIndex, 'before'];
      }
      if (edge === 'bottom') {
        return [rootBlockIndex + 1, 'after'];
      }
    }
  }
  const isRightToLeft = (0,i18n_build_module/* isRTL */.V8)();

  // Allow before/after when dragging over the left/right edges of the drop zone.
  if (dropZoneElement && parentBlockOrientation === 'horizontal') {
    const rect = dropZoneElement.getBoundingClientRect();
    const [distance, edge] = getDistanceToNearestEdge(position, rect, ['left', 'right']);

    // If dragging over the left or right of the drop zone, insert the block
    // before or after the parent block. This only applies to blocks that use
    // a drop zone element, typically container blocks such as Group.
    if (rect.width > MINIMUM_WIDTH_FOR_THRESHOLD && distance < THRESHOLD_DISTANCE) {
      if (isRightToLeft && edge === 'right' || !isRightToLeft && edge === 'left') {
        return [rootBlockIndex, 'before'];
      }
      if (isRightToLeft && edge === 'left' || !isRightToLeft && edge === 'right') {
        return [rootBlockIndex + 1, 'after'];
      }
    }
  }
  blocksData.forEach(({
    isUnmodifiedDefaultBlock,
    getBoundingClientRect,
    blockIndex,
    blockOrientation
  }) => {
    const rect = getBoundingClientRect();
    let [distance, edge] = getDistanceToNearestEdge(position, rect, allowedEdges);
    // If the the point is close to a side, prioritize that side.
    const [sideDistance, sideEdge] = getDistanceToNearestEdge(position, rect, ['left', 'right']);
    const isPointInsideRect = isPointContainedByRect(position, rect);

    // Prioritize the element if the point is inside of an unmodified default block.
    if (isUnmodifiedDefaultBlock && isPointInsideRect) {
      distance = 0;
    } else if (orientation === 'vertical' && blockOrientation !== 'horizontal' && (isPointInsideRect && sideDistance < THRESHOLD_DISTANCE || !isPointInsideRect && isPointWithinTopAndBottomBoundariesOfRect(position, rect))) {
      /**
       * This condition should only apply when the layout is vertical (otherwise there's
       * no need to create a Row) and dropzones should only activate when the block is
       * either within and close to the sides of the target block or on its outer sides.
       */
      targetBlockIndex = blockIndex;
      nearestSide = sideEdge;
    }
    if (distance < minDistance) {
      // Where the dropped block will be inserted on the nearest block.
      insertPosition = edge === 'bottom' || !isRightToLeft && edge === 'right' || isRightToLeft && edge === 'left' ? 'after' : 'before';

      // Update the currently known best candidate.
      minDistance = distance;
      nearestIndex = blockIndex;
    }
  });
  const adjacentIndex = nearestIndex + (insertPosition === 'after' ? 1 : -1);
  const isNearestBlockUnmodifiedDefaultBlock = !!blocksData[nearestIndex]?.isUnmodifiedDefaultBlock;
  const isAdjacentBlockUnmodifiedDefaultBlock = !!blocksData[adjacentIndex]?.isUnmodifiedDefaultBlock;

  // If the target index is set then group with the block at that index.
  if (targetBlockIndex !== null) {
    return [targetBlockIndex, 'group', nearestSide];
  }
  // If both blocks are not unmodified default blocks then just insert between them.
  if (!isNearestBlockUnmodifiedDefaultBlock && !isAdjacentBlockUnmodifiedDefaultBlock) {
    // If the user is dropping to the trailing edge of the block
    // add 1 to the index to represent dragging after.
    const insertionIndex = insertPosition === 'after' ? nearestIndex + 1 : nearestIndex;
    return [insertionIndex, 'insert'];
  }

  // Otherwise, replace the nearest unmodified default block.
  return [isNearestBlockUnmodifiedDefaultBlock ? nearestIndex : adjacentIndex, 'replace'];
}

/**
 * Check if the dragged blocks can be dropped on the target.
 * @param {Function} getBlockType
 * @param {Object[]} allowedBlocks
 * @param {string[]} draggedBlockNames
 * @param {string}   targetBlockName
 * @return {boolean} Whether the dragged blocks can be dropped on the target.
 */
function isDropTargetValid(getBlockType, allowedBlocks, draggedBlockNames, targetBlockName) {
  // At root level allowedBlocks is undefined and all blocks are allowed.
  // Otherwise, check if all dragged blocks are allowed.
  let areBlocksAllowed = true;
  if (allowedBlocks) {
    const allowedBlockNames = allowedBlocks?.map(({
      name
    }) => name);
    areBlocksAllowed = draggedBlockNames.every(name => allowedBlockNames?.includes(name));
  }

  // Work out if dragged blocks have an allowed parent and if so
  // check target block matches the allowed parent.
  const draggedBlockTypes = draggedBlockNames.map(name => getBlockType(name));
  const targetMatchesDraggedBlockParents = draggedBlockTypes.every(block => {
    const [allowedParentName] = block?.parent || [];
    if (!allowedParentName) {
      return true;
    }
    return allowedParentName === targetBlockName;
  });
  return areBlocksAllowed && targetMatchesDraggedBlockParents;
}

/**
 * @typedef  {Object} WPBlockDropZoneConfig
 * @property {?HTMLElement} dropZoneElement Optional element to be used as the drop zone.
 * @property {string}       rootClientId    The root client id for the block list.
 */

/**
 * A React hook that can be used to make a block list handle drag and drop.
 *
 * @param {WPBlockDropZoneConfig} dropZoneConfig configuration data for the drop zone.
 */
function useBlockDropZone({
  dropZoneElement,
  // An undefined value represents a top-level block. Default to an empty
  // string for this so that `targetRootClientId` can be easily compared to
  // values returned by the `getRootBlockClientId` selector, which also uses
  // an empty string to represent top-level blocks.
  rootClientId: targetRootClientId = '',
  parentClientId: parentBlockClientId = '',
  isDisabled = false
} = {}) {
  const registry = (0,use_registry/* default */.A)();
  const [dropTarget, setDropTarget] = (0,react.useState)({
    index: null,
    operation: 'insert'
  });
  const {
    getBlockType
  } = (0,use_select/* default */.A)(build_module/* store */.M_);
  const {
    getBlockListSettings,
    getBlocks,
    getBlockIndex,
    getDraggedBlockClientIds,
    getBlockNamesByClientId,
    getAllowedBlocks,
    isDragging
  } = lock_unlock_unlock((0,use_select/* default */.A)(store_store));
  const {
    showInsertionPoint,
    hideInsertionPoint,
    startDragging,
    stopDragging
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  const onBlockDrop = useOnBlockDrop(dropTarget.operation === 'before' || dropTarget.operation === 'after' ? parentBlockClientId : targetRootClientId, dropTarget.index, {
    operation: dropTarget.operation,
    nearestSide: dropTarget.nearestSide
  });
  const throttled = useThrottle((0,react.useCallback)((event, ownerDocument) => {
    if (!isDragging()) {
      // When dragging from the desktop, no drag start event is fired.
      // So, ensure that the drag state is set when the user drags over a drop zone.
      startDragging();
    }
    const allowedBlocks = getAllowedBlocks(targetRootClientId);
    const targetBlockName = getBlockNamesByClientId([targetRootClientId])[0];
    const draggedBlockNames = getBlockNamesByClientId(getDraggedBlockClientIds());
    const isBlockDroppingAllowed = isDropTargetValid(getBlockType, allowedBlocks, draggedBlockNames, targetBlockName);
    if (!isBlockDroppingAllowed) {
      return;
    }
    const blocks = getBlocks(targetRootClientId);

    // The block list is empty, don't show the insertion point but still allow dropping.
    if (blocks.length === 0) {
      registry.batch(() => {
        setDropTarget({
          index: 0,
          operation: 'insert'
        });
        showInsertionPoint(targetRootClientId, 0, {
          operation: 'insert'
        });
      });
      return;
    }
    const blocksData = blocks.map(block => {
      const clientId = block.clientId;
      return {
        isUnmodifiedDefaultBlock: (0,build_module/* isUnmodifiedDefaultBlock */.Xw)(block),
        getBoundingClientRect: () => ownerDocument.getElementById(`block-${clientId}`).getBoundingClientRect(),
        blockIndex: getBlockIndex(clientId),
        blockOrientation: getBlockListSettings(clientId)?.orientation
      };
    });
    const [targetIndex, operation, nearestSide] = getDropTargetPosition(blocksData, {
      x: event.clientX,
      y: event.clientY
    }, getBlockListSettings(targetRootClientId)?.orientation, {
      dropZoneElement,
      parentBlockClientId,
      parentBlockOrientation: parentBlockClientId ? getBlockListSettings(parentBlockClientId)?.orientation : undefined,
      rootBlockIndex: getBlockIndex(targetRootClientId)
    });
    registry.batch(() => {
      setDropTarget({
        index: targetIndex,
        operation,
        nearestSide
      });
      const insertionPointClientId = ['before', 'after'].includes(operation) ? parentBlockClientId : targetRootClientId;
      showInsertionPoint(insertionPointClientId, targetIndex, {
        operation,
        nearestSide
      });
    });
  }, [getAllowedBlocks, targetRootClientId, getBlockNamesByClientId, getDraggedBlockClientIds, getBlockType, getBlocks, getBlockListSettings, dropZoneElement, parentBlockClientId, getBlockIndex, registry, showInsertionPoint, isDragging, startDragging]), 200);
  return (0,use_drop_zone/* default */.A)({
    dropZoneElement,
    isDisabled,
    onDrop: onBlockDrop,
    onDragOver(event) {
      // `currentTarget` is only available while the event is being
      // handled, so get it now and pass it to the thottled function.
      // https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget
      throttled(event, event.currentTarget.ownerDocument);
    },
    onDragLeave() {
      throttled.cancel();
      hideInsertionPoint();
    },
    onDragEnd() {
      throttled.cancel();
      stopDragging();
      hideInsertionPoint();
    }
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */













const inner_blocks_EMPTY_OBJECT = {};
function BlockContext({
  children,
  clientId
}) {
  const context = useBlockContext(clientId);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockContextProvider, {
    value: context,
    children: children
  });
}
const BlockListItemsMemo = (0,react.memo)(block_list_BlockListItems);

/**
 * InnerBlocks is a component which allows a single block to have multiple blocks
 * as children. The UncontrolledInnerBlocks component is used whenever the inner
 * blocks are not controlled by another entity. In other words, it is normally
 * used for inner blocks in the post editor
 *
 * @param {Object} props The component props.
 */
function UncontrolledInnerBlocks(props) {
  const {
    clientId,
    allowedBlocks,
    prioritizedInserterBlocks,
    defaultBlock,
    directInsert,
    __experimentalDefaultBlock,
    __experimentalDirectInsert,
    template,
    templateLock,
    wrapperRef,
    templateInsertUpdatesSelection,
    __experimentalCaptureToolbars: captureToolbars,
    __experimentalAppenderTagName,
    renderAppender,
    orientation,
    placeholder,
    layout,
    name,
    blockType,
    parentLock,
    defaultLayout
  } = props;
  useNestedSettingsUpdate(clientId, parentLock, allowedBlocks, prioritizedInserterBlocks, defaultBlock, directInsert, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, layout);
  useInnerBlockTemplateSync(clientId, template, templateLock, templateInsertUpdatesSelection);
  const defaultLayoutBlockSupport = (0,build_module/* getBlockSupport */.bI)(name, 'layout') || (0,build_module/* getBlockSupport */.bI)(name, '__experimentalLayout') || inner_blocks_EMPTY_OBJECT;
  const {
    allowSizingOnChildren = false
  } = defaultLayoutBlockSupport;
  const usedLayout = layout || defaultLayoutBlockSupport;
  const memoedLayout = (0,react.useMemo)(() => ({
    // Default layout will know about any content/wide size defined by the theme.
    ...defaultLayout,
    ...usedLayout,
    ...(allowSizingOnChildren && {
      allowSizingOnChildren: true
    })
  }), [defaultLayout, usedLayout, allowSizingOnChildren]);

  // For controlled inner blocks, we don't want a change in blocks to
  // re-render the blocks list.
  const items = /*#__PURE__*/(0,jsx_runtime.jsx)(BlockListItemsMemo, {
    rootClientId: clientId,
    renderAppender: renderAppender,
    __experimentalAppenderTagName: __experimentalAppenderTagName,
    layout: memoedLayout,
    wrapperRef: wrapperRef,
    placeholder: placeholder
  });
  if (Object.keys(blockType.providesContext).length === 0) {
    return items;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockContext, {
    clientId: clientId,
    children: items
  });
}

/**
 * The controlled inner blocks component wraps the uncontrolled inner blocks
 * component with the blockSync hook. This keeps the innerBlocks of the block in
 * the block-editor store in sync with the blocks of the controlling entity. An
 * example of an inner block controller is a template part block, which provides
 * its own blocks from the template part entity data source.
 *
 * @param {Object} props The component props.
 */
function ControlledInnerBlocks(props) {
  useBlockSync(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(UncontrolledInnerBlocks, {
    ...props
  });
}
const ForwardedInnerBlocks = (0,react.forwardRef)((props, ref) => {
  const innerBlocksProps = useInnerBlocksProps({
    ref
  }, props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-inner-blocks",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      ...innerBlocksProps
    })
  });
});

/**
 * This hook is used to lightly mark an element as an inner blocks wrapper
 * element. Call this hook and pass the returned props to the element to mark as
 * an inner blocks wrapper, automatically rendering inner blocks as children. If
 * you define a ref for the element, it is important to pass the ref to this
 * hook, which the hook in turn will pass to the component through the props it
 * returns. Optionally, you can also pass any other props through this hook, and
 * they will be merged and returned.
 *
 * @param {Object} props   Optional. Props to pass to the element. Must contain
 *                         the ref if one is defined.
 * @param {Object} options Optional. Inner blocks options.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inner-blocks/README.md
 */
function useInnerBlocksProps(props = {}, options = {}) {
  const {
    __unstableDisableLayoutClassNames,
    __unstableDisableDropZone,
    dropZoneElement
  } = options;
  const {
    clientId,
    layout = null,
    __unstableLayoutClassNames: layoutClassNames = ''
  } = context_useBlockEditContext();
  const selected = (0,use_select/* default */.A)(select => {
    const {
      getBlockName,
      isBlockSelected,
      hasSelectedInnerBlock,
      __unstableGetEditorMode,
      getTemplateLock,
      getBlockRootClientId,
      getBlockEditingMode,
      getBlockSettings,
      isDragging,
      getSettings
    } = lock_unlock_unlock(select(store_store));
    let _isDropZoneDisabled;
    // In zoom out mode, we want to disable the drop zone for the sections.
    // The inner blocks belonging to the section drop zone is
    // already disabled by the blocks themselves being disabled.
    if (__unstableGetEditorMode() === 'zoom-out') {
      const {
        sectionRootClientId
      } = lock_unlock_unlock(getSettings());
      _isDropZoneDisabled = clientId !== sectionRootClientId;
    }
    if (!clientId) {
      return {
        isDropZoneDisabled: _isDropZoneDisabled
      };
    }
    const {
      hasBlockSupport,
      getBlockType
    } = select(build_module/* store */.M_);
    const blockName = getBlockName(clientId);
    const enableClickThrough = __unstableGetEditorMode() === 'navigation';
    const blockEditingMode = getBlockEditingMode(clientId);
    const parentClientId = getBlockRootClientId(clientId);
    const [defaultLayout] = getBlockSettings(clientId, 'layout');
    if (_isDropZoneDisabled !== undefined) {
      _isDropZoneDisabled = blockEditingMode === 'disabled';
    }
    return {
      __experimentalCaptureToolbars: hasBlockSupport(blockName, '__experimentalExposeControlsToChildren', false),
      hasOverlay: blockName !== 'core/template' && !isBlockSelected(clientId) && !hasSelectedInnerBlock(clientId, true) && enableClickThrough && !isDragging(),
      name: blockName,
      blockType: getBlockType(blockName),
      parentLock: getTemplateLock(parentClientId),
      parentClientId,
      isDropZoneDisabled: _isDropZoneDisabled,
      defaultLayout
    };
  }, [clientId]);
  const {
    __experimentalCaptureToolbars,
    hasOverlay,
    name,
    blockType,
    parentLock,
    parentClientId,
    isDropZoneDisabled,
    defaultLayout
  } = selected;
  const blockDropZoneRef = useBlockDropZone({
    dropZoneElement,
    rootClientId: clientId,
    parentClientId
  });
  const ref = (0,use_merge_refs/* default */.A)([props.ref, __unstableDisableDropZone || isDropZoneDisabled ? null : blockDropZoneRef]);
  const innerBlocksProps = {
    __experimentalCaptureToolbars,
    layout,
    name,
    blockType,
    parentLock,
    defaultLayout,
    ...options
  };
  const InnerBlocks = innerBlocksProps.value && innerBlocksProps.onChange ? ControlledInnerBlocks : UncontrolledInnerBlocks;
  return {
    ...props,
    ref,
    className: (0,dist_clsx/* default */.A)(props.className, 'block-editor-block-list__layout', __unstableDisableLayoutClassNames ? '' : layoutClassNames, {
      'has-overlay': hasOverlay
    }),
    children: clientId ? /*#__PURE__*/(0,jsx_runtime.jsx)(InnerBlocks, {
      ...innerBlocksProps,
      clientId: clientId
    }) : /*#__PURE__*/(0,jsx_runtime.jsx)(block_list_BlockListItems, {
      ...options
    })
  };
}
useInnerBlocksProps.save = build_module/* __unstableGetInnerBlocksProps */.v9;

// Expose default appender placeholders as components.
ForwardedInnerBlocks.DefaultBlockAppender = default_block_appender;
ForwardedInnerBlocks.ButtonBlockAppender = inner_blocks_button_block_appender;
ForwardedInnerBlocks.Content = () => useInnerBlocksProps.save().children;

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inner-blocks/README.md
 */
/* harmony default export */ const inner_blocks = ((/* unused pure expression or super */ null && (ForwardedInnerBlocks)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/observe-typing/index.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


/**
 * Set of key codes upon which typing is to be initiated on a keydown event.
 *
 * @type {Set<number>}
 */

const KEY_DOWN_ELIGIBLE_KEY_CODES = new Set([keycodes_build_module.UP, keycodes_build_module/* RIGHT */.NS, keycodes_build_module/* DOWN */.PX, keycodes_build_module/* LEFT */.M3, keycodes_build_module/* ENTER */.Fm, keycodes_build_module/* BACKSPACE */.G_]);

/**
 * Returns true if a given keydown event can be inferred as intent to start
 * typing, or false otherwise. A keydown is considered eligible if it is a
 * text navigation without shift active.
 *
 * @param {KeyboardEvent} event Keydown event to test.
 *
 * @return {boolean} Whether event is eligible to start typing.
 */
function isKeyDownEligibleForStartTyping(event) {
  const {
    keyCode,
    shiftKey
  } = event;
  return !shiftKey && KEY_DOWN_ELIGIBLE_KEY_CODES.has(keyCode);
}

/**
 * Removes the `isTyping` flag when the mouse moves in the document of the given
 * element.
 */
function useMouseMoveTypingReset() {
  const isTyping = (0,use_select/* default */.A)(select => select(store_store).isTyping(), []);
  const {
    stopTyping
  } = (0,use_dispatch/* default */.A)(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    if (!isTyping) {
      return;
    }
    const {
      ownerDocument
    } = node;
    let lastClientX;
    let lastClientY;

    /**
     * On mouse move, unset typing flag if user has moved cursor.
     *
     * @param {MouseEvent} event Mousemove event.
     */
    function stopTypingOnMouseMove(event) {
      const {
        clientX,
        clientY
      } = event;

      // We need to check that the mouse really moved because Safari
      // triggers mousemove events when shift or ctrl are pressed.
      if (lastClientX && lastClientY && (lastClientX !== clientX || lastClientY !== clientY)) {
        stopTyping();
      }
      lastClientX = clientX;
      lastClientY = clientY;
    }
    ownerDocument.addEventListener('mousemove', stopTypingOnMouseMove);
    return () => {
      ownerDocument.removeEventListener('mousemove', stopTypingOnMouseMove);
    };
  }, [isTyping, stopTyping]);
}

/**
 * Sets and removes the `isTyping` flag based on user actions:
 *
 * - Sets the flag if the user types within the given element.
 * - Removes the flag when the user selects some text, focusses a non-text
 *   field, presses ESC or TAB, or moves the mouse in the document.
 */
function useTypingObserver() {
  const {
    isTyping
  } = (0,use_select/* default */.A)(select => {
    const {
      isTyping: _isTyping
    } = select(store_store);
    return {
      isTyping: _isTyping()
    };
  }, []);
  const {
    startTyping,
    stopTyping
  } = (0,use_dispatch/* default */.A)(store_store);
  const ref1 = useMouseMoveTypingReset();
  const ref2 = (0,use_ref_effect/* default */.A)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    const selection = defaultView.getSelection();

    // Listeners to stop typing should only be added when typing.
    // Listeners to start typing should only be added when not typing.
    if (isTyping) {
      let timerId;

      /**
       * Stops typing when focus transitions to a non-text field element.
       *
       * @param {FocusEvent} event Focus event.
       */
      function stopTypingOnNonTextField(event) {
        const {
          target
        } = event;

        // Since focus to a non-text field via arrow key will trigger
        // before the keydown event, wait until after current stack
        // before evaluating whether typing is to be stopped. Otherwise,
        // typing will re-start.
        timerId = defaultView.setTimeout(() => {
          if (!isTextField(target)) {
            stopTyping();
          }
        });
      }

      /**
       * Unsets typing flag if user presses Escape while typing flag is
       * active.
       *
       * @param {KeyboardEvent} event Keypress or keydown event to
       *                              interpret.
       */
      function stopTypingOnEscapeKey(event) {
        const {
          keyCode
        } = event;
        if (keyCode === keycodes_build_module/* ESCAPE */._f || keyCode === keycodes_build_module/* TAB */.wn) {
          stopTyping();
        }
      }

      /**
       * On selection change, unset typing flag if user has made an
       * uncollapsed (shift) selection.
       */
      function stopTypingOnSelectionUncollapse() {
        if (!selection.isCollapsed) {
          stopTyping();
        }
      }
      node.addEventListener('focus', stopTypingOnNonTextField);
      node.addEventListener('keydown', stopTypingOnEscapeKey);
      ownerDocument.addEventListener('selectionchange', stopTypingOnSelectionUncollapse);
      return () => {
        defaultView.clearTimeout(timerId);
        node.removeEventListener('focus', stopTypingOnNonTextField);
        node.removeEventListener('keydown', stopTypingOnEscapeKey);
        ownerDocument.removeEventListener('selectionchange', stopTypingOnSelectionUncollapse);
      };
    }

    /**
     * Handles a keypress or keydown event to infer intention to start
     * typing.
     *
     * @param {KeyboardEvent} event Keypress or keydown event to interpret.
     */
    function startTypingInTextField(event) {
      const {
        type,
        target
      } = event;

      // Abort early if already typing, or key press is incurred outside a
      // text field (e.g. arrow-ing through toolbar buttons).
      // Ignore typing if outside the current DOM container
      if (!isTextField(target) || !node.contains(target)) {
        return;
      }

      // Special-case keydown because certain keys do not emit a keypress
      // event. Conversely avoid keydown as the canonical event since
      // there are many keydown which are explicitly not targeted for
      // typing.
      if (type === 'keydown' && !isKeyDownEligibleForStartTyping(event)) {
        return;
      }
      startTyping();
    }
    node.addEventListener('keypress', startTypingInTextField);
    node.addEventListener('keydown', startTypingInTextField);
    return () => {
      node.removeEventListener('keypress', startTypingInTextField);
      node.removeEventListener('keydown', startTypingInTextField);
    };
  }, [isTyping, startTyping, stopTyping]);
  return (0,use_merge_refs/* default */.A)([ref1, ref2]);
}
function ObserveTyping({
  children
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ref: useTypingObserver(),
    children: children
  });
}

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/observe-typing/README.md
 */
/* harmony default export */ const observe_typing = (ObserveTyping);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-list/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */












const block_list_IntersectionObserver = (0,react.createContext)();
const pendingBlockVisibilityUpdatesPerRegistry = new WeakMap();
function block_list_Root({
  className,
  ...settings
}) {
  const isLargeViewport = (0,use_viewport_match/* default */.A)('medium');
  const {
    isOutlineMode,
    isFocusMode,
    editorMode,
    temporarilyEditingAsBlocks
  } = (0,use_select/* default */.A)(select => {
    const {
      getSettings,
      __unstableGetEditorMode,
      getTemporarilyEditingAsBlocks,
      isTyping
    } = lock_unlock_unlock(select(store_store));
    const {
      outlineMode,
      focusMode
    } = getSettings();
    return {
      isOutlineMode: outlineMode && !isTyping(),
      isFocusMode: focusMode,
      editorMode: __unstableGetEditorMode(),
      temporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks()
    };
  }, []);
  const registry = (0,use_registry/* default */.A)();
  const {
    setBlockVisibility
  } = (0,use_dispatch/* default */.A)(store_store);
  const delayedBlockVisibilityUpdates = (0,use_debounce/* default */.A)((0,react.useCallback)(() => {
    const updates = {};
    pendingBlockVisibilityUpdatesPerRegistry.get(registry).forEach(([id, isIntersecting]) => {
      updates[id] = isIntersecting;
    });
    setBlockVisibility(updates);
  }, [registry]), 300, {
    trailing: true
  });
  const intersectionObserver = (0,react.useMemo)(() => {
    const {
      IntersectionObserver: Observer
    } = window;
    if (!Observer) {
      return;
    }
    return new Observer(entries => {
      if (!pendingBlockVisibilityUpdatesPerRegistry.get(registry)) {
        pendingBlockVisibilityUpdatesPerRegistry.set(registry, []);
      }
      for (const entry of entries) {
        const clientId = entry.target.getAttribute('data-block');
        pendingBlockVisibilityUpdatesPerRegistry.get(registry).push([clientId, entry.isIntersecting]);
      }
      delayedBlockVisibilityUpdates();
    });
  }, []);
  const innerBlocksProps = useInnerBlocksProps({
    ref: (0,use_merge_refs/* default */.A)([useBlockSelectionClearer(), useInBetweenInserter(), useTypingObserver()]),
    className: (0,dist_clsx/* default */.A)('is-root-container', className, {
      'is-outline-mode': isOutlineMode,
      'is-focus-mode': isFocusMode && isLargeViewport,
      'is-navigate-mode': editorMode === 'navigation'
    })
  }, settings);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(block_list_IntersectionObserver.Provider, {
    value: intersectionObserver,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      ...innerBlocksProps
    }), !!temporarilyEditingAsBlocks && /*#__PURE__*/(0,jsx_runtime.jsx)(StopEditingAsBlocksOnOutsideSelect, {
      clientId: temporarilyEditingAsBlocks
    })]
  });
}
function StopEditingAsBlocksOnOutsideSelect({
  clientId
}) {
  const {
    stopEditingAsBlocks
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  const isBlockOrDescendantSelected = (0,use_select/* default */.A)(select => {
    const {
      isBlockSelected,
      hasSelectedInnerBlock
    } = select(store_store);
    return isBlockSelected(clientId) || hasSelectedInnerBlock(clientId, true);
  }, [clientId]);
  (0,react.useEffect)(() => {
    if (!isBlockOrDescendantSelected) {
      stopEditingAsBlocks(clientId);
    }
  }, [isBlockOrDescendantSelected, clientId, stopEditingAsBlocks]);
  return null;
}
function BlockList(settings) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Provider, {
    value: DEFAULT_BLOCK_EDIT_CONTEXT,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_list_Root, {
      ...settings
    })
  });
}
const block_list_EMPTY_ARRAY = [];
const block_list_EMPTY_SET = new Set();
function Items({
  placeholder,
  rootClientId,
  renderAppender: CustomAppender,
  __experimentalAppenderTagName,
  layout = defaultLayout
}) {
  // Avoid passing CustomAppender to useSelect because it could be a new
  // function on every render.
  const hasAppender = CustomAppender !== false;
  const hasCustomAppender = !!CustomAppender;
  const {
    order,
    selectedBlocks,
    visibleBlocks,
    shouldRenderAppender
  } = (0,use_select/* default */.A)(select => {
    const {
      getSettings,
      getBlockOrder,
      getSelectedBlockClientId,
      getSelectedBlockClientIds,
      __unstableGetVisibleBlocks,
      getTemplateLock,
      getBlockEditingMode,
      __unstableGetEditorMode
    } = select(store_store);
    const _order = getBlockOrder(rootClientId);
    if (getSettings().__unstableIsPreviewMode) {
      return {
        order: _order,
        selectedBlocks: block_list_EMPTY_ARRAY,
        visibleBlocks: block_list_EMPTY_SET
      };
    }
    const selectedBlockClientId = getSelectedBlockClientId();
    return {
      order: _order,
      selectedBlocks: getSelectedBlockClientIds(),
      visibleBlocks: __unstableGetVisibleBlocks(),
      shouldRenderAppender: hasAppender && __unstableGetEditorMode() !== 'zoom-out' && (hasCustomAppender ? !getTemplateLock(rootClientId) && getBlockEditingMode(rootClientId) !== 'disabled' : rootClientId === selectedBlockClientId || !rootClientId && !selectedBlockClientId && !_order.length)
    };
  }, [rootClientId, hasAppender, hasCustomAppender]);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(LayoutProvider, {
    value: layout,
    children: [order.map(clientId => /*#__PURE__*/(0,jsx_runtime.jsx)(async_mode_provider_context/* default */.Ay, {
      value:
      // Only provide data asynchronously if the block is
      // not visible and not selected.
      !visibleBlocks.has(clientId) && !selectedBlocks.includes(clientId),
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_list_block, {
        rootClientId: rootClientId,
        clientId: clientId
      })
    }, clientId)), order.length < 1 && placeholder, shouldRenderAppender && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockListAppender, {
      tagName: __experimentalAppenderTagName,
      rootClientId: rootClientId,
      CustomAppender: CustomAppender
    })]
  });
}
function block_list_BlockListItems(props) {
  // This component needs to always be synchronous as it's the one changing
  // the async mode depending on the block selection.
  return /*#__PURE__*/(0,jsx_runtime.jsx)(async_mode_provider_context/* default */.Ay, {
    value: false,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(Items, {
      ...props
    })
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/use-block-toolbar-popover-props.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



const COMMON_PROPS = {
  placement: 'top-start'
};

// By default the toolbar sets the `shift` prop. If the user scrolls the page
// down the toolbar will stay on screen by adopting a sticky position at the
// top of the viewport.
const use_block_toolbar_popover_props_DEFAULT_PROPS = {
  ...COMMON_PROPS,
  flip: false,
  shift: true
};

// When there isn't enough height between the top of the block and the editor
// canvas, the `shift` prop is set to `false`, as it will cause the block to be
// obscured. The `flip` behavior is enabled, which positions the toolbar below
// the block. This only happens if the block is smaller than the viewport, as
// otherwise the toolbar will be off-screen.
const RESTRICTED_HEIGHT_PROPS = {
  ...COMMON_PROPS,
  flip: true,
  shift: false
};

/**
 * Get the popover props for the block toolbar, determined by the space at the top of the canvas and the toolbar height.
 *
 * @param {Element} contentElement       The DOM element that represents the editor content or canvas.
 * @param {Element} selectedBlockElement The outer DOM element of the first selected block.
 * @param {Element} scrollContainer      The scrollable container for the contentElement.
 * @param {number}  toolbarHeight        The height of the toolbar in pixels.
 * @param {boolean} isSticky             Whether or not the selected block is sticky or fixed.
 *
 * @return {Object} The popover props used to determine the position of the toolbar.
 */
function getProps(contentElement, selectedBlockElement, scrollContainer, toolbarHeight, isSticky) {
  if (!contentElement || !selectedBlockElement) {
    return use_block_toolbar_popover_props_DEFAULT_PROPS;
  }

  // Get how far the content area has been scrolled.
  const scrollTop = scrollContainer?.scrollTop || 0;
  const blockRect = selectedBlockElement.getBoundingClientRect();
  const contentRect = contentElement.getBoundingClientRect();

  // Get the vertical position of top of the visible content area.
  const topOfContentElementInViewport = scrollTop + contentRect.top;

  // The document element's clientHeight represents the viewport height.
  const viewportHeight = contentElement.ownerDocument.documentElement.clientHeight;

  // The restricted height area is calculated as the sum of the
  // vertical position of the visible content area, plus the height
  // of the block toolbar.
  const restrictedTopArea = topOfContentElementInViewport + toolbarHeight;
  const hasSpaceForToolbarAbove = blockRect.top > restrictedTopArea;
  const isBlockTallerThanViewport = blockRect.height > viewportHeight - toolbarHeight;

  // Sticky blocks are treated as if they will never have enough space for the toolbar above.
  if (!isSticky && (hasSpaceForToolbarAbove || isBlockTallerThanViewport)) {
    return use_block_toolbar_popover_props_DEFAULT_PROPS;
  }
  return RESTRICTED_HEIGHT_PROPS;
}

/**
 * Determines the desired popover positioning behavior, returning a set of appropriate props.
 *
 * @param {Object}  elements
 * @param {Element} elements.contentElement The DOM element that represents the editor content or canvas.
 * @param {string}  elements.clientId       The clientId of the first selected block.
 *
 * @return {Object} The popover props used to determine the position of the toolbar.
 */
function useBlockToolbarPopoverProps({
  contentElement,
  clientId
}) {
  const selectedBlockElement = useBlockElement(clientId);
  const [toolbarHeight, setToolbarHeight] = (0,react.useState)(0);
  const {
    blockIndex,
    isSticky
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockIndex,
      getBlockAttributes
    } = select(store_store);
    return {
      blockIndex: getBlockIndex(clientId),
      isSticky: hasStickyOrFixedPositionValue(getBlockAttributes(clientId))
    };
  }, [clientId]);
  const scrollContainer = (0,react.useMemo)(() => {
    if (!contentElement) {
      return;
    }
    return (0,get_scroll_container/* default */.A)(contentElement);
  }, [contentElement]);
  const [props, setProps] = (0,react.useState)(() => getProps(contentElement, selectedBlockElement, scrollContainer, toolbarHeight, isSticky));
  const popoverRef = (0,use_ref_effect/* default */.A)(popoverNode => {
    setToolbarHeight(popoverNode.offsetHeight);
  }, []);
  const updateProps = (0,react.useCallback)(() => setProps(getProps(contentElement, selectedBlockElement, scrollContainer, toolbarHeight, isSticky)), [contentElement, selectedBlockElement, scrollContainer, toolbarHeight]);

  // Update props when the block is moved. This also ensures the props are
  // correct on initial mount, and when the selected block or content element
  // changes (since the callback ref will update).
  (0,react.useLayoutEffect)(updateProps, [blockIndex, updateProps]);

  // Update props when the viewport is resized or the block is resized.
  (0,react.useLayoutEffect)(() => {
    if (!contentElement || !selectedBlockElement) {
      return;
    }

    // Update the toolbar props on viewport resize.
    const contentView = contentElement?.ownerDocument?.defaultView;
    contentView?.addEventHandler?.('resize', updateProps);

    // Update the toolbar props on block resize.
    let resizeObserver;
    const blockView = selectedBlockElement?.ownerDocument?.defaultView;
    if (blockView.ResizeObserver) {
      resizeObserver = new blockView.ResizeObserver(updateProps);
      resizeObserver.observe(selectedBlockElement);
    }
    return () => {
      contentView?.removeEventHandler?.('resize', updateProps);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [updateProps, contentElement, selectedBlockElement]);
  return {
    ...props,
    ref: popoverRef
  };
}
//# sourceMappingURL=use-block-toolbar-popover-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/use-selected-block-tool-props.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns props for the selected block tools and empty block inserter.
 *
 * @param {string} clientId Selected block client ID.
 */
function useSelectedBlockToolProps(clientId) {
  const selectedBlockProps = (0,use_select/* default */.A)(select => {
    const {
      getBlockRootClientId,
      getBlockParents,
      __experimentalGetBlockListSettingsForBlocks,
      isBlockInsertionPointVisible,
      getBlockInsertionPoint,
      getBlockOrder,
      hasMultiSelection,
      getLastMultiSelectedBlockClientId
    } = select(store_store);
    const blockParentsClientIds = getBlockParents(clientId);

    // Get Block List Settings for all ancestors of the current Block clientId.
    const parentBlockListSettings = __experimentalGetBlockListSettingsForBlocks(blockParentsClientIds);

    // Get the clientId of the topmost parent with the capture toolbars setting.
    const capturingClientId = blockParentsClientIds.find(parentClientId => parentBlockListSettings[parentClientId]?.__experimentalCaptureToolbars);
    let isInsertionPointVisible = false;
    if (isBlockInsertionPointVisible()) {
      const insertionPoint = getBlockInsertionPoint();
      const order = getBlockOrder(insertionPoint.rootClientId);
      isInsertionPointVisible = order[insertionPoint.index] === clientId;
    }
    return {
      capturingClientId,
      isInsertionPointVisible,
      lastClientId: hasMultiSelection() ? getLastMultiSelectedBlockClientId() : null,
      rootClientId: getBlockRootClientId(clientId)
    };
  }, [clientId]);
  return selectedBlockProps;
}
//# sourceMappingURL=use-selected-block-tool-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/empty-block-inserter.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */





function EmptyBlockInserter({
  clientId,
  __unstableContentRef
}) {
  const {
    capturingClientId,
    isInsertionPointVisible,
    lastClientId,
    rootClientId
  } = useSelectedBlockToolProps(clientId);
  const popoverProps = useBlockToolbarPopoverProps({
    contentElement: __unstableContentRef?.current,
    clientId
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(cover, {
    clientId: capturingClientId || clientId,
    bottomClientId: lastClientId,
    className: (0,dist_clsx/* default */.A)('block-editor-block-list__block-side-inserter-popover', {
      'is-insertion-point-visible': isInsertionPointVisible
    }),
    __unstableContentRef: __unstableContentRef,
    ...popoverProps,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-block-list__empty-block-inserter",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(inserter, {
        position: "bottom right",
        rootClientId: rootClientId,
        clientId: clientId,
        __experimentalIsQuick: true
      })
    })
  });
}
//# sourceMappingURL=empty-block-inserter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-draggable/use-scroll-when-dragging.js
/**
 * WordPress dependencies
 */


const SCROLL_INACTIVE_DISTANCE_PX = 50;
const SCROLL_INTERVAL_MS = 25;
const PIXELS_PER_SECOND_PER_PERCENTAGE = 1000;
const VELOCITY_MULTIPLIER = PIXELS_PER_SECOND_PER_PERCENTAGE * (SCROLL_INTERVAL_MS / 1000);

/**
 * React hook that scrolls the scroll container when a block is being dragged.
 *
 * @return {Function[]} `startScrolling`, `scrollOnDragOver`, `stopScrolling`
 *                      functions to be called in `onDragStart`, `onDragOver`
 *                      and `onDragEnd` events respectively.
 */
function useScrollWhenDragging() {
  const dragStartY = (0,react.useRef)(null);
  const velocityY = (0,react.useRef)(null);
  const scrollParentY = (0,react.useRef)(null);
  const scrollEditorInterval = (0,react.useRef)(null);

  // Clear interval when unmounting.
  (0,react.useEffect)(() => () => {
    if (scrollEditorInterval.current) {
      clearInterval(scrollEditorInterval.current);
      scrollEditorInterval.current = null;
    }
  }, []);
  const startScrolling = (0,react.useCallback)(event => {
    dragStartY.current = event.clientY;

    // Find nearest parent(s) to scroll.
    scrollParentY.current = (0,get_scroll_container/* default */.A)(event.target);
    scrollEditorInterval.current = setInterval(() => {
      if (scrollParentY.current && velocityY.current) {
        const newTop = scrollParentY.current.scrollTop + velocityY.current;

        // Setting `behavior: 'smooth'` as a scroll property seems to hurt performance.
        // Better to use a small scroll interval.
        scrollParentY.current.scroll({
          top: newTop
        });
      }
    }, SCROLL_INTERVAL_MS);
  }, []);
  const scrollOnDragOver = (0,react.useCallback)(event => {
    if (!scrollParentY.current) {
      return;
    }
    const scrollParentHeight = scrollParentY.current.offsetHeight;
    const offsetDragStartPosition = dragStartY.current - scrollParentY.current.offsetTop;
    const offsetDragPosition = event.clientY - scrollParentY.current.offsetTop;
    if (event.clientY > offsetDragStartPosition) {
      // User is dragging downwards.
      const moveableDistance = Math.max(scrollParentHeight - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const dragDistance = Math.max(offsetDragPosition - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const distancePercentage = moveableDistance === 0 || dragDistance === 0 ? 0 : dragDistance / moveableDistance;
      velocityY.current = VELOCITY_MULTIPLIER * distancePercentage;
    } else if (event.clientY < offsetDragStartPosition) {
      // User is dragging upwards.
      const moveableDistance = Math.max(offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const dragDistance = Math.max(offsetDragStartPosition - offsetDragPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const distancePercentage = moveableDistance === 0 || dragDistance === 0 ? 0 : dragDistance / moveableDistance;
      velocityY.current = -VELOCITY_MULTIPLIER * distancePercentage;
    } else {
      velocityY.current = 0;
    }
  }, []);
  const stopScrolling = () => {
    dragStartY.current = null;
    scrollParentY.current = null;
    if (scrollEditorInterval.current) {
      clearInterval(scrollEditorInterval.current);
      scrollEditorInterval.current = null;
    }
  };
  return [startScrolling, scrollOnDragOver, stopScrolling];
}
//# sourceMappingURL=use-scroll-when-dragging.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-draggable/index.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */






const BlockDraggable = ({
  appendToOwnerDocument,
  children,
  clientIds,
  cloneClassname,
  elementId,
  onDragStart,
  onDragEnd,
  fadeWhenDisabled = false,
  dragComponent
}) => {
  const {
    srcRootClientId,
    isDraggable,
    icon,
    visibleInserter,
    getBlockType
  } = (0,use_select/* default */.A)(select => {
    const {
      canMoveBlocks,
      getBlockRootClientId,
      getBlockName,
      getBlockAttributes,
      isBlockInsertionPointVisible
    } = select(store_store);
    const {
      getBlockType: _getBlockType,
      getActiveBlockVariation
    } = select(build_module/* store */.M_);
    const rootClientId = getBlockRootClientId(clientIds[0]);
    const blockName = getBlockName(clientIds[0]);
    const variation = getActiveBlockVariation(blockName, getBlockAttributes(clientIds[0]));
    return {
      srcRootClientId: rootClientId,
      isDraggable: canMoveBlocks(clientIds),
      icon: variation?.icon || _getBlockType(blockName)?.icon,
      visibleInserter: isBlockInsertionPointVisible(),
      getBlockType: _getBlockType
    };
  }, [clientIds]);
  const isDragging = (0,react.useRef)(false);
  const [startScrolling, scrollOnDragOver, stopScrolling] = useScrollWhenDragging();
  const {
    getAllowedBlocks,
    getBlockNamesByClientId,
    getBlockRootClientId
  } = (0,use_select/* default */.A)(store_store);
  const {
    startDraggingBlocks,
    stopDraggingBlocks
  } = (0,use_dispatch/* default */.A)(store_store);

  // Stop dragging blocks if the block draggable is unmounted.
  (0,react.useEffect)(() => {
    return () => {
      if (isDragging.current) {
        stopDraggingBlocks();
      }
    };
  }, []);

  // Find the root of the editor iframe.
  const blockRef = useBlockRef(clientIds[0]);
  const editorRoot = blockRef.current?.closest('body');

  /*
   * Add a dragover event listener to the editor root to track the blocks being dragged over.
   * The listener has to be inside the editor iframe otherwise the target isn't accessible.
   */
  (0,react.useEffect)(() => {
    if (!editorRoot || !fadeWhenDisabled) {
      return;
    }
    const onDragOver = event => {
      if (!event.target.closest('[data-block]')) {
        return;
      }
      const draggedBlockNames = getBlockNamesByClientId(clientIds);
      const targetClientId = event.target.closest('[data-block]').getAttribute('data-block');
      const allowedBlocks = getAllowedBlocks(targetClientId);
      const targetBlockName = getBlockNamesByClientId([targetClientId])[0];

      /*
       * Check if the target is valid to drop in.
       * If the target's allowedBlocks is an empty array,
       * it isn't a container block, in which case we check
       * its parent's validity instead.
       */
      let dropTargetValid;
      if (allowedBlocks?.length === 0) {
        const targetRootClientId = getBlockRootClientId(targetClientId);
        const targetRootBlockName = getBlockNamesByClientId([targetRootClientId])[0];
        const rootAllowedBlocks = getAllowedBlocks(targetRootClientId);
        dropTargetValid = isDropTargetValid(getBlockType, rootAllowedBlocks, draggedBlockNames, targetRootBlockName);
      } else {
        dropTargetValid = isDropTargetValid(getBlockType, allowedBlocks, draggedBlockNames, targetBlockName);
      }

      /*
       * Update the body class to reflect if drop target is valid.
       * This has to be done on the document body because the draggable
       * chip is rendered outside of the editor iframe.
       */
      if (!dropTargetValid && !visibleInserter) {
        window?.document?.body?.classList?.add('block-draggable-invalid-drag-token');
      } else {
        window?.document?.body?.classList?.remove('block-draggable-invalid-drag-token');
      }
    };
    const throttledOnDragOver = (0,throttle/* throttle */.n)(onDragOver, 200);
    editorRoot.addEventListener('dragover', throttledOnDragOver);
    return () => {
      editorRoot.removeEventListener('dragover', throttledOnDragOver);
    };
  }, [clientIds, editorRoot, fadeWhenDisabled, getAllowedBlocks, getBlockNamesByClientId, getBlockRootClientId, getBlockType, visibleInserter]);
  if (!isDraggable) {
    return children({
      draggable: false
    });
  }
  const transferData = {
    type: 'block',
    srcClientIds: clientIds,
    srcRootClientId
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(draggable/* default */.A, {
    appendToOwnerDocument: appendToOwnerDocument,
    cloneClassname: cloneClassname,
    __experimentalTransferDataType: "wp-blocks",
    transferData: transferData,
    onDragStart: event => {
      // Defer hiding the dragged source element to the next
      // frame to enable dragging.
      window.requestAnimationFrame(() => {
        startDraggingBlocks(clientIds);
        isDragging.current = true;
        startScrolling(event);
        if (onDragStart) {
          onDragStart();
        }
      });
    },
    onDragOver: scrollOnDragOver,
    onDragEnd: () => {
      stopDraggingBlocks();
      isDragging.current = false;
      stopScrolling();
      if (onDragEnd) {
        onDragEnd();
      }
    },
    __experimentalDragComponent:
    // Check against `undefined` so that `null` can be used to disable
    // the default drag component.
    dragComponent !== undefined ? dragComponent : /*#__PURE__*/(0,jsx_runtime.jsx)(BlockDraggableChip, {
      count: clientIds.length,
      icon: icon,
      fadeWhenDisabled: true
    }),
    elementId: elementId,
    children: ({
      onDraggableStart,
      onDraggableEnd
    }) => {
      return children({
        draggable: true,
        onDragStart: onDraggableStart,
        onDragEnd: onDraggableEnd
      });
    }
  });
};
/* harmony default export */ const block_draggable = (BlockDraggable);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-mover/mover-description.js
/**
 * WordPress dependencies
 */

const getMovementDirection = (moveDirection, orientation) => {
  if (moveDirection === 'up') {
    if (orientation === 'horizontal') {
      return (0,i18n_build_module/* isRTL */.V8)() ? 'right' : 'left';
    }
    return 'up';
  } else if (moveDirection === 'down') {
    if (orientation === 'horizontal') {
      return (0,i18n_build_module/* isRTL */.V8)() ? 'left' : 'right';
    }
    return 'down';
  }
  return null;
};

/**
 * Return a label for the block movement controls depending on block position.
 *
 * @param {number}  selectedCount Number of blocks selected.
 * @param {string}  type          Block type - in the case of a single block, should
 *                                define its 'type'. I.e. 'Text', 'Heading', 'Image' etc.
 * @param {number}  firstIndex    The index (position - 1) of the first block selected.
 * @param {boolean} isFirst       This is the first block.
 * @param {boolean} isLast        This is the last block.
 * @param {number}  dir           Direction of movement (> 0 is considered to be going
 *                                down, < 0 is up).
 * @param {string}  orientation   The orientation of the block movers, vertical or
 *                                horizontal.
 *
 * @return {string | undefined} Label for the block movement controls.
 */
function getBlockMoverDescription(selectedCount, type, firstIndex, isFirst, isLast, dir, orientation) {
  const position = firstIndex + 1;
  if (selectedCount > 1) {
    return getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation);
  }
  if (isFirst && isLast) {
    return (0,i18n_build_module/* sprintf */.nv)(
    // translators: %s: Type of block (i.e. Text, Image etc)
    (0,i18n_build_module.__)('Block %s is the only block, and cannot be moved'), type);
  }
  if (dir > 0 && !isLast) {
    // Moving down.
    const movementDirection = getMovementDirection('down', orientation);
    if (movementDirection === 'down') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,i18n_build_module.__)('Move %1$s block from position %2$d down to position %3$d'), type, position, position + 1);
    }
    if (movementDirection === 'left') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,i18n_build_module.__)('Move %1$s block from position %2$d left to position %3$d'), type, position, position + 1);
    }
    if (movementDirection === 'right') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,i18n_build_module.__)('Move %1$s block from position %2$d right to position %3$d'), type, position, position + 1);
    }
  }
  if (dir > 0 && isLast) {
    // Moving down, and is the last item.
    const movementDirection = getMovementDirection('down', orientation);
    if (movementDirection === 'down') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc)
      (0,i18n_build_module.__)('Block %1$s is at the end of the content and can’t be moved down'), type);
    }
    if (movementDirection === 'left') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc)
      (0,i18n_build_module.__)('Block %1$s is at the end of the content and can’t be moved left'), type);
    }
    if (movementDirection === 'right') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc)
      (0,i18n_build_module.__)('Block %1$s is at the end of the content and can’t be moved right'), type);
    }
  }
  if (dir < 0 && !isFirst) {
    // Moving up.
    const movementDirection = getMovementDirection('up', orientation);
    if (movementDirection === 'up') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,i18n_build_module.__)('Move %1$s block from position %2$d up to position %3$d'), type, position, position - 1);
    }
    if (movementDirection === 'left') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,i18n_build_module.__)('Move %1$s block from position %2$d left to position %3$d'), type, position, position - 1);
    }
    if (movementDirection === 'right') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,i18n_build_module.__)('Move %1$s block from position %2$d right to position %3$d'), type, position, position - 1);
    }
  }
  if (dir < 0 && isFirst) {
    // Moving up, and is the first item.
    const movementDirection = getMovementDirection('up', orientation);
    if (movementDirection === 'up') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc)
      (0,i18n_build_module.__)('Block %1$s is at the beginning of the content and can’t be moved up'), type);
    }
    if (movementDirection === 'left') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc)
      (0,i18n_build_module.__)('Block %1$s is at the beginning of the content and can’t be moved left'), type);
    }
    if (movementDirection === 'right') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Type of block (i.e. Text, Image etc)
      (0,i18n_build_module.__)('Block %1$s is at the beginning of the content and can’t be moved right'), type);
    }
  }
}

/**
 * Return a label for the block movement controls depending on block position.
 *
 * @param {number}  selectedCount Number of blocks selected.
 * @param {number}  firstIndex    The index (position - 1) of the first block selected.
 * @param {boolean} isFirst       This is the first block.
 * @param {boolean} isLast        This is the last block.
 * @param {number}  dir           Direction of movement (> 0 is considered to be going
 *                                down, < 0 is up).
 * @param {string}  orientation   The orientation of the block movers, vertical or
 *                                horizontal.
 *
 * @return {string | undefined} Label for the block movement controls.
 */
function getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation) {
  const position = firstIndex + 1;
  if (isFirst && isLast) {
    // All blocks are selected
    return (0,i18n_build_module.__)('All blocks are selected, and cannot be moved');
  }
  if (dir > 0 && !isLast) {
    // moving down
    const movementDirection = getMovementDirection('down', orientation);
    if (movementDirection === 'down') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,i18n_build_module.__)('Move %1$d blocks from position %2$d down by one place'), selectedCount, position);
    }
    if (movementDirection === 'left') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,i18n_build_module.__)('Move %1$d blocks from position %2$d left by one place'), selectedCount, position);
    }
    if (movementDirection === 'right') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,i18n_build_module.__)('Move %1$d blocks from position %2$d right by one place'), selectedCount, position);
    }
  }
  if (dir > 0 && isLast) {
    // moving down, and the selected blocks are the last item
    const movementDirection = getMovementDirection('down', orientation);
    if (movementDirection === 'down') {
      return (0,i18n_build_module.__)('Blocks cannot be moved down as they are already at the bottom');
    }
    if (movementDirection === 'left') {
      return (0,i18n_build_module.__)('Blocks cannot be moved left as they are already are at the leftmost position');
    }
    if (movementDirection === 'right') {
      return (0,i18n_build_module.__)('Blocks cannot be moved right as they are already are at the rightmost position');
    }
  }
  if (dir < 0 && !isFirst) {
    // moving up
    const movementDirection = getMovementDirection('up', orientation);
    if (movementDirection === 'up') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,i18n_build_module.__)('Move %1$d blocks from position %2$d up by one place'), selectedCount, position);
    }
    if (movementDirection === 'left') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,i18n_build_module.__)('Move %1$d blocks from position %2$d left by one place'), selectedCount, position);
    }
    if (movementDirection === 'right') {
      return (0,i18n_build_module/* sprintf */.nv)(
      // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,i18n_build_module.__)('Move %1$d blocks from position %2$d right by one place'), selectedCount, position);
    }
  }
  if (dir < 0 && isFirst) {
    // moving up, and the selected blocks are the first item
    const movementDirection = getMovementDirection('up', orientation);
    if (movementDirection === 'up') {
      return (0,i18n_build_module.__)('Blocks cannot be moved up as they are already at the top');
    }
    if (movementDirection === 'left') {
      return (0,i18n_build_module.__)('Blocks cannot be moved left as they are already are at the leftmost position');
    }
    if (movementDirection === 'right') {
      return (0,i18n_build_module.__)('Blocks cannot be moved right as they are already are at the rightmost position');
    }
  }
}
//# sourceMappingURL=mover-description.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-mover/button.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */






const getArrowIcon = (direction, orientation) => {
  if (direction === 'up') {
    if (orientation === 'horizontal') {
      return (0,i18n_build_module/* isRTL */.V8)() ? chevron_right/* default */.A : chevron_left;
    }
    return chevron_up/* default */.A;
  } else if (direction === 'down') {
    if (orientation === 'horizontal') {
      return (0,i18n_build_module/* isRTL */.V8)() ? chevron_left : chevron_right/* default */.A;
    }
    return library_chevron_down/* default */.A;
  }
  return null;
};
const getMovementDirectionLabel = (moveDirection, orientation) => {
  if (moveDirection === 'up') {
    if (orientation === 'horizontal') {
      return (0,i18n_build_module/* isRTL */.V8)() ? (0,i18n_build_module.__)('Move right') : (0,i18n_build_module.__)('Move left');
    }
    return (0,i18n_build_module.__)('Move up');
  } else if (moveDirection === 'down') {
    if (orientation === 'horizontal') {
      return (0,i18n_build_module/* isRTL */.V8)() ? (0,i18n_build_module.__)('Move left') : (0,i18n_build_module.__)('Move right');
    }
    return (0,i18n_build_module.__)('Move down');
  }
  return null;
};
const BlockMoverButton = (0,react.forwardRef)(({
  clientIds,
  direction,
  orientation: moverOrientation,
  ...props
}, ref) => {
  const instanceId = (0,use_instance_id/* default */.A)(BlockMoverButton);
  const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
  const blocksCount = normalizedClientIds.length;
  const {
    disabled
  } = props;
  const {
    blockType,
    isDisabled,
    rootClientId,
    isFirst,
    isLast,
    firstIndex,
    orientation = 'vertical'
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockIndex,
      getBlockRootClientId,
      getBlockOrder,
      getBlock,
      getBlockListSettings
    } = select(store_store);
    const firstClientId = normalizedClientIds[0];
    const blockRootClientId = getBlockRootClientId(firstClientId);
    const firstBlockIndex = getBlockIndex(firstClientId);
    const lastBlockIndex = getBlockIndex(normalizedClientIds[normalizedClientIds.length - 1]);
    const blockOrder = getBlockOrder(blockRootClientId);
    const block = getBlock(firstClientId);
    const isFirstBlock = firstBlockIndex === 0;
    const isLastBlock = lastBlockIndex === blockOrder.length - 1;
    const {
      orientation: blockListOrientation
    } = getBlockListSettings(blockRootClientId) || {};
    return {
      blockType: block ? (0,build_module/* getBlockType */.E7)(block.name) : null,
      isDisabled: disabled || (direction === 'up' ? isFirstBlock : isLastBlock),
      rootClientId: blockRootClientId,
      firstIndex: firstBlockIndex,
      isFirst: isFirstBlock,
      isLast: isLastBlock,
      orientation: moverOrientation || blockListOrientation
    };
  }, [clientIds, direction]);
  const {
    moveBlocksDown,
    moveBlocksUp
  } = (0,use_dispatch/* default */.A)(store_store);
  const moverFunction = direction === 'up' ? moveBlocksUp : moveBlocksDown;
  const onClick = event => {
    moverFunction(clientIds, rootClientId);
    if (props.onClick) {
      props.onClick(event);
    }
  };
  const descriptionId = `block-editor-block-mover-button__description-${instanceId}`;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
      ref: ref,
      className: (0,dist_clsx/* default */.A)('block-editor-block-mover-button', `is-${direction}-button`),
      icon: getArrowIcon(direction, orientation),
      label: getMovementDirectionLabel(direction, orientation),
      "aria-describedby": descriptionId,
      ...props,
      onClick: isDisabled ? null : onClick,
      disabled: isDisabled,
      __experimentalIsFocusable: true
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
      id: descriptionId,
      children: getBlockMoverDescription(blocksCount, blockType && blockType.title, firstIndex, isFirst, isLast, direction === 'up' ? -1 : 1, orientation)
    })]
  });
});
const BlockMoverUpButton = (0,react.forwardRef)((props, ref) => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockMoverButton, {
    direction: "up",
    ref: ref,
    ...props
  });
});
const BlockMoverDownButton = (0,react.forwardRef)((props, ref) => {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockMoverButton, {
    direction: "down",
    ref: ref,
    ...props
  });
});
//# sourceMappingURL=button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-mover/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */





function BlockMover({
  clientIds,
  hideDragHandle,
  isBlockMoverUpButtonDisabled,
  isBlockMoverDownButtonDisabled
}) {
  const {
    canMove,
    rootClientId,
    isFirst,
    isLast,
    orientation
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockIndex,
      getBlockListSettings,
      canMoveBlocks,
      getBlockOrder,
      getBlockRootClientId
    } = select(store_store);
    const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
    const firstClientId = normalizedClientIds[0];
    const _rootClientId = getBlockRootClientId(firstClientId);
    const firstIndex = getBlockIndex(firstClientId);
    const lastIndex = getBlockIndex(normalizedClientIds[normalizedClientIds.length - 1]);
    const blockOrder = getBlockOrder(_rootClientId);
    return {
      canMove: canMoveBlocks(clientIds),
      rootClientId: _rootClientId,
      isFirst: firstIndex === 0,
      isLast: lastIndex === blockOrder.length - 1,
      orientation: getBlockListSettings(_rootClientId)?.orientation
    };
  }, [clientIds]);
  if (!canMove || isFirst && isLast && !rootClientId) {
    return null;
  }
  const dragHandleLabel = (0,i18n_build_module.__)('Drag');
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(toolbar_group/* default */.A, {
    className: (0,dist_clsx/* default */.A)('block-editor-block-mover', {
      'is-horizontal': orientation === 'horizontal'
    }),
    children: [!hideDragHandle && /*#__PURE__*/(0,jsx_runtime.jsx)(block_draggable, {
      clientIds: clientIds,
      fadeWhenDisabled: true,
      children: draggableProps => /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        icon: drag_handle,
        className: "block-editor-block-mover__drag-handle",
        "aria-hidden": "true",
        label: dragHandleLabel
        // Should not be able to tab to drag handle as this
        // button can only be used with a pointer device.
        ,
        tabIndex: "-1",
        ...draggableProps
      })
    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: "block-editor-block-mover__move-button-container",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_item/* default */.A, {
        children: itemProps => /*#__PURE__*/(0,jsx_runtime.jsx)(BlockMoverUpButton, {
          disabled: isBlockMoverUpButtonDisabled,
          clientIds: clientIds,
          ...itemProps
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_item/* default */.A, {
        children: itemProps => /*#__PURE__*/(0,jsx_runtime.jsx)(BlockMoverDownButton, {
          disabled: isBlockMoverDownButtonDisabled,
          clientIds: clientIds,
          ...itemProps
        })
      })]
    })]
  });
}

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-mover/README.md
 */
/* harmony default export */ const block_mover = (BlockMover);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/utils.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */

const {
  clearTimeout: utils_clearTimeout,
  setTimeout: utils_setTimeout
} = window;
const DEBOUNCE_TIMEOUT = 200;

/**
 * Hook that creates debounced callbacks when the node is hovered or focused.
 *
 * @param {Object}  props                       Component props.
 * @param {Object}  props.ref                   Element reference.
 * @param {boolean} props.isFocused             Whether the component has current focus.
 * @param {number}  props.highlightParent       Whether to highlight the parent block. It defaults in highlighting the selected block.
 * @param {number}  [props.debounceTimeout=250] Debounce timeout in milliseconds.
 */
function useDebouncedShowGestures({
  ref,
  isFocused,
  highlightParent,
  debounceTimeout = DEBOUNCE_TIMEOUT
}) {
  const {
    getSelectedBlockClientId,
    getBlockRootClientId
  } = (0,use_select/* default */.A)(store_store);
  const {
    toggleBlockHighlight
  } = (0,use_dispatch/* default */.A)(store_store);
  const timeoutRef = (0,react.useRef)();
  const isDistractionFree = (0,use_select/* default */.A)(select => select(store_store).getSettings().isDistractionFree, []);
  const handleOnChange = nextIsFocused => {
    if (nextIsFocused && isDistractionFree) {
      return;
    }
    const selectedBlockClientId = getSelectedBlockClientId();
    const clientId = highlightParent ? getBlockRootClientId(selectedBlockClientId) : selectedBlockClientId;
    toggleBlockHighlight(clientId, nextIsFocused);
  };
  const getIsHovered = () => {
    return ref?.current && ref.current.matches(':hover');
  };
  const shouldHideGestures = () => {
    const isHovered = getIsHovered();
    return !isFocused && !isHovered;
  };
  const clearTimeoutRef = () => {
    const timeout = timeoutRef.current;
    if (timeout && utils_clearTimeout) {
      utils_clearTimeout(timeout);
    }
  };
  const debouncedShowGestures = event => {
    if (event) {
      event.stopPropagation();
    }
    clearTimeoutRef();
    handleOnChange(true);
  };
  const debouncedHideGestures = event => {
    if (event) {
      event.stopPropagation();
    }
    clearTimeoutRef();
    timeoutRef.current = utils_setTimeout(() => {
      if (shouldHideGestures()) {
        handleOnChange(false);
      }
    }, debounceTimeout);
  };
  (0,react.useEffect)(() => () => {
    /**
     * We need to call the change handler with `isFocused`
     * set to false on unmount because we also clear the
     * timeout that would handle that.
     */
    handleOnChange(false);
    clearTimeoutRef();
  }, []);
  return {
    debouncedShowGestures,
    debouncedHideGestures
  };
}

/**
 * Hook that provides gesture events for DOM elements
 * that interact with the isFocused state.
 *
 * @param {Object} props                         Component props.
 * @param {Object} props.ref                     Element reference.
 * @param {number} [props.highlightParent=false] Whether to highlight the parent block. It defaults to highlighting the selected block.
 * @param {number} [props.debounceTimeout=250]   Debounce timeout in milliseconds.
 */
function useShowHoveredOrFocusedGestures({
  ref,
  highlightParent = false,
  debounceTimeout = DEBOUNCE_TIMEOUT
}) {
  const [isFocused, setIsFocused] = (0,react.useState)(false);
  const {
    debouncedShowGestures,
    debouncedHideGestures
  } = useDebouncedShowGestures({
    ref,
    debounceTimeout,
    isFocused,
    highlightParent
  });
  const registerRef = (0,react.useRef)(false);
  const isFocusedWithin = () => {
    return ref?.current && ref.current.contains(ref.current.ownerDocument.activeElement);
  };
  (0,react.useEffect)(() => {
    const node = ref.current;
    const handleOnFocus = () => {
      if (isFocusedWithin()) {
        setIsFocused(true);
        debouncedShowGestures();
      }
    };
    const handleOnBlur = () => {
      if (!isFocusedWithin()) {
        setIsFocused(false);
        debouncedHideGestures();
      }
    };

    /**
     * Events are added via DOM events (vs. React synthetic events),
     * as the child React components swallow mouse events.
     */
    if (node && !registerRef.current) {
      node.addEventListener('focus', handleOnFocus, true);
      node.addEventListener('blur', handleOnBlur, true);
      registerRef.current = true;
    }
    return () => {
      if (node) {
        node.removeEventListener('focus', handleOnFocus);
        node.removeEventListener('blur', handleOnBlur);
      }
    };
  }, [ref, registerRef, setIsFocused, debouncedShowGestures, debouncedHideGestures]);
  return {
    onMouseMove: debouncedShowGestures,
    onMouseLeave: debouncedHideGestures
  };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-parent-selector/index.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */





/**
 * Block parent selector component, displaying the hierarchy of the
 * current block selection as a single icon to "go up" a level.
 *
 * @return {Component} Parent block selector.
 */

function BlockParentSelector() {
  const {
    selectBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    firstParentClientId,
    isVisible
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockName,
      getBlockParents,
      getSelectedBlockClientId,
      getBlockEditingMode
    } = select(store_store);
    const {
      hasBlockSupport
    } = select(build_module/* store */.M_);
    const selectedBlockClientId = getSelectedBlockClientId();
    const parents = getBlockParents(selectedBlockClientId);
    const _firstParentClientId = parents[parents.length - 1];
    const parentBlockName = getBlockName(_firstParentClientId);
    const _parentBlockType = (0,build_module/* getBlockType */.E7)(parentBlockName);
    return {
      firstParentClientId: _firstParentClientId,
      isVisible: _firstParentClientId && getBlockEditingMode(_firstParentClientId) === 'default' && hasBlockSupport(_parentBlockType, '__experimentalParentSelector', true)
    };
  }, []);
  const blockInformation = useBlockDisplayInformation(firstParentClientId);

  // Allows highlighting the parent block outline when focusing or hovering
  // the parent block selector within the child.
  const nodeRef = (0,react.useRef)();
  const showHoveredOrFocusedGestures = useShowHoveredOrFocusedGestures({
    ref: nodeRef,
    highlightParent: true
  });
  if (!isVisible) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-block-parent-selector",
    ref: nodeRef,
    ...showHoveredOrFocusedGestures,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
      className: "block-editor-block-parent-selector__button",
      onClick: () => selectBlock(firstParentClientId),
      label: (0,i18n_build_module/* sprintf */.nv)( /* translators: %s: Name of the block's parent. */
      (0,i18n_build_module.__)('Select parent block: %s'), blockInformation?.title),
      showTooltip: true,
      icon: /*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
        icon: blockInformation?.icon
      })
    })
  }, firstParentClientId);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-switcher/preview-block-popover.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function PreviewBlockPopover({
  blocks
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-block-switcher__popover__preview__parent",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-block-switcher__popover__preview__container",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(popover/* default */.Ay, {
        className: "block-editor-block-switcher__preview__popover",
        placement: "bottom-start",
        focusOnMount: false,
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
          className: "block-editor-block-switcher__preview",
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {
            className: "block-editor-block-switcher__preview-title",
            children: (0,i18n_build_module.__)('Preview')
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_preview, {
            viewportWidth: 500,
            blocks: blocks
          })]
        })
      })
    })
  });
}
//# sourceMappingURL=preview-block-popover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-variation-transformations.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






const block_variation_transformations_EMPTY_OBJECT = {};
function useBlockVariationTransforms({
  clientIds,
  blocks
}) {
  const {
    activeBlockVariation,
    blockVariationTransformations
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockAttributes,
      canRemoveBlocks
    } = select(store_store);
    const {
      getActiveBlockVariation,
      getBlockVariations
    } = select(build_module/* store */.M_);
    const canRemove = canRemoveBlocks(clientIds);
    // Only handle single selected blocks for now.
    if (blocks.length !== 1 || !canRemove) {
      return block_variation_transformations_EMPTY_OBJECT;
    }
    const [firstBlock] = blocks;
    return {
      blockVariationTransformations: getBlockVariations(firstBlock.name, 'transform'),
      activeBlockVariation: getActiveBlockVariation(firstBlock.name, getBlockAttributes(firstBlock.clientId))
    };
  }, [clientIds, blocks]);
  const transformations = (0,react.useMemo)(() => {
    return blockVariationTransformations?.filter(({
      name
    }) => name !== activeBlockVariation?.name);
  }, [blockVariationTransformations, activeBlockVariation]);
  return transformations;
}
const BlockVariationTransformations = ({
  transformations,
  onSelect,
  blocks
}) => {
  const [hoveredTransformItemName, setHoveredTransformItemName] = (0,react.useState)();
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [hoveredTransformItemName && /*#__PURE__*/(0,jsx_runtime.jsx)(PreviewBlockPopover, {
      blocks: (0,build_module/* cloneBlock */.JB)(blocks[0], transformations.find(({
        name
      }) => name === hoveredTransformItemName).attributes)
    }), transformations?.map(item => /*#__PURE__*/(0,jsx_runtime.jsx)(BlockVariationTranformationItem, {
      item: item,
      onSelect: onSelect,
      setHoveredTransformItemName: setHoveredTransformItemName
    }, item.name))]
  });
};
function BlockVariationTranformationItem({
  item,
  onSelect,
  setHoveredTransformItemName
}) {
  const {
    name,
    icon,
    title
  } = item;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_item/* default */.A, {
    className: (0,build_module/* getBlockMenuDefaultClassName */.HK)(name),
    onClick: event => {
      event.preventDefault();
      onSelect(name);
    },
    onMouseLeave: () => setHoveredTransformItemName(null),
    onMouseEnter: () => setHoveredTransformItemName(name),
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
      icon: icon,
      showColors: true
    }), title]
  });
}
/* harmony default export */ const block_variation_transformations = (BlockVariationTransformations);
//# sourceMappingURL=block-variation-transformations.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-transformations-menu.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




/**
 * Helper hook to group transformations to display them in a specific order in the UI.
 * For now we group only priority content driven transformations(ex. paragraph -> heading).
 *
 * Later on we could also group 'layout' transformations(ex. paragraph -> group) and
 * display them in different sections.
 *
 * @param {Object[]} possibleBlockTransformations The available block transformations.
 * @return {Record<string, Object[]>} The grouped block transformations.
 */



function useGroupedTransforms(possibleBlockTransformations) {
  const priorityContentTranformationBlocks = {
    'core/paragraph': 1,
    'core/heading': 2,
    'core/list': 3,
    'core/quote': 4
  };
  const transformations = (0,react.useMemo)(() => {
    const priorityTextTranformsNames = Object.keys(priorityContentTranformationBlocks);
    const groupedPossibleTransforms = possibleBlockTransformations.reduce((accumulator, item) => {
      const {
        name
      } = item;
      if (priorityTextTranformsNames.includes(name)) {
        accumulator.priorityTextTransformations.push(item);
      } else {
        accumulator.restTransformations.push(item);
      }
      return accumulator;
    }, {
      priorityTextTransformations: [],
      restTransformations: []
    });
    /**
     * If there is only one priority text transformation and it's a Quote,
     * is should move to the rest transformations. This is because Quote can
     * be a container for any block type, so in multi-block selection it will
     * always be suggested, even for non-text blocks.
     */
    if (groupedPossibleTransforms.priorityTextTransformations.length === 1 && groupedPossibleTransforms.priorityTextTransformations[0].name === 'core/quote') {
      const singleQuote = groupedPossibleTransforms.priorityTextTransformations.pop();
      groupedPossibleTransforms.restTransformations.push(singleQuote);
    }
    return groupedPossibleTransforms;
  }, [possibleBlockTransformations]);

  // Order the priority text transformations.
  transformations.priorityTextTransformations.sort(({
    name: currentName
  }, {
    name: nextName
  }) => {
    return priorityContentTranformationBlocks[currentName] < priorityContentTranformationBlocks[nextName] ? -1 : 1;
  });
  return transformations;
}
const BlockTransformationsMenu = ({
  className,
  possibleBlockTransformations,
  possibleBlockVariationTransformations,
  onSelect,
  onSelectVariation,
  blocks
}) => {
  const [hoveredTransformItemName, setHoveredTransformItemName] = (0,react.useState)();
  const {
    priorityTextTransformations,
    restTransformations
  } = useGroupedTransforms(possibleBlockTransformations);
  // We have to check if both content transformations(priority and rest) are set
  // in order to create a separate MenuGroup for them.
  const hasBothContentTransformations = priorityTextTransformations.length && restTransformations.length;
  const restTransformItems = !!restTransformations.length && /*#__PURE__*/(0,jsx_runtime.jsx)(RestTransformationItems, {
    restTransformations: restTransformations,
    onSelect: onSelect,
    setHoveredTransformItemName: setHoveredTransformItemName
  });
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(menu_group/* default */.A, {
      label: (0,i18n_build_module.__)('Transform to'),
      className: className,
      children: [hoveredTransformItemName && /*#__PURE__*/(0,jsx_runtime.jsx)(PreviewBlockPopover, {
        blocks: (0,build_module/* switchToBlockType */.bh)(blocks, hoveredTransformItemName)
      }), !!possibleBlockVariationTransformations?.length && /*#__PURE__*/(0,jsx_runtime.jsx)(block_variation_transformations, {
        transformations: possibleBlockVariationTransformations,
        blocks: blocks,
        onSelect: onSelectVariation
      }), priorityTextTransformations.map(item => /*#__PURE__*/(0,jsx_runtime.jsx)(BlockTranformationItem, {
        item: item,
        onSelect: onSelect,
        setHoveredTransformItemName: setHoveredTransformItemName
      }, item.name)), !hasBothContentTransformations && restTransformItems]
    }), !!hasBothContentTransformations && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
      className: className,
      children: restTransformItems
    })]
  });
};
function RestTransformationItems({
  restTransformations,
  onSelect,
  setHoveredTransformItemName
}) {
  return restTransformations.map(item => /*#__PURE__*/(0,jsx_runtime.jsx)(BlockTranformationItem, {
    item: item,
    onSelect: onSelect,
    setHoveredTransformItemName: setHoveredTransformItemName
  }, item.name));
}
function BlockTranformationItem({
  item,
  onSelect,
  setHoveredTransformItemName
}) {
  const {
    name,
    icon,
    title,
    isDisabled
  } = item;
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_item/* default */.A, {
    className: (0,build_module/* getBlockMenuDefaultClassName */.HK)(name),
    onClick: event => {
      event.preventDefault();
      onSelect(name);
    },
    disabled: isDisabled,
    onMouseLeave: () => setHoveredTransformItemName(null),
    onMouseEnter: () => setHoveredTransformItemName(name),
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
      icon: icon,
      showColors: true
    }), title]
  });
}
/* harmony default export */ const block_transformations_menu = (BlockTransformationsMenu);
//# sourceMappingURL=block-transformations-menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-styles/utils.js
/**
 * WordPress dependencies
 */



/**
 * Returns the active style from the given className.
 *
 * @param {Array}  styles    Block styles.
 * @param {string} className Class name
 *
 * @return {Object?} The active style.
 */
function getActiveStyle(styles, className) {
  for (const style of new TokenList(className).values()) {
    if (style.indexOf('is-style-') === -1) {
      continue;
    }
    const potentialStyleName = style.substring(9);
    const activeStyle = styles?.find(({
      name
    }) => name === potentialStyleName);
    if (activeStyle) {
      return activeStyle;
    }
  }
  return getDefaultStyle(styles);
}

/**
 * Replaces the active style in the block's className.
 *
 * @param {string}  className   Class name.
 * @param {Object?} activeStyle The replaced style.
 * @param {Object}  newStyle    The replacing style.
 *
 * @return {string} The updated className.
 */
function replaceActiveStyle(className, activeStyle, newStyle) {
  const list = new TokenList(className);
  if (activeStyle) {
    list.remove('is-style-' + activeStyle.name);
  }
  list.add('is-style-' + newStyle.name);
  return list.value;
}

/**
 * Returns a collection of styles that can be represented on the frontend.
 * The function checks a style collection for a default style. If none is found, it adds one to
 * act as a fallback for when there is no active style applied to a block. The default item also serves
 * as a switch on the frontend to deactivate non-default styles.
 *
 * @param {Array} styles Block styles.
 *
 * @return {Array<Object?>}        The style collection.
 */
function getRenderedStyles(styles) {
  if (!styles || styles.length === 0) {
    return [];
  }
  return getDefaultStyle(styles) ? styles : [{
    name: 'default',
    label: (0,i18n_build_module._x)('Default', 'block style'),
    isDefault: true
  }, ...styles];
}

/**
 * Returns a style object from a collection of styles where that style object is the default block style.
 *
 * @param {Array} styles Block styles.
 *
 * @return {Object?}        The default style object, if found.
 */
function getDefaultStyle(styles) {
  return styles?.find(style => style.isDefault);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-styles/use-styles-for-block.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/**
 *
 * @param {WPBlock}     block Block object.
 * @param {WPBlockType} type  Block type settings.
 * @return {WPBlock}          A generic block ready for styles preview.
 */
function useGenericPreviewBlock(block, type) {
  return (0,react.useMemo)(() => {
    const example = type?.example;
    const blockName = type?.name;
    if (example && blockName) {
      return (0,build_module/* getBlockFromExample */.KL)(blockName, {
        attributes: example.attributes,
        innerBlocks: example.innerBlocks
      });
    }
    if (block) {
      return (0,build_module/* cloneBlock */.JB)(block);
    }
  }, [type?.example ? block?.name : block, type]);
}

/**
 * @typedef useStylesForBlocksArguments
 * @property {string}     clientId Block client ID.
 * @property {() => void} onSwitch Block style switch callback function.
 */

/**
 *
 * @param {useStylesForBlocksArguments} useStylesForBlocks arguments.
 * @return {Object}                                         Results of the select methods.
 */
function useStylesForBlocks({
  clientId,
  onSwitch
}) {
  const selector = select => {
    const {
      getBlock
    } = select(store_store);
    const block = getBlock(clientId);
    if (!block) {
      return {};
    }
    const blockType = (0,build_module/* getBlockType */.E7)(block.name);
    const {
      getBlockStyles
    } = select(build_module/* store */.M_);
    return {
      block,
      blockType,
      styles: getBlockStyles(block.name),
      className: block.attributes.className || ''
    };
  };
  const {
    styles,
    block,
    blockType,
    className
  } = (0,use_select/* default */.A)(selector, [clientId]);
  const {
    updateBlockAttributes
  } = (0,use_dispatch/* default */.A)(store_store);
  const stylesToRender = getRenderedStyles(styles);
  const activeStyle = getActiveStyle(stylesToRender, className);
  const genericPreviewBlock = useGenericPreviewBlock(block, blockType);
  const onSelect = style => {
    const styleClassName = replaceActiveStyle(className, activeStyle, style);
    updateBlockAttributes(clientId, {
      className: styleClassName
    });
    onSwitch();
  };
  return {
    onSelect,
    stylesToRender,
    activeStyle,
    genericPreviewBlock,
    className
  };
}
//# sourceMappingURL=use-styles-for-block.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-styles/menu-items.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const menu_items_noop = () => {};
function BlockStylesMenuItems({
  clientId,
  onSwitch = menu_items_noop
}) {
  const {
    onSelect,
    stylesToRender,
    activeStyle
  } = useStylesForBlocks({
    clientId,
    onSwitch
  });
  if (!stylesToRender || stylesToRender.length === 0) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
    children: stylesToRender.map(style => {
      const menuItemText = style.label || style.name;
      return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
        icon: activeStyle.name === style.name ? check/* default */.A : null,
        onClick: () => onSelect(style),
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_component/* default */.A, {
          as: "span",
          limit: 18,
          ellipsizeMode: "tail",
          truncate: true,
          children: menuItemText
        })
      }, style.name);
    })
  });
}
//# sourceMappingURL=menu-items.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-styles-menu.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function BlockStylesMenu({
  hoveredBlock,
  onSwitch
}) {
  const {
    clientId
  } = hoveredBlock;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
    label: (0,i18n_build_module.__)('Styles'),
    className: "block-editor-block-switcher__styles__menugroup",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(BlockStylesMenuItems, {
      clientId: clientId,
      onSwitch: onSwitch
    })
  });
}
//# sourceMappingURL=block-styles-menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-switcher/utils.js
/**
 * WordPress dependencies
 */


/**
 * Try to find a matching block by a block's name in a provided
 * block. We recurse through InnerBlocks and return the reference
 * of the matched block (it could be an InnerBlock).
 * If no match is found return nothing.
 *
 * @param {WPBlock} block             The block to try to find a match.
 * @param {string}  selectedBlockName The block's name to use for matching condition.
 * @param {Set}     consumedBlocks    A set holding the previously matched/consumed blocks.
 *
 * @return {WPBlock | undefined} The matched block if found or nothing(`undefined`).
 */
const getMatchingBlockByName = (block, selectedBlockName, consumedBlocks = new Set()) => {
  const {
    clientId,
    name,
    innerBlocks = []
  } = block;
  // Check if block has been consumed already.
  if (consumedBlocks.has(clientId)) {
    return;
  }
  if (name === selectedBlockName) {
    return block;
  }
  // Try to find a matching block from InnerBlocks recursively.
  for (const innerBlock of innerBlocks) {
    const match = getMatchingBlockByName(innerBlock, selectedBlockName, consumedBlocks);
    if (match) {
      return match;
    }
  }
};

/**
 * Find and return the block attributes to retain through
 * the transformation, based on Block Type's `role:content`
 * attributes. If no `role:content` attributes exist,
 * return selected block's attributes.
 *
 * @param {string} name       Block type's namespaced name.
 * @param {Object} attributes Selected block's attributes.
 * @return {Object} The block's attributes to retain.
 */
const getRetainedBlockAttributes = (name, attributes) => {
  const contentAttributes = (0,build_module/* __experimentalGetBlockAttributesNamesByRole */.GJ)(name, 'content');
  if (!contentAttributes?.length) {
    return attributes;
  }
  return contentAttributes.reduce((_accumulator, attribute) => {
    if (attributes[attribute]) {
      _accumulator[attribute] = attributes[attribute];
    }
    return _accumulator;
  }, {});
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-switcher/use-transformed-patterns.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Mutate the matched block's attributes by getting
 * which block type's attributes to retain and prioritize
 * them in the merging of the attributes.
 *
 * @param {WPBlock} match         The matched block.
 * @param {WPBlock} selectedBlock The selected block.
 * @return {void}
 */
const transformMatchingBlock = (match, selectedBlock) => {
  // Get the block attributes to retain through the transformation.
  const retainedBlockAttributes = getRetainedBlockAttributes(selectedBlock.name, selectedBlock.attributes);
  match.attributes = {
    ...match.attributes,
    ...retainedBlockAttributes
  };
};

/**
 * By providing the selected blocks and pattern's blocks
 * find the matching blocks, transform them and return them.
 * If not all selected blocks are matched, return nothing.
 *
 * @param {WPBlock[]} selectedBlocks The selected blocks.
 * @param {WPBlock[]} patternBlocks  The pattern's blocks.
 * @return {WPBlock[]|void} The transformed pattern's blocks or undefined if not all selected blocks have been matched.
 */
const getPatternTransformedBlocks = (selectedBlocks, patternBlocks) => {
  // Clone Pattern's blocks to produce new clientIds and be able to mutate the matches.
  const _patternBlocks = patternBlocks.map(block => (0,build_module/* cloneBlock */.JB)(block));
  /**
   * Keep track of the consumed pattern blocks.
   * This is needed because we loop the selected blocks
   * and for example we may have selected two paragraphs and
   * the pattern's blocks could have more `paragraphs`.
   */
  const consumedBlocks = new Set();
  for (const selectedBlock of selectedBlocks) {
    let isMatch = false;
    for (const patternBlock of _patternBlocks) {
      const match = getMatchingBlockByName(patternBlock, selectedBlock.name, consumedBlocks);
      if (!match) {
        continue;
      }
      isMatch = true;
      consumedBlocks.add(match.clientId);
      // We update (mutate) the matching pattern block.
      transformMatchingBlock(match, selectedBlock);
      // No need to loop through other pattern's blocks.
      break;
    }
    // Bail eary if a selected block has not been matched.
    if (!isMatch) {
      return;
    }
  }
  return _patternBlocks;
};

/**
 * @typedef {WPBlockPattern & {transformedBlocks: WPBlock[]}} TransformedBlockPattern
 */

/**
 * Custom hook that accepts patterns from state and the selected
 * blocks and tries to match these with the pattern's blocks.
 * If all selected blocks are matched with a Pattern's block,
 * we transform them by retaining block's attributes with `role:content`.
 * The transformed pattern's blocks are set to a new pattern
 * property `transformedBlocks`.
 *
 * @param {WPBlockPattern[]} patterns       Patterns from state.
 * @param {WPBlock[]}        selectedBlocks The currently selected blocks.
 * @return {TransformedBlockPattern[]} Returns the eligible matched patterns with all the selected blocks.
 */
const useTransformedPatterns = (patterns, selectedBlocks) => {
  return (0,react.useMemo)(() => patterns.reduce((accumulator, _pattern) => {
    const transformedBlocks = getPatternTransformedBlocks(selectedBlocks, _pattern.blocks);
    if (transformedBlocks) {
      accumulator.push({
        ..._pattern,
        transformedBlocks
      });
    }
    return accumulator;
  }, []), [patterns, selectedBlocks]);
};
/* harmony default export */ const use_transformed_patterns = (useTransformedPatterns);
//# sourceMappingURL=use-transformed-patterns.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-switcher/pattern-transformations-menu.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */





const {
  CompositeV2: pattern_transformations_menu_Composite,
  CompositeItemV2: pattern_transformations_menu_CompositeItem,
  useCompositeStoreV2: pattern_transformations_menu_useCompositeStore
} = lock_unlock_unlock(privateApis);
function PatternTransformationsMenu({
  blocks,
  patterns: statePatterns,
  onSelect
}) {
  const [showTransforms, setShowTransforms] = (0,react.useState)(false);
  const patterns = use_transformed_patterns(statePatterns, blocks);
  if (!patterns.length) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_group/* default */.A, {
    className: "block-editor-block-switcher__pattern__transforms__menugroup",
    children: [showTransforms && /*#__PURE__*/(0,jsx_runtime.jsx)(PreviewPatternsPopover, {
      patterns: patterns,
      onSelect: onSelect
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
      onClick: event => {
        event.preventDefault();
        setShowTransforms(!showTransforms);
      },
      icon: chevron_right/* default */.A,
      children: (0,i18n_build_module.__)('Patterns')
    })]
  });
}
function PreviewPatternsPopover({
  patterns,
  onSelect
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: "block-editor-block-switcher__popover__preview__parent",
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: "block-editor-block-switcher__popover__preview__container",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(popover/* default */.Ay, {
        className: "block-editor-block-switcher__preview__popover",
        position: "bottom right",
        children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
          className: "block-editor-block-switcher__preview is-pattern-list-preview",
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(pattern_transformations_menu_BlockPatternsList, {
            patterns: patterns,
            onSelect: onSelect
          })
        })
      })
    })
  });
}
function pattern_transformations_menu_BlockPatternsList({
  patterns,
  onSelect
}) {
  const composite = pattern_transformations_menu_useCompositeStore();
  return /*#__PURE__*/(0,jsx_runtime.jsx)(pattern_transformations_menu_Composite, {
    store: composite,
    role: "listbox",
    className: "block-editor-block-switcher__preview-patterns-container",
    "aria-label": (0,i18n_build_module.__)('Patterns list'),
    children: patterns.map(pattern => /*#__PURE__*/(0,jsx_runtime.jsx)(pattern_transformations_menu_BlockPattern, {
      pattern: pattern,
      onSelect: onSelect
    }, pattern.name))
  });
}
function pattern_transformations_menu_BlockPattern({
  pattern,
  onSelect
}) {
  // TODO check pattern/preview width...
  const baseClassName = 'block-editor-block-switcher__preview-patterns-container';
  const descriptionId = (0,use_instance_id/* default */.A)(pattern_transformations_menu_BlockPattern, `${baseClassName}-list__item-description`);
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: `${baseClassName}-list__list-item`,
    children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(pattern_transformations_menu_CompositeItem, {
      render: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        role: "option",
        "aria-label": pattern.title,
        "aria-describedby": pattern.description ? descriptionId : undefined,
        className: `${baseClassName}-list__item`
      }),
      onClick: () => onSelect(pattern.transformedBlocks),
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_preview, {
        blocks: pattern.transformedBlocks,
        viewportWidth: pattern.viewportWidth || 500
      }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        className: `${baseClassName}-list__item-title`,
        children: pattern.title
      })]
    }), !!pattern.description && /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
      id: descriptionId,
      children: pattern.description
    })]
  });
}
/* harmony default export */ const pattern_transformations_menu = (PatternTransformationsMenu);
//# sourceMappingURL=pattern-transformations-menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-title/use-block-display-title.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Returns the block's configured title as a string, or empty if the title
 * cannot be determined.
 *
 * @example
 *
 * ```js
 * useBlockDisplayTitle( { clientId: 'afd1cb17-2c08-4e7a-91be-007ba7ddc3a1', maximumLength: 17 } );
 * ```
 *
 * @param {Object}           props
 * @param {string}           props.clientId      Client ID of block.
 * @param {number|undefined} props.maximumLength The maximum length that the block title string may be before truncated.
 * @param {string|undefined} props.context       The context to pass to `getBlockLabel`.
 * @return {?string} Block title.
 */
function useBlockDisplayTitle({
  clientId,
  maximumLength,
  context
}) {
  const blockTitle = (0,use_select/* default */.A)(select => {
    if (!clientId) {
      return null;
    }
    const {
      getBlockName,
      getBlockAttributes
    } = select(store_store);
    const {
      getBlockType,
      getActiveBlockVariation
    } = select(build_module/* store */.M_);
    const blockName = getBlockName(clientId);
    const blockType = getBlockType(blockName);
    if (!blockType) {
      return null;
    }
    const attributes = getBlockAttributes(clientId);
    const label = (0,build_module/* __experimentalGetBlockLabel */.Y0)(blockType, attributes, context);
    // If the label is defined we prioritize it over a possible block variation title match.
    if (label !== blockType.title) {
      return label;
    }
    const match = getActiveBlockVariation(blockName, attributes);
    // Label will fallback to the title if no label is defined for the current label context.
    return match?.title || blockType.title;
  }, [clientId, context]);
  if (!blockTitle) {
    return null;
  }
  if (maximumLength && maximumLength > 0 && blockTitle.length > maximumLength) {
    const omission = '...';
    return blockTitle.slice(0, maximumLength - omission.length) + omission;
  }
  return blockTitle;
}
//# sourceMappingURL=use-block-display-title.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-switcher/index.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */










function BlockSwitcherDropdownMenuContents({
  onClose,
  clientIds,
  hasBlockStyles,
  canRemove,
  isUsingBindings
}) {
  const {
    replaceBlocks,
    multiSelect,
    updateBlockAttributes
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    possibleBlockTransformations,
    patterns,
    blocks
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlocksByClientId,
      getBlockRootClientId,
      getBlockTransformItems,
      __experimentalGetPatternTransformItems
    } = select(store_store);
    const rootClientId = getBlockRootClientId(Array.isArray(clientIds) ? clientIds[0] : clientIds);
    const _blocks = getBlocksByClientId(clientIds);
    return {
      blocks: _blocks,
      possibleBlockTransformations: getBlockTransformItems(_blocks, rootClientId),
      patterns: __experimentalGetPatternTransformItems(_blocks, rootClientId)
    };
  }, [clientIds]);
  const blockVariationTransformations = useBlockVariationTransforms({
    clientIds,
    blocks
  });
  function selectForMultipleBlocks(insertedBlocks) {
    if (insertedBlocks.length > 1) {
      multiSelect(insertedBlocks[0].clientId, insertedBlocks[insertedBlocks.length - 1].clientId);
    }
  }
  // Simple block tranformation based on the `Block Transforms` API.
  function onBlockTransform(name) {
    const newBlocks = (0,build_module/* switchToBlockType */.bh)(blocks, name);
    replaceBlocks(clientIds, newBlocks);
    selectForMultipleBlocks(newBlocks);
  }
  function onBlockVariationTransform(name) {
    updateBlockAttributes(blocks[0].clientId, {
      ...blockVariationTransformations.find(({
        name: variationName
      }) => variationName === name).attributes
    });
  }
  // Pattern transformation through the `Patterns` API.
  function onPatternTransform(transformedBlocks) {
    replaceBlocks(clientIds, transformedBlocks);
    selectForMultipleBlocks(transformedBlocks);
  }
  /**
   * The `isTemplate` check is a stopgap solution here.
   * Ideally, the Transforms API should handle this
   * by allowing to exclude blocks from wildcard transformations.
   */
  const isSingleBlock = blocks.length === 1;
  const isTemplate = isSingleBlock && (0,build_module/* isTemplatePart */.gc)(blocks[0]);
  const hasPossibleBlockTransformations = !!possibleBlockTransformations.length && canRemove && !isTemplate;
  const hasPossibleBlockVariationTransformations = !!blockVariationTransformations?.length;
  const hasPatternTransformation = !!patterns?.length && canRemove;
  const hasBlockOrBlockVariationTransforms = hasPossibleBlockTransformations || hasPossibleBlockVariationTransformations;
  const hasContents = hasBlockStyles || hasBlockOrBlockVariationTransforms || hasPatternTransformation;
  if (!hasContents) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
      className: "block-editor-block-switcher__no-transforms",
      children: (0,i18n_build_module.__)('No transforms.')
    });
  }
  const connectedBlockDescription = isSingleBlock ? (0,i18n_build_module._x)('This block is connected.', 'block toolbar button label and description') : (0,i18n_build_module._x)('These blocks are connected.', 'block toolbar button label and description');
  return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
    className: "block-editor-block-switcher__container",
    children: [hasPatternTransformation && /*#__PURE__*/(0,jsx_runtime.jsx)(pattern_transformations_menu, {
      blocks: blocks,
      patterns: patterns,
      onSelect: transformedBlocks => {
        onPatternTransform(transformedBlocks);
        onClose();
      }
    }), hasBlockOrBlockVariationTransforms && /*#__PURE__*/(0,jsx_runtime.jsx)(block_transformations_menu, {
      className: "block-editor-block-switcher__transforms__menugroup",
      possibleBlockTransformations: possibleBlockTransformations,
      possibleBlockVariationTransformations: blockVariationTransformations,
      blocks: blocks,
      onSelect: name => {
        onBlockTransform(name);
        onClose();
      },
      onSelectVariation: name => {
        onBlockVariationTransform(name);
        onClose();
      }
    }), hasBlockStyles && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockStylesMenu, {
      hoveredBlock: blocks[0],
      onSwitch: onClose
    }), isUsingBindings && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(text_component/* default */.A, {
        className: "block-editor-block-switcher__binding-indicator",
        children: connectedBlockDescription
      })
    })]
  });
}
const BlockSwitcher = ({
  clientIds,
  disabled,
  isUsingBindings
}) => {
  const {
    canRemove,
    hasBlockStyles,
    icon,
    invalidBlocks,
    isReusable,
    isTemplate
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlocksByClientId,
      getBlockAttributes,
      canRemoveBlocks
    } = select(store_store);
    const {
      getBlockStyles,
      getBlockType,
      getActiveBlockVariation
    } = select(build_module/* store */.M_);
    const _blocks = getBlocksByClientId(clientIds);
    if (!_blocks.length || _blocks.some(block => !block)) {
      return {
        invalidBlocks: true
      };
    }
    const [{
      name: firstBlockName
    }] = _blocks;
    const _isSingleBlockSelected = _blocks.length === 1;
    const blockType = getBlockType(firstBlockName);
    let _icon;
    if (_isSingleBlockSelected) {
      const match = getActiveBlockVariation(firstBlockName, getBlockAttributes(clientIds[0]));
      // Take into account active block variations.
      _icon = match?.icon || blockType.icon;
    } else {
      const isSelectionOfSameType = new Set(_blocks.map(({
        name
      }) => name)).size === 1;
      // When selection consists of blocks of multiple types, display an
      // appropriate icon to communicate the non-uniformity.
      _icon = isSelectionOfSameType ? blockType.icon : library_copy;
    }
    return {
      canRemove: canRemoveBlocks(clientIds),
      hasBlockStyles: _isSingleBlockSelected && !!getBlockStyles(firstBlockName)?.length,
      icon: _icon,
      isReusable: _isSingleBlockSelected && (0,build_module/* isReusableBlock */.tk)(_blocks[0]),
      isTemplate: _isSingleBlockSelected && (0,build_module/* isTemplatePart */.gc)(_blocks[0])
    };
  }, [clientIds]);
  const blockTitle = useBlockDisplayTitle({
    clientId: clientIds?.[0],
    maximumLength: 35
  });
  if (invalidBlocks) {
    return null;
  }
  const isSingleBlock = clientIds.length === 1;
  const blockSwitcherLabel = isSingleBlock ? blockTitle : (0,i18n_build_module.__)('Multiple blocks selected');
  const hideDropdown = disabled || !hasBlockStyles && !canRemove;
  if (hideDropdown) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_group/* default */.A, {
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
        disabled: true,
        className: "block-editor-block-switcher__no-switcher-icon",
        title: blockSwitcherLabel,
        icon: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
            icon: icon,
            showColors: true
          }), (isReusable || isTemplate) && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            className: "block-editor-block-switcher__toggle-text",
            children: blockTitle
          })]
        })
      })
    });
  }
  const blockSwitcherDescription = isSingleBlock ? (0,i18n_build_module.__)('Change block type or style') : (0,i18n_build_module/* sprintf */.nv)( /* translators: %d: number of blocks. */
  (0,i18n_build_module._n)('Change type of %d block', 'Change type of %d blocks', clientIds.length), clientIds.length);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_group/* default */.A, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_item/* default */.A, {
      children: toggleProps => /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_menu/* default */.A, {
        className: "block-editor-block-switcher",
        label: blockSwitcherLabel,
        popoverProps: {
          placement: 'bottom-start',
          className: 'block-editor-block-switcher__popover'
        },
        icon: /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
            icon: icon,
            className: "block-editor-block-switcher__toggle",
            showColors: true
          }), (isReusable || isTemplate) && /*#__PURE__*/(0,jsx_runtime.jsx)("span", {
            className: "block-editor-block-switcher__toggle-text",
            children: blockTitle
          })]
        }),
        toggleProps: {
          describedBy: blockSwitcherDescription,
          ...toggleProps
        },
        menuProps: {
          orientation: 'both'
        },
        children: ({
          onClose
        }) => /*#__PURE__*/(0,jsx_runtime.jsx)(BlockSwitcherDropdownMenuContents, {
          onClose: onClose,
          clientIds: clientIds,
          hasBlockStyles: hasBlockStyles,
          canRemove: canRemove,
          isUsingBindings: isUsingBindings
        })
      })
    })
  });
};
/* harmony default export */ const block_switcher = (BlockSwitcher);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-toolbar-last-item.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableBlockToolbarLastItem,
  Slot: block_toolbar_last_item_Slot
} = (0,slot_fill/* createSlotFill */.QJ)('__unstableBlockToolbarLastItem');
__unstableBlockToolbarLastItem.Slot = block_toolbar_last_item_Slot;
/* harmony default export */ const block_toolbar_last_item = (__unstableBlockToolbarLastItem);
//# sourceMappingURL=block-toolbar-last-item.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/hooks/supports.js
/**
 * WordPress dependencies
 */


const ALIGN_SUPPORT_KEY = 'align';
const ALIGN_WIDE_SUPPORT_KEY = 'alignWide';
const supports_BORDER_SUPPORT_KEY = '__experimentalBorder';
const supports_COLOR_SUPPORT_KEY = 'color';
const CUSTOM_CLASS_NAME_SUPPORT_KEY = 'customClassName';
const supports_FONT_FAMILY_SUPPORT_KEY = 'typography.__experimentalFontFamily';
const supports_FONT_SIZE_SUPPORT_KEY = 'typography.fontSize';
const supports_LINE_HEIGHT_SUPPORT_KEY = 'typography.lineHeight';
/**
 * Key within block settings' support array indicating support for font style.
 */
const supports_FONT_STYLE_SUPPORT_KEY = 'typography.__experimentalFontStyle';
/**
 * Key within block settings' support array indicating support for font weight.
 */
const supports_FONT_WEIGHT_SUPPORT_KEY = 'typography.__experimentalFontWeight';
/**
 * Key within block settings' supports array indicating support for text
 * align e.g. settings found in `block.json`.
 */
const supports_TEXT_ALIGN_SUPPORT_KEY = 'typography.textAlign';
/**
 * Key within block settings' supports array indicating support for text
 * columns e.g. settings found in `block.json`.
 */
const supports_TEXT_COLUMNS_SUPPORT_KEY = 'typography.textColumns';
/**
 * Key within block settings' supports array indicating support for text
 * decorations e.g. settings found in `block.json`.
 */
const supports_TEXT_DECORATION_SUPPORT_KEY = 'typography.__experimentalTextDecoration';
/**
 * Key within block settings' supports array indicating support for writing mode
 * e.g. settings found in `block.json`.
 */
const supports_WRITING_MODE_SUPPORT_KEY = 'typography.__experimentalWritingMode';
/**
 * Key within block settings' supports array indicating support for text
 * transforms e.g. settings found in `block.json`.
 */
const supports_TEXT_TRANSFORM_SUPPORT_KEY = 'typography.__experimentalTextTransform';

/**
 * Key within block settings' supports array indicating support for letter-spacing
 * e.g. settings found in `block.json`.
 */
const supports_LETTER_SPACING_SUPPORT_KEY = 'typography.__experimentalLetterSpacing';
const LAYOUT_SUPPORT_KEY = 'layout';
const supports_TYPOGRAPHY_SUPPORT_KEYS = [supports_LINE_HEIGHT_SUPPORT_KEY, supports_FONT_SIZE_SUPPORT_KEY, supports_FONT_STYLE_SUPPORT_KEY, supports_FONT_WEIGHT_SUPPORT_KEY, supports_FONT_FAMILY_SUPPORT_KEY, supports_TEXT_ALIGN_SUPPORT_KEY, supports_TEXT_COLUMNS_SUPPORT_KEY, supports_TEXT_DECORATION_SUPPORT_KEY, supports_TEXT_TRANSFORM_SUPPORT_KEY, supports_WRITING_MODE_SUPPORT_KEY, supports_LETTER_SPACING_SUPPORT_KEY];
const EFFECTS_SUPPORT_KEYS = ['shadow'];
const supports_SPACING_SUPPORT_KEY = 'spacing';
const supports_styleSupportKeys = [...EFFECTS_SUPPORT_KEYS, ...supports_TYPOGRAPHY_SUPPORT_KEYS, supports_BORDER_SUPPORT_KEY, supports_COLOR_SUPPORT_KEY, supports_SPACING_SUPPORT_KEY];

/**
 * Returns true if the block defines support for align.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const hasAlignSupport = nameOrType => (0,build_module/* hasBlockSupport */.pN)(nameOrType, ALIGN_SUPPORT_KEY);

/**
 * Returns the block support value for align, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */
const getAlignSupport = nameOrType => getBlockSupport(nameOrType, ALIGN_SUPPORT_KEY);

/**
 * Returns true if the block defines support for align wide.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const hasAlignWideSupport = nameOrType => hasBlockSupport(nameOrType, ALIGN_WIDE_SUPPORT_KEY);

/**
 * Returns the block support value for align wide, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */
const getAlignWideSupport = nameOrType => getBlockSupport(nameOrType, ALIGN_WIDE_SUPPORT_KEY);

/**
 * Determine whether there is block support for border properties.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @param {string}        feature    Border feature to check support for.
 *
 * @return {boolean} Whether there is support.
 */
function supports_hasBorderSupport(nameOrType, feature = 'any') {
  if (platform/* default */.A.OS !== 'web') {
    return false;
  }
  const support = (0,build_module/* getBlockSupport */.bI)(nameOrType, supports_BORDER_SUPPORT_KEY);
  if (support === true) {
    return true;
  }
  if (feature === 'any') {
    return !!(support?.color || support?.radius || support?.width || support?.style);
  }
  return !!support?.[feature];
}

/**
 * Get block support for border properties.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @param {string}        feature    Border feature to get.
 *
 * @return {unknown} The block support.
 */
const getBorderSupport = (nameOrType, feature) => getBlockSupport(nameOrType, [supports_BORDER_SUPPORT_KEY, feature]);

/**
 * Returns true if the block defines support for color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const supports_hasColorSupport = nameOrType => {
  const colorSupport = getBlockSupport(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport && (colorSupport.link === true || colorSupport.gradient === true || colorSupport.background !== false || colorSupport.text !== false);
};

/**
 * Returns true if the block defines support for link color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const supports_hasLinkColorSupport = nameOrType => {
  if (Platform.OS !== 'web') {
    return false;
  }
  const colorSupport = getBlockSupport(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.link;
};

/**
 * Returns true if the block defines support for gradient color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const supports_hasGradientSupport = nameOrType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.gradients;
};

/**
 * Returns true if the block defines support for background color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const supports_hasBackgroundColorSupport = nameOrType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.background !== false;
};

/**
 * Returns true if the block defines support for text-align.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const hasTextAlignSupport = nameOrType => (0,build_module/* hasBlockSupport */.pN)(nameOrType, supports_TEXT_ALIGN_SUPPORT_KEY);

/**
 * Returns the block support value for text-align, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */
const getTextAlignSupport = nameOrType => getBlockSupport(nameOrType, supports_TEXT_ALIGN_SUPPORT_KEY);

/**
 * Returns true if the block defines support for background color.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const supports_hasTextColorSupport = nameOrType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.text !== false;
};

/**
 * Get block support for color properties.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @param {string}        feature    Color feature to get.
 *
 * @return {unknown} The block support.
 */
const getColorSupport = (nameOrType, feature) => getBlockSupport(nameOrType, [supports_COLOR_SUPPORT_KEY, feature]);

/**
 * Returns true if the block defines support for custom class name.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const hasCustomClassNameSupport = nameOrType => (0,build_module/* hasBlockSupport */.pN)(nameOrType, CUSTOM_CLASS_NAME_SUPPORT_KEY, true);

/**
 * Returns the block support value for custom class name, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */
const getCustomClassNameSupport = nameOrType => getBlockSupport(nameOrType, CUSTOM_CLASS_NAME_SUPPORT_KEY, true);

/**
 * Returns true if the block defines support for font family.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const hasFontFamilySupport = nameOrType => (0,build_module/* hasBlockSupport */.pN)(nameOrType, supports_FONT_FAMILY_SUPPORT_KEY);

/**
 * Returns the block support value for font family, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */
const getFontFamilySupport = nameOrType => getBlockSupport(nameOrType, supports_FONT_FAMILY_SUPPORT_KEY);

/**
 * Returns true if the block defines support for font size.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const hasFontSizeSupport = nameOrType => (0,build_module/* hasBlockSupport */.pN)(nameOrType, supports_FONT_SIZE_SUPPORT_KEY);

/**
 * Returns the block support value for font size, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */
const getFontSizeSupport = nameOrType => getBlockSupport(nameOrType, supports_FONT_SIZE_SUPPORT_KEY);

/**
 * Returns true if the block defines support for layout.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const hasLayoutSupport = nameOrType => (0,build_module/* hasBlockSupport */.pN)(nameOrType, LAYOUT_SUPPORT_KEY);

/**
 * Returns the block support value for layout, if defined.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {unknown} The block support value.
 */
const getLayoutSupport = nameOrType => getBlockSupport(nameOrType, LAYOUT_SUPPORT_KEY);

/**
 * Returns true if the block defines support for style.
 *
 * @param {string|Object} nameOrType Block name or type object.
 * @return {boolean} Whether the block supports the feature.
 */
const supports_hasStyleSupport = nameOrType => supports_styleSupportKeys.some(key => (0,build_module/* hasBlockSupport */.pN)(nameOrType, key));
//# sourceMappingURL=supports.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/use-paste-styles/index.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



/**
 * Determine if the copied text looks like serialized blocks or not.
 * Since plain text will always get parsed into a freeform block,
 * we check that if the parsed blocks is anything other than that.
 *
 * @param {string} text The copied text.
 * @return {boolean} True if the text looks like serialized blocks, false otherwise.
 */
function hasSerializedBlocks(text) {
  try {
    const blocks = (0,build_module/* parse */.qg)(text, {
      __unstableSkipMigrationLogs: true,
      __unstableSkipAutop: true
    });
    if (blocks.length === 1 && blocks[0].name === 'core/freeform') {
      // It's likely that the text is just plain text and not serialized blocks.
      return false;
    }
    return true;
  } catch (err) {
    // Parsing error, the text is not serialized blocks.
    // (Even though that it technically won't happen)
    return false;
  }
}

/**
 * Style attributes are attributes being added in `block-editor/src/hooks/*`.
 * (Except for some unrelated to style like `anchor` or `settings`.)
 * They generally represent the default block supports.
 */
const STYLE_ATTRIBUTES = {
  align: hasAlignSupport,
  borderColor: nameOrType => supports_hasBorderSupport(nameOrType, 'color'),
  backgroundColor: supports_hasBackgroundColorSupport,
  textAlign: hasTextAlignSupport,
  textColor: supports_hasTextColorSupport,
  gradient: supports_hasGradientSupport,
  className: hasCustomClassNameSupport,
  fontFamily: hasFontFamilySupport,
  fontSize: hasFontSizeSupport,
  layout: hasLayoutSupport,
  style: supports_hasStyleSupport
};

/**
 * Get the "style attributes" from a given block to a target block.
 *
 * @param {WPBlock} sourceBlock The source block.
 * @param {WPBlock} targetBlock The target block.
 * @return {Object} the filtered attributes object.
 */
function getStyleAttributes(sourceBlock, targetBlock) {
  return Object.entries(STYLE_ATTRIBUTES).reduce((attributes, [attributeKey, hasSupport]) => {
    // Only apply the attribute if both blocks support it.
    if (hasSupport(sourceBlock.name) && hasSupport(targetBlock.name)) {
      // Override attributes that are not present in the block to their defaults.
      attributes[attributeKey] = sourceBlock.attributes[attributeKey];
    }
    return attributes;
  }, {});
}

/**
 * Update the target blocks with style attributes recursively.
 *
 * @param {WPBlock[]} targetBlocks          The target blocks to be updated.
 * @param {WPBlock[]} sourceBlocks          The source blocks to get th style attributes from.
 * @param {Function}  updateBlockAttributes The function to update the attributes.
 */
function recursivelyUpdateBlockAttributes(targetBlocks, sourceBlocks, updateBlockAttributes) {
  for (let index = 0; index < Math.min(sourceBlocks.length, targetBlocks.length); index += 1) {
    updateBlockAttributes(targetBlocks[index].clientId, getStyleAttributes(sourceBlocks[index], targetBlocks[index]));
    recursivelyUpdateBlockAttributes(targetBlocks[index].innerBlocks, sourceBlocks[index].innerBlocks, updateBlockAttributes);
  }
}

/**
 * A hook to return a pasteStyles event function for handling pasting styles to blocks.
 *
 * @return {Function} A function to update the styles to the blocks.
 */
function usePasteStyles() {
  const registry = (0,use_registry/* default */.A)();
  const {
    updateBlockAttributes
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    createSuccessNotice,
    createWarningNotice,
    createErrorNotice
  } = (0,use_dispatch/* default */.A)(store);
  return (0,react.useCallback)(async targetBlocks => {
    let html = '';
    try {
      // `http:` sites won't have the clipboard property on navigator.
      // (with the exception of localhost.)
      if (!window.navigator.clipboard) {
        createErrorNotice((0,i18n_build_module.__)('Unable to paste styles. This feature is only available on secure (https) sites in supporting browsers.'), {
          type: 'snackbar'
        });
        return;
      }
      html = await window.navigator.clipboard.readText();
    } catch (error) {
      // Possibly the permission is denied.
      createErrorNotice((0,i18n_build_module.__)('Unable to paste styles. Please allow browser clipboard permissions before continuing.'), {
        type: 'snackbar'
      });
      return;
    }

    // Abort if the copied text is empty or doesn't look like serialized blocks.
    if (!html || !hasSerializedBlocks(html)) {
      createWarningNotice((0,i18n_build_module.__)("Unable to paste styles. Block styles couldn't be found within the copied content."), {
        type: 'snackbar'
      });
      return;
    }
    const copiedBlocks = (0,build_module/* parse */.qg)(html);
    if (copiedBlocks.length === 1) {
      // Apply styles of the block to all the target blocks.
      registry.batch(() => {
        recursivelyUpdateBlockAttributes(targetBlocks, targetBlocks.map(() => copiedBlocks[0]), updateBlockAttributes);
      });
    } else {
      registry.batch(() => {
        recursivelyUpdateBlockAttributes(targetBlocks, copiedBlocks, updateBlockAttributes);
      });
    }
    if (targetBlocks.length === 1) {
      const title = (0,build_module/* getBlockType */.E7)(targetBlocks[0].name)?.title;
      createSuccessNotice((0,i18n_build_module/* sprintf */.nv)(
      // Translators: Name of the block being pasted, e.g. "Paragraph".
      (0,i18n_build_module.__)('Pasted styles to %s.'), title), {
        type: 'snackbar'
      });
    } else {
      createSuccessNotice((0,i18n_build_module/* sprintf */.nv)(
      // Translators: The number of the blocks.
      (0,i18n_build_module.__)('Pasted styles to %d blocks.'), targetBlocks.length), {
        type: 'snackbar'
      });
    }
  }, [registry.batch, updateBlockAttributes, createSuccessNotice, createWarningNotice, createErrorNotice]);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-actions/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockActions({
  clientIds,
  children,
  __experimentalUpdateSelection: updateSelection
}) {
  const {
    getDefaultBlockName,
    getGroupingBlockName
  } = (0,use_select/* default */.A)(build_module/* store */.M_);
  const selected = (0,use_select/* default */.A)(select => {
    const {
      canInsertBlockType,
      getBlockRootClientId,
      getBlocksByClientId,
      getDirectInsertBlock,
      canMoveBlocks,
      canRemoveBlocks
    } = select(store_store);
    const blocks = getBlocksByClientId(clientIds);
    const rootClientId = getBlockRootClientId(clientIds[0]);
    const canInsertDefaultBlock = canInsertBlockType(getDefaultBlockName(), rootClientId);
    const directInsertBlock = rootClientId ? getDirectInsertBlock(rootClientId) : null;
    return {
      canMove: canMoveBlocks(clientIds),
      canRemove: canRemoveBlocks(clientIds),
      canInsertBlock: canInsertDefaultBlock || !!directInsertBlock,
      canCopyStyles: blocks.every(block => {
        return !!block && ((0,build_module/* hasBlockSupport */.pN)(block.name, 'color') || (0,build_module/* hasBlockSupport */.pN)(block.name, 'typography'));
      }),
      canDuplicate: blocks.every(block => {
        return !!block && (0,build_module/* hasBlockSupport */.pN)(block.name, 'multiple', true) && canInsertBlockType(block.name, rootClientId);
      })
    };
  }, [clientIds, getDefaultBlockName]);
  const {
    getBlocksByClientId,
    getBlocks
  } = (0,use_select/* default */.A)(store_store);
  const {
    canMove,
    canRemove,
    canInsertBlock,
    canCopyStyles,
    canDuplicate
  } = selected;
  const {
    removeBlocks,
    replaceBlocks,
    duplicateBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    flashBlock,
    setBlockMovingClientId,
    setNavigationMode,
    selectBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const notifyCopy = useNotifyCopy();
  const pasteStyles = usePasteStyles();
  return children({
    canCopyStyles,
    canDuplicate,
    canInsertBlock,
    canMove,
    canRemove,
    onDuplicate() {
      return duplicateBlocks(clientIds, updateSelection);
    },
    onRemove() {
      return removeBlocks(clientIds, updateSelection);
    },
    onInsertBefore() {
      insertBeforeBlock(clientIds[0]);
    },
    onInsertAfter() {
      insertAfterBlock(clientIds[clientIds.length - 1]);
    },
    onMoveTo() {
      setNavigationMode(true);
      selectBlock(clientIds[0]);
      setBlockMovingClientId(clientIds[0]);
    },
    onGroup() {
      if (!clientIds.length) {
        return;
      }
      const groupingBlockName = getGroupingBlockName();

      // Activate the `transform` on `core/group` which does the conversion.
      const newBlocks = (0,build_module/* switchToBlockType */.bh)(getBlocksByClientId(clientIds), groupingBlockName);
      if (!newBlocks) {
        return;
      }
      replaceBlocks(clientIds, newBlocks);
    },
    onUngroup() {
      if (!clientIds.length) {
        return;
      }
      const innerBlocks = getBlocks(clientIds[0]);
      if (!innerBlocks.length) {
        return;
      }
      replaceBlocks(clientIds, innerBlocks);
    },
    onCopy() {
      if (clientIds.length === 1) {
        flashBlock(clientIds[0]);
      }
      notifyCopy('copy', clientIds);
    },
    async onPasteStyles() {
      await pasteStyles(getBlocksByClientId(clientIds));
    }
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-html-convert-button.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


function BlockHTMLConvertButton({
  clientId
}) {
  const block = (0,use_select/* default */.A)(select => select(store_store).getBlock(clientId), [clientId]);
  const {
    replaceBlocks
  } = (0,use_dispatch/* default */.A)(store_store);
  if (!block || block.name !== 'core/html') {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
    onClick: () => replaceBlocks(clientId, (0,build_module/* rawHandler */.lh)({
      HTML: (0,build_module/* getBlockContent */.F8)(block)
    })),
    children: (0,i18n_build_module.__)('Convert to Blocks')
  });
}
/* harmony default export */ const block_html_convert_button = (BlockHTMLConvertButton);
//# sourceMappingURL=block-html-convert-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-menu-first-item.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableBlockSettingsMenuFirstItem,
  Slot: block_settings_menu_first_item_Slot
} = (0,slot_fill/* createSlotFill */.QJ)('__unstableBlockSettingsMenuFirstItem');
__unstableBlockSettingsMenuFirstItem.Slot = block_settings_menu_first_item_Slot;
/* harmony default export */ const block_settings_menu_first_item = (__unstableBlockSettingsMenuFirstItem);
//# sourceMappingURL=block-settings-menu-first-item.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-parent-selector-menu-item.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function BlockParentSelectorMenuItem({
  parentClientId,
  parentBlockType
}) {
  const isSmallViewport = (0,use_viewport_match/* default */.A)('medium', '<');
  const {
    selectBlock
  } = (0,use_dispatch/* default */.A)(store_store);

  // Allows highlighting the parent block outline when focusing or hovering
  // the parent block selector within the child.
  const menuItemRef = (0,react.useRef)();
  const gesturesProps = useShowHoveredOrFocusedGestures({
    ref: menuItemRef,
    highlightParent: true
  });
  if (!isSmallViewport) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
    ...gesturesProps,
    ref: menuItemRef,
    icon: /*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
      icon: parentBlockType.icon
    }),
    onClick: () => selectBlock(parentClientId),
    children: (0,i18n_build_module/* sprintf */.nv)( /* translators: %s: Name of the block's parent. */
    (0,i18n_build_module.__)('Select parent block (%s)'), parentBlockType.title)
  });
}
//# sourceMappingURL=block-parent-selector-menu-item.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-dropdown.js
/**
 * WordPress dependencies
 */










/**
 * Internal dependencies
 */










const block_settings_dropdown_POPOVER_PROPS = {
  className: 'block-editor-block-settings-menu__popover',
  placement: 'bottom-start'
};
function CopyMenuItem({
  clientIds,
  onCopy,
  label,
  shortcut
}) {
  const {
    getBlocksByClientId
  } = (0,use_select/* default */.A)(store_store);
  const ref = useCopyToClipboard(() => (0,build_module/* serialize */.lK)(getBlocksByClientId(clientIds)), onCopy);
  const copyMenuItemLabel = label ? label : (0,i18n_build_module.__)('Copy');
  return /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
    ref: ref,
    shortcut: shortcut,
    children: copyMenuItemLabel
  });
}
function BlockSettingsDropdown({
  block,
  clientIds,
  children,
  __experimentalSelectBlock,
  ...props
}) {
  // Get the client id of the current block for this menu, if one is set.
  const currentClientId = block?.clientId;
  const count = clientIds.length;
  const firstBlockClientId = clientIds[0];
  const {
    firstParentClientId,
    onlyBlock,
    parentBlockType,
    previousBlockClientId,
    selectedBlockClientIds,
    openedBlockSettingsMenu,
    isContentOnly
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockCount,
      getBlockName,
      getBlockRootClientId,
      getPreviousBlockClientId,
      getSelectedBlockClientIds,
      getBlockAttributes,
      getOpenedBlockSettingsMenu,
      getBlockEditingMode
    } = lock_unlock_unlock(select(store_store));
    const {
      getActiveBlockVariation
    } = select(build_module/* store */.M_);
    const _firstParentClientId = getBlockRootClientId(firstBlockClientId);
    const parentBlockName = _firstParentClientId && getBlockName(_firstParentClientId);
    return {
      firstParentClientId: _firstParentClientId,
      onlyBlock: 1 === getBlockCount(_firstParentClientId),
      parentBlockType: _firstParentClientId && (getActiveBlockVariation(parentBlockName, getBlockAttributes(_firstParentClientId)) || (0,build_module/* getBlockType */.E7)(parentBlockName)),
      previousBlockClientId: getPreviousBlockClientId(firstBlockClientId),
      selectedBlockClientIds: getSelectedBlockClientIds(),
      openedBlockSettingsMenu: getOpenedBlockSettingsMenu(),
      isContentOnly: getBlockEditingMode(firstBlockClientId) === 'contentOnly'
    };
  }, [firstBlockClientId]);
  const {
    getBlockOrder,
    getSelectedBlockClientIds
  } = (0,use_select/* default */.A)(store_store);
  const {
    setOpenedBlockSettingsMenu
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  const shortcuts = (0,use_select/* default */.A)(select => {
    const {
      getShortcutRepresentation
    } = select(keyboard_shortcuts_build_module/* store */.M_);
    return {
      duplicate: getShortcutRepresentation('core/block-editor/duplicate'),
      remove: getShortcutRepresentation('core/block-editor/remove'),
      insertAfter: getShortcutRepresentation('core/block-editor/insert-after'),
      insertBefore: getShortcutRepresentation('core/block-editor/insert-before')
    };
  }, []);
  const hasSelectedBlocks = selectedBlockClientIds.length > 0;
  async function updateSelectionAfterDuplicate(clientIdsPromise) {
    if (!__experimentalSelectBlock) {
      return;
    }
    const ids = await clientIdsPromise;
    if (ids && ids[0]) {
      __experimentalSelectBlock(ids[0], false);
    }
  }
  function updateSelectionAfterRemove() {
    if (!__experimentalSelectBlock) {
      return;
    }
    let blockToFocus = previousBlockClientId || firstParentClientId;

    // Focus the first block if there's no previous block nor parent block.
    if (!blockToFocus) {
      blockToFocus = getBlockOrder()[0];
    }

    // Only update the selection if the original selection is removed.
    const shouldUpdateSelection = hasSelectedBlocks && getSelectedBlockClientIds().length === 0;
    __experimentalSelectBlock(blockToFocus, shouldUpdateSelection);
  }

  // This can occur when the selected block (the parent)
  // displays child blocks within a List View.
  const parentBlockIsSelected = selectedBlockClientIds?.includes(firstParentClientId);

  // When a currentClientId is in use, treat the menu as a controlled component.
  // This ensures that only one block settings menu is open at a time.
  // This is a temporary solution to work around an issue with `onFocusOutside`
  // where it does not allow a dropdown to be closed if focus was never within
  // the dropdown to begin with. Examples include a user either CMD+Clicking or
  // right clicking into an inactive window.
  // See: https://github.com/WordPress/gutenberg/pull/54083
  const open = !currentClientId ? undefined : openedBlockSettingsMenu === currentClientId || false;
  function onToggle(localOpen) {
    if (localOpen && openedBlockSettingsMenu !== currentClientId) {
      setOpenedBlockSettingsMenu(currentClientId);
    } else if (!localOpen && openedBlockSettingsMenu && openedBlockSettingsMenu === currentClientId) {
      setOpenedBlockSettingsMenu(undefined);
    }
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(BlockActions, {
    clientIds: clientIds,
    __experimentalUpdateSelection: !__experimentalSelectBlock,
    children: ({
      canCopyStyles,
      canDuplicate,
      canInsertBlock,
      canMove,
      canRemove,
      onDuplicate,
      onInsertAfter,
      onInsertBefore,
      onRemove,
      onCopy,
      onPasteStyles,
      onMoveTo
    }) => /*#__PURE__*/(0,jsx_runtime.jsx)(dropdown_menu/* default */.A, {
      icon: more_vertical/* default */.A,
      label: (0,i18n_build_module.__)('Options'),
      className: "block-editor-block-settings-menu",
      popoverProps: block_settings_dropdown_POPOVER_PROPS,
      open: open,
      onToggle: onToggle,
      noIcons: true,
      ...props,
      children: ({
        onClose
      }) => /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsxs)(menu_group/* default */.A, {
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_settings_menu_first_item.Slot, {
            fillProps: {
              onClose
            }
          }), !parentBlockIsSelected && !!firstParentClientId && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockParentSelectorMenuItem, {
            parentClientId: firstParentClientId,
            parentBlockType: parentBlockType
          }), count === 1 && /*#__PURE__*/(0,jsx_runtime.jsx)(block_html_convert_button, {
            clientId: firstBlockClientId
          }), !isContentOnly && /*#__PURE__*/(0,jsx_runtime.jsx)(CopyMenuItem, {
            clientIds: clientIds,
            onCopy: onCopy,
            shortcut: keycodes_build_module/* displayShortcut */.dz.primary('c')
          }), canDuplicate && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
            onClick: (0,pipe/* default */.h)(onClose, onDuplicate, updateSelectionAfterDuplicate),
            shortcut: shortcuts.duplicate,
            children: (0,i18n_build_module.__)('Duplicate')
          }), canInsertBlock && !isContentOnly && /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [/*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
              onClick: (0,pipe/* default */.h)(onClose, onInsertBefore),
              shortcut: shortcuts.insertBefore,
              children: (0,i18n_build_module.__)('Add before')
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
              onClick: (0,pipe/* default */.h)(onClose, onInsertAfter),
              shortcut: shortcuts.insertAfter,
              children: (0,i18n_build_module.__)('Add after')
            })]
          })]
        }), canCopyStyles && !isContentOnly && /*#__PURE__*/(0,jsx_runtime.jsxs)(menu_group/* default */.A, {
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(CopyMenuItem, {
            clientIds: clientIds,
            onCopy: onCopy,
            label: (0,i18n_build_module.__)('Copy styles')
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
            onClick: onPasteStyles,
            children: (0,i18n_build_module.__)('Paste styles')
          })]
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_settings_menu_controls.Slot, {
          fillProps: {
            onClose,
            canMove,
            onMoveTo,
            onlyBlock,
            count,
            firstBlockClientId
          },
          clientIds: clientIds
        }), typeof children === 'function' ? children({
          onClose
        }) : react.Children.map(child => (0,react.cloneElement)(child, {
          onClose
        })), canRemove && /*#__PURE__*/(0,jsx_runtime.jsx)(menu_group/* default */.A, {
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(menu_item/* default */.A, {
            onClick: (0,pipe/* default */.h)(onClose, onRemove, updateSelectionAfterRemove),
            shortcut: shortcuts.remove,
            children: (0,i18n_build_module.__)('Delete')
          })
        })]
      })
    })
  });
}
/* harmony default export */ const block_settings_dropdown = (BlockSettingsDropdown);
//# sourceMappingURL=block-settings-dropdown.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function BlockSettingsMenu({
  clientIds,
  ...props
}) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_group/* default */.A, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_item/* default */.A, {
      children: toggleProps => /*#__PURE__*/(0,jsx_runtime.jsx)(block_settings_dropdown, {
        clientIds: clientIds,
        toggleProps: toggleProps,
        ...props
      })
    })
  });
}
/* harmony default export */ const block_settings_menu = (BlockSettingsMenu);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-lock/toolbar.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





function BlockLockToolbar({
  clientId
}) {
  const {
    canLock,
    isLocked
  } = useBlockLock(clientId);
  const [isModalOpen, toggleModal] = (0,react.useReducer)(isActive => !isActive, false);
  const hasLockButtonShown = (0,react.useRef)(false);

  // If the block lock button has been shown, we don't want to remove it
  // from the toolbar until the toolbar is rendered again without it.
  // Removing it beforehand can cause focus loss issues, such as when
  // unlocking the block from the modal. It needs to return focus from
  // whence it came, and to do that, we need to leave the button in the toolbar.
  (0,react.useEffect)(() => {
    if (isLocked) {
      hasLockButtonShown.current = true;
    }
  }, [isLocked]);
  if (!isLocked && !hasLockButtonShown.current) {
    return null;
  }
  let label = isLocked ? (0,i18n_build_module.__)('Unlock') : (0,i18n_build_module.__)('Lock');
  if (!canLock && isLocked) {
    label = (0,i18n_build_module.__)('Locked');
  }
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_group/* default */.A, {
      className: "block-editor-block-lock-toolbar",
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
        accessibleWhenDisabled: true,
        disabled: !canLock,
        icon: isLocked ? library_lock : library_unlock,
        label: label,
        onClick: toggleModal,
        "aria-expanded": isModalOpen,
        "aria-haspopup": "dialog"
      })
    }), isModalOpen && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockLockModal, {
      clientId: clientId,
      onClose: toggleModal
    })]
  });
}
//# sourceMappingURL=toolbar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/group.js
/**
 * WordPress dependencies
 */


const group_group = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M18 4h-7c-1.1 0-2 .9-2 2v3H6c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2v-3h3c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-4.5 14c0 .3-.2.5-.5.5H6c-.3 0-.5-.2-.5-.5v-7c0-.3.2-.5.5-.5h3V13c0 1.1.9 2 2 2h2.5v3zm0-4.5H11c-.3 0-.5-.2-.5-.5v-2.5H13c.3 0 .5.2.5.5v2.5zm5-.5c0 .3-.2.5-.5.5h-3V11c0-1.1-.9-2-2-2h-2.5V6c0-.3.2-.5.5-.5h7c.3 0 .5.2.5.5v7z"
  })
});
/* harmony default export */ const library_group = (group_group);
//# sourceMappingURL=group.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/row.js
/**
 * WordPress dependencies
 */


const row = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M4 6.5h5a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H4V16h5a.5.5 0 0 0 .5-.5v-7A.5.5 0 0 0 9 8H4V6.5Zm16 0h-5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h5V16h-5a.5.5 0 0 1-.5-.5v-7A.5.5 0 0 1 15 8h5V6.5Z"
  })
});
/* harmony default export */ const library_row = (row);
//# sourceMappingURL=row.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/stack.js
/**
 * WordPress dependencies
 */


const stack = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M17.5 4v5a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V4H8v5a.5.5 0 0 0 .5.5h7A.5.5 0 0 0 16 9V4h1.5Zm0 16v-5a2 2 0 0 0-2-2h-7a2 2 0 0 0-2 2v5H8v-5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v5h1.5Z"
  })
});
/* harmony default export */ const library_stack = (stack);
//# sourceMappingURL=stack.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/grid.js
/**
 * WordPress dependencies
 */


const grid_grid = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "m3 5c0-1.10457.89543-2 2-2h13.5c1.1046 0 2 .89543 2 2v13.5c0 1.1046-.8954 2-2 2h-13.5c-1.10457 0-2-.8954-2-2zm2-.5h6v6.5h-6.5v-6c0-.27614.22386-.5.5-.5zm-.5 8v6c0 .2761.22386.5.5.5h6v-6.5zm8 0v6.5h6c.2761 0 .5-.2239.5-.5v-6zm0-8v6.5h6.5v-6c0-.27614-.2239-.5-.5-.5z",
    fillRule: "evenodd",
    clipRule: "evenodd"
  })
});
/* harmony default export */ const library_grid = (grid_grid);
//# sourceMappingURL=grid.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/toolbar.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




const layouts = {
  group: {
    type: 'constrained'
  },
  row: {
    type: 'flex',
    flexWrap: 'nowrap'
  },
  stack: {
    type: 'flex',
    orientation: 'vertical'
  },
  grid: {
    type: 'grid'
  }
};
function BlockGroupToolbar() {
  const {
    blocksSelection,
    clientIds,
    groupingBlockName,
    isGroupable
  } = useConvertToGroupButtonProps();
  const {
    replaceBlocks
  } = (0,use_dispatch/* default */.A)(store_store);
  const {
    canRemove,
    variations
  } = (0,use_select/* default */.A)(select => {
    const {
      canRemoveBlocks
    } = select(store_store);
    const {
      getBlockVariations
    } = select(build_module/* store */.M_);
    return {
      canRemove: canRemoveBlocks(clientIds),
      variations: getBlockVariations(groupingBlockName, 'transform')
    };
  }, [clientIds, groupingBlockName]);
  const onConvertToGroup = layout => {
    const newBlocks = (0,build_module/* switchToBlockType */.bh)(blocksSelection, groupingBlockName);
    if (typeof layout !== 'string') {
      layout = 'group';
    }
    if (newBlocks && newBlocks.length > 0) {
      // Because the block is not in the store yet we can't use
      // updateBlockAttributes so need to manually update attributes.
      newBlocks[0].attributes.layout = layouts[layout];
      replaceBlocks(clientIds, newBlocks);
    }
  };
  const onConvertToRow = () => onConvertToGroup('row');
  const onConvertToStack = () => onConvertToGroup('stack');
  const onConvertToGrid = () => onConvertToGroup('grid');

  // Don't render the button if the current selection cannot be grouped.
  // A good example is selecting multiple button blocks within a Buttons block:
  // The group block is not a valid child of Buttons, so we should not show the button.
  // Any blocks that are locked against removal also cannot be grouped.
  if (!isGroupable || !canRemove) {
    return null;
  }
  const canInsertRow = !!variations.find(({
    name
  }) => name === 'group-row');
  const canInsertStack = !!variations.find(({
    name
  }) => name === 'group-stack');
  const canInsertGrid = !!variations.find(({
    name
  }) => name === 'group-grid');
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(toolbar_group/* default */.A, {
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
      icon: library_group,
      label: (0,i18n_build_module._x)('Group', 'verb'),
      onClick: onConvertToGroup
    }), canInsertRow && /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
      icon: library_row,
      label: (0,i18n_build_module._x)('Row', 'single horizontal line'),
      onClick: onConvertToRow
    }), canInsertStack && /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
      icon: library_stack,
      label: (0,i18n_build_module._x)('Stack', 'verb'),
      onClick: onConvertToStack
    }), canInsertGrid && /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
      icon: library_grid,
      label: (0,i18n_build_module._x)('Grid', 'verb'),
      onClick: onConvertToGrid
    })]
  });
}
/* harmony default export */ const toolbar = (BlockGroupToolbar);
//# sourceMappingURL=toolbar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-edit-visually-button/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


function BlockEditVisuallyButton({
  clientIds
}) {
  // Edit visually only works for single block selection.
  const clientId = clientIds.length === 1 ? clientIds[0] : undefined;
  const canEditVisually = (0,use_select/* default */.A)(select => !!clientId && select(store_store).getBlockMode(clientId) === 'html', [clientId]);
  const {
    toggleBlockMode
  } = (0,use_dispatch/* default */.A)(store_store);
  if (!canEditVisually) {
    return null;
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_group/* default */.A, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
      onClick: () => {
        toggleBlockMode(clientId);
      },
      children: (0,i18n_build_module.__)('Edit visually')
    })
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-name-context.js
/**
 * WordPress dependencies
 */

const __unstableBlockNameContext = (0,react.createContext)('');
/* harmony default export */ const block_name_context = (__unstableBlockNameContext);
//# sourceMappingURL=block-name-context.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar/index.js + 4 modules
var toolbar_toolbar = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toolbar/toolbar/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/navigable-toolbar/index.js
/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */



function hasOnlyToolbarItem(elements) {
  const dataProp = 'toolbarItem';
  return !elements.some(element => !(dataProp in element.dataset));
}
function getAllFocusableToolbarItemsIn(container) {
  return Array.from(container.querySelectorAll('[data-toolbar-item]:not([disabled])'));
}
function hasFocusWithin(container) {
  return container.contains(container.ownerDocument.activeElement);
}
function focusFirstTabbableIn(container) {
  const [firstTabbable] = dom_build_module/* focus */.XC.tabbable.find(container);
  if (firstTabbable) {
    firstTabbable.focus({
      // When focusing newly mounted toolbars,
      // the position of the popover is often not right on the first render
      // This prevents the layout shifts when focusing the dialogs.
      preventScroll: true
    });
  }
}
function useIsAccessibleToolbar(toolbarRef) {
  /*
   * By default, we'll assume the starting accessible state of the Toolbar
   * is true, as it seems to be the most common case.
   *
   * Transitioning from an (initial) false to true state causes the
   * <Toolbar /> component to mount twice, which is causing undesired
   * side-effects. These side-effects appear to only affect certain
   * E2E tests.
   *
   * This was initial discovered in this pull-request:
   * https://github.com/WordPress/gutenberg/pull/23425
   */
  const initialAccessibleToolbarState = true;

  // By default, it's gonna render NavigableMenu. If all the tabbable elements
  // inside the toolbar are ToolbarItem components (or derived components like
  // ToolbarButton), then we can wrap them with the accessible Toolbar
  // component.
  const [isAccessibleToolbar, setIsAccessibleToolbar] = (0,react.useState)(initialAccessibleToolbarState);
  const determineIsAccessibleToolbar = (0,react.useCallback)(() => {
    const tabbables = dom_build_module/* focus */.XC.tabbable.find(toolbarRef.current);
    const onlyToolbarItem = hasOnlyToolbarItem(tabbables);
    if (!onlyToolbarItem) {
      (0,deprecated_build_module/* default */.A)('Using custom components as toolbar controls', {
        since: '5.6',
        alternative: 'ToolbarItem, ToolbarButton or ToolbarDropdownMenu components',
        link: 'https://developer.wordpress.org/block-editor/components/toolbar-button/#inside-blockcontrols'
      });
    }
    setIsAccessibleToolbar(onlyToolbarItem);
  }, [toolbarRef]);
  (0,react.useLayoutEffect)(() => {
    // Toolbar buttons may be rendered asynchronously, so we use
    // MutationObserver to check if the toolbar subtree has been modified.
    const observer = new window.MutationObserver(determineIsAccessibleToolbar);
    observer.observe(toolbarRef.current, {
      childList: true,
      subtree: true
    });
    return () => observer.disconnect();
  }, [determineIsAccessibleToolbar, isAccessibleToolbar, toolbarRef]);
  return isAccessibleToolbar;
}
function useToolbarFocus({
  toolbarRef,
  focusOnMount,
  isAccessibleToolbar,
  defaultIndex,
  onIndexChange,
  shouldUseKeyboardFocusShortcut,
  focusEditorOnEscape
}) {
  // Make sure we don't use modified versions of this prop.
  const [initialFocusOnMount] = (0,react.useState)(focusOnMount);
  const [initialIndex] = (0,react.useState)(defaultIndex);
  const focusToolbar = (0,react.useCallback)(() => {
    focusFirstTabbableIn(toolbarRef.current);
  }, [toolbarRef]);
  const focusToolbarViaShortcut = () => {
    if (shouldUseKeyboardFocusShortcut) {
      focusToolbar();
    }
  };

  // Focus on toolbar when pressing alt+F10 when the toolbar is visible.
  (0,keyboard_shortcuts_build_module/* useShortcut */.wk)('core/block-editor/focus-toolbar', focusToolbarViaShortcut);
  (0,react.useEffect)(() => {
    if (initialFocusOnMount) {
      focusToolbar();
    }
  }, [isAccessibleToolbar, initialFocusOnMount, focusToolbar]);
  (0,react.useEffect)(() => {
    // Store ref so we have access on useEffect cleanup: https://legacy.reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timing
    const navigableToolbarRef = toolbarRef.current;
    // If initialIndex is passed, we focus on that toolbar item when the
    // toolbar gets mounted and initial focus is not forced.
    // We have to wait for the next browser paint because block controls aren't
    // rendered right away when the toolbar gets mounted.
    let raf = 0;

    // If the toolbar already had focus before the render, we don't want to move it.
    // https://github.com/WordPress/gutenberg/issues/58511
    if (!initialFocusOnMount && !hasFocusWithin(navigableToolbarRef)) {
      raf = window.requestAnimationFrame(() => {
        const items = getAllFocusableToolbarItemsIn(navigableToolbarRef);
        const index = initialIndex || 0;
        if (items[index] && hasFocusWithin(navigableToolbarRef)) {
          items[index].focus({
            // When focusing newly mounted toolbars,
            // the position of the popover is often not right on the first render
            // This prevents the layout shifts when focusing the dialogs.
            preventScroll: true
          });
        }
      });
    }
    return () => {
      window.cancelAnimationFrame(raf);
      if (!onIndexChange || !navigableToolbarRef) {
        return;
      }
      // When the toolbar element is unmounted and onIndexChange is passed, we
      // pass the focused toolbar item index so it can be hydrated later.
      const items = getAllFocusableToolbarItemsIn(navigableToolbarRef);
      const index = items.findIndex(item => item.tabIndex === 0);
      onIndexChange(index);
    };
  }, [initialIndex, initialFocusOnMount, onIndexChange, toolbarRef]);
  const {
    getLastFocus
  } = lock_unlock_unlock((0,use_select/* default */.A)(store_store));
  /**
   * Handles returning focus to the block editor canvas when pressing escape.
   */
  (0,react.useEffect)(() => {
    const navigableToolbarRef = toolbarRef.current;
    if (focusEditorOnEscape) {
      const handleKeyDown = event => {
        const lastFocus = getLastFocus();
        if (event.keyCode === keycodes_build_module/* ESCAPE */._f && lastFocus?.current) {
          // Focus the last focused element when pressing escape.
          event.preventDefault();
          lastFocus.current.focus();
        }
      };
      navigableToolbarRef.addEventListener('keydown', handleKeyDown);
      return () => {
        navigableToolbarRef.removeEventListener('keydown', handleKeyDown);
      };
    }
  }, [focusEditorOnEscape, getLastFocus, toolbarRef]);
}
function NavigableToolbar({
  children,
  focusOnMount,
  focusEditorOnEscape = false,
  shouldUseKeyboardFocusShortcut = true,
  __experimentalInitialIndex: initialIndex,
  __experimentalOnIndexChange: onIndexChange,
  ...props
}) {
  const toolbarRef = (0,react.useRef)();
  const isAccessibleToolbar = useIsAccessibleToolbar(toolbarRef);
  useToolbarFocus({
    toolbarRef,
    focusOnMount,
    defaultIndex: initialIndex,
    onIndexChange,
    isAccessibleToolbar,
    shouldUseKeyboardFocusShortcut,
    focusEditorOnEscape
  });
  if (isAccessibleToolbar) {
    return /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_toolbar/* default */.A, {
      label: props['aria-label'],
      ref: toolbarRef,
      ...props,
      children: children
    });
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(navigable_container_menu/* default */.Ay, {
    orientation: "horizontal",
    role: "toolbar",
    ref: toolbarRef,
    ...props,
    children: children
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/shuffle.js
/**
 * WordPress dependencies
 */


const shuffle = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/SVG",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    d: "M17.192 6.75L15.47 5.03l1.06-1.06 3.537 3.53-3.537 3.53-1.06-1.06 1.723-1.72h-3.19c-.602 0-.993.202-1.28.498-.309.319-.538.792-.695 1.383-.13.488-.222 1.023-.296 1.508-.034.664-.116 1.413-.303 2.117-.193.721-.513 1.467-1.068 2.04-.575.594-1.359.954-2.357.954H4v-1.5h4.003c.601 0 .993-.202 1.28-.498.308-.319.538-.792.695-1.383.149-.557.216-1.093.288-1.662l.039-.31a9.653 9.653 0 0 1 .272-1.653c.193-.722.513-1.467 1.067-2.04.576-.594 1.36-.954 2.358-.954h3.19zM8.004 6.75c.8 0 1.46.23 1.988.628a6.24 6.24 0 0 0-.684 1.396 1.725 1.725 0 0 0-.024-.026c-.287-.296-.679-.498-1.28-.498H4v-1.5h4.003zM12.699 14.726c-.161.459-.38.94-.684 1.396.527.397 1.188.628 1.988.628h3.19l-1.722 1.72 1.06 1.06L20.067 16l-3.537-3.53-1.06 1.06 1.723 1.72h-3.19c-.602 0-.993-.202-1.28-.498a1.96 1.96 0 0 1-.024-.026z"
  })
});
/* harmony default export */ const library_shuffle = (shuffle);
//# sourceMappingURL=shuffle.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/shuffle.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


const shuffle_EMPTY_ARRAY = [];
function shuffle_Container(props) {
  return /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_group/* default */.A, {
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
      ...props
    })
  });
}
function Shuffle({
  clientId,
  as = shuffle_Container
}) {
  const {
    categories,
    patterns,
    patternName
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockAttributes,
      getBlockRootClientId,
      __experimentalGetAllowedPatterns
    } = select(store_store);
    const attributes = getBlockAttributes(clientId);
    const _categories = attributes?.metadata?.categories || shuffle_EMPTY_ARRAY;
    const _patternName = attributes?.metadata?.patternName;
    const rootBlock = getBlockRootClientId(clientId);
    const _patterns = __experimentalGetAllowedPatterns(rootBlock);
    return {
      categories: _categories,
      patterns: _patterns,
      patternName: _patternName
    };
  }, [clientId]);
  const {
    replaceBlocks
  } = (0,use_dispatch/* default */.A)(store_store);
  const sameCategoryPatternsWithSingleWrapper = (0,react.useMemo)(() => {
    if (!categories || categories.length === 0 || !patterns || patterns.length === 0) {
      return shuffle_EMPTY_ARRAY;
    }
    return patterns.filter(pattern => {
      return (
        // Check if the pattern has only one top level block,
        // otherwise we may shuffle to pattern that will not allow to continue shuffling.
        pattern.blocks.length === 1 && pattern.categories?.some(category => {
          return categories.includes(category);
        }) && (
        // Check if the pattern is not a synced pattern.
        pattern.syncStatus === 'unsynced' || !pattern.id)
      );
    });
  }, [categories, patterns]);
  if (sameCategoryPatternsWithSingleWrapper.length < 2) {
    return null;
  }
  function getNextPattern() {
    const numberOfPatterns = sameCategoryPatternsWithSingleWrapper.length;
    const patternIndex = sameCategoryPatternsWithSingleWrapper.findIndex(({
      name
    }) => name === patternName);
    const nextPatternIndex = patternIndex + 1 < numberOfPatterns ? patternIndex + 1 : 0;
    return sameCategoryPatternsWithSingleWrapper[nextPatternIndex];
  }
  const ComponentToUse = as;
  return /*#__PURE__*/(0,jsx_runtime.jsx)(ComponentToUse, {
    label: (0,i18n_build_module.__)('Shuffle'),
    icon: library_shuffle,
    onClick: () => {
      const nextPattern = getNextPattern();
      nextPattern.blocks[0].attributes = {
        ...nextPattern.blocks[0].attributes,
        metadata: {
          ...nextPattern.blocks[0].attributes.metadata,
          categories
        }
      };
      replaceBlocks(clientId, nextPattern.blocks);
    }
  });
}
//# sourceMappingURL=shuffle.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-controls/use-has-block-controls.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */

function useHasAnyBlockControls() {
  let hasAnyBlockControls = false;
  for (const group in block_controls_groups) {
    // It is safe to violate the rules of hooks here as the `groups` object
    // is static and will not change length between renders. Do not return
    // early as that will cause the hook to be called a different number of
    // times between renders.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    if (useHasBlockControls(group)) {
      hasAnyBlockControls = true;
    }
  }
  return hasAnyBlockControls;
}
function useHasBlockControls(group = 'default') {
  const Slot = block_controls_groups[group]?.Slot;
  const fills = useSlotFills(Slot?.__unstableName);
  if (!Slot) {
    globalThis.SCRIPT_DEBUG === true ? (0,warning_build_module/* default */.A)(`Unknown BlockControls group "${group}" provided.`) : void 0;
    return null;
  }
  return !!fills?.length;
}
//# sourceMappingURL=use-has-block-controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/use-has-block-toolbar.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Returns true if the block toolbar should be shown.
 *
 * @return {boolean} Whether the block toolbar component will be rendered.
 */
function useHasBlockToolbar() {
  const {
    isToolbarEnabled,
    isDefaultEditingMode
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockEditingMode,
      getBlockName,
      getBlockSelectionStart
    } = select(store_store);

    // we only care about the 1st selected block
    // for the toolbar, so we use getBlockSelectionStart
    // instead of getSelectedBlockClientIds
    const selectedBlockClientId = getBlockSelectionStart();
    const blockType = selectedBlockClientId && (0,build_module/* getBlockType */.E7)(getBlockName(selectedBlockClientId));
    return {
      isToolbarEnabled: blockType && (0,build_module/* hasBlockSupport */.pN)(blockType, '__experimentalToolbar', true),
      isDefaultEditingMode: getBlockEditingMode(selectedBlockClientId) === 'default'
    };
  }, []);
  const hasAnyBlockControls = useHasAnyBlockControls();
  if (!isToolbarEnabled || !isDefaultEditingMode && !hasAnyBlockControls) {
    return false;
  }
  return true;
}
//# sourceMappingURL=use-has-block-toolbar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */
















/**
 * Renders the block toolbar.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-toolbar/README.md
 *
 * @param {Object}   props                             Components props.
 * @param {boolean}  props.hideDragHandle              Show or hide the Drag Handle for drag and drop functionality.
 * @param {boolean}  props.focusOnMount                Focus the toolbar when mounted.
 * @param {number}   props.__experimentalInitialIndex  The initial index of the toolbar item to focus.
 * @param {Function} props.__experimentalOnIndexChange Callback function to be called when the index of the focused toolbar item changes.
 * @param {string}   props.variant                     Style variant of the toolbar, also passed to the Dropdowns rendered from Block Toolbar Buttons.
 */



function PrivateBlockToolbar({
  hideDragHandle,
  focusOnMount,
  __experimentalInitialIndex,
  __experimentalOnIndexChange,
  variant = 'unstyled'
}) {
  const {
    blockClientId,
    blockClientIds,
    isDefaultEditingMode,
    blockType,
    toolbarKey,
    shouldShowVisualToolbar,
    showParentSelector,
    isUsingBindings
  } = (0,use_select/* default */.A)(select => {
    const {
      getBlockName,
      getBlockMode,
      getBlockParents,
      getSelectedBlockClientIds,
      isBlockValid,
      getBlockRootClientId,
      getBlockEditingMode,
      getBlockAttributes
    } = select(store_store);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const selectedBlockClientId = selectedBlockClientIds[0];
    const blockRootClientId = getBlockRootClientId(selectedBlockClientId);
    const parents = getBlockParents(selectedBlockClientId);
    const firstParentClientId = parents[parents.length - 1];
    const parentBlockName = getBlockName(firstParentClientId);
    const parentBlockType = (0,build_module/* getBlockType */.E7)(parentBlockName);
    const _isDefaultEditingMode = getBlockEditingMode(selectedBlockClientId) === 'default';
    const _blockName = getBlockName(selectedBlockClientId);
    const isValid = selectedBlockClientIds.every(id => isBlockValid(id));
    const isVisual = selectedBlockClientIds.every(id => getBlockMode(id) === 'visual');
    const _isUsingBindings = selectedBlockClientIds.every(clientId => !!getBlockAttributes(clientId)?.metadata?.bindings);
    return {
      blockClientId: selectedBlockClientId,
      blockClientIds: selectedBlockClientIds,
      isDefaultEditingMode: _isDefaultEditingMode,
      blockType: selectedBlockClientId && (0,build_module/* getBlockType */.E7)(_blockName),
      shouldShowVisualToolbar: isValid && isVisual,
      rootClientId: blockRootClientId,
      toolbarKey: `${selectedBlockClientId}${firstParentClientId}`,
      showParentSelector: parentBlockType && getBlockEditingMode(firstParentClientId) === 'default' && (0,build_module/* hasBlockSupport */.pN)(parentBlockType, '__experimentalParentSelector', true) && selectedBlockClientIds.length === 1 && _isDefaultEditingMode,
      isUsingBindings: _isUsingBindings
    };
  }, []);
  const toolbarWrapperRef = (0,react.useRef)(null);

  // Handles highlighting the current block outline on hover or focus of the
  // block type toolbar area.
  const nodeRef = (0,react.useRef)();
  const showHoveredOrFocusedGestures = useShowHoveredOrFocusedGestures({
    ref: nodeRef
  });
  const isLargeViewport = !(0,use_viewport_match/* default */.A)('medium', '<');
  const hasBlockToolbar = useHasBlockToolbar();
  if (!hasBlockToolbar) {
    return null;
  }
  const isMultiToolbar = blockClientIds.length > 1;
  const isSynced = (0,build_module/* isReusableBlock */.tk)(blockType) || (0,build_module/* isTemplatePart */.gc)(blockType);

  // Shifts the toolbar to make room for the parent block selector.
  const classes = (0,dist_clsx/* default */.A)('block-editor-block-contextual-toolbar', {
    'has-parent': showParentSelector
  });
  const innerClasses = (0,dist_clsx/* default */.A)('block-editor-block-toolbar', {
    'is-synced': isSynced,
    'is-connected': isUsingBindings
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(NavigableToolbar, {
    focusEditorOnEscape: true,
    className: classes
    /* translators: accessibility text for the block toolbar */,
    "aria-label": (0,i18n_build_module.__)('Block tools')
    // The variant is applied as "toolbar" when undefined, which is the black border style of the dropdown from the toolbar popover.
    ,
    variant: variant === 'toolbar' ? undefined : variant,
    focusOnMount: focusOnMount,
    __experimentalInitialIndex: __experimentalInitialIndex,
    __experimentalOnIndexChange: __experimentalOnIndexChange
    // Resets the index whenever the active block changes so
    // this is not persisted. See https://github.com/WordPress/gutenberg/pull/25760#issuecomment-717906169
    ,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      ref: toolbarWrapperRef,
      className: innerClasses,
      children: [!isMultiToolbar && isLargeViewport && isDefaultEditingMode && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockParentSelector, {}), (shouldShowVisualToolbar || isMultiToolbar) && (isDefaultEditingMode || isSynced) && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        ref: nodeRef,
        ...showHoveredOrFocusedGestures,
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(toolbar_group/* default */.A, {
          className: "block-editor-block-toolbar__block-controls",
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_switcher, {
            clientIds: blockClientIds,
            disabled: !isDefaultEditingMode,
            isUsingBindings: isUsingBindings
          }), isDefaultEditingMode && /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [!isMultiToolbar && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockLockToolbar, {
              clientId: blockClientId
            }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_mover, {
              clientIds: blockClientIds,
              hideDragHandle: hideDragHandle
            })]
          })]
        })
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(Shuffle, {
        clientId: blockClientId
      }), shouldShowVisualToolbar && isMultiToolbar && /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar, {}), shouldShowVisualToolbar && /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)(block_controls.Slot, {
          group: "parent",
          className: "block-editor-block-toolbar__slot"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_controls.Slot, {
          group: "block",
          className: "block-editor-block-toolbar__slot"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_controls.Slot, {
          className: "block-editor-block-toolbar__slot"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_controls.Slot, {
          group: "inline",
          className: "block-editor-block-toolbar__slot"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_controls.Slot, {
          group: "other",
          className: "block-editor-block-toolbar__slot"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(block_name_context.Provider, {
          value: blockType?.name,
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_toolbar_last_item.Slot, {})
        })]
      }), /*#__PURE__*/(0,jsx_runtime.jsx)(BlockEditVisuallyButton, {
        clientIds: blockClientIds
      }), isDefaultEditingMode && /*#__PURE__*/(0,jsx_runtime.jsx)(block_settings_menu, {
        clientIds: blockClientIds
      })]
    })
  }, toolbarKey);
}

/**
 * Renders the block toolbar.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-toolbar/README.md
 *
 * @param {Object}  props                Components props.
 * @param {boolean} props.hideDragHandle Show or hide the Drag Handle for drag and drop functionality.
 * @param {string}  props.variant        Style variant of the toolbar, also passed to the Dropdowns rendered from Block Toolbar Buttons.
 */
function BlockToolbar({
  hideDragHandle,
  variant
}) {
  return /*#__PURE__*/_jsx(PrivateBlockToolbar, {
    hideDragHandle: hideDragHandle,
    variant: variant,
    focusOnMount: undefined,
    __experimentalInitialIndex: undefined,
    __experimentalOnIndexChange: undefined
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/block-toolbar-popover.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






function BlockToolbarPopover({
  clientId,
  isTyping,
  __unstableContentRef
}) {
  const {
    capturingClientId,
    isInsertionPointVisible,
    lastClientId
  } = useSelectedBlockToolProps(clientId);

  // Stores the active toolbar item index so the block toolbar can return focus
  // to it when re-mounting.
  const initialToolbarItemIndexRef = (0,react.useRef)();
  (0,react.useEffect)(() => {
    // Resets the index whenever the active block changes so this is not
    // persisted. See https://github.com/WordPress/gutenberg/pull/25760#issuecomment-717906169
    initialToolbarItemIndexRef.current = undefined;
  }, [clientId]);
  const {
    stopTyping
  } = (0,use_dispatch/* default */.A)(store_store);
  const isToolbarForced = (0,react.useRef)(false);
  (0,keyboard_shortcuts_build_module/* useShortcut */.wk)('core/block-editor/focus-toolbar', () => {
    isToolbarForced.current = true;
    stopTyping(true);
  });
  (0,react.useEffect)(() => {
    isToolbarForced.current = false;
  });
  const popoverProps = useBlockToolbarPopoverProps({
    contentElement: __unstableContentRef?.current,
    clientId
  });
  return !isTyping && /*#__PURE__*/(0,jsx_runtime.jsx)(block_popover, {
    clientId: capturingClientId || clientId,
    bottomClientId: lastClientId,
    className: (0,dist_clsx/* default */.A)('block-editor-block-list__block-popover', {
      'is-insertion-point-visible': isInsertionPointVisible
    }),
    resize: false,
    ...popoverProps,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(PrivateBlockToolbar
    // If the toolbar is being shown because of being forced
    // it should focus the toolbar right after the mount.
    , {
      focusOnMount: isToolbarForced.current,
      __experimentalInitialIndex: initialToolbarItemIndexRef.current,
      __experimentalOnIndexChange: index => {
        initialToolbarItemIndexRef.current = index;
      },
      variant: "toolbar"
    })
  });
}
//# sourceMappingURL=block-toolbar-popover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/trash.js
/**
 * WordPress dependencies
 */


const trash = /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,jsx_runtime.jsx)(svg/* Path */.wA, {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12 5.5A2.25 2.25 0 0 0 9.878 7h4.244A2.251 2.251 0 0 0 12 5.5ZM12 4a3.751 3.751 0 0 0-3.675 3H5v1.5h1.27l.818 8.997a2.75 2.75 0 0 0 2.739 2.501h4.347a2.75 2.75 0 0 0 2.738-2.5L17.73 8.5H19V7h-3.325A3.751 3.751 0 0 0 12 4Zm4.224 4.5H7.776l.806 8.861a1.25 1.25 0 0 0 1.245 1.137h4.347a1.25 1.25 0 0 0 1.245-1.137l.805-8.861Z"
  })
});
/* harmony default export */ const library_trash = (trash);
//# sourceMappingURL=trash.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-title/index.js
/**
 * Internal dependencies
 */



/**
 * Renders the block's configured title as a string, or empty if the title
 * cannot be determined.
 *
 * @example
 *
 * ```jsx
 * <BlockTitle clientId="afd1cb17-2c08-4e7a-91be-007ba7ddc3a1" maximumLength={ 17 }/>
 * ```
 *
 * @param {Object}           props
 * @param {string}           props.clientId      Client ID of block.
 * @param {number|undefined} props.maximumLength The maximum length that the block title string may be before truncated.
 * @param {string|undefined} props.context       The context to pass to `getBlockLabel`.
 *
 * @return {JSX.Element} Block title.
 */
function BlockTitle({
  clientId,
  maximumLength,
  context
}) {
  return useBlockDisplayTitle({
    clientId,
    maximumLength,
    context
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/block-selection-button.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */










/**
 * Internal dependencies
 */








/**
 * Block selection button component, displaying the label of the block. If the block
 * descends from a root block, a button is displayed enabling the user to select
 * the root block.
 *
 * @param {string} props          Component props.
 * @param {string} props.clientId Client ID of block.
 *
 * @return {Component} The component to be rendered.
 */


function BlockSelectionButton({
  clientId,
  rootClientId
}) {
  const selected = (0,use_select/* default */.A)(select => {
    const {
      getBlock,
      getBlockIndex,
      hasBlockMovingClientId,
      getBlockListSettings,
      __unstableGetEditorMode,
      getNextBlockClientId,
      getPreviousBlockClientId,
      canRemoveBlock,
      canMoveBlock
    } = select(store_store);
    const {
      getActiveBlockVariation,
      getBlockType
    } = select(build_module/* store */.M_);
    const index = getBlockIndex(clientId);
    const {
      name,
      attributes
    } = getBlock(clientId);
    const blockType = getBlockType(name);
    const orientation = getBlockListSettings(rootClientId)?.orientation;
    const match = getActiveBlockVariation(name, attributes);
    const isBlockTemplatePart = blockType?.name === 'core/template-part';
    let isNextBlockTemplatePart = false;
    const nextClientId = getNextBlockClientId();
    if (nextClientId) {
      const {
        name: nextName
      } = getBlock(nextClientId);
      const nextBlockType = getBlockType(nextName);
      isNextBlockTemplatePart = nextBlockType?.name === 'core/template-part';
    }
    let isPrevBlockTemplatePart = false;
    const prevClientId = getPreviousBlockClientId();
    if (prevClientId) {
      const {
        name: prevName
      } = getBlock(prevClientId);
      const prevBlockType = getBlockType(prevName);
      isPrevBlockTemplatePart = prevBlockType?.name === 'core/template-part';
    }
    return {
      blockMovingMode: hasBlockMovingClientId(),
      editorMode: __unstableGetEditorMode(),
      icon: match?.icon || blockType.icon,
      label: (0,build_module/* __experimentalGetAccessibleBlockLabel */.wZ)(blockType, attributes, index + 1, orientation),
      isBlockTemplatePart,
      isNextBlockTemplatePart,
      isPrevBlockTemplatePart,
      canRemove: canRemoveBlock(clientId),
      canMove: canMoveBlock(clientId)
    };
  }, [clientId, rootClientId]);
  const {
    label,
    icon,
    blockMovingMode,
    editorMode,
    isBlockTemplatePart,
    isNextBlockTemplatePart,
    isPrevBlockTemplatePart,
    canRemove,
    canMove
  } = selected;
  const {
    setNavigationMode,
    removeBlock
  } = (0,use_dispatch/* default */.A)(store_store);
  const ref = (0,react.useRef)();

  // Focus the breadcrumb in navigation mode.
  (0,react.useEffect)(() => {
    if (editorMode === 'navigation') {
      ref.current.focus();
      (0,a11y_build_module/* speak */.L)(label);
    }
  }, [label, editorMode]);
  const blockElement = useBlockElement(clientId);
  const {
    hasBlockMovingClientId,
    getBlockIndex,
    getBlockRootClientId,
    getClientIdsOfDescendants,
    getSelectedBlockClientId,
    getMultiSelectedBlocksEndClientId,
    getPreviousBlockClientId,
    getNextBlockClientId
  } = (0,use_select/* default */.A)(store_store);
  const {
    selectBlock,
    clearSelectedBlock,
    setBlockMovingClientId,
    moveBlockToPosition
  } = (0,use_dispatch/* default */.A)(store_store);
  function onKeyDown(event) {
    const {
      keyCode
    } = event;
    const isUp = keyCode === keycodes_build_module.UP;
    const isDown = keyCode === keycodes_build_module/* DOWN */.PX;
    const isLeft = keyCode === keycodes_build_module/* LEFT */.M3;
    const isRight = keyCode === keycodes_build_module/* RIGHT */.NS;
    const isTab = keyCode === keycodes_build_module/* TAB */.wn;
    const isEscape = keyCode === keycodes_build_module/* ESCAPE */._f;
    const isEnter = keyCode === keycodes_build_module/* ENTER */.Fm;
    const isSpace = keyCode === keycodes_build_module/* SPACE */.t6;
    const isShift = event.shiftKey;
    if (isEscape && editorMode === 'navigation') {
      setNavigationMode(false);
      event.preventDefault();
      return;
    }
    if (keyCode === keycodes_build_module/* BACKSPACE */.G_ || keyCode === keycodes_build_module/* DELETE */.SJ) {
      removeBlock(clientId);
      event.preventDefault();
      return;
    }
    const selectedBlockClientId = getSelectedBlockClientId();
    const selectionEndClientId = getMultiSelectedBlocksEndClientId();
    const selectionBeforeEndClientId = getPreviousBlockClientId(selectionEndClientId || selectedBlockClientId);
    const selectionAfterEndClientId = getNextBlockClientId(selectionEndClientId || selectedBlockClientId);
    const navigateUp = isTab && isShift || isUp;
    const navigateDown = isTab && !isShift || isDown;
    // Move out of current nesting level (no effect if at root level).
    const navigateOut = isLeft;
    // Move into next nesting level (no effect if the current block has no innerBlocks).
    const navigateIn = isRight;
    let focusedBlockUid;
    if (navigateUp) {
      focusedBlockUid = selectionBeforeEndClientId;
    } else if (navigateDown) {
      focusedBlockUid = selectionAfterEndClientId;
    } else if (navigateOut) {
      var _getBlockRootClientId;
      focusedBlockUid = (_getBlockRootClientId = getBlockRootClientId(selectedBlockClientId)) !== null && _getBlockRootClientId !== void 0 ? _getBlockRootClientId : selectedBlockClientId;
    } else if (navigateIn) {
      var _getClientIdsOfDescen;
      focusedBlockUid = (_getClientIdsOfDescen = getClientIdsOfDescendants(selectedBlockClientId)[0]) !== null && _getClientIdsOfDescen !== void 0 ? _getClientIdsOfDescen : selectedBlockClientId;
    }
    const startingBlockClientId = hasBlockMovingClientId();
    if (isEscape && startingBlockClientId && !event.defaultPrevented) {
      setBlockMovingClientId(null);
      event.preventDefault();
    }
    if ((isEnter || isSpace) && startingBlockClientId) {
      const sourceRoot = getBlockRootClientId(startingBlockClientId);
      const destRoot = getBlockRootClientId(selectedBlockClientId);
      const sourceBlockIndex = getBlockIndex(startingBlockClientId);
      let destinationBlockIndex = getBlockIndex(selectedBlockClientId);
      if (sourceBlockIndex < destinationBlockIndex && sourceRoot === destRoot) {
        destinationBlockIndex -= 1;
      }
      moveBlockToPosition(startingBlockClientId, sourceRoot, destRoot, destinationBlockIndex);
      selectBlock(startingBlockClientId);
      setBlockMovingClientId(null);
    }
    // Prevent the block from being moved into itself.
    if (startingBlockClientId && selectedBlockClientId === startingBlockClientId && navigateIn) {
      return;
    }
    if (navigateDown || navigateUp || navigateOut || navigateIn) {
      if (focusedBlockUid) {
        event.preventDefault();
        selectBlock(focusedBlockUid);
      } else if (isTab && selectedBlockClientId) {
        let nextTabbable;
        if (navigateDown) {
          nextTabbable = blockElement;
          do {
            nextTabbable = dom_build_module/* focus */.XC.tabbable.findNext(nextTabbable);
          } while (nextTabbable && blockElement.contains(nextTabbable));
          if (!nextTabbable) {
            nextTabbable = blockElement.ownerDocument.defaultView.frameElement;
            nextTabbable = dom_build_module/* focus */.XC.tabbable.findNext(nextTabbable);
          }
        } else {
          nextTabbable = dom_build_module/* focus */.XC.tabbable.findPrevious(blockElement);
        }
        if (nextTabbable) {
          event.preventDefault();
          nextTabbable.focus();
          clearSelectedBlock();
        }
      }
    }
  }
  const classNames = (0,dist_clsx/* default */.A)('block-editor-block-list__block-selection-button', {
    'is-block-moving-mode': !!blockMovingMode
  });
  const dragHandleLabel = (0,i18n_build_module.__)('Drag');
  const showBlockDraggable = canMove && editorMode === 'navigation' || editorMode === 'zoom-out' && canMove && !isBlockTemplatePart;
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    className: classNames,
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)(flex_component/* default */.A, {
      justify: "center",
      className: "block-editor-block-list__block-selection-button__content",
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_icon, {
          icon: icon,
          showColors: true
        })
      }), showBlockDraggable && /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_draggable, {
          clientIds: [clientId],
          children: draggableProps => /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
            icon: drag_handle,
            className: "block-selection-button_drag-handle",
            "aria-hidden": "true",
            label: dragHandleLabel
            // Should not be able to tab to drag handle as this
            // button can only be used with a pointer device.
            ,
            tabIndex: "-1",
            ...draggableProps
          })
        })
      }), editorMode === 'zoom-out' && !isBlockTemplatePart && /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_mover, {
          clientIds: [clientId],
          hideDragHandle: true,
          isBlockMoverUpButtonDisabled: isPrevBlockTemplatePart,
          isBlockMoverDownButtonDisabled: isNextBlockTemplatePart
        })
      }), canMove && canRemove && editorMode === 'zoom-out' && /*#__PURE__*/(0,jsx_runtime.jsx)(Shuffle, {
        clientId: clientId,
        as: build_module_button/* default */.Ay
      }), canRemove && editorMode === 'zoom-out' && !isBlockTemplatePart && /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(toolbar_button/* default */.A, {
          icon: library_trash,
          label: "Delete",
          onClick: () => {
            removeBlock(clientId);
          }
        })
      }), editorMode === 'navigation' && /*#__PURE__*/(0,jsx_runtime.jsx)(flex_item_component/* default */.A, {
        children: /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
          ref: ref,
          onClick: editorMode === 'navigation' ? () => setNavigationMode(false) : undefined,
          onKeyDown: onKeyDown,
          label: label,
          showTooltip: false,
          className: "block-selection-button_select-button",
          children: /*#__PURE__*/(0,jsx_runtime.jsx)(BlockTitle, {
            clientId: clientId,
            maximumLength: 35
          })
        })
      })]
    })
  });
}
/* harmony default export */ const block_selection_button = (BlockSelectionButton);
//# sourceMappingURL=block-selection-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/block-toolbar-breadcrumb.js
/**
 * External dependencies
 */


/**
 * Internal dependencies
 */





function BlockToolbarBreadcrumb({
  clientId,
  __unstableContentRef
}) {
  const {
    capturingClientId,
    isInsertionPointVisible,
    lastClientId,
    rootClientId
  } = useSelectedBlockToolProps(clientId);
  const popoverProps = useBlockToolbarPopoverProps({
    contentElement: __unstableContentRef?.current,
    clientId
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(PrivateBlockPopover, {
    clientId: capturingClientId || clientId,
    bottomClientId: lastClientId,
    className: (0,dist_clsx/* default */.A)('block-editor-block-list__block-popover', {
      'is-insertion-point-visible': isInsertionPointVisible
    }),
    resize: false,
    ...popoverProps,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(block_selection_button, {
      clientId: clientId,
      rootClientId: rootClientId
    })
  });
}
//# sourceMappingURL=block-toolbar-breadcrumb.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/zoom-out-mode-inserters.js
/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */





function ZoomOutModeInserters() {
  const [isReady, setIsReady] = (0,react.useState)(false);
  const {
    blockOrder,
    sectionRootClientId,
    insertionPoint,
    setInserterIsOpened,
    selectedSection
  } = (0,use_select/* default */.A)(select => {
    const {
      getSettings,
      getBlockOrder
    } = select(store_store);
    const {
      sectionRootClientId: root
    } = lock_unlock_unlock(getSettings());
    // To do: move ZoomOutModeInserters to core/editor.
    // Or we perhaps we should move the insertion point state to the
    // block-editor store. I'm not sure what it was ever moved to the editor
    // store, because all the inserter components all live in the
    // block-editor package.
    // eslint-disable-next-line @wordpress/data-no-store-string-literals
    const editor = select('core/editor');
    return {
      selectedSection: editor.getSelectedBlock(),
      blockOrder: getBlockOrder(root),
      insertionPoint: lock_unlock_unlock(editor).getInsertionPoint(),
      sectionRootClientId: root,
      setInserterIsOpened: getSettings().__experimentalSetIsInserterOpened
    };
  }, []);
  const isMounted = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    if (!isMounted.current) {
      isMounted.current = true;
      return;
    }
    // reset insertion point when the block order changes
    setInserterIsOpened(true);
  }, [blockOrder, setInserterIsOpened]);

  // Defer the initial rendering to avoid the jumps due to the animation.
  (0,react.useEffect)(() => {
    const timeout = setTimeout(() => {
      setIsReady(true);
    }, 500);
    return () => {
      clearTimeout(timeout);
    };
  }, []);
  if (!isReady || !selectedSection) {
    return null;
  }
  return [undefined, ...blockOrder].map((clientId, index) => {
    return /*#__PURE__*/(0,jsx_runtime.jsxs)(inbetween, {
      previousClientId: clientId,
      nextClientId: blockOrder[index],
      children: [insertionPoint.insertionIndex === index && /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
        style: {
          borderRadius: '0',
          height: '12px',
          opacity: 1,
          transform: 'translateY(-50%)',
          width: '100%'
        },
        className: "block-editor-block-list__insertion-point-indicator"
      }), insertionPoint.insertionIndex !== index && /*#__PURE__*/(0,jsx_runtime.jsx)(build_module_button/* default */.Ay, {
        variant: "primary",
        icon: plus/* default */.A,
        size: "compact",
        className: "block-editor-button-pattern-inserter__button",
        onClick: () => {
          setInserterIsOpened({
            rootClientId: sectionRootClientId,
            insertionIndex: index,
            tab: 'patterns',
            category: 'all'
          });
        },
        label: (0,i18n_build_module._x)('Add pattern', 'Generic label for pattern inserter button')
      })]
    }, index);
  });
}
/* harmony default export */ const zoom_out_mode_inserters = (ZoomOutModeInserters);
//# sourceMappingURL=zoom-out-mode-inserters.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/use-show-block-tools.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Source of truth for which block tools are showing in the block editor.
 *
 * @return {Object} Object of which block tools will be shown.
 */
function useShowBlockTools() {
  return (0,use_select/* default */.A)(select => {
    const {
      getSelectedBlockClientId,
      getFirstMultiSelectedBlockClientId,
      getBlock,
      getSettings,
      hasMultiSelection,
      __unstableGetEditorMode,
      isTyping
    } = select(store_store);
    const clientId = getSelectedBlockClientId() || getFirstMultiSelectedBlockClientId();
    const block = getBlock(clientId) || {
      name: '',
      attributes: {}
    };
    const editorMode = __unstableGetEditorMode();
    const hasSelectedBlock = clientId && block?.name;
    const isEmptyDefaultBlock = (0,build_module/* isUnmodifiedDefaultBlock */.Xw)(block);
    const _showEmptyBlockSideInserter = clientId && !isTyping() && editorMode === 'edit' && isEmptyDefaultBlock;
    const maybeShowBreadcrumb = hasSelectedBlock && !hasMultiSelection() && (editorMode === 'navigation' || editorMode === 'zoom-out');
    return {
      showEmptyBlockSideInserter: _showEmptyBlockSideInserter,
      showBreadcrumb: !_showEmptyBlockSideInserter && maybeShowBreadcrumb,
      showBlockToolbarPopover: !getSettings().hasFixedToolbar && !_showEmptyBlockSideInserter && hasSelectedBlock && !isEmptyDefaultBlock && !maybeShowBreadcrumb
    };
  }, []);
}
//# sourceMappingURL=use-show-block-tools.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/block-tools/index.js
/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */











function block_tools_selector(select) {
  const {
    getSelectedBlockClientId,
    getFirstMultiSelectedBlockClientId,
    getSettings,
    __unstableGetEditorMode,
    isTyping
  } = select(store_store);
  const clientId = getSelectedBlockClientId() || getFirstMultiSelectedBlockClientId();
  const editorMode = __unstableGetEditorMode();
  return {
    clientId,
    hasFixedToolbar: getSettings().hasFixedToolbar,
    isTyping: isTyping(),
    isZoomOutMode: editorMode === 'zoom-out'
  };
}

/**
 * Renders block tools (the block toolbar, select/navigation mode toolbar, the
 * insertion point and a slot for the inline rich text toolbar). Must be wrapped
 * around the block content and editor styles wrapper or iframe.
 *
 * @param {Object} $0                      Props.
 * @param {Object} $0.children             The block content and style container.
 * @param {Object} $0.__unstableContentRef Ref holding the content scroll container.
 */
function BlockTools({
  children,
  __unstableContentRef,
  ...props
}) {
  const {
    clientId,
    hasFixedToolbar,
    isTyping,
    isZoomOutMode
  } = (0,use_select/* default */.A)(block_tools_selector, []);
  const isMatch = (0,keyboard_shortcuts_build_module/* __unstableUseShortcutEventMatch */.ZK)();
  const {
    getBlocksByClientId,
    getSelectedBlockClientIds,
    getBlockRootClientId,
    isGroupable
  } = (0,use_select/* default */.A)(store_store);
  const {
    getGroupingBlockName
  } = (0,use_select/* default */.A)(build_module/* store */.M_);
  const {
    showEmptyBlockSideInserter,
    showBreadcrumb,
    showBlockToolbarPopover
  } = useShowBlockTools();
  const {
    duplicateBlocks,
    removeBlocks,
    replaceBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    selectBlock,
    moveBlocksUp,
    moveBlocksDown,
    expandBlock
  } = lock_unlock_unlock((0,use_dispatch/* default */.A)(store_store));
  function onKeyDown(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (isMatch('core/block-editor/move-up', event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        const rootClientId = getBlockRootClientId(clientIds[0]);
        moveBlocksUp(clientIds, rootClientId);
      }
    } else if (isMatch('core/block-editor/move-down', event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        const rootClientId = getBlockRootClientId(clientIds[0]);
        moveBlocksDown(clientIds, rootClientId);
      }
    } else if (isMatch('core/block-editor/duplicate', event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        duplicateBlocks(clientIds);
      }
    } else if (isMatch('core/block-editor/remove', event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        removeBlocks(clientIds);
      }
    } else if (isMatch('core/block-editor/insert-after', event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        insertAfterBlock(clientIds[clientIds.length - 1]);
      }
    } else if (isMatch('core/block-editor/insert-before', event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        insertBeforeBlock(clientIds[0]);
      }
    } else if (isMatch('core/block-editor/unselect', event)) {
      if (event.target.closest('[role=toolbar]')) {
        // This shouldn't be necessary, but we have a combination of a few things all combining to create a situation where:
        // - Because the block toolbar uses createPortal to populate the block toolbar fills, we can't rely on the React event bubbling to hit the onKeyDown listener for the block toolbar
        // - Since we can't use the React tree, we use the DOM tree which _should_ handle the event bubbling correctly from a `createPortal` element.
        // - This bubbles via the React tree, which hits this `unselect` escape keypress before the block toolbar DOM event listener has access to it.
        // An alternative would be to remove the addEventListener on the navigableToolbar and use this event to handle it directly right here. That feels hacky too though.
        return;
      }
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length > 1) {
        event.preventDefault();
        // If there is more than one block selected, select the first
        // block so that focus is directed back to the beginning of the selection.
        // In effect, to the user this feels like deselecting the multi-selection.
        selectBlock(clientIds[0]);
      }
    } else if (isMatch('core/block-editor/collapse-list-view', event)) {
      // If focus is currently within a text field, such as a rich text block or other editable field,
      // skip collapsing the list view, and allow the keyboard shortcut to be handled by the text field.
      // This condition checks for both the active element and the active element within an iframed editor.
      if (isTextField(event.target) || isTextField(event.target?.contentWindow?.document?.activeElement)) {
        return;
      }
      event.preventDefault();
      expandBlock(clientId);
    } else if (isMatch('core/block-editor/group', event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length > 1 && isGroupable(clientIds)) {
        event.preventDefault();
        const blocks = getBlocksByClientId(clientIds);
        const groupingBlockName = getGroupingBlockName();
        const newBlocks = (0,build_module/* switchToBlockType */.bh)(blocks, groupingBlockName);
        replaceBlocks(clientIds, newBlocks);
        (0,a11y_build_module/* speak */.L)((0,i18n_build_module.__)('Selected blocks are grouped.'));
      }
    }
  }
  const blockToolbarRef = use_popover_scroll(__unstableContentRef);
  const blockToolbarAfterRef = use_popover_scroll(__unstableContentRef);
  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    (0,jsx_runtime.jsx)("div", {
      ...props,
      onKeyDown: onKeyDown,
      children: /*#__PURE__*/(0,jsx_runtime.jsxs)(insertion_point_InsertionPointOpenRef.Provider, {
        value: (0,react.useRef)(false),
        children: [!isTyping && /*#__PURE__*/(0,jsx_runtime.jsx)(InsertionPoint, {
          __unstableContentRef: __unstableContentRef
        }), showEmptyBlockSideInserter && /*#__PURE__*/(0,jsx_runtime.jsx)(EmptyBlockInserter, {
          __unstableContentRef: __unstableContentRef,
          clientId: clientId
        }), showBlockToolbarPopover && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockToolbarPopover, {
          __unstableContentRef: __unstableContentRef,
          clientId: clientId,
          isTyping: isTyping
        }), showBreadcrumb && /*#__PURE__*/(0,jsx_runtime.jsx)(BlockToolbarBreadcrumb, {
          __unstableContentRef: __unstableContentRef,
          clientId: clientId
        }), !isZoomOutMode && !hasFixedToolbar && /*#__PURE__*/(0,jsx_runtime.jsx)(popover/* default */.Ay.Slot, {
          name: "block-toolbar",
          ref: blockToolbarRef
        }), children, /*#__PURE__*/(0,jsx_runtime.jsx)(popover/* default */.Ay.Slot, {
          name: "__unstable-block-tools-after",
          ref: blockToolbarAfterRef
        }), window.__experimentalEnableZoomedOutPatternsTab && isZoomOutMode && /*#__PURE__*/(0,jsx_runtime.jsx)(zoom_out_mode_inserters, {
          __unstableContentRef: __unstableContentRef
        })]
      })
    })
  );
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/components/index.js
/*
 * Block Creation Components
 */






































































/*
 * Content Related Components
 */








































/*
 * State Related Components
 */





/*
 * The following rename hint component can be removed in 6.4.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@13.0.7_@emotion+is-prop-valid@1.2.1_@types+react-dom@18.3.0_@types+re_fvtonh2j4ga2gghni5ladu3cc4/node_modules/@wordpress/block-editor/build-module/index.js
/**
 * Internal dependencies
 */








//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  dB: () => (/* reexport */ __EXPERIMENTAL_ELEMENTS),
  G8: () => (/* reexport */ __EXPERIMENTAL_PATHS_WITH_OVERRIDE),
  RY: () => (/* reexport */ __EXPERIMENTAL_STYLE_PROPERTY),
  Eb: () => (/* reexport */ __experimentalCloneSanitizedBlock),
  wZ: () => (/* reexport */ getAccessibleBlockLabel),
  GJ: () => (/* reexport */ __experimentalGetBlockAttributesNamesByRole),
  Y0: () => (/* reexport */ getBlockLabel),
  cV: () => (/* reexport */ getBlockProps),
  v9: () => (/* reexport */ getInnerBlocksProps),
  JB: () => (/* reexport */ cloneBlock),
  Wv: () => (/* reexport */ createBlock),
  to: () => (/* reexport */ createBlocksFromInnerBlocksTemplate),
  V6: () => (/* reexport */ doBlocksMatchTemplate),
  wG: () => (/* reexport */ findTransform),
  Ph: () => (/* reexport */ getBlockAttributes),
  F8: () => (/* reexport */ getBlockInnerHTML),
  KW: () => (/* reexport */ getBlockDefaultClassName),
  KL: () => (/* reexport */ getBlockFromExample),
  HK: () => (/* reexport */ getBlockMenuDefaultClassName),
  bI: () => (/* reexport */ getBlockSupport),
  XD: () => (/* reexport */ getBlockTransforms),
  E7: () => (/* reexport */ getBlockType),
  li: () => (/* reexport */ getBlockTypes),
  oO: () => (/* reexport */ getBlockVariations),
  K$: () => (/* reexport */ getDefaultBlockName),
  Fk: () => (/* reexport */ getPossibleBlockTransformations),
  Z9: () => (/* reexport */ getSaveContent),
  pN: () => (/* reexport */ hasBlockSupport),
  tk: () => (/* reexport */ isReusableBlock),
  gc: () => (/* reexport */ isTemplatePart),
  C5: () => (/* reexport */ isUnmodifiedBlock),
  Xw: () => (/* reexport */ utils_isUnmodifiedDefaultBlock),
  qg: () => (/* reexport */ parser_parse),
  Gk: () => (/* reexport */ pasteHandler),
  lh: () => (/* reexport */ rawHandler),
  lK: () => (/* reexport */ serializer_serialize),
  Kx: () => (/* reexport */ serializeRawBlock),
  M_: () => (/* reexport */ store),
  bh: () => (/* reexport */ switchToBlockType),
  Nk: () => (/* reexport */ synchronizeBlocksWithTemplate),
  YV: () => (/* reexport */ validateBlock)
});

// UNUSED EXPORTS: __experimentalSanitizeBlockAttributes, __unstableSerializeAndClean, children, getCategories, getChildBlockNames, getFreeformContentHandlerName, getGroupingBlockName, getPhrasingContentSchema, getSaveElement, getUnregisteredTypeHandlerName, hasChildBlocks, hasChildBlocksWithInserterSupport, isValidBlockContent, isValidIcon, node, normalizeIconObject, parseWithAttributeSchema, registerBlockCollection, registerBlockStyle, registerBlockType, registerBlockVariation, setCategories, setDefaultBlockName, setFreeformContentHandlerName, setGroupingBlockName, setUnregisteredTypeHandlerName, unregisterBlockStyle, unregisterBlockType, unregisterBlockVariation, unstable__bootstrapServerSideBlockDefinitions, updateCategory, withBlockContentContext

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/selectors.js
var selectors_namespaceObject = {};
__webpack_require__.r(selectors_namespaceObject);
__webpack_require__.d(selectors_namespaceObject, {
  __experimentalHasContentRoleAttribute: () => (__experimentalHasContentRoleAttribute),
  getActiveBlockVariation: () => (getActiveBlockVariation),
  getBlockStyles: () => (getBlockStyles),
  getBlockSupport: () => (selectors_getBlockSupport),
  getBlockType: () => (selectors_getBlockType),
  getBlockTypes: () => (selectors_getBlockTypes),
  getBlockVariations: () => (selectors_getBlockVariations),
  getCategories: () => (getCategories),
  getChildBlockNames: () => (selectors_getChildBlockNames),
  getCollections: () => (getCollections),
  getDefaultBlockName: () => (selectors_getDefaultBlockName),
  getDefaultBlockVariation: () => (getDefaultBlockVariation),
  getFreeformFallbackBlockName: () => (getFreeformFallbackBlockName),
  getGroupingBlockName: () => (selectors_getGroupingBlockName),
  getUnregisteredFallbackBlockName: () => (getUnregisteredFallbackBlockName),
  hasBlockSupport: () => (selectors_hasBlockSupport),
  hasChildBlocks: () => (selectors_hasChildBlocks),
  hasChildBlocksWithInserterSupport: () => (selectors_hasChildBlocksWithInserterSupport),
  isMatchingSearchTerm: () => (isMatchingSearchTerm)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/private-selectors.js
var private_selectors_namespaceObject = {};
__webpack_require__.r(private_selectors_namespaceObject);
__webpack_require__.d(private_selectors_namespaceObject, {
  getAllBlockBindingsSources: () => (getAllBlockBindingsSources),
  getBlockBindingsSource: () => (getBlockBindingsSource),
  getBootstrappedBlockType: () => (getBootstrappedBlockType),
  getSupportedStyles: () => (getSupportedStyles),
  getUnprocessedBlockTypes: () => (getUnprocessedBlockTypes)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/actions.js
var actions_namespaceObject = {};
__webpack_require__.r(actions_namespaceObject);
__webpack_require__.d(actions_namespaceObject, {
  __experimentalReapplyBlockFilters: () => (__experimentalReapplyBlockFilters),
  addBlockCollection: () => (addBlockCollection),
  addBlockStyles: () => (addBlockStyles),
  addBlockTypes: () => (addBlockTypes),
  addBlockVariations: () => (addBlockVariations),
  reapplyBlockTypeFilters: () => (reapplyBlockTypeFilters),
  removeBlockCollection: () => (removeBlockCollection),
  removeBlockStyles: () => (removeBlockStyles),
  removeBlockTypes: () => (removeBlockTypes),
  removeBlockVariations: () => (removeBlockVariations),
  setCategories: () => (setCategories),
  setDefaultBlockName: () => (actions_setDefaultBlockName),
  setFreeformFallbackBlockName: () => (setFreeformFallbackBlockName),
  setGroupingBlockName: () => (actions_setGroupingBlockName),
  setUnregisteredFallbackBlockName: () => (setUnregisteredFallbackBlockName),
  updateCategory: () => (updateCategory)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/private-actions.js
var private_actions_namespaceObject = {};
__webpack_require__.r(private_actions_namespaceObject);
__webpack_require__.d(private_actions_namespaceObject, {
  addBootstrappedBlockType: () => (addBootstrappedBlockType),
  addUnprocessedBlockType: () => (addUnprocessedBlockType),
  registerBlockBindingsSource: () => (registerBlockBindingsSource)
});

// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/redux-store/index.js + 18 modules
var redux_store = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/redux-store/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/index.js
var build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/camel-case@4.1.2/node_modules/camel-case/dist.es2015/index.js
var dist_es2015 = __webpack_require__("../../node_modules/.pnpm/camel-case@4.1.2/node_modules/camel-case/dist.es2015/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+i18n@5.0.1/node_modules/@wordpress/i18n/build-module/index.js + 3 modules
var i18n_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+i18n@5.0.1/node_modules/@wordpress/i18n/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/index.mjs
var colord = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/index.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/names.mjs
var names = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/names.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs
var a11y = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/strip-html.js
var strip_html = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/strip-html.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@7.0.2_react@18.3.1/node_modules/@wordpress/rich-text/build-module/index.js + 17 modules
var rich_text_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+rich-text@7.0.2_react@18.3.1/node_modules/@wordpress/rich-text/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/constants.js
const BLOCK_ICON_DEFAULT = 'block-default';

/**
 * Array of valid keys in a block type settings deprecation object.
 *
 * @type {string[]}
 */
const DEPRECATED_ENTRY_KEYS = ['attributes', 'supports', 'save', 'migrate', 'isEligible', 'apiVersion'];
const __EXPERIMENTAL_STYLE_PROPERTY = {
  // Kept for back-compatibility purposes.
  '--wp--style--color--link': {
    value: ['color', 'link'],
    support: ['color', 'link']
  },
  aspectRatio: {
    value: ['dimensions', 'aspectRatio'],
    support: ['dimensions', 'aspectRatio'],
    useEngine: true
  },
  background: {
    value: ['color', 'gradient'],
    support: ['color', 'gradients'],
    useEngine: true
  },
  backgroundColor: {
    value: ['color', 'background'],
    support: ['color', 'background'],
    requiresOptOut: true,
    useEngine: true
  },
  backgroundImage: {
    value: ['background', 'backgroundImage'],
    support: ['background', 'backgroundImage'],
    useEngine: true
  },
  backgroundRepeat: {
    value: ['background', 'backgroundRepeat'],
    support: ['background', 'backgroundRepeat'],
    useEngine: true
  },
  backgroundSize: {
    value: ['background', 'backgroundSize'],
    support: ['background', 'backgroundSize'],
    useEngine: true
  },
  backgroundPosition: {
    value: ['background', 'backgroundPosition'],
    support: ['background', 'backgroundPosition'],
    useEngine: true
  },
  borderColor: {
    value: ['border', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderRadius: {
    value: ['border', 'radius'],
    support: ['__experimentalBorder', 'radius'],
    properties: {
      borderTopLeftRadius: 'topLeft',
      borderTopRightRadius: 'topRight',
      borderBottomLeftRadius: 'bottomLeft',
      borderBottomRightRadius: 'bottomRight'
    },
    useEngine: true
  },
  borderStyle: {
    value: ['border', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderWidth: {
    value: ['border', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  borderTopColor: {
    value: ['border', 'top', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderTopStyle: {
    value: ['border', 'top', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderTopWidth: {
    value: ['border', 'top', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  borderRightColor: {
    value: ['border', 'right', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderRightStyle: {
    value: ['border', 'right', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderRightWidth: {
    value: ['border', 'right', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  borderBottomColor: {
    value: ['border', 'bottom', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderBottomStyle: {
    value: ['border', 'bottom', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderBottomWidth: {
    value: ['border', 'bottom', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  borderLeftColor: {
    value: ['border', 'left', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderLeftStyle: {
    value: ['border', 'left', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderLeftWidth: {
    value: ['border', 'left', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  color: {
    value: ['color', 'text'],
    support: ['color', 'text'],
    requiresOptOut: true,
    useEngine: true
  },
  columnCount: {
    value: ['typography', 'textColumns'],
    support: ['typography', 'textColumns'],
    useEngine: true
  },
  filter: {
    value: ['filter', 'duotone'],
    support: ['filter', 'duotone']
  },
  linkColor: {
    value: ['elements', 'link', 'color', 'text'],
    support: ['color', 'link']
  },
  captionColor: {
    value: ['elements', 'caption', 'color', 'text'],
    support: ['color', 'caption']
  },
  buttonColor: {
    value: ['elements', 'button', 'color', 'text'],
    support: ['color', 'button']
  },
  buttonBackgroundColor: {
    value: ['elements', 'button', 'color', 'background'],
    support: ['color', 'button']
  },
  headingColor: {
    value: ['elements', 'heading', 'color', 'text'],
    support: ['color', 'heading']
  },
  headingBackgroundColor: {
    value: ['elements', 'heading', 'color', 'background'],
    support: ['color', 'heading']
  },
  fontFamily: {
    value: ['typography', 'fontFamily'],
    support: ['typography', '__experimentalFontFamily'],
    useEngine: true
  },
  fontSize: {
    value: ['typography', 'fontSize'],
    support: ['typography', 'fontSize'],
    useEngine: true
  },
  fontStyle: {
    value: ['typography', 'fontStyle'],
    support: ['typography', '__experimentalFontStyle'],
    useEngine: true
  },
  fontWeight: {
    value: ['typography', 'fontWeight'],
    support: ['typography', '__experimentalFontWeight'],
    useEngine: true
  },
  lineHeight: {
    value: ['typography', 'lineHeight'],
    support: ['typography', 'lineHeight'],
    useEngine: true
  },
  margin: {
    value: ['spacing', 'margin'],
    support: ['spacing', 'margin'],
    properties: {
      marginTop: 'top',
      marginRight: 'right',
      marginBottom: 'bottom',
      marginLeft: 'left'
    },
    useEngine: true
  },
  minHeight: {
    value: ['dimensions', 'minHeight'],
    support: ['dimensions', 'minHeight'],
    useEngine: true
  },
  padding: {
    value: ['spacing', 'padding'],
    support: ['spacing', 'padding'],
    properties: {
      paddingTop: 'top',
      paddingRight: 'right',
      paddingBottom: 'bottom',
      paddingLeft: 'left'
    },
    useEngine: true
  },
  textAlign: {
    value: ['typography', 'textAlign'],
    support: ['typography', 'textAlign'],
    useEngine: false
  },
  textDecoration: {
    value: ['typography', 'textDecoration'],
    support: ['typography', '__experimentalTextDecoration'],
    useEngine: true
  },
  textTransform: {
    value: ['typography', 'textTransform'],
    support: ['typography', '__experimentalTextTransform'],
    useEngine: true
  },
  letterSpacing: {
    value: ['typography', 'letterSpacing'],
    support: ['typography', '__experimentalLetterSpacing'],
    useEngine: true
  },
  writingMode: {
    value: ['typography', 'writingMode'],
    support: ['typography', '__experimentalWritingMode'],
    useEngine: true
  },
  '--wp--style--root--padding': {
    value: ['spacing', 'padding'],
    support: ['spacing', 'padding'],
    properties: {
      '--wp--style--root--padding-top': 'top',
      '--wp--style--root--padding-right': 'right',
      '--wp--style--root--padding-bottom': 'bottom',
      '--wp--style--root--padding-left': 'left'
    },
    rootOnly: true
  }
};
const __EXPERIMENTAL_ELEMENTS = {
  link: 'a:where(:not(.wp-element-button))',
  heading: 'h1, h2, h3, h4, h5, h6',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  button: '.wp-element-button, .wp-block-button__link',
  caption: '.wp-element-caption, .wp-block-audio figcaption, .wp-block-embed figcaption, .wp-block-gallery figcaption, .wp-block-image figcaption, .wp-block-table figcaption, .wp-block-video figcaption',
  cite: 'cite'
};

// These paths may have three origins, custom, theme, and default,
// and are expected to override other origins with custom, theme,
// and default priority.
const __EXPERIMENTAL_PATHS_WITH_OVERRIDE = {
  'color.duotone': true,
  'color.gradients': true,
  'color.palette': true,
  'dimensions.aspectRatios': true,
  'typography.fontSizes': true,
  'spacing.spacingSizes': true
};
//# sourceMappingURL=constants.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/select.js
var build_module_select = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/select.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/registration.js
/* eslint no-console: [ 'error', { allow: [ 'error', 'warn' ] } ] */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */
const i18nBlockSchema = {
  title: "block title",
  description: "block description",
  keywords: ["block keyword"],
  styles: [{
    label: "block style label"
  }],
  variations: [{
    title: "block variation title",
    description: "block variation description",
    keywords: ["block variation keyword"]
  }]
};



/**
 * An icon type definition. One of a Dashicon slug, an element,
 * or a component.
 *
 * @typedef {(string|Element|Component)} WPIcon
 *
 * @see https://developer.wordpress.org/resource/dashicons/
 */

/**
 * Render behavior of a block type icon; one of a Dashicon slug, an element,
 * or a component.
 *
 * @typedef {WPIcon} WPBlockTypeIconRender
 */

/**
 * An object describing a normalized block type icon.
 *
 * @typedef {Object} WPBlockTypeIconDescriptor
 *
 * @property {WPBlockTypeIconRender} src         Render behavior of the icon,
 *                                               one of a Dashicon slug, an
 *                                               element, or a component.
 * @property {string}                background  Optimal background hex string
 *                                               color when displaying icon.
 * @property {string}                foreground  Optimal foreground hex string
 *                                               color when displaying icon.
 * @property {string}                shadowColor Optimal shadow hex string
 *                                               color when displaying icon.
 */

/**
 * Value to use to render the icon for a block type in an editor interface,
 * either a Dashicon slug, an element, a component, or an object describing
 * the icon.
 *
 * @typedef {(WPBlockTypeIconDescriptor|WPBlockTypeIconRender)} WPBlockTypeIcon
 */

/**
 * Named block variation scopes.
 *
 * @typedef {'block'|'inserter'|'transform'} WPBlockVariationScope
 */

/**
 * An object describing a variation defined for the block type.
 *
 * @typedef {Object} WPBlockVariation
 *
 * @property {string}                  name          The unique and machine-readable name.
 * @property {string}                  title         A human-readable variation title.
 * @property {string}                  [description] A detailed variation description.
 * @property {string}                  [category]    Block type category classification,
 *                                                   used in search interfaces to arrange
 *                                                   block types by category.
 * @property {WPIcon}                  [icon]        An icon helping to visualize the variation.
 * @property {boolean}                 [isDefault]   Indicates whether the current variation is
 *                                                   the default one. Defaults to `false`.
 * @property {Object}                  [attributes]  Values which override block attributes.
 * @property {Array[]}                 [innerBlocks] Initial configuration of nested blocks.
 * @property {Object}                  [example]     Example provides structured data for
 *                                                   the block preview. You can set to
 *                                                   `undefined` to disable the preview shown
 *                                                   for the block type.
 * @property {WPBlockVariationScope[]} [scope]       The list of scopes where the variation
 *                                                   is applicable. When not provided, it
 *                                                   assumes all available scopes.
 * @property {string[]}                [keywords]    An array of terms (which can be translated)
 *                                                   that help users discover the variation
 *                                                   while searching.
 * @property {Function|string[]}       [isActive]    This can be a function or an array of block attributes.
 *                                                   Function that accepts a block's attributes and the
 *                                                   variation's attributes and determines if a variation is active.
 *                                                   This function doesn't try to find a match dynamically based
 *                                                   on all block's attributes, as in many cases some attributes are irrelevant.
 *                                                   An example would be for `embed` block where we only care
 *                                                   about `providerNameSlug` attribute's value.
 *                                                   We can also use a `string[]` to tell which attributes
 *                                                   should be compared as a shorthand. Each attributes will
 *                                                   be matched and the variation will be active if all of them are matching.
 */

/**
 * Defined behavior of a block type.
 *
 * @typedef {Object} WPBlockType
 *
 * @property {string}             name          Block type's namespaced name.
 * @property {string}             title         Human-readable block type label.
 * @property {string}             [description] A detailed block type description.
 * @property {string}             [category]    Block type category classification,
 *                                              used in search interfaces to arrange
 *                                              block types by category.
 * @property {WPBlockTypeIcon}    [icon]        Block type icon.
 * @property {string[]}           [keywords]    Additional keywords to produce block
 *                                              type as result in search interfaces.
 * @property {Object}             [attributes]  Block type attributes.
 * @property {Component}          [save]        Optional component describing
 *                                              serialized markup structure of a
 *                                              block type.
 * @property {Component}          edit          Component rendering an element to
 *                                              manipulate the attributes of a block
 *                                              in the context of an editor.
 * @property {WPBlockVariation[]} [variations]  The list of block variations.
 * @property {Object}             [example]     Example provides structured data for
 *                                              the block preview. When not defined
 *                                              then no preview is shown.
 */

function isObject(object) {
  return object !== null && typeof object === 'object';
}

/**
 * Sets the server side block definition of blocks.
 *
 * @param {Object} definitions Server-side block definitions
 */
// eslint-disable-next-line camelcase
function unstable__bootstrapServerSideBlockDefinitions(definitions) {
  const {
    addBootstrappedBlockType
  } = unlock(dispatch(blocksStore));
  for (const [name, blockType] of Object.entries(definitions)) {
    addBootstrappedBlockType(name, blockType);
  }
}

/**
 * Gets block settings from metadata loaded from `block.json` file.
 *
 * @param {Object} metadata            Block metadata loaded from `block.json`.
 * @param {string} metadata.textdomain Textdomain to use with translations.
 *
 * @return {Object} Block settings.
 */
function getBlockSettingsFromMetadata({
  textdomain,
  ...metadata
}) {
  const allowedFields = ['apiVersion', 'title', 'category', 'parent', 'ancestor', 'icon', 'description', 'keywords', 'attributes', 'providesContext', 'usesContext', 'selectors', 'supports', 'styles', 'example', 'variations', 'blockHooks', 'allowedBlocks'];
  const settings = Object.fromEntries(Object.entries(metadata).filter(([key]) => allowedFields.includes(key)));
  if (textdomain) {
    Object.keys(i18nBlockSchema).forEach(key => {
      if (!settings[key]) {
        return;
      }
      settings[key] = translateBlockSettingUsingI18nSchema(i18nBlockSchema[key], settings[key], textdomain);
    });
  }
  return settings;
}

/**
 * Registers a new block provided a unique name and an object defining its
 * behavior. Once registered, the block is made available as an option to any
 * editor interface where blocks are implemented.
 *
 * For more in-depth information on registering a custom block see the
 * [Create a block tutorial](https://developer.wordpress.org/block-editor/getting-started/create-block/).
 *
 * @param {string|Object} blockNameOrMetadata Block type name or its metadata.
 * @param {Object}        settings            Block settings.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { registerBlockType } from '@wordpress/blocks'
 *
 * registerBlockType( 'namespace/block-name', {
 *     title: __( 'My First Block' ),
 *     edit: () => <div>{ __( 'Hello from the editor!' ) }</div>,
 *     save: () => <div>Hello from the saved content!</div>,
 * } );
 * ```
 *
 * @return {WPBlockType | undefined} The block, if it has been successfully registered;
 *                    otherwise `undefined`.
 */
function registerBlockType(blockNameOrMetadata, settings) {
  const name = isObject(blockNameOrMetadata) ? blockNameOrMetadata.name : blockNameOrMetadata;
  if (typeof name !== 'string') {
    console.error('Block names must be strings.');
    return;
  }
  if (!/^[a-z][a-z0-9-]*\/[a-z][a-z0-9-]*$/.test(name)) {
    console.error('Block names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-block');
    return;
  }
  if (select(blocksStore).getBlockType(name)) {
    console.error('Block "' + name + '" is already registered.');
    return;
  }
  const {
    addBootstrappedBlockType,
    addUnprocessedBlockType
  } = unlock(dispatch(blocksStore));
  if (isObject(blockNameOrMetadata)) {
    const metadata = getBlockSettingsFromMetadata(blockNameOrMetadata);
    addBootstrappedBlockType(name, metadata);
  }
  addUnprocessedBlockType(name, settings);
  return select(blocksStore).getBlockType(name);
}

/**
 * Translates block settings provided with metadata using the i18n schema.
 *
 * @param {string|string[]|Object[]} i18nSchema   I18n schema for the block setting.
 * @param {string|string[]|Object[]} settingValue Value for the block setting.
 * @param {string}                   textdomain   Textdomain to use with translations.
 *
 * @return {string|string[]|Object[]} Translated setting.
 */
function translateBlockSettingUsingI18nSchema(i18nSchema, settingValue, textdomain) {
  if (typeof i18nSchema === 'string' && typeof settingValue === 'string') {
    // eslint-disable-next-line @wordpress/i18n-no-variables, @wordpress/i18n-text-domain
    return _x(settingValue, i18nSchema, textdomain);
  }
  if (Array.isArray(i18nSchema) && i18nSchema.length && Array.isArray(settingValue)) {
    return settingValue.map(value => translateBlockSettingUsingI18nSchema(i18nSchema[0], value, textdomain));
  }
  if (isObject(i18nSchema) && Object.entries(i18nSchema).length && isObject(settingValue)) {
    return Object.keys(settingValue).reduce((accumulator, key) => {
      if (!i18nSchema[key]) {
        accumulator[key] = settingValue[key];
        return accumulator;
      }
      accumulator[key] = translateBlockSettingUsingI18nSchema(i18nSchema[key], settingValue[key], textdomain);
      return accumulator;
    }, {});
  }
  return settingValue;
}

/**
 * Registers a new block collection to group blocks in the same namespace in the inserter.
 *
 * @param {string} namespace       The namespace to group blocks by in the inserter; corresponds to the block namespace.
 * @param {Object} settings        The block collection settings.
 * @param {string} settings.title  The title to display in the block inserter.
 * @param {Object} [settings.icon] The icon to display in the block inserter.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { registerBlockCollection, registerBlockType } from '@wordpress/blocks';
 *
 * // Register the collection.
 * registerBlockCollection( 'my-collection', {
 *     title: __( 'Custom Collection' ),
 * } );
 *
 * // Register a block in the same namespace to add it to the collection.
 * registerBlockType( 'my-collection/block-name', {
 *     title: __( 'My First Block' ),
 *     edit: () => <div>{ __( 'Hello from the editor!' ) }</div>,
 *     save: () => <div>'Hello from the saved content!</div>,
 * } );
 * ```
 */
function registerBlockCollection(namespace, {
  title,
  icon
}) {
  dispatch(blocksStore).addBlockCollection(namespace, title, icon);
}

/**
 * Unregisters a block collection
 *
 * @param {string} namespace The namespace to group blocks by in the inserter; corresponds to the block namespace
 *
 * @example
 * ```js
 * import { unregisterBlockCollection } from '@wordpress/blocks';
 *
 * unregisterBlockCollection( 'my-collection' );
 * ```
 */
function unregisterBlockCollection(namespace) {
  dispatch(blocksStore).removeBlockCollection(namespace);
}

/**
 * Unregisters a block.
 *
 * @param {string} name Block name.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { unregisterBlockType } from '@wordpress/blocks';
 *
 * const ExampleComponent = () => {
 *     return (
 *         <Button
 *             onClick={ () =>
 *                 unregisterBlockType( 'my-collection/block-name' )
 *             }
 *         >
 *             { __( 'Unregister my custom block.' ) }
 *         </Button>
 *     );
 * };
 * ```
 *
 * @return {WPBlockType | undefined} The previous block value, if it has been successfully
 *                    unregistered; otherwise `undefined`.
 */
function unregisterBlockType(name) {
  const oldBlock = select(blocksStore).getBlockType(name);
  if (!oldBlock) {
    console.error('Block "' + name + '" is not registered.');
    return;
  }
  dispatch(blocksStore).removeBlockTypes(name);
  return oldBlock;
}

/**
 * Assigns name of block for handling non-block content.
 *
 * @param {string} blockName Block name.
 */
function setFreeformContentHandlerName(blockName) {
  dispatch(blocksStore).setFreeformFallbackBlockName(blockName);
}

/**
 * Retrieves name of block handling non-block content, or undefined if no
 * handler has been defined.
 *
 * @return {?string} Block name.
 */
function registration_getFreeformContentHandlerName() {
  return (0,build_module_select/* select */.L)(store).getFreeformFallbackBlockName();
}

/**
 * Retrieves name of block used for handling grouping interactions.
 *
 * @return {?string} Block name.
 */
function getGroupingBlockName() {
  return (0,build_module_select/* select */.L)(store).getGroupingBlockName();
}

/**
 * Assigns name of block handling unregistered block types.
 *
 * @param {string} blockName Block name.
 */
function setUnregisteredTypeHandlerName(blockName) {
  dispatch(blocksStore).setUnregisteredFallbackBlockName(blockName);
}

/**
 * Retrieves name of block handling unregistered block types, or undefined if no
 * handler has been defined.
 *
 * @return {?string} Block name.
 */
function getUnregisteredTypeHandlerName() {
  return (0,build_module_select/* select */.L)(store).getUnregisteredFallbackBlockName();
}

/**
 * Assigns the default block name.
 *
 * @param {string} name Block name.
 *
 * @example
 * ```js
 * import { setDefaultBlockName } from '@wordpress/blocks';
 *
 * const ExampleComponent = () => {
 *
 *     return (
 *         <Button onClick={ () => setDefaultBlockName( 'core/heading' ) }>
 *             { __( 'Set the default block to Heading' ) }
 *         </Button>
 *     );
 * };
 * ```
 */
function setDefaultBlockName(name) {
  dispatch(blocksStore).setDefaultBlockName(name);
}

/**
 * Assigns name of block for handling block grouping interactions.
 *
 * This function lets you select a different block to group other blocks in instead of the
 * default `core/group` block. This function must be used in a component or when the DOM is fully
 * loaded. See https://developer.wordpress.org/block-editor/reference-guides/packages/packages-dom-ready/
 *
 * @param {string} name Block name.
 *
 * @example
 * ```js
 * import { setGroupingBlockName } from '@wordpress/blocks';
 *
 * const ExampleComponent = () => {
 *
 *     return (
 *         <Button onClick={ () => setGroupingBlockName( 'core/columns' ) }>
 *             { __( 'Wrap in columns' ) }
 *         </Button>
 *     );
 * };
 * ```
 */
function setGroupingBlockName(name) {
  dispatch(blocksStore).setGroupingBlockName(name);
}

/**
 * Retrieves the default block name.
 *
 * @return {?string} Block name.
 */
function getDefaultBlockName() {
  return (0,build_module_select/* select */.L)(store).getDefaultBlockName();
}

/**
 * Returns a registered block type.
 *
 * @param {string} name Block name.
 *
 * @return {?Object} Block type.
 */
function getBlockType(name) {
  return (0,build_module_select/* select */.L)(store)?.getBlockType(name);
}

/**
 * Returns all registered blocks.
 *
 * @return {Array} Block settings.
 */
function getBlockTypes() {
  return (0,build_module_select/* select */.L)(store).getBlockTypes();
}

/**
 * Returns the block support value for a feature, if defined.
 *
 * @param {(string|Object)} nameOrType      Block name or type object
 * @param {string}          feature         Feature to retrieve
 * @param {*}               defaultSupports Default value to return if not
 *                                          explicitly defined
 *
 * @return {?*} Block support value
 */
function getBlockSupport(nameOrType, feature, defaultSupports) {
  return (0,build_module_select/* select */.L)(store).getBlockSupport(nameOrType, feature, defaultSupports);
}

/**
 * Returns true if the block defines support for a feature, or false otherwise.
 *
 * @param {(string|Object)} nameOrType      Block name or type object.
 * @param {string}          feature         Feature to test.
 * @param {boolean}         defaultSupports Whether feature is supported by
 *                                          default if not explicitly defined.
 *
 * @return {boolean} Whether block supports feature.
 */
function hasBlockSupport(nameOrType, feature, defaultSupports) {
  return (0,build_module_select/* select */.L)(store).hasBlockSupport(nameOrType, feature, defaultSupports);
}

/**
 * Determines whether or not the given block is a reusable block. This is a
 * special block type that is used to point to a global block stored via the
 * API.
 *
 * @param {Object} blockOrType Block or Block Type to test.
 *
 * @return {boolean} Whether the given block is a reusable block.
 */
function isReusableBlock(blockOrType) {
  return blockOrType?.name === 'core/block';
}

/**
 * Determines whether or not the given block is a template part. This is a
 * special block type that allows composing a page template out of reusable
 * design elements.
 *
 * @param {Object} blockOrType Block or Block Type to test.
 *
 * @return {boolean} Whether the given block is a template part.
 */
function isTemplatePart(blockOrType) {
  return blockOrType?.name === 'core/template-part';
}

/**
 * Returns an array with the child blocks of a given block.
 *
 * @param {string} blockName Name of block (example: “latest-posts”).
 *
 * @return {Array} Array of child block names.
 */
const getChildBlockNames = blockName => {
  return select(blocksStore).getChildBlockNames(blockName);
};

/**
 * Returns a boolean indicating if a block has child blocks or not.
 *
 * @param {string} blockName Name of block (example: “latest-posts”).
 *
 * @return {boolean} True if a block contains child blocks and false otherwise.
 */
const hasChildBlocks = blockName => {
  return select(blocksStore).hasChildBlocks(blockName);
};

/**
 * Returns a boolean indicating if a block has at least one child block with inserter support.
 *
 * @param {string} blockName Block type name.
 *
 * @return {boolean} True if a block contains at least one child blocks with inserter support
 *                   and false otherwise.
 */
const hasChildBlocksWithInserterSupport = blockName => {
  return select(blocksStore).hasChildBlocksWithInserterSupport(blockName);
};

/**
 * Registers a new block style for the given block types.
 *
 * For more information on connecting the styles with CSS
 * [the official documentation](https://developer.wordpress.org/block-editor/reference-guides/block-api/block-styles/#styles).
 *
 * @param {string|Array} blockNames     Name of blocks e.g. “core/latest-posts” or `["core/group", "core/columns"]`.
 * @param {Object}       styleVariation Object containing `name` which is the class name applied to the block and `label` which identifies the variation to the user.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { registerBlockStyle } from '@wordpress/blocks';
 * import { Button } from '@wordpress/components';
 *
 *
 * const ExampleComponent = () => {
 *     return (
 *         <Button
 *             onClick={ () => {
 *                 registerBlockStyle( 'core/quote', {
 *                     name: 'fancy-quote',
 *                     label: __( 'Fancy Quote' ),
 *                 } );
 *             } }
 *         >
 *             { __( 'Add a new block style for core/quote' ) }
 *         </Button>
 *     );
 * };
 * ```
 */
const registerBlockStyle = (blockNames, styleVariation) => {
  dispatch(blocksStore).addBlockStyles(blockNames, styleVariation);
};

/**
 * Unregisters a block style for the given block.
 *
 * @param {string} blockName          Name of block (example: “core/latest-posts”).
 * @param {string} styleVariationName Name of class applied to the block.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { unregisterBlockStyle } from '@wordpress/blocks';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     return (
 *     <Button
 *         onClick={ () => {
 *             unregisterBlockStyle( 'core/quote', 'plain' );
 *         } }
 *     >
 *         { __( 'Remove the "Plain" block style for core/quote' ) }
 *     </Button>
 *     );
 * };
 * ```
 */
const unregisterBlockStyle = (blockName, styleVariationName) => {
  dispatch(blocksStore).removeBlockStyles(blockName, styleVariationName);
};

/**
 * Returns an array with the variations of a given block type.
 * Ignored from documentation as the recommended usage is via useSelect from @wordpress/data.
 *
 * @ignore
 *
 * @param {string}                blockName Name of block (example: “core/columns”).
 * @param {WPBlockVariationScope} [scope]   Block variation scope name.
 *
 * @return {(WPBlockVariation[]|void)} Block variations.
 */
const getBlockVariations = (blockName, scope) => {
  return (0,build_module_select/* select */.L)(store).getBlockVariations(blockName, scope);
};

/**
 * Registers a new block variation for the given block type.
 *
 * For more information on block variations see
 * [the official documentation ](https://developer.wordpress.org/block-editor/reference-guides/block-api/block-variations/).
 *
 * @param {string}           blockName Name of the block (example: “core/columns”).
 * @param {WPBlockVariation} variation Object describing a block variation.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { registerBlockVariation } from '@wordpress/blocks';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     return (
 *         <Button
 *             onClick={ () => {
 *                 registerBlockVariation( 'core/embed', {
 *                     name: 'custom',
 *                     title: __( 'My Custom Embed' ),
 *                     attributes: { providerNameSlug: 'custom' },
 *                 } );
 *             } }
 *          >
 *              __( 'Add a custom variation for core/embed' ) }
 *         </Button>
 *     );
 * };
 * ```
 */
const registerBlockVariation = (blockName, variation) => {
  if (typeof variation.name !== 'string') {
    console.warn('Variation names must be unique strings.');
  }
  dispatch(blocksStore).addBlockVariations(blockName, variation);
};

/**
 * Unregisters a block variation defined for the given block type.
 *
 * @param {string} blockName     Name of the block (example: “core/columns”).
 * @param {string} variationName Name of the variation defined for the block.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { unregisterBlockVariation } from '@wordpress/blocks';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     return (
 *         <Button
 *             onClick={ () => {
 *                 unregisterBlockVariation( 'core/embed', 'youtube' );
 *             } }
 *         >
 *             { __( 'Remove the YouTube variation from core/embed' ) }
 *         </Button>
 *     );
 * };
 * ```
 */
const unregisterBlockVariation = (blockName, variationName) => {
  dispatch(blocksStore).removeBlockVariations(blockName, variationName);
};
//# sourceMappingURL=registration.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/utils.js
/**
 * External dependencies
 */




/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


(0,colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);

/**
 * Array of icon colors containing a color to be used if the icon color
 * was not explicitly set but the icon background color was.
 *
 * @type {Object}
 */
const ICON_COLORS = ['#191e23', '#f8f9f9'];

/**
 * Determines whether the block's attributes are equal to the default attributes
 * which means the block is unmodified.
 *
 * @param {WPBlock} block Block Object
 *
 * @return {boolean} Whether the block is an unmodified block.
 */
function isUnmodifiedBlock(block) {
  var _getBlockType$attribu;
  return Object.entries((_getBlockType$attribu = getBlockType(block.name)?.attributes) !== null && _getBlockType$attribu !== void 0 ? _getBlockType$attribu : {}).every(([key, definition]) => {
    const value = block.attributes[key];

    // Every attribute that has a default must match the default.
    if (definition.hasOwnProperty('default')) {
      return value === definition.default;
    }

    // The rich text type is a bit different from the rest because it
    // has an implicit default value of an empty RichTextData instance,
    // so check the length of the value.
    if (definition.type === 'rich-text') {
      return !value?.length;
    }

    // Every attribute that doesn't have a default should be undefined.
    return value === undefined;
  });
}

/**
 * Determines whether the block is a default block and its attributes are equal
 * to the default attributes which means the block is unmodified.
 *
 * @param {WPBlock} block Block Object
 *
 * @return {boolean} Whether the block is an unmodified default block.
 */
function utils_isUnmodifiedDefaultBlock(block) {
  return block.name === getDefaultBlockName() && isUnmodifiedBlock(block);
}

/**
 * Function that checks if the parameter is a valid icon.
 *
 * @param {*} icon Parameter to be checked.
 *
 * @return {boolean} True if the parameter is a valid icon and false otherwise.
 */

function isValidIcon(icon) {
  return !!icon && (typeof icon === 'string' || (0,react.isValidElement)(icon) || typeof icon === 'function' || icon instanceof react.Component);
}

/**
 * Function that receives an icon as set by the blocks during the registration
 * and returns a new icon object that is normalized so we can rely on just on possible icon structure
 * in the codebase.
 *
 * @param {WPBlockTypeIconRender} icon Render behavior of a block type icon;
 *                                     one of a Dashicon slug, an element, or a
 *                                     component.
 *
 * @return {WPBlockTypeIconDescriptor} Object describing the icon.
 */
function normalizeIconObject(icon) {
  icon = icon || BLOCK_ICON_DEFAULT;
  if (isValidIcon(icon)) {
    return {
      src: icon
    };
  }
  if ('background' in icon) {
    const colordBgColor = (0,colord/* colord */.Mj)(icon.background);
    const getColorContrast = iconColor => colordBgColor.contrast(iconColor);
    const maxContrast = Math.max(...ICON_COLORS.map(getColorContrast));
    return {
      ...icon,
      foreground: icon.foreground ? icon.foreground : ICON_COLORS.find(iconColor => getColorContrast(iconColor) === maxContrast),
      shadowColor: colordBgColor.alpha(0.3).toRgbString()
    };
  }
  return icon;
}

/**
 * Normalizes block type passed as param. When string is passed then
 * it converts it to the matching block type object.
 * It passes the original object otherwise.
 *
 * @param {string|Object} blockTypeOrName Block type or name.
 *
 * @return {?Object} Block type.
 */
function utils_normalizeBlockType(blockTypeOrName) {
  if (typeof blockTypeOrName === 'string') {
    return getBlockType(blockTypeOrName);
  }
  return blockTypeOrName;
}

/**
 * Get the label for the block, usually this is either the block title,
 * or the value of the block's `label` function when that's specified.
 *
 * @param {Object} blockType  The block type.
 * @param {Object} attributes The values of the block's attributes.
 * @param {Object} context    The intended use for the label.
 *
 * @return {string} The block label.
 */
function getBlockLabel(blockType, attributes, context = 'visual') {
  const {
    __experimentalLabel: getLabel,
    title
  } = blockType;
  const label = getLabel && getLabel(attributes, {
    context
  });
  if (!label) {
    return title;
  }
  if (label.toPlainText) {
    return label.toPlainText();
  }

  // Strip any HTML (i.e. RichText formatting) before returning.
  return (0,strip_html/* default */.A)(label);
}

/**
 * Get a label for the block for use by screenreaders, this is more descriptive
 * than the visual label and includes the block title and the value of the
 * `getLabel` function if it's specified.
 *
 * @param {?Object} blockType              The block type.
 * @param {Object}  attributes             The values of the block's attributes.
 * @param {?number} position               The position of the block in the block list.
 * @param {string}  [direction='vertical'] The direction of the block layout.
 *
 * @return {string} The block label.
 */
function getAccessibleBlockLabel(blockType, attributes, position, direction = 'vertical') {
  // `title` is already localized, `label` is a user-supplied value.
  const title = blockType?.title;
  const label = blockType ? getBlockLabel(blockType, attributes, 'accessibility') : '';
  const hasPosition = position !== undefined;

  // getBlockLabel returns the block title as a fallback when there's no label,
  // if it did return the title, this function needs to avoid adding the
  // title twice within the accessible label. Use this `hasLabel` boolean to
  // handle that.
  const hasLabel = label && label !== title;
  if (hasPosition && direction === 'vertical') {
    if (hasLabel) {
      return (0,i18n_build_module/* sprintf */.nv)( /* translators: accessibility text. 1: The block title. 2: The block row number. 3: The block label.. */
      (0,i18n_build_module.__)('%1$s Block. Row %2$d. %3$s'), title, position, label);
    }
    return (0,i18n_build_module/* sprintf */.nv)( /* translators: accessibility text. 1: The block title. 2: The block row number. */
    (0,i18n_build_module.__)('%1$s Block. Row %2$d'), title, position);
  } else if (hasPosition && direction === 'horizontal') {
    if (hasLabel) {
      return (0,i18n_build_module/* sprintf */.nv)( /* translators: accessibility text. 1: The block title. 2: The block column number. 3: The block label.. */
      (0,i18n_build_module.__)('%1$s Block. Column %2$d. %3$s'), title, position, label);
    }
    return (0,i18n_build_module/* sprintf */.nv)( /* translators: accessibility text. 1: The block title. 2: The block column number. */
    (0,i18n_build_module.__)('%1$s Block. Column %2$d'), title, position);
  }
  if (hasLabel) {
    return (0,i18n_build_module/* sprintf */.nv)( /* translators: accessibility text. %1: The block title. %2: The block label. */
    (0,i18n_build_module.__)('%1$s Block. %2$s'), title, label);
  }
  return (0,i18n_build_module/* sprintf */.nv)( /* translators: accessibility text. %s: The block title. */
  (0,i18n_build_module.__)('%s Block'), title);
}
function getDefault(attributeSchema) {
  if (attributeSchema.default !== undefined) {
    return attributeSchema.default;
  }
  if (attributeSchema.type === 'rich-text') {
    return new rich_text_build_module/* RichTextData */.EF();
  }
}

/**
 * Ensure attributes contains only values defined by block type, and merge
 * default values for missing attributes.
 *
 * @param {string} name       The block's name.
 * @param {Object} attributes The block's attributes.
 * @return {Object} The sanitized attributes.
 */
function __experimentalSanitizeBlockAttributes(name, attributes) {
  // Get the type definition associated with a registered block.
  const blockType = getBlockType(name);
  if (undefined === blockType) {
    throw new Error(`Block type '${name}' is not registered.`);
  }
  return Object.entries(blockType.attributes).reduce((accumulator, [key, schema]) => {
    const value = attributes[key];
    if (undefined !== value) {
      if (schema.type === 'rich-text') {
        if (value instanceof rich_text_build_module/* RichTextData */.EF) {
          accumulator[key] = value;
        } else if (typeof value === 'string') {
          accumulator[key] = rich_text_build_module/* RichTextData */.EF.fromHTMLString(value);
        }
      } else if (schema.type === 'string' && value instanceof rich_text_build_module/* RichTextData */.EF) {
        accumulator[key] = value.toHTMLString();
      } else {
        accumulator[key] = value;
      }
    } else {
      const _default = getDefault(schema);
      if (undefined !== _default) {
        accumulator[key] = _default;
      }
    }
    if (['node', 'children'].indexOf(schema.source) !== -1) {
      // Ensure value passed is always an array, which we're expecting in
      // the RichText component to handle the deprecated value.
      if (typeof accumulator[key] === 'string') {
        accumulator[key] = [accumulator[key]];
      } else if (!Array.isArray(accumulator[key])) {
        accumulator[key] = [];
      }
    }
    return accumulator;
  }, {});
}

/**
 * Filter block attributes by `role` and return their names.
 *
 * @param {string} name Block attribute's name.
 * @param {string} role The role of a block attribute.
 *
 * @return {string[]} The attribute names that have the provided role.
 */
function __experimentalGetBlockAttributesNamesByRole(name, role) {
  const attributes = getBlockType(name)?.attributes;
  if (!attributes) {
    return [];
  }
  const attributesNames = Object.keys(attributes);
  if (!role) {
    return attributesNames;
  }
  return attributesNames.filter(attributeName => attributes[attributeName]?.__experimentalRole === role);
}

/**
 * Return a new object with the specified keys omitted.
 *
 * @param {Object} object Original object.
 * @param {Array}  keys   Keys to be omitted.
 *
 * @return {Object} Object with omitted keys.
 */
function omit(object, keys) {
  return Object.fromEntries(Object.entries(object).filter(([key]) => !keys.includes(key)));
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/reducer.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * @typedef {Object} WPBlockCategory
 *
 * @property {string} slug  Unique category slug.
 * @property {string} title Category label, for display in user interface.
 */

/**
 * Default set of categories.
 *
 * @type {WPBlockCategory[]}
 */
const DEFAULT_CATEGORIES = [{
  slug: 'text',
  title: (0,i18n_build_module.__)('Text')
}, {
  slug: 'media',
  title: (0,i18n_build_module.__)('Media')
}, {
  slug: 'design',
  title: (0,i18n_build_module.__)('Design')
}, {
  slug: 'widgets',
  title: (0,i18n_build_module.__)('Widgets')
}, {
  slug: 'theme',
  title: (0,i18n_build_module.__)('Theme')
}, {
  slug: 'embed',
  title: (0,i18n_build_module.__)('Embeds')
}, {
  slug: 'reusable',
  title: (0,i18n_build_module.__)('Reusable blocks')
}];

// Key block types by their name.
function keyBlockTypesByName(types) {
  return types.reduce((newBlockTypes, block) => ({
    ...newBlockTypes,
    [block.name]: block
  }), {});
}

// Filter items to ensure they're unique by their name.
function getUniqueItemsByName(items) {
  return items.reduce((acc, currentItem) => {
    if (!acc.some(item => item.name === currentItem.name)) {
      acc.push(currentItem);
    }
    return acc;
  }, []);
}
function bootstrappedBlockTypes(state = {}, action) {
  switch (action.type) {
    case 'ADD_BOOTSTRAPPED_BLOCK_TYPE':
      const {
        name,
        blockType
      } = action;
      const serverDefinition = state[name];
      let newDefinition;
      // Don't overwrite if already set. It covers the case when metadata
      // was initialized from the server.
      if (serverDefinition) {
        // The `blockHooks` prop is not yet included in the server provided
        // definitions and needs to be polyfilled. This can be removed when the
        // minimum supported WordPress is >= 6.4.
        if (serverDefinition.blockHooks === undefined && blockType.blockHooks) {
          newDefinition = {
            ...serverDefinition,
            ...newDefinition,
            blockHooks: blockType.blockHooks
          };
        }

        // The `allowedBlocks` prop is not yet included in the server provided
        // definitions and needs to be polyfilled. This can be removed when the
        // minimum supported WordPress is >= 6.5.
        if (serverDefinition.allowedBlocks === undefined && blockType.allowedBlocks) {
          newDefinition = {
            ...serverDefinition,
            ...newDefinition,
            allowedBlocks: blockType.allowedBlocks
          };
        }
      } else {
        newDefinition = Object.fromEntries(Object.entries(blockType).filter(([, value]) => value !== null && value !== undefined).map(([key, value]) => [(0,dist_es2015/* camelCase */.xQ)(key), value]));
        newDefinition.name = name;
      }
      if (newDefinition) {
        return {
          ...state,
          [name]: newDefinition
        };
      }
      return state;
    case 'REMOVE_BLOCK_TYPES':
      return omit(state, action.names);
  }
  return state;
}

/**
 * Reducer managing the unprocessed block types in a form passed when registering the by block.
 * It's for internal use only. It allows recomputing the processed block types on-demand after block type filters
 * get added or removed.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function unprocessedBlockTypes(state = {}, action) {
  switch (action.type) {
    case 'ADD_UNPROCESSED_BLOCK_TYPE':
      return {
        ...state,
        [action.name]: action.blockType
      };
    case 'REMOVE_BLOCK_TYPES':
      return omit(state, action.names);
  }
  return state;
}

/**
 * Reducer managing the processed block types with all filters applied.
 * The state is derived from the `unprocessedBlockTypes` reducer.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function blockTypes(state = {}, action) {
  switch (action.type) {
    case 'ADD_BLOCK_TYPES':
      return {
        ...state,
        ...keyBlockTypesByName(action.blockTypes)
      };
    case 'REMOVE_BLOCK_TYPES':
      return omit(state, action.names);
  }
  return state;
}

/**
 * Reducer managing the block styles.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function blockStyles(state = {}, action) {
  var _state$action$blockNa;
  switch (action.type) {
    case 'ADD_BLOCK_TYPES':
      return {
        ...state,
        ...Object.fromEntries(Object.entries(keyBlockTypesByName(action.blockTypes)).map(([name, blockType]) => {
          var _blockType$styles, _state$blockType$name;
          return [name, getUniqueItemsByName([...((_blockType$styles = blockType.styles) !== null && _blockType$styles !== void 0 ? _blockType$styles : []).map(style => ({
            ...style,
            source: 'block'
          })), ...((_state$blockType$name = state[blockType.name]) !== null && _state$blockType$name !== void 0 ? _state$blockType$name : []).filter(({
            source
          }) => 'block' !== source)])];
        }))
      };
    case 'ADD_BLOCK_STYLES':
      const updatedStyles = {};
      action.blockNames.forEach(blockName => {
        var _state$blockName;
        updatedStyles[blockName] = getUniqueItemsByName([...((_state$blockName = state[blockName]) !== null && _state$blockName !== void 0 ? _state$blockName : []), ...action.styles]);
      });
      return {
        ...state,
        ...updatedStyles
      };
    case 'REMOVE_BLOCK_STYLES':
      return {
        ...state,
        [action.blockName]: ((_state$action$blockNa = state[action.blockName]) !== null && _state$action$blockNa !== void 0 ? _state$action$blockNa : []).filter(style => action.styleNames.indexOf(style.name) === -1)
      };
  }
  return state;
}

/**
 * Reducer managing the block variations.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function blockVariations(state = {}, action) {
  var _state$action$blockNa2, _state$action$blockNa3;
  switch (action.type) {
    case 'ADD_BLOCK_TYPES':
      return {
        ...state,
        ...Object.fromEntries(Object.entries(keyBlockTypesByName(action.blockTypes)).map(([name, blockType]) => {
          var _blockType$variations, _state$blockType$name2;
          return [name, getUniqueItemsByName([...((_blockType$variations = blockType.variations) !== null && _blockType$variations !== void 0 ? _blockType$variations : []).map(variation => ({
            ...variation,
            source: 'block'
          })), ...((_state$blockType$name2 = state[blockType.name]) !== null && _state$blockType$name2 !== void 0 ? _state$blockType$name2 : []).filter(({
            source
          }) => 'block' !== source)])];
        }))
      };
    case 'ADD_BLOCK_VARIATIONS':
      return {
        ...state,
        [action.blockName]: getUniqueItemsByName([...((_state$action$blockNa2 = state[action.blockName]) !== null && _state$action$blockNa2 !== void 0 ? _state$action$blockNa2 : []), ...action.variations])
      };
    case 'REMOVE_BLOCK_VARIATIONS':
      return {
        ...state,
        [action.blockName]: ((_state$action$blockNa3 = state[action.blockName]) !== null && _state$action$blockNa3 !== void 0 ? _state$action$blockNa3 : []).filter(variation => action.variationNames.indexOf(variation.name) === -1)
      };
  }
  return state;
}

/**
 * Higher-order Reducer creating a reducer keeping track of given block name.
 *
 * @param {string} setActionType Action type.
 *
 * @return {Function} Reducer.
 */
function createBlockNameSetterReducer(setActionType) {
  return (state = null, action) => {
    switch (action.type) {
      case 'REMOVE_BLOCK_TYPES':
        if (action.names.indexOf(state) !== -1) {
          return null;
        }
        return state;
      case setActionType:
        return action.name || null;
    }
    return state;
  };
}
const defaultBlockName = createBlockNameSetterReducer('SET_DEFAULT_BLOCK_NAME');
const freeformFallbackBlockName = createBlockNameSetterReducer('SET_FREEFORM_FALLBACK_BLOCK_NAME');
const unregisteredFallbackBlockName = createBlockNameSetterReducer('SET_UNREGISTERED_FALLBACK_BLOCK_NAME');
const groupingBlockName = createBlockNameSetterReducer('SET_GROUPING_BLOCK_NAME');

/**
 * Reducer managing the categories
 *
 * @param {WPBlockCategory[]} state  Current state.
 * @param {Object}            action Dispatched action.
 *
 * @return {WPBlockCategory[]} Updated state.
 */
function categories(state = DEFAULT_CATEGORIES, action) {
  switch (action.type) {
    case 'SET_CATEGORIES':
      return action.categories || [];
    case 'UPDATE_CATEGORY':
      {
        if (!action.category || !Object.keys(action.category).length) {
          return state;
        }
        const categoryToChange = state.find(({
          slug
        }) => slug === action.slug);
        if (categoryToChange) {
          return state.map(category => {
            if (category.slug === action.slug) {
              return {
                ...category,
                ...action.category
              };
            }
            return category;
          });
        }
      }
  }
  return state;
}
function collections(state = {}, action) {
  switch (action.type) {
    case 'ADD_BLOCK_COLLECTION':
      return {
        ...state,
        [action.namespace]: {
          title: action.title,
          icon: action.icon
        }
      };
    case 'REMOVE_BLOCK_COLLECTION':
      return omit(state, action.namespace);
  }
  return state;
}
function blockBindingsSources(state = {}, action) {
  if (action.type === 'REGISTER_BLOCK_BINDINGS_SOURCE') {
    return {
      ...state,
      [action.sourceName]: {
        label: action.sourceLabel,
        getValue: action.getValue,
        setValue: action.setValue,
        setValues: action.setValues,
        getPlaceholder: action.getPlaceholder,
        canUserEditValue: action.canUserEditValue || (() => false)
      }
    };
  }
  return state;
}
/* harmony default export */ const reducer = ((0,build_module/* combineReducers */.HY)({
  bootstrappedBlockTypes,
  unprocessedBlockTypes,
  blockTypes,
  blockStyles,
  blockVariations,
  defaultBlockName,
  freeformFallbackBlockName,
  unregisteredFallbackBlockName,
  groupingBlockName,
  categories,
  collections,
  blockBindingsSources
}));
//# sourceMappingURL=reducer.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/remove-accents@0.5.0/node_modules/remove-accents/index.js
var remove_accents = __webpack_require__("../../node_modules/.pnpm/remove-accents@0.5.0/node_modules/remove-accents/index.js");
var remove_accents_default = /*#__PURE__*/__webpack_require__.n(remove_accents);
// EXTERNAL MODULE: ../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js
var rememo = __webpack_require__("../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/utils.js
/**
 * Helper util to return a value from a certain path of the object.
 * Path is specified as either:
 * - a string of properties, separated by dots, for example: "x.y".
 * - an array of properties, for example `[ 'x', 'y' ]`.
 * You can also specify a default value in case the result is nullish.
 *
 * @param {Object}       object       Input object.
 * @param {string|Array} path         Path to the object property.
 * @param {*}            defaultValue Default value if the value at the specified path is nullish.
 * @return {*} Value of the object property at the specified path.
 */
const getValueFromObjectPath = (object, path, defaultValue) => {
  var _value;
  const normalizedPath = Array.isArray(path) ? path : path.split('.');
  let value = object;
  normalizedPath.forEach(fieldName => {
    value = value?.[fieldName];
  });
  return (_value = value) !== null && _value !== void 0 ? _value : defaultValue;
};
function utils_isObject(candidate) {
  return typeof candidate === 'object' && candidate.constructor === Object && candidate !== null;
}

/**
 * Determine whether a set of object properties matches a given object.
 *
 * Given an object of block attributes and an object of variation attributes,
 * this function checks recursively whether all the variation attributes are
 * present in the block attributes object.
 *
 * @param {Object} blockAttributes     The object to inspect.
 * @param {Object} variationAttributes The object of property values to match.
 * @return {boolean} Whether the block attributes match the variation attributes.
 */
function matchesAttributes(blockAttributes, variationAttributes) {
  if (utils_isObject(blockAttributes) && utils_isObject(variationAttributes)) {
    return Object.entries(variationAttributes).every(([key, value]) => matchesAttributes(blockAttributes?.[key], value));
  }
  return blockAttributes === variationAttributes;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/selectors.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/** @typedef {import('../api/registration').WPBlockVariation} WPBlockVariation */
/** @typedef {import('../api/registration').WPBlockVariationScope} WPBlockVariationScope */
/** @typedef {import('./reducer').WPBlockCategory} WPBlockCategory */

/**
 * Given a block name or block type object, returns the corresponding
 * normalized block type object.
 *
 * @param {Object}          state      Blocks state.
 * @param {(string|Object)} nameOrType Block name or type object
 *
 * @return {Object} Block type object.
 */
const getNormalizedBlockType = (state, nameOrType) => 'string' === typeof nameOrType ? selectors_getBlockType(state, nameOrType) : nameOrType;

/**
 * Returns all the available block types.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const blockTypes = useSelect(
 *         ( select ) => select( blocksStore ).getBlockTypes(),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { blockTypes.map( ( block ) => (
 *                 <li key={ block.name }>{ block.title }</li>
 *             ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Array} Block Types.
 */
const selectors_getBlockTypes = (0,rememo/* default */.A)(state => Object.values(state.blockTypes), state => [state.blockTypes]);

/**
 * Returns a block type by name.
 *
 * @param {Object} state Data state.
 * @param {string} name  Block type name.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const paragraphBlock = useSelect( ( select ) =>
 *         ( select ) => select( blocksStore ).getBlockType( 'core/paragraph' ),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { paragraphBlock &&
 *                 Object.entries( paragraphBlock.supports ).map(
 *                     ( blockSupportsEntry ) => {
 *                         const [ propertyName, value ] = blockSupportsEntry;
 *                         return (
 *                             <li
 *                                 key={ propertyName }
 *                             >{ `${ propertyName } : ${ value }` }</li>
 *                         );
 *                     }
 *                 ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Object?} Block Type.
 */
function selectors_getBlockType(state, name) {
  return state.blockTypes[name];
}

/**
 * Returns block styles by block name.
 *
 * @param {Object} state Data state.
 * @param {string} name  Block type name.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const buttonBlockStyles = useSelect( ( select ) =>
 *         select( blocksStore ).getBlockStyles( 'core/button' ),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { buttonBlockStyles &&
 *                 buttonBlockStyles.map( ( style ) => (
 *                     <li key={ style.name }>{ style.label }</li>
 *                 ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Array?} Block Styles.
 */
function getBlockStyles(state, name) {
  return state.blockStyles[name];
}

/**
 * Returns block variations by block name.
 *
 * @param {Object}                state     Data state.
 * @param {string}                blockName Block type name.
 * @param {WPBlockVariationScope} [scope]   Block variation scope name.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const socialLinkVariations = useSelect( ( select ) =>
 *         select( blocksStore ).getBlockVariations( 'core/social-link' ),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { socialLinkVariations &&
 *                 socialLinkVariations.map( ( variation ) => (
 *                     <li key={ variation.name }>{ variation.title }</li>
 *             ) ) }
 *     </ul>
 *     );
 * };
 * ```
 *
 * @return {(WPBlockVariation[]|void)} Block variations.
 */
const selectors_getBlockVariations = (0,rememo/* default */.A)((state, blockName, scope) => {
  const variations = state.blockVariations[blockName];
  if (!variations || !scope) {
    return variations;
  }
  return variations.filter(variation => {
    // For backward compatibility reasons, variation's scope defaults to
    // `block` and `inserter` when not set.
    return (variation.scope || ['block', 'inserter']).includes(scope);
  });
}, (state, blockName) => [state.blockVariations[blockName]]);

/**
 * Returns the active block variation for a given block based on its attributes.
 * Variations are determined by their `isActive` property.
 * Which is either an array of block attribute keys or a function.
 *
 * In case of an array of block attribute keys, the `attributes` are compared
 * to the variation's attributes using strict equality check.
 *
 * In case of function type, the function should accept a block's attributes
 * and the variation's attributes and determines if a variation is active.
 * A function that accepts a block's attributes and the variation's attributes and determines if a variation is active.
 *
 * @param {Object}                state      Data state.
 * @param {string}                blockName  Name of block (example: “core/columns”).
 * @param {Object}                attributes Block attributes used to determine active variation.
 * @param {WPBlockVariationScope} [scope]    Block variation scope name.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { store as blockEditorStore } from '@wordpress/block-editor';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     // This example assumes that a core/embed block is the first block in the Block Editor.
 *     const activeBlockVariation = useSelect( ( select ) => {
 *         // Retrieve the list of blocks.
 *         const [ firstBlock ] = select( blockEditorStore ).getBlocks()
 *
 *         // Return the active block variation for the first block.
 *         return select( blocksStore ).getActiveBlockVariation(
 *             firstBlock.name,
 *             firstBlock.attributes
 *         );
 *     }, [] );
 *
 *     return activeBlockVariation && activeBlockVariation.name === 'spotify' ? (
 *         <p>{ __( 'Spotify variation' ) }</p>
 *         ) : (
 *         <p>{ __( 'Other variation' ) }</p>
 *     );
 * };
 * ```
 *
 * @return {(WPBlockVariation|undefined)} Active block variation.
 */
function getActiveBlockVariation(state, blockName, attributes, scope) {
  const variations = selectors_getBlockVariations(state, blockName, scope);
  if (!variations) {
    return variations;
  }
  const blockType = selectors_getBlockType(state, blockName);
  const attributeKeys = Object.keys(blockType?.attributes || {});
  let match;
  let maxMatchedAttributes = 0;
  for (const variation of variations) {
    if (Array.isArray(variation.isActive)) {
      const definedAttributes = variation.isActive.filter(attribute => {
        // We support nested attribute paths, e.g. `layout.type`.
        // In this case, we need to check if the part before the
        // first dot is a known attribute.
        const topLevelAttribute = attribute.split('.')[0];
        return attributeKeys.includes(topLevelAttribute);
      });
      const definedAttributesLength = definedAttributes.length;
      if (definedAttributesLength === 0) {
        continue;
      }
      const isMatch = definedAttributes.every(attribute => {
        const variationAttributeValue = getValueFromObjectPath(variation.attributes, attribute);
        if (variationAttributeValue === undefined) {
          return false;
        }
        let blockAttributeValue = getValueFromObjectPath(attributes, attribute);
        if (blockAttributeValue instanceof rich_text_build_module/* RichTextData */.EF) {
          blockAttributeValue = blockAttributeValue.toHTMLString();
        }
        return matchesAttributes(blockAttributeValue, variationAttributeValue);
      });
      if (isMatch && definedAttributesLength > maxMatchedAttributes) {
        match = variation;
        maxMatchedAttributes = definedAttributesLength;
      }
    } else if (variation.isActive?.(attributes, variation.attributes)) {
      // If isActive is a function, we cannot know how many attributes it matches.
      // This means that we cannot compare the specificity of our matches,
      // and simply return the best match we have found.
      return match || variation;
    }
  }
  return match;
}

/**
 * Returns the default block variation for the given block type.
 * When there are multiple variations annotated as the default one,
 * the last added item is picked. This simplifies registering overrides.
 * When there is no default variation set, it returns the first item.
 *
 * @param {Object}                state     Data state.
 * @param {string}                blockName Block type name.
 * @param {WPBlockVariationScope} [scope]   Block variation scope name.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const defaultEmbedBlockVariation = useSelect( ( select ) =>
 *         select( blocksStore ).getDefaultBlockVariation( 'core/embed' ),
 *         []
 *     );
 *
 *     return (
 *         defaultEmbedBlockVariation && (
 *             <p>
 *                 { sprintf(
 *                     __( 'core/embed default variation: %s' ),
 *                     defaultEmbedBlockVariation.title
 *                 ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {?WPBlockVariation} The default block variation.
 */
function getDefaultBlockVariation(state, blockName, scope) {
  const variations = selectors_getBlockVariations(state, blockName, scope);
  const defaultVariation = [...variations].reverse().find(({
    isDefault
  }) => !!isDefault);
  return defaultVariation || variations[0];
}

/**
 * Returns all the available block categories.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect, } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const blockCategories = useSelect( ( select ) =>
 *         select( blocksStore ).getCategories(),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { blockCategories.map( ( category ) => (
 *                 <li key={ category.slug }>{ category.title }</li>
 *             ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {WPBlockCategory[]} Categories list.
 */
function getCategories(state) {
  return state.categories;
}

/**
 * Returns all the available collections.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const blockCollections = useSelect( ( select ) =>
 *         select( blocksStore ).getCollections(),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { Object.values( blockCollections ).length > 0 &&
 *                 Object.values( blockCollections ).map( ( collection ) => (
 *                     <li key={ collection.title }>{ collection.title }</li>
 *             ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Object} Collections list.
 */
function getCollections(state) {
  return state.collections;
}

/**
 * Returns the name of the default block name.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const defaultBlockName = useSelect( ( select ) =>
 *         select( blocksStore ).getDefaultBlockName(),
 *         []
 *     );
 *
 *     return (
 *         defaultBlockName && (
 *             <p>
 *                 { sprintf( __( 'Default block name: %s' ), defaultBlockName ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {string?} Default block name.
 */
function selectors_getDefaultBlockName(state) {
  return state.defaultBlockName;
}

/**
 * Returns the name of the block for handling non-block content.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const freeformFallbackBlockName = useSelect( ( select ) =>
 *         select( blocksStore ).getFreeformFallbackBlockName(),
 *         []
 *     );
 *
 *     return (
 *         freeformFallbackBlockName && (
 *             <p>
 *                 { sprintf( __(
 *                     'Freeform fallback block name: %s' ),
 *                     freeformFallbackBlockName
 *                 ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {string?} Name of the block for handling non-block content.
 */
function getFreeformFallbackBlockName(state) {
  return state.freeformFallbackBlockName;
}

/**
 * Returns the name of the block for handling unregistered blocks.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const unregisteredFallbackBlockName = useSelect( ( select ) =>
 *         select( blocksStore ).getUnregisteredFallbackBlockName(),
 *         []
 *     );
 *
 *     return (
 *         unregisteredFallbackBlockName && (
 *             <p>
 *                 { sprintf( __(
 *                     'Unregistered fallback block name: %s' ),
 *                     unregisteredFallbackBlockName
 *                 ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {string?} Name of the block for handling unregistered blocks.
 */
function getUnregisteredFallbackBlockName(state) {
  return state.unregisteredFallbackBlockName;
}

/**
 * Returns the name of the block for handling the grouping of blocks.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const groupingBlockName = useSelect( ( select ) =>
 *         select( blocksStore ).getGroupingBlockName(),
 *         []
 *     );
 *
 *     return (
 *         groupingBlockName && (
 *             <p>
 *                 { sprintf(
 *                     __( 'Default grouping block name: %s' ),
 *                     groupingBlockName
 *                 ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {string?} Name of the block for handling the grouping of blocks.
 */
function selectors_getGroupingBlockName(state) {
  return state.groupingBlockName;
}

/**
 * Returns an array with the child blocks of a given block.
 *
 * @param {Object} state     Data state.
 * @param {string} blockName Block type name.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const childBlockNames = useSelect( ( select ) =>
 *         select( blocksStore ).getChildBlockNames( 'core/navigation' ),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { childBlockNames &&
 *                 childBlockNames.map( ( child ) => (
 *                     <li key={ child }>{ child }</li>
 *             ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Array} Array of child block names.
 */
const selectors_getChildBlockNames = (0,rememo/* default */.A)((state, blockName) => {
  return selectors_getBlockTypes(state).filter(blockType => {
    return blockType.parent?.includes(blockName);
  }).map(({
    name
  }) => name);
}, state => [state.blockTypes]);

/**
 * Returns the block support value for a feature, if defined.
 *
 * @param {Object}          state           Data state.
 * @param {(string|Object)} nameOrType      Block name or type object
 * @param {Array|string}    feature         Feature to retrieve
 * @param {*}               defaultSupports Default value to return if not
 *                                          explicitly defined
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const paragraphBlockSupportValue = useSelect( ( select ) =>
 *         select( blocksStore ).getBlockSupport( 'core/paragraph', 'anchor' ),
 *         []
 *     );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __( 'core/paragraph supports.anchor value: %s' ),
 *                 paragraphBlockSupportValue
 *             ) }
 *         </p>
 *     );
 * };
 * ```
 *
 * @return {?*} Block support value
 */
const selectors_getBlockSupport = (state, nameOrType, feature, defaultSupports) => {
  const blockType = getNormalizedBlockType(state, nameOrType);
  if (!blockType?.supports) {
    return defaultSupports;
  }
  return getValueFromObjectPath(blockType.supports, feature, defaultSupports);
};

/**
 * Returns true if the block defines support for a feature, or false otherwise.
 *
 * @param {Object}          state           Data state.
 * @param {(string|Object)} nameOrType      Block name or type object.
 * @param {string}          feature         Feature to test.
 * @param {boolean}         defaultSupports Whether feature is supported by
 *                                          default if not explicitly defined.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const paragraphBlockSupportClassName = useSelect( ( select ) =>
 *         select( blocksStore ).hasBlockSupport( 'core/paragraph', 'className' ),
 *         []
 *     );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __( 'core/paragraph supports custom class name?: %s' ),
 *                 paragraphBlockSupportClassName
 *             ) }
 *         /p>
 *     );
 * };
 * ```
 *
 * @return {boolean} Whether block supports feature.
 */
function selectors_hasBlockSupport(state, nameOrType, feature, defaultSupports) {
  return !!selectors_getBlockSupport(state, nameOrType, feature, defaultSupports);
}

/**
 * Normalizes a search term string: removes accents, converts to lowercase, removes extra whitespace.
 *
 * @param {string|null|undefined} term Search term to normalize.
 * @return {string} Normalized search term.
 */
function getNormalizedSearchTerm(term) {
  return remove_accents_default()(term !== null && term !== void 0 ? term : '').toLowerCase().trim();
}

/**
 * Returns true if the block type by the given name or object value matches a
 * search term, or false otherwise.
 *
 * @param {Object}          state      Blocks state.
 * @param {(string|Object)} nameOrType Block name or type object.
 * @param {string}          searchTerm Search term by which to filter.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const termFound = useSelect(
 *         ( select ) =>
 *             select( blocksStore ).isMatchingSearchTerm(
 *                 'core/navigation',
 *                 'theme'
 *             ),
 *             []
 *         );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __(
 *                     'Search term was found in the title, keywords, category or description in block.json: %s'
 *                 ),
 *                 termFound
 *             ) }
 *         </p>
 *     );
 * };
 * ```
 *
 * @return {Object[]} Whether block type matches search term.
 */
function isMatchingSearchTerm(state, nameOrType, searchTerm = '') {
  const blockType = getNormalizedBlockType(state, nameOrType);
  const normalizedSearchTerm = getNormalizedSearchTerm(searchTerm);
  const isSearchMatch = candidate => getNormalizedSearchTerm(candidate).includes(normalizedSearchTerm);
  return isSearchMatch(blockType.title) || blockType.keywords?.some(isSearchMatch) || isSearchMatch(blockType.category) || typeof blockType.description === 'string' && isSearchMatch(blockType.description);
}

/**
 * Returns a boolean indicating if a block has child blocks or not.
 *
 * @param {Object} state     Data state.
 * @param {string} blockName Block type name.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const navigationBlockHasChildBlocks = useSelect( ( select ) =>
 *         select( blocksStore ).hasChildBlocks( 'core/navigation' ),
 *         []
 *     );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __( 'core/navigation has child blocks: %s' ),
 *                 navigationBlockHasChildBlocks
 *             ) }
 *         </p>
 *     );
 * };
 * ```
 *
 * @return {boolean} True if a block contains child blocks and false otherwise.
 */
const selectors_hasChildBlocks = (state, blockName) => {
  return selectors_getChildBlockNames(state, blockName).length > 0;
};

/**
 * Returns a boolean indicating if a block has at least one child block with inserter support.
 *
 * @param {Object} state     Data state.
 * @param {string} blockName Block type name.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const navigationBlockHasChildBlocksWithInserterSupport = useSelect( ( select ) =>
 *         select( blocksStore ).hasChildBlocksWithInserterSupport(
 *             'core/navigation'
 *         ),
 *         []
 *     );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __( 'core/navigation has child blocks with inserter support: %s' ),
 *                 navigationBlockHasChildBlocksWithInserterSupport
 *             ) }
 *         </p>
 *     );
 * };
 * ```
 *
 * @return {boolean} True if a block contains at least one child blocks with inserter support
 *                   and false otherwise.
 */
const selectors_hasChildBlocksWithInserterSupport = (state, blockName) => {
  return selectors_getChildBlockNames(state, blockName).some(childBlockName => {
    return selectors_hasBlockSupport(state, childBlockName, 'inserter', true);
  });
};

/**
 * DO-NOT-USE in production.
 * This selector is created for internal/experimental only usage and may be
 * removed anytime without any warning, causing breakage on any plugin or theme invoking it.
 */
const __experimentalHasContentRoleAttribute = (0,rememo/* default */.A)((state, blockTypeName) => {
  const blockType = selectors_getBlockType(state, blockTypeName);
  if (!blockType) {
    return false;
  }
  return Object.entries(blockType.attributes).some(([, {
    __experimentalRole
  }]) => __experimentalRole === 'content');
}, (state, blockTypeName) => [state.blockTypes[blockTypeName]?.attributes]);
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/private-selectors.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const ROOT_BLOCK_SUPPORTS = ['background', 'backgroundColor', 'color', 'linkColor', 'captionColor', 'buttonColor', 'headingColor', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'lineHeight', 'padding', 'contentSize', 'wideSize', 'blockGap', 'textDecoration', 'textTransform', 'letterSpacing'];

/**
 * Filters the list of supported styles for a given element.
 *
 * @param {string[]}         blockSupports list of supported styles.
 * @param {string|undefined} name          block name.
 * @param {string|undefined} element       element name.
 *
 * @return {string[]} filtered list of supported styles.
 */
function filterElementBlockSupports(blockSupports, name, element) {
  return blockSupports.filter(support => {
    if (support === 'fontSize' && element === 'heading') {
      return false;
    }

    // This is only available for links
    if (support === 'textDecoration' && !name && element !== 'link') {
      return false;
    }

    // This is only available for heading, button, caption and text
    if (support === 'textTransform' && !name && !(['heading', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(element) || element === 'button' || element === 'caption' || element === 'text')) {
      return false;
    }

    // This is only available for heading, button, caption and text
    if (support === 'letterSpacing' && !name && !(['heading', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(element) || element === 'button' || element === 'caption' || element === 'text')) {
      return false;
    }

    // Text columns is only available for blocks.
    if (support === 'textColumns' && !name) {
      return false;
    }
    return true;
  });
}

/**
 * Returns the list of supported styles for a given block name and element.
 */
const getSupportedStyles = (0,rememo/* default */.A)((state, name, element) => {
  if (!name) {
    return filterElementBlockSupports(ROOT_BLOCK_SUPPORTS, name, element);
  }
  const blockType = selectors_getBlockType(state, name);
  if (!blockType) {
    return [];
  }
  const supportKeys = [];

  // Check for blockGap support.
  // Block spacing support doesn't map directly to a single style property, so needs to be handled separately.
  if (blockType?.supports?.spacing?.blockGap) {
    supportKeys.push('blockGap');
  }

  // check for shadow support
  if (blockType?.supports?.shadow) {
    supportKeys.push('shadow');
  }
  Object.keys(__EXPERIMENTAL_STYLE_PROPERTY).forEach(styleName => {
    if (!__EXPERIMENTAL_STYLE_PROPERTY[styleName].support) {
      return;
    }

    // Opting out means that, for certain support keys like background color,
    // blocks have to explicitly set the support value false. If the key is
    // unset, we still enable it.
    if (__EXPERIMENTAL_STYLE_PROPERTY[styleName].requiresOptOut) {
      if (__EXPERIMENTAL_STYLE_PROPERTY[styleName].support[0] in blockType.supports && getValueFromObjectPath(blockType.supports, __EXPERIMENTAL_STYLE_PROPERTY[styleName].support) !== false) {
        supportKeys.push(styleName);
        return;
      }
    }
    if (getValueFromObjectPath(blockType.supports, __EXPERIMENTAL_STYLE_PROPERTY[styleName].support, false)) {
      supportKeys.push(styleName);
    }
  });
  return filterElementBlockSupports(supportKeys, name, element);
}, (state, name) => [state.blockTypes[name]]);

/**
 * Returns the bootstrapped block type metadata for a give block name.
 *
 * @param {Object} state Data state.
 * @param {string} name  Block name.
 *
 * @return {Object} Bootstrapped block type metadata for a block.
 */
function getBootstrappedBlockType(state, name) {
  return state.bootstrappedBlockTypes[name];
}

/**
 * Returns all the unprocessed (before applying the `registerBlockType` filter)
 * block type settings as passed during block registration.
 *
 * @param {Object} state Data state.
 *
 * @return {Array} Unprocessed block type settings for all blocks.
 */
function getUnprocessedBlockTypes(state) {
  return state.unprocessedBlockTypes;
}

/**
 * Returns all the block bindings sources registered.
 *
 * @param {Object} state Data state.
 *
 * @return {Object} All the registered sources and their properties.
 */
function getAllBlockBindingsSources(state) {
  return state.blockBindingsSources;
}

/**
 * Returns a specific block bindings source.
 *
 * @param {Object} state      Data state.
 * @param {string} sourceName Name of the source to get.
 *
 * @return {Object} The specific block binding source and its properties.
 */
function getBlockBindingsSource(state, sourceName) {
  return state.blockBindingsSources[sourceName];
}
//# sourceMappingURL=private-selectors.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+deprecated@4.0.1/node_modules/@wordpress/deprecated/build-module/index.js
var deprecated_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+deprecated@4.0.1/node_modules/@wordpress/deprecated/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs
var is_plain_object = __webpack_require__("../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/index.js
var react_is = __webpack_require__("../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+hooks@4.0.1/node_modules/@wordpress/hooks/build-module/index.js + 10 modules
var hooks_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+hooks@4.0.1/node_modules/@wordpress/hooks/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/process-block-type.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/** @typedef {import('../api/registration').WPBlockType} WPBlockType */

const error = (...args) => window?.console?.error?.(...args);
const warn = (...args) => window?.console?.warn?.(...args);

/**
 * Mapping of legacy category slugs to their latest normal values, used to
 * accommodate updates of the default set of block categories.
 *
 * @type {Record<string,string>}
 */
const LEGACY_CATEGORY_MAPPING = {
  common: 'text',
  formatting: 'text',
  layout: 'design'
};

/**
 * Merge block variations bootstrapped from the server and client.
 *
 * When a variation is registered in both places, its properties are merged.
 *
 * @param {Array} bootstrappedVariations - A block type variations from the server.
 * @param {Array} clientVariations       - A block type variations from the client.
 * @return {Array} The merged array of block variations.
 */
function mergeBlockVariations(bootstrappedVariations = [], clientVariations = []) {
  const result = [...bootstrappedVariations];
  clientVariations.forEach(clientVariation => {
    const index = result.findIndex(bootstrappedVariation => bootstrappedVariation.name === clientVariation.name);
    if (index !== -1) {
      result[index] = {
        ...result[index],
        ...clientVariation
      };
    } else {
      result.push(clientVariation);
    }
  });
  return result;
}

/**
 * Takes the unprocessed block type settings, merges them with block type metadata
 * and applies all the existing filters for the registered block type.
 * Next, it validates all the settings and performs additional processing to the block type definition.
 *
 * @param {string}      name          Block name.
 * @param {WPBlockType} blockSettings Unprocessed block type settings.
 *
 * @return {WPBlockType | undefined} The block, if it has been processed and can be registered; otherwise `undefined`.
 */
const processBlockType = (name, blockSettings) => ({
  select
}) => {
  const bootstrappedBlockType = select.getBootstrappedBlockType(name);
  const blockType = {
    name,
    icon: BLOCK_ICON_DEFAULT,
    keywords: [],
    attributes: {},
    providesContext: {},
    usesContext: [],
    selectors: {},
    supports: {},
    styles: [],
    blockHooks: {},
    save: () => null,
    ...bootstrappedBlockType,
    ...blockSettings,
    variations: mergeBlockVariations(bootstrappedBlockType?.variations, blockSettings?.variations)
  };
  const settings = (0,hooks_build_module/* applyFilters */.W5)('blocks.registerBlockType', blockType, name, null);
  if (settings.description && typeof settings.description !== 'string') {
    (0,deprecated_build_module/* default */.A)('Declaring non-string block descriptions', {
      since: '6.2'
    });
  }
  if (settings.deprecated) {
    settings.deprecated = settings.deprecated.map(deprecation => Object.fromEntries(Object.entries(
    // Only keep valid deprecation keys.
    (0,hooks_build_module/* applyFilters */.W5)('blocks.registerBlockType',
    // Merge deprecation keys with pre-filter settings
    // so that filters that depend on specific keys being
    // present don't fail.
    {
      // Omit deprecation keys here so that deprecations
      // can opt out of specific keys like "supports".
      ...omit(blockType, DEPRECATED_ENTRY_KEYS),
      ...deprecation
    }, blockType.name, deprecation)).filter(([key]) => DEPRECATED_ENTRY_KEYS.includes(key))));
  }
  if (!(0,is_plain_object/* isPlainObject */.Q)(settings)) {
    error('Block settings must be a valid object.');
    return;
  }
  if (typeof settings.save !== 'function') {
    error('The "save" property must be a valid function.');
    return;
  }
  if ('edit' in settings && !(0,react_is.isValidElementType)(settings.edit)) {
    error('The "edit" property must be a valid component.');
    return;
  }

  // Canonicalize legacy categories to equivalent fallback.
  if (LEGACY_CATEGORY_MAPPING.hasOwnProperty(settings.category)) {
    settings.category = LEGACY_CATEGORY_MAPPING[settings.category];
  }
  if ('category' in settings && !select.getCategories().some(({
    slug
  }) => slug === settings.category)) {
    warn('The block "' + name + '" is registered with an invalid category "' + settings.category + '".');
    delete settings.category;
  }
  if (!('title' in settings) || settings.title === '') {
    error('The block "' + name + '" must have a title.');
    return;
  }
  if (typeof settings.title !== 'string') {
    error('Block titles must be strings.');
    return;
  }
  settings.icon = normalizeIconObject(settings.icon);
  if (!isValidIcon(settings.icon.src)) {
    error('The icon passed is invalid. ' + 'The icon should be a string, an element, a function, or an object following the specifications documented in https://developer.wordpress.org/block-editor/developers/block-api/block-registration/#icon-optional');
    return;
  }
  return settings;
};
//# sourceMappingURL=process-block-type.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/actions.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/** @typedef {import('../api/registration').WPBlockVariation} WPBlockVariation */
/** @typedef {import('../api/registration').WPBlockType} WPBlockType */
/** @typedef {import('./reducer').WPBlockCategory} WPBlockCategory */

/**
 * Returns an action object used in signalling that block types have been added.
 * Ignored from documentation as the recommended usage for this action through registerBlockType from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {WPBlockType|WPBlockType[]} blockTypes Object or array of objects representing blocks to added.
 *
 *
 * @return {Object} Action object.
 */
function addBlockTypes(blockTypes) {
  return {
    type: 'ADD_BLOCK_TYPES',
    blockTypes: Array.isArray(blockTypes) ? blockTypes : [blockTypes]
  };
}

/**
 * Signals that all block types should be computed again.
 * It uses stored unprocessed block types and all the most recent list of registered filters.
 *
 * It addresses the issue where third party block filters get registered after third party blocks. A sample sequence:
 *   1. Filter A.
 *   2. Block B.
 *   3. Block C.
 *   4. Filter D.
 *   5. Filter E.
 *   6. Block F.
 *   7. Filter G.
 * In this scenario some filters would not get applied for all blocks because they are registered too late.
 */
function reapplyBlockTypeFilters() {
  return ({
    dispatch,
    select
  }) => {
    const processedBlockTypes = [];
    for (const [name, settings] of Object.entries(select.getUnprocessedBlockTypes())) {
      const result = dispatch(processBlockType(name, settings));
      if (result) {
        processedBlockTypes.push(result);
      }
    }
    if (!processedBlockTypes.length) {
      return;
    }
    dispatch.addBlockTypes(processedBlockTypes);
  };
}
function __experimentalReapplyBlockFilters() {
  (0,deprecated_build_module/* default */.A)('wp.data.dispatch( "core/blocks" ).__experimentalReapplyBlockFilters', {
    since: '6.4',
    alternative: 'reapplyBlockFilters'
  });
  return reapplyBlockTypeFilters();
}

/**
 * Returns an action object used to remove a registered block type.
 * Ignored from documentation as the recommended usage for this action through unregisterBlockType from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string|string[]} names Block name or array of block names to be removed.
 *
 *
 * @return {Object} Action object.
 */
function removeBlockTypes(names) {
  return {
    type: 'REMOVE_BLOCK_TYPES',
    names: Array.isArray(names) ? names : [names]
  };
}

/**
 * Returns an action object used in signalling that new block styles have been added.
 * Ignored from documentation as the recommended usage for this action through registerBlockStyle from @wordpress/blocks.
 *
 * @param {string|Array} blockNames Block names to register new styles for.
 * @param {Array|Object} styles     Block style object or array of block style objects.
 *
 * @ignore
 *
 * @return {Object} Action object.
 */
function addBlockStyles(blockNames, styles) {
  return {
    type: 'ADD_BLOCK_STYLES',
    styles: Array.isArray(styles) ? styles : [styles],
    blockNames: Array.isArray(blockNames) ? blockNames : [blockNames]
  };
}

/**
 * Returns an action object used in signalling that block styles have been removed.
 * Ignored from documentation as the recommended usage for this action through unregisterBlockStyle from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string}       blockName  Block name.
 * @param {Array|string} styleNames Block style names or array of block style names.
 *
 * @return {Object} Action object.
 */
function removeBlockStyles(blockName, styleNames) {
  return {
    type: 'REMOVE_BLOCK_STYLES',
    styleNames: Array.isArray(styleNames) ? styleNames : [styleNames],
    blockName
  };
}

/**
 * Returns an action object used in signalling that new block variations have been added.
 * Ignored from documentation as the recommended usage for this action through registerBlockVariation from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string}                              blockName  Block name.
 * @param {WPBlockVariation|WPBlockVariation[]} variations Block variations.
 *
 * @return {Object} Action object.
 */
function addBlockVariations(blockName, variations) {
  return {
    type: 'ADD_BLOCK_VARIATIONS',
    variations: Array.isArray(variations) ? variations : [variations],
    blockName
  };
}

/**
 * Returns an action object used in signalling that block variations have been removed.
 * Ignored from documentation as the recommended usage for this action through unregisterBlockVariation from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string}          blockName      Block name.
 * @param {string|string[]} variationNames Block variation names.
 *
 * @return {Object} Action object.
 */
function removeBlockVariations(blockName, variationNames) {
  return {
    type: 'REMOVE_BLOCK_VARIATIONS',
    variationNames: Array.isArray(variationNames) ? variationNames : [variationNames],
    blockName
  };
}

/**
 * Returns an action object used to set the default block name.
 * Ignored from documentation as the recommended usage for this action through setDefaultBlockName from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} name Block name.
 *
 * @return {Object} Action object.
 */
function actions_setDefaultBlockName(name) {
  return {
    type: 'SET_DEFAULT_BLOCK_NAME',
    name
  };
}

/**
 * Returns an action object used to set the name of the block used as a fallback
 * for non-block content.
 * Ignored from documentation as the recommended usage for this action through setFreeformContentHandlerName from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} name Block name.
 *
 * @return {Object} Action object.
 */
function setFreeformFallbackBlockName(name) {
  return {
    type: 'SET_FREEFORM_FALLBACK_BLOCK_NAME',
    name
  };
}

/**
 * Returns an action object used to set the name of the block used as a fallback
 * for unregistered blocks.
 * Ignored from documentation as the recommended usage for this action through setUnregisteredTypeHandlerName from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} name Block name.
 *
 * @return {Object} Action object.
 */
function setUnregisteredFallbackBlockName(name) {
  return {
    type: 'SET_UNREGISTERED_FALLBACK_BLOCK_NAME',
    name
  };
}

/**
 * Returns an action object used to set the name of the block used
 * when grouping other blocks
 * eg: in "Group/Ungroup" interactions
 * Ignored from documentation as the recommended usage for this action through setGroupingBlockName from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} name Block name.
 *
 * @return {Object} Action object.
 */
function actions_setGroupingBlockName(name) {
  return {
    type: 'SET_GROUPING_BLOCK_NAME',
    name
  };
}

/**
 * Returns an action object used to set block categories.
 * Ignored from documentation as the recommended usage for this action through setCategories from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {WPBlockCategory[]} categories Block categories.
 *
 * @return {Object} Action object.
 */
function setCategories(categories) {
  return {
    type: 'SET_CATEGORIES',
    categories
  };
}

/**
 * Returns an action object used to update a category.
 * Ignored from documentation as the recommended usage for this action through updateCategory from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} slug     Block category slug.
 * @param {Object} category Object containing the category properties that should be updated.
 *
 * @return {Object} Action object.
 */
function updateCategory(slug, category) {
  return {
    type: 'UPDATE_CATEGORY',
    slug,
    category
  };
}

/**
 * Returns an action object used to add block collections
 * Ignored from documentation as the recommended usage for this action through registerBlockCollection from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} namespace The namespace of the blocks to put in the collection
 * @param {string} title     The title to display in the block inserter
 * @param {Object} icon      (optional) The icon to display in the block inserter
 *
 * @return {Object} Action object.
 */
function addBlockCollection(namespace, title, icon) {
  return {
    type: 'ADD_BLOCK_COLLECTION',
    namespace,
    title,
    icon
  };
}

/**
 * Returns an action object used to remove block collections
 * Ignored from documentation as the recommended usage for this action through unregisterBlockCollection from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} namespace The namespace of the blocks to put in the collection
 *
 * @return {Object} Action object.
 */
function removeBlockCollection(namespace) {
  return {
    type: 'REMOVE_BLOCK_COLLECTION',
    namespace
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/private-actions.js
/**
 * Internal dependencies
 */


/** @typedef {import('../api/registration').WPBlockType} WPBlockType */

/**
 * Add bootstrapped block type metadata to the store. These metadata usually come from
 * the `block.json` file and are either statically boostrapped from the server, or
 * passed as the `metadata` parameter to the `registerBlockType` function.
 *
 * @param {string}      name      Block name.
 * @param {WPBlockType} blockType Block type metadata.
 */
function addBootstrappedBlockType(name, blockType) {
  return {
    type: 'ADD_BOOTSTRAPPED_BLOCK_TYPE',
    name,
    blockType
  };
}

/**
 * Add unprocessed block type settings to the store. These data are passed as the
 * `settings` parameter to the client-side `registerBlockType` function.
 *
 * @param {string}      name      Block name.
 * @param {WPBlockType} blockType Unprocessed block type settings.
 */
function addUnprocessedBlockType(name, blockType) {
  return ({
    dispatch
  }) => {
    dispatch({
      type: 'ADD_UNPROCESSED_BLOCK_TYPE',
      name,
      blockType
    });
    const processedBlockType = dispatch(processBlockType(name, blockType));
    if (!processedBlockType) {
      return;
    }
    dispatch.addBlockTypes(processedBlockType);
  };
}

/**
 * Register new block bindings source.
 *
 * @param {string} source Name of the source to register.
 */
function registerBlockBindingsSource(source) {
  return {
    type: 'REGISTER_BLOCK_BINDINGS_SOURCE',
    sourceName: source.name,
    sourceLabel: source.label,
    getValue: source.getValue,
    setValue: source.setValue,
    setValues: source.setValues,
    getPlaceholder: source.getPlaceholder,
    canUserEditValue: source.canUserEditValue
  };
}
//# sourceMappingURL=private-actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/constants.js
const STORE_NAME = 'core/blocks';
//# sourceMappingURL=constants.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+private-apis@1.10.0/node_modules/@wordpress/private-apis/build-module/implementation.js
var implementation = __webpack_require__("../../node_modules/.pnpm/@wordpress+private-apis@1.10.0/node_modules/@wordpress/private-apis/build-module/implementation.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/lock-unlock.js
/**
 * WordPress dependencies
 */

const {
  lock,
  unlock: lock_unlock_unlock
} = (0,implementation/* __dangerousOptInToUnstableAPIsOnlyForCoreModules */.yf)('I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.', '@wordpress/blocks');
//# sourceMappingURL=lock-unlock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/store/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */








/**
 * Store definition for the blocks namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */
const store = (0,redux_store/* default */.A)(STORE_NAME, {
  reducer: reducer,
  selectors: selectors_namespaceObject,
  actions: actions_namespaceObject
});
(0,build_module/* register */.kz)(store);
lock_unlock_unlock(store).registerPrivateSelectors(private_selectors_namespaceObject);
lock_unlock_unlock(store).registerPrivateActions(private_actions_namespaceObject);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js + 3 modules
var v4 = __webpack_require__("../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/factory.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Returns a block object given its type and attributes.
 *
 * @param {string} name        Block name.
 * @param {Object} attributes  Block attributes.
 * @param {?Array} innerBlocks Nested blocks.
 *
 * @return {Object} Block object.
 */
function createBlock(name, attributes = {}, innerBlocks = []) {
  const sanitizedAttributes = __experimentalSanitizeBlockAttributes(name, attributes);
  const clientId = (0,v4/* default */.A)();

  // Blocks are stored with a unique ID, the assigned type name, the block
  // attributes, and their inner blocks.
  return {
    clientId,
    name,
    isValid: true,
    attributes: sanitizedAttributes,
    innerBlocks
  };
}

/**
 * Given an array of InnerBlocks templates or Block Objects,
 * returns an array of created Blocks from them.
 * It handles the case of having InnerBlocks as Blocks by
 * converting them to the proper format to continue recursively.
 *
 * @param {Array} innerBlocksOrTemplate Nested blocks or InnerBlocks templates.
 *
 * @return {Object[]} Array of Block objects.
 */
function createBlocksFromInnerBlocksTemplate(innerBlocksOrTemplate = []) {
  return innerBlocksOrTemplate.map(innerBlock => {
    const innerBlockTemplate = Array.isArray(innerBlock) ? innerBlock : [innerBlock.name, innerBlock.attributes, innerBlock.innerBlocks];
    const [name, attributes, innerBlocks = []] = innerBlockTemplate;
    return createBlock(name, attributes, createBlocksFromInnerBlocksTemplate(innerBlocks));
  });
}

/**
 * Given a block object, returns a copy of the block object while sanitizing its attributes,
 * optionally merging new attributes and/or replacing its inner blocks.
 *
 * @param {Object} block           Block instance.
 * @param {Object} mergeAttributes Block attributes.
 * @param {?Array} newInnerBlocks  Nested blocks.
 *
 * @return {Object} A cloned block.
 */
function __experimentalCloneSanitizedBlock(block, mergeAttributes = {}, newInnerBlocks) {
  const clientId = (0,v4/* default */.A)();
  const sanitizedAttributes = __experimentalSanitizeBlockAttributes(block.name, {
    ...block.attributes,
    ...mergeAttributes
  });
  return {
    ...block,
    clientId,
    attributes: sanitizedAttributes,
    innerBlocks: newInnerBlocks || block.innerBlocks.map(innerBlock => __experimentalCloneSanitizedBlock(innerBlock))
  };
}

/**
 * Given a block object, returns a copy of the block object,
 * optionally merging new attributes and/or replacing its inner blocks.
 *
 * @param {Object} block           Block instance.
 * @param {Object} mergeAttributes Block attributes.
 * @param {?Array} newInnerBlocks  Nested blocks.
 *
 * @return {Object} A cloned block.
 */
function cloneBlock(block, mergeAttributes = {}, newInnerBlocks) {
  const clientId = (0,v4/* default */.A)();
  return {
    ...block,
    clientId,
    attributes: {
      ...block.attributes,
      ...mergeAttributes
    },
    innerBlocks: newInnerBlocks || block.innerBlocks.map(innerBlock => cloneBlock(innerBlock))
  };
}

/**
 * Returns a boolean indicating whether a transform is possible based on
 * various bits of context.
 *
 * @param {Object} transform The transform object to validate.
 * @param {string} direction Is this a 'from' or 'to' transform.
 * @param {Array}  blocks    The blocks to transform from.
 *
 * @return {boolean} Is the transform possible?
 */
const isPossibleTransformForSource = (transform, direction, blocks) => {
  if (!blocks.length) {
    return false;
  }

  // If multiple blocks are selected, only multi block transforms
  // or wildcard transforms are allowed.
  const isMultiBlock = blocks.length > 1;
  const firstBlockName = blocks[0].name;
  const isValidForMultiBlocks = isWildcardBlockTransform(transform) || !isMultiBlock || transform.isMultiBlock;
  if (!isValidForMultiBlocks) {
    return false;
  }

  // Check non-wildcard transforms to ensure that transform is valid
  // for a block selection of multiple blocks of different types.
  if (!isWildcardBlockTransform(transform) && !blocks.every(block => block.name === firstBlockName)) {
    return false;
  }

  // Only consider 'block' type transforms as valid.
  const isBlockType = transform.type === 'block';
  if (!isBlockType) {
    return false;
  }

  // Check if the transform's block name matches the source block (or is a wildcard)
  // only if this is a transform 'from'.
  const sourceBlock = blocks[0];
  const hasMatchingName = direction !== 'from' || transform.blocks.indexOf(sourceBlock.name) !== -1 || isWildcardBlockTransform(transform);
  if (!hasMatchingName) {
    return false;
  }

  // Don't allow single Grouping blocks to be transformed into
  // a Grouping block.
  if (!isMultiBlock && direction === 'from' && isContainerGroupBlock(sourceBlock.name) && isContainerGroupBlock(transform.blockName)) {
    return false;
  }

  // If the transform has a `isMatch` function specified, check that it returns true.
  if (!maybeCheckTransformIsMatch(transform, blocks)) {
    return false;
  }
  return true;
};

/**
 * Returns block types that the 'blocks' can be transformed into, based on
 * 'from' transforms on other blocks.
 *
 * @param {Array} blocks The blocks to transform from.
 *
 * @return {Array} Block types that the blocks can be transformed into.
 */
const getBlockTypesForPossibleFromTransforms = blocks => {
  if (!blocks.length) {
    return [];
  }
  const allBlockTypes = getBlockTypes();

  // filter all blocks to find those with a 'from' transform.
  const blockTypesWithPossibleFromTransforms = allBlockTypes.filter(blockType => {
    const fromTransforms = getBlockTransforms('from', blockType.name);
    return !!findTransform(fromTransforms, transform => {
      return isPossibleTransformForSource(transform, 'from', blocks);
    });
  });
  return blockTypesWithPossibleFromTransforms;
};

/**
 * Returns block types that the 'blocks' can be transformed into, based on
 * the source block's own 'to' transforms.
 *
 * @param {Array} blocks The blocks to transform from.
 *
 * @return {Array} Block types that the source can be transformed into.
 */
const getBlockTypesForPossibleToTransforms = blocks => {
  if (!blocks.length) {
    return [];
  }
  const sourceBlock = blocks[0];
  const blockType = getBlockType(sourceBlock.name);
  const transformsTo = blockType ? getBlockTransforms('to', blockType.name) : [];

  // filter all 'to' transforms to find those that are possible.
  const possibleTransforms = transformsTo.filter(transform => {
    return transform && isPossibleTransformForSource(transform, 'to', blocks);
  });

  // Build a list of block names using the possible 'to' transforms.
  const blockNames = possibleTransforms.map(transformation => transformation.blocks).flat();

  // Map block names to block types.
  return blockNames.map(getBlockType);
};

/**
 * Determines whether transform is a "block" type
 * and if so whether it is a "wildcard" transform
 * ie: targets "any" block type
 *
 * @param {Object} t the Block transform object
 *
 * @return {boolean} whether transform is a wildcard transform
 */
const isWildcardBlockTransform = t => t && t.type === 'block' && Array.isArray(t.blocks) && t.blocks.includes('*');

/**
 * Determines whether the given Block is the core Block which
 * acts as a container Block for other Blocks as part of the
 * Grouping mechanics
 *
 * @param {string} name the name of the Block to test against
 *
 * @return {boolean} whether or not the Block is the container Block type
 */
const isContainerGroupBlock = name => name === getGroupingBlockName();

/**
 * Returns an array of block types that the set of blocks received as argument
 * can be transformed into.
 *
 * @param {Array} blocks Blocks array.
 *
 * @return {Array} Block types that the blocks argument can be transformed to.
 */
function getPossibleBlockTransformations(blocks) {
  if (!blocks.length) {
    return [];
  }
  const blockTypesForFromTransforms = getBlockTypesForPossibleFromTransforms(blocks);
  const blockTypesForToTransforms = getBlockTypesForPossibleToTransforms(blocks);
  return [...new Set([...blockTypesForFromTransforms, ...blockTypesForToTransforms])];
}

/**
 * Given an array of transforms, returns the highest-priority transform where
 * the predicate function returns a truthy value. A higher-priority transform
 * is one with a lower priority value (i.e. first in priority order). Returns
 * null if the transforms set is empty or the predicate function returns a
 * falsey value for all entries.
 *
 * @param {Object[]} transforms Transforms to search.
 * @param {Function} predicate  Function returning true on matching transform.
 *
 * @return {?Object} Highest-priority transform candidate.
 */
function findTransform(transforms, predicate) {
  // The hooks library already has built-in mechanisms for managing priority
  // queue, so leverage via locally-defined instance.
  const hooks = (0,hooks_build_module/* createHooks */.FF)();
  for (let i = 0; i < transforms.length; i++) {
    const candidate = transforms[i];
    if (predicate(candidate)) {
      hooks.addFilter('transform', 'transform/' + i.toString(), result => result ? result : candidate, candidate.priority);
    }
  }

  // Filter name is arbitrarily chosen but consistent with above aggregation.
  return hooks.applyFilters('transform', null);
}

/**
 * Returns normal block transforms for a given transform direction, optionally
 * for a specific block by name, or an empty array if there are no transforms.
 * If no block name is provided, returns transforms for all blocks. A normal
 * transform object includes `blockName` as a property.
 *
 * @param {string}        direction       Transform direction ("to", "from").
 * @param {string|Object} blockTypeOrName Block type or name.
 *
 * @return {Array} Block transforms for direction.
 */
function getBlockTransforms(direction, blockTypeOrName) {
  // When retrieving transforms for all block types, recurse into self.
  if (blockTypeOrName === undefined) {
    return getBlockTypes().map(({
      name
    }) => getBlockTransforms(direction, name)).flat();
  }

  // Validate that block type exists and has array of direction.
  const blockType = utils_normalizeBlockType(blockTypeOrName);
  const {
    name: blockName,
    transforms
  } = blockType || {};
  if (!transforms || !Array.isArray(transforms[direction])) {
    return [];
  }
  const usingMobileTransformations = transforms.supportedMobileTransforms && Array.isArray(transforms.supportedMobileTransforms);
  const filteredTransforms = usingMobileTransformations ? transforms[direction].filter(t => {
    if (t.type === 'raw') {
      return true;
    }
    if (!t.blocks || !t.blocks.length) {
      return false;
    }
    if (isWildcardBlockTransform(t)) {
      return true;
    }
    return t.blocks.every(transformBlockName => transforms.supportedMobileTransforms.includes(transformBlockName));
  }) : transforms[direction];

  // Map transforms to normal form.
  return filteredTransforms.map(transform => ({
    ...transform,
    blockName,
    usingMobileTransformations
  }));
}

/**
 * Checks that a given transforms isMatch method passes for given source blocks.
 *
 * @param {Object} transform A transform object.
 * @param {Array}  blocks    Blocks array.
 *
 * @return {boolean} True if given blocks are a match for the transform.
 */
function maybeCheckTransformIsMatch(transform, blocks) {
  if (typeof transform.isMatch !== 'function') {
    return true;
  }
  const sourceBlock = blocks[0];
  const attributes = transform.isMultiBlock ? blocks.map(block => block.attributes) : sourceBlock.attributes;
  const block = transform.isMultiBlock ? blocks : sourceBlock;
  return transform.isMatch(attributes, block);
}

/**
 * Switch one or more blocks into one or more blocks of the new block type.
 *
 * @param {Array|Object} blocks Blocks array or block object.
 * @param {string}       name   Block name.
 *
 * @return {?Array} Array of blocks or null.
 */
function switchToBlockType(blocks, name) {
  const blocksArray = Array.isArray(blocks) ? blocks : [blocks];
  const isMultiBlock = blocksArray.length > 1;
  const firstBlock = blocksArray[0];
  const sourceName = firstBlock.name;

  // Find the right transformation by giving priority to the "to"
  // transformation.
  const transformationsFrom = getBlockTransforms('from', name);
  const transformationsTo = getBlockTransforms('to', sourceName);
  const transformation = findTransform(transformationsTo, t => t.type === 'block' && (isWildcardBlockTransform(t) || t.blocks.indexOf(name) !== -1) && (!isMultiBlock || t.isMultiBlock) && maybeCheckTransformIsMatch(t, blocksArray)) || findTransform(transformationsFrom, t => t.type === 'block' && (isWildcardBlockTransform(t) || t.blocks.indexOf(sourceName) !== -1) && (!isMultiBlock || t.isMultiBlock) && maybeCheckTransformIsMatch(t, blocksArray));

  // Stop if there is no valid transformation.
  if (!transformation) {
    return null;
  }
  let transformationResults;
  if (transformation.isMultiBlock) {
    if ('__experimentalConvert' in transformation) {
      transformationResults = transformation.__experimentalConvert(blocksArray);
    } else {
      transformationResults = transformation.transform(blocksArray.map(currentBlock => currentBlock.attributes), blocksArray.map(currentBlock => currentBlock.innerBlocks));
    }
  } else if ('__experimentalConvert' in transformation) {
    transformationResults = transformation.__experimentalConvert(firstBlock);
  } else {
    transformationResults = transformation.transform(firstBlock.attributes, firstBlock.innerBlocks);
  }

  // Ensure that the transformation function returned an object or an array
  // of objects.
  if (transformationResults === null || typeof transformationResults !== 'object') {
    return null;
  }

  // If the transformation function returned a single object, we want to work
  // with an array instead.
  transformationResults = Array.isArray(transformationResults) ? transformationResults : [transformationResults];

  // Ensure that every block object returned by the transformation has a
  // valid block type.
  if (transformationResults.some(result => !getBlockType(result.name))) {
    return null;
  }
  const hasSwitchedBlock = transformationResults.some(result => result.name === name);

  // Ensure that at least one block object returned by the transformation has
  // the expected "destination" block type.
  if (!hasSwitchedBlock) {
    return null;
  }
  const ret = transformationResults.map((result, index, results) => {
    /**
     * Filters an individual transform result from block transformation.
     * All of the original blocks are passed, since transformations are
     * many-to-many, not one-to-one.
     *
     * @param {Object}   transformedBlock The transformed block.
     * @param {Object[]} blocks           Original blocks transformed.
     * @param {Object[]} index            Index of the transformed block on the array of results.
     * @param {Object[]} results          An array all the blocks that resulted from the transformation.
     */
    return (0,hooks_build_module/* applyFilters */.W5)('blocks.switchToBlockType.transformedBlock', result, blocks, index, results);
  });
  return ret;
}

/**
 * Create a block object from the example API.
 *
 * @param {string} name
 * @param {Object} example
 *
 * @return {Object} block.
 */
const getBlockFromExample = (name, example) => {
  try {
    var _example$innerBlocks;
    return createBlock(name, example.attributes, ((_example$innerBlocks = example.innerBlocks) !== null && _example$innerBlocks !== void 0 ? _example$innerBlocks : []).map(innerBlock => getBlockFromExample(innerBlock.name, innerBlock)));
  } catch {
    return createBlock('core/missing', {
      originalName: name,
      originalContent: '',
      originalUndelimitedContent: ''
    });
  }
};
//# sourceMappingURL=factory.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-serialization-default-parser@5.10.0/node_modules/@wordpress/block-serialization-default-parser/build-module/index.js
/**
 * @type {string}
 */
let build_module_document;
/**
 * @type {number}
 */
let offset;
/**
 * @type {ParsedBlock[]}
 */
let output;
/**
 * @type {ParsedFrame[]}
 */
let stack;

/**
 * @typedef {Object|null} Attributes
 */

/**
 * @typedef {Object} ParsedBlock
 * @property {string|null}        blockName    Block name.
 * @property {Attributes}         attrs        Block attributes.
 * @property {ParsedBlock[]}      innerBlocks  Inner blocks.
 * @property {string}             innerHTML    Inner HTML.
 * @property {Array<string|null>} innerContent Inner content.
 */

/**
 * @typedef {Object} ParsedFrame
 * @property {ParsedBlock} block            Block.
 * @property {number}      tokenStart       Token start.
 * @property {number}      tokenLength      Token length.
 * @property {number}      prevOffset       Previous offset.
 * @property {number|null} leadingHtmlStart Leading HTML start.
 */

/**
 * @typedef {'no-more-tokens'|'void-block'|'block-opener'|'block-closer'} TokenType
 */

/**
 * @typedef {[TokenType, string, Attributes, number, number]} Token
 */

/**
 * Matches block comment delimiters
 *
 * While most of this pattern is straightforward the attribute parsing
 * incorporates a tricks to make sure we don't choke on specific input
 *
 *  - since JavaScript has no possessive quantifier or atomic grouping
 *    we are emulating it with a trick
 *
 *    we want a possessive quantifier or atomic group to prevent backtracking
 *    on the `}`s should we fail to match the remainder of the pattern
 *
 *    we can emulate this with a positive lookahead and back reference
 *    (a++)*c === ((?=(a+))\1)*c
 *
 *    let's examine an example:
 *      - /(a+)*c/.test('aaaaaaaaaaaaad') fails after over 49,000 steps
 *      - /(a++)*c/.test('aaaaaaaaaaaaad') fails after 85 steps
 *      - /(?>a+)*c/.test('aaaaaaaaaaaaad') fails after 126 steps
 *
 *    this is because the possessive `++` and the atomic group `(?>)`
 *    tell the engine that all those `a`s belong together as a single group
 *    and so it won't split it up when stepping backwards to try and match
 *
 *    if we use /((?=(a+))\1)*c/ then we get the same behavior as the atomic group
 *    or possessive and prevent the backtracking because the `a+` is matched but
 *    not captured. thus, we find the long string of `a`s and remember it, then
 *    reference it as a whole unit inside our pattern
 *
 *    @see http://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead
 *    @see http://blog.stevenlevithan.com/archives/mimic-atomic-groups
 *    @see https://javascript.info/regexp-infinite-backtracking-problem
 *
 *    once browsers reliably support atomic grouping or possessive
 *    quantifiers natively we should remove this trick and simplify
 *
 * @type {RegExp}
 *
 * @since 3.8.0
 * @since 4.6.1 added optimization to prevent backtracking on attribute parsing
 */
const tokenizer = /<!--\s+(\/)?wp:([a-z][a-z0-9_-]*\/)?([a-z][a-z0-9_-]*)\s+({(?:(?=([^}]+|}+(?=})|(?!}\s+\/?-->)[^])*)\5|[^]*?)}\s+)?(\/)?-->/g;

/**
 * Constructs a block object.
 *
 * @param {string|null}   blockName
 * @param {Attributes}    attrs
 * @param {ParsedBlock[]} innerBlocks
 * @param {string}        innerHTML
 * @param {string[]}      innerContent
 * @return {ParsedBlock} The block object.
 */
function Block(blockName, attrs, innerBlocks, innerHTML, innerContent) {
  return {
    blockName,
    attrs,
    innerBlocks,
    innerHTML,
    innerContent
  };
}

/**
 * Constructs a freeform block object.
 *
 * @param {string} innerHTML
 * @return {ParsedBlock} The freeform block object.
 */
function Freeform(innerHTML) {
  return Block(null, {}, [], innerHTML, [innerHTML]);
}

/**
 * Constructs a frame object.
 *
 * @param {ParsedBlock} block
 * @param {number}      tokenStart
 * @param {number}      tokenLength
 * @param {number}      prevOffset
 * @param {number|null} leadingHtmlStart
 * @return {ParsedFrame} The frame object.
 */
function Frame(block, tokenStart, tokenLength, prevOffset, leadingHtmlStart) {
  return {
    block,
    tokenStart,
    tokenLength,
    prevOffset: prevOffset || tokenStart + tokenLength,
    leadingHtmlStart
  };
}

/**
 * Parser function, that converts input HTML into a block based structure.
 *
 * @param {string} doc The HTML document to parse.
 *
 * @example
 * Input post:
 * ```html
 * <!-- wp:columns {"columns":3} -->
 * <div class="wp-block-columns has-3-columns"><!-- wp:column -->
 * <div class="wp-block-column"><!-- wp:paragraph -->
 * <p>Left</p>
 * <!-- /wp:paragraph --></div>
 * <!-- /wp:column -->
 *
 * <!-- wp:column -->
 * <div class="wp-block-column"><!-- wp:paragraph -->
 * <p><strong>Middle</strong></p>
 * <!-- /wp:paragraph --></div>
 * <!-- /wp:column -->
 *
 * <!-- wp:column -->
 * <div class="wp-block-column"></div>
 * <!-- /wp:column --></div>
 * <!-- /wp:columns -->
 * ```
 *
 * Parsing code:
 * ```js
 * import { parse } from '@wordpress/block-serialization-default-parser';
 *
 * parse( post ) === [
 *     {
 *         blockName: "core/columns",
 *         attrs: {
 *             columns: 3
 *         },
 *         innerBlocks: [
 *             {
 *                 blockName: "core/column",
 *                 attrs: null,
 *                 innerBlocks: [
 *                     {
 *                         blockName: "core/paragraph",
 *                         attrs: null,
 *                         innerBlocks: [],
 *                         innerHTML: "\n<p>Left</p>\n"
 *                     }
 *                 ],
 *                 innerHTML: '\n<div class="wp-block-column"></div>\n'
 *             },
 *             {
 *                 blockName: "core/column",
 *                 attrs: null,
 *                 innerBlocks: [
 *                     {
 *                         blockName: "core/paragraph",
 *                         attrs: null,
 *                         innerBlocks: [],
 *                         innerHTML: "\n<p><strong>Middle</strong></p>\n"
 *                     }
 *                 ],
 *                 innerHTML: '\n<div class="wp-block-column"></div>\n'
 *             },
 *             {
 *                 blockName: "core/column",
 *                 attrs: null,
 *                 innerBlocks: [],
 *                 innerHTML: '\n<div class="wp-block-column"></div>\n'
 *             }
 *         ],
 *         innerHTML: '\n<div class="wp-block-columns has-3-columns">\n\n\n\n</div>\n'
 *     }
 * ];
 * ```
 * @return {ParsedBlock[]} A block-based representation of the input HTML.
 */
const parse = doc => {
  build_module_document = doc;
  offset = 0;
  output = [];
  stack = [];
  tokenizer.lastIndex = 0;
  do {
    // twiddle our thumbs
  } while (proceed());
  return output;
};

/**
 * Parses the next token in the input document.
 *
 * @return {boolean} Returns true when there is more tokens to parse.
 */
function proceed() {
  const stackDepth = stack.length;
  const next = nextToken();
  const [tokenType, blockName, attrs, startOffset, tokenLength] = next;

  // We may have some HTML soup before the next block.
  const leadingHtmlStart = startOffset > offset ? offset : null;
  switch (tokenType) {
    case 'no-more-tokens':
      // If not in a block then flush output.
      if (0 === stackDepth) {
        addFreeform();
        return false;
      }

      // Otherwise we have a problem
      // This is an error
      // we have options
      //  - treat it all as freeform text
      //  - assume an implicit closer (easiest when not nesting)

      // For the easy case we'll assume an implicit closer.
      if (1 === stackDepth) {
        addBlockFromStack();
        return false;
      }

      // For the nested case where it's more difficult we'll
      // have to assume that multiple closers are missing
      // and so we'll collapse the whole stack piecewise.
      while (0 < stack.length) {
        addBlockFromStack();
      }
      return false;
    case 'void-block':
      // easy case is if we stumbled upon a void block
      // in the top-level of the document.
      if (0 === stackDepth) {
        if (null !== leadingHtmlStart) {
          output.push(Freeform(build_module_document.substr(leadingHtmlStart, startOffset - leadingHtmlStart)));
        }
        output.push(Block(blockName, attrs, [], '', []));
        offset = startOffset + tokenLength;
        return true;
      }

      // Otherwise we found an inner block.
      addInnerBlock(Block(blockName, attrs, [], '', []), startOffset, tokenLength);
      offset = startOffset + tokenLength;
      return true;
    case 'block-opener':
      // Track all newly-opened blocks on the stack.
      stack.push(Frame(Block(blockName, attrs, [], '', []), startOffset, tokenLength, startOffset + tokenLength, leadingHtmlStart));
      offset = startOffset + tokenLength;
      return true;
    case 'block-closer':
      // If we're missing an opener we're in trouble
      // This is an error.
      if (0 === stackDepth) {
        // We have options
        //  - assume an implicit opener
        //  - assume _this_ is the opener
        // - give up and close out the document.
        addFreeform();
        return false;
      }

      // If we're not nesting then this is easy - close the block.
      if (1 === stackDepth) {
        addBlockFromStack(startOffset);
        offset = startOffset + tokenLength;
        return true;
      }

      // Otherwise we're nested and we have to close out the current
      // block and add it as a innerBlock to the parent.
      const stackTop = /** @type {ParsedFrame} */stack.pop();
      const html = build_module_document.substr(stackTop.prevOffset, startOffset - stackTop.prevOffset);
      stackTop.block.innerHTML += html;
      stackTop.block.innerContent.push(html);
      stackTop.prevOffset = startOffset + tokenLength;
      addInnerBlock(stackTop.block, stackTop.tokenStart, stackTop.tokenLength, startOffset + tokenLength);
      offset = startOffset + tokenLength;
      return true;
    default:
      // This is an error.
      addFreeform();
      return false;
  }
}

/**
 * Parse JSON if valid, otherwise return null
 *
 * Note that JSON coming from the block comment
 * delimiters is constrained to be an object
 * and cannot be things like `true` or `null`
 *
 * @param {string} input JSON input string to parse
 * @return {Object|null} parsed JSON if valid
 */
function parseJSON(input) {
  try {
    return JSON.parse(input);
  } catch (e) {
    return null;
  }
}

/**
 * Finds the next token in the document.
 *
 * @return {Token} The next matched token.
 */
function nextToken() {
  // Aye the magic
  // we're using a single RegExp to tokenize the block comment delimiters
  // we're also using a trick here because the only difference between a
  // block opener and a block closer is the leading `/` before `wp:` (and
  // a closer has no attributes). we can trap them both and process the
  // match back in JavaScript to see which one it was.
  const matches = tokenizer.exec(build_module_document);

  // We have no more tokens.
  if (null === matches) {
    return ['no-more-tokens', '', null, 0, 0];
  }
  const startedAt = matches.index;
  const [match, closerMatch, namespaceMatch, nameMatch, attrsMatch /* Internal/unused. */,, voidMatch] = matches;
  const length = match.length;
  const isCloser = !!closerMatch;
  const isVoid = !!voidMatch;
  const namespace = namespaceMatch || 'core/';
  const name = namespace + nameMatch;
  const hasAttrs = !!attrsMatch;
  const attrs = hasAttrs ? parseJSON(attrsMatch) : {};

  // This state isn't allowed
  // This is an error.
  if (isCloser && (isVoid || hasAttrs)) {
    // We can ignore them since they don't hurt anything
    // we may warn against this at some point or reject it.
  }
  if (isVoid) {
    return ['void-block', name, attrs, startedAt, length];
  }
  if (isCloser) {
    return ['block-closer', name, null, startedAt, length];
  }
  return ['block-opener', name, attrs, startedAt, length];
}

/**
 * Adds a freeform block to the output.
 *
 * @param {number} [rawLength]
 */
function addFreeform(rawLength) {
  const length = rawLength ? rawLength : build_module_document.length - offset;
  if (0 === length) {
    return;
  }
  output.push(Freeform(build_module_document.substr(offset, length)));
}

/**
 * Adds inner block to the parent block.
 *
 * @param {ParsedBlock} block
 * @param {number}      tokenStart
 * @param {number}      tokenLength
 * @param {number}      [lastOffset]
 */
function addInnerBlock(block, tokenStart, tokenLength, lastOffset) {
  const parent = stack[stack.length - 1];
  parent.block.innerBlocks.push(block);
  const html = build_module_document.substr(parent.prevOffset, tokenStart - parent.prevOffset);
  if (html) {
    parent.block.innerHTML += html;
    parent.block.innerContent.push(html);
  }
  parent.block.innerContent.push(null);
  parent.prevOffset = lastOffset ? lastOffset : tokenStart + tokenLength;
}

/**
 * Adds block from the stack to the output.
 *
 * @param {number} [endOffset]
 */
function addBlockFromStack(endOffset) {
  const {
    block,
    leadingHtmlStart,
    prevOffset,
    tokenStart
  } = /** @type {ParsedFrame} */stack.pop();
  const html = endOffset ? build_module_document.substr(prevOffset, endOffset - prevOffset) : build_module_document.substr(prevOffset);
  if (html) {
    block.innerHTML += html;
    block.innerContent.push(html);
  }
  if (null !== leadingHtmlStart) {
    output.push(Freeform(build_module_document.substr(leadingHtmlStart, tokenStart - leadingHtmlStart)));
  }
  output.push(block);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+autop@4.10.0/node_modules/@wordpress/autop/build-module/index.js
/**
 * The regular expression for an HTML element.
 */
const htmlSplitRegex = (() => {
  /* eslint-disable no-multi-spaces */
  const comments = '!' +
  // Start of comment, after the <.
  '(?:' +
  // Unroll the loop: Consume everything until --> is found.
  '-(?!->)' +
  // Dash not followed by end of comment.
  '[^\\-]*' +
  // Consume non-dashes.
  ')*' +
  // Loop possessively.
  '(?:-->)?'; // End of comment. If not found, match all input.

  const cdata = '!\\[CDATA\\[' +
  // Start of comment, after the <.
  '[^\\]]*' +
  // Consume non-].
  '(?:' +
  // Unroll the loop: Consume everything until ]]> is found.
  '](?!]>)' +
  // One ] not followed by end of comment.
  '[^\\]]*' +
  // Consume non-].
  ')*?' +
  // Loop possessively.
  '(?:]]>)?'; // End of comment. If not found, match all input.

  const escaped = '(?=' +
  // Is the element escaped?
  '!--' + '|' + '!\\[CDATA\\[' + ')' + '((?=!-)' +
  // If yes, which type?
  comments + '|' + cdata + ')';
  const regex = '(' +
  // Capture the entire match.
  '<' +
  // Find start of element.
  '(' +
  // Conditional expression follows.
  escaped +
  // Find end of escaped element.
  '|' +
  // ... else ...
  '[^>]*>?' +
  // Find end of normal element.
  ')' + ')';
  return new RegExp(regex);
  /* eslint-enable no-multi-spaces */
})();

/**
 * Separate HTML elements and comments from the text.
 *
 * @param input The text which has to be formatted.
 *
 * @return The formatted text.
 */
function htmlSplit(input) {
  const parts = [];
  let workingInput = input;
  let match;
  while (match = workingInput.match(htmlSplitRegex)) {
    // The `match` result, when invoked on a RegExp with the `g` flag (`/foo/g`) will not include `index`.
    // If the `g` flag is omitted, `index` is included.
    // `htmlSplitRegex` does not have the `g` flag so we can assert it will have an index number.
    // Assert `match.index` is a number.
    const index = match.index;
    parts.push(workingInput.slice(0, index));
    parts.push(match[0]);
    workingInput = workingInput.slice(index + match[0].length);
  }
  if (workingInput.length) {
    parts.push(workingInput);
  }
  return parts;
}

/**
 * Replace characters or phrases within HTML elements only.
 *
 * @param haystack     The text which has to be formatted.
 * @param replacePairs In the form {from: 'to', …}.
 *
 * @return The formatted text.
 */
function replaceInHtmlTags(haystack, replacePairs) {
  // Find all elements.
  const textArr = htmlSplit(haystack);
  let changed = false;

  // Extract all needles.
  const needles = Object.keys(replacePairs);

  // Loop through delimiters (elements) only.
  for (let i = 1; i < textArr.length; i += 2) {
    for (let j = 0; j < needles.length; j++) {
      const needle = needles[j];
      if (-1 !== textArr[i].indexOf(needle)) {
        textArr[i] = textArr[i].replace(new RegExp(needle, 'g'), replacePairs[needle]);
        changed = true;
        // After one strtr() break out of the foreach loop and look at next element.
        break;
      }
    }
  }
  if (changed) {
    haystack = textArr.join('');
  }
  return haystack;
}

/**
 * Replaces double line-breaks with paragraph elements.
 *
 * A group of regex replaces used to identify text formatted with newlines and
 * replace double line-breaks with HTML paragraph tags. The remaining line-
 * breaks after conversion become `<br />` tags, unless br is set to 'false'.
 *
 * @param text The text which has to be formatted.
 * @param br   Optional. If set, will convert all remaining line-
 *             breaks after paragraphing. Default true.
 *
 * @example
 *```js
 * import { autop } from '@wordpress/autop';
 * autop( 'my text' ); // "<p>my text</p>"
 * ```
 *
 * @return Text which has been converted into paragraph tags.
 */
function autop(text, br = true) {
  const preTags = [];
  if (text.trim() === '') {
    return '';
  }

  // Just to make things a little easier, pad the end.
  text = text + '\n';

  /*
   * Pre tags shouldn't be touched by autop.
   * Replace pre tags with placeholders and bring them back after autop.
   */
  if (text.indexOf('<pre') !== -1) {
    const textParts = text.split('</pre>');
    const lastText = textParts.pop();
    text = '';
    for (let i = 0; i < textParts.length; i++) {
      const textPart = textParts[i];
      const start = textPart.indexOf('<pre');

      // Malformed html?
      if (start === -1) {
        text += textPart;
        continue;
      }
      const name = '<pre wp-pre-tag-' + i + '></pre>';
      preTags.push([name, textPart.substr(start) + '</pre>']);
      text += textPart.substr(0, start) + name;
    }
    text += lastText;
  }
  // Change multiple <br>s into two line breaks, which will turn into paragraphs.
  text = text.replace(/<br\s*\/?>\s*<br\s*\/?>/g, '\n\n');
  const allBlocks = '(?:table|thead|tfoot|caption|col|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|form|map|area|blockquote|address|math|style|p|h[1-6]|hr|fieldset|legend|section|article|aside|hgroup|header|footer|nav|figure|figcaption|details|menu|summary)';

  // Add a double line break above block-level opening tags.
  text = text.replace(new RegExp('(<' + allBlocks + '[\\s/>])', 'g'), '\n\n$1');

  // Add a double line break below block-level closing tags.
  text = text.replace(new RegExp('(</' + allBlocks + '>)', 'g'), '$1\n\n');

  // Standardize newline characters to "\n".
  text = text.replace(/\r\n|\r/g, '\n');

  // Find newlines in all elements and add placeholders.
  text = replaceInHtmlTags(text, {
    '\n': ' <!-- wpnl --> '
  });

  // Collapse line breaks before and after <option> elements so they don't get autop'd.
  if (text.indexOf('<option') !== -1) {
    text = text.replace(/\s*<option/g, '<option');
    text = text.replace(/<\/option>\s*/g, '</option>');
  }

  /*
   * Collapse line breaks inside <object> elements, before <param> and <embed> elements
   * so they don't get autop'd.
   */
  if (text.indexOf('</object>') !== -1) {
    text = text.replace(/(<object[^>]*>)\s*/g, '$1');
    text = text.replace(/\s*<\/object>/g, '</object>');
    text = text.replace(/\s*(<\/?(?:param|embed)[^>]*>)\s*/g, '$1');
  }

  /*
   * Collapse line breaks inside <audio> and <video> elements,
   * before and after <source> and <track> elements.
   */
  if (text.indexOf('<source') !== -1 || text.indexOf('<track') !== -1) {
    text = text.replace(/([<\[](?:audio|video)[^>\]]*[>\]])\s*/g, '$1');
    text = text.replace(/\s*([<\[]\/(?:audio|video)[>\]])/g, '$1');
    text = text.replace(/\s*(<(?:source|track)[^>]*>)\s*/g, '$1');
  }

  // Collapse line breaks before and after <figcaption> elements.
  if (text.indexOf('<figcaption') !== -1) {
    text = text.replace(/\s*(<figcaption[^>]*>)/, '$1');
    text = text.replace(/<\/figcaption>\s*/, '</figcaption>');
  }

  // Remove more than two contiguous line breaks.
  text = text.replace(/\n\n+/g, '\n\n');

  // Split up the contents into an array of strings, separated by double line breaks.
  const texts = text.split(/\n\s*\n/).filter(Boolean);

  // Reset text prior to rebuilding.
  text = '';

  // Rebuild the content as a string, wrapping every bit with a <p>.
  texts.forEach(textPiece => {
    text += '<p>' + textPiece.replace(/^\n*|\n*$/g, '') + '</p>\n';
  });

  // Under certain strange conditions it could create a P of entirely whitespace.
  text = text.replace(/<p>\s*<\/p>/g, '');

  // Add a closing <p> inside <div>, <address>, or <form> tag if missing.
  text = text.replace(/<p>([^<]+)<\/(div|address|form)>/g, '<p>$1</p></$2>');

  // If an opening or closing block element tag is wrapped in a <p>, unwrap it.
  text = text.replace(new RegExp('<p>\\s*(</?' + allBlocks + '[^>]*>)\\s*</p>', 'g'), '$1');

  // In some cases <li> may get wrapped in <p>, fix them.
  text = text.replace(/<p>(<li.+?)<\/p>/g, '$1');

  // If a <blockquote> is wrapped with a <p>, move it inside the <blockquote>.
  text = text.replace(/<p><blockquote([^>]*)>/gi, '<blockquote$1><p>');
  text = text.replace(/<\/blockquote><\/p>/g, '</p></blockquote>');

  // If an opening or closing block element tag is preceded by an opening <p> tag, remove it.
  text = text.replace(new RegExp('<p>\\s*(</?' + allBlocks + '[^>]*>)', 'g'), '$1');

  // If an opening or closing block element tag is followed by a closing <p> tag, remove it.
  text = text.replace(new RegExp('(</?' + allBlocks + '[^>]*>)\\s*</p>', 'g'), '$1');

  // Optionally insert line breaks.
  if (br) {
    // Replace newlines that shouldn't be touched with a placeholder.
    text = text.replace(/<(script|style).*?<\/\\1>/g, match => match[0].replace(/\n/g, '<WPPreserveNewline />'));

    // Normalize <br>
    text = text.replace(/<br>|<br\/>/g, '<br />');

    // Replace any new line characters that aren't preceded by a <br /> with a <br />.
    text = text.replace(/(<br \/>)?\s*\n/g, (a, b) => b ? a : '<br />\n');

    // Replace newline placeholders with newlines.
    text = text.replace(/<WPPreserveNewline \/>/g, '\n');
  }

  // If a <br /> tag is after an opening or closing block tag, remove it.
  text = text.replace(new RegExp('(</?' + allBlocks + '[^>]*>)\\s*<br />', 'g'), '$1');

  // If a <br /> tag is before a subset of opening or closing block tags, remove it.
  text = text.replace(/<br \/>(\s*<\/?(?:p|li|div|dl|dd|dt|th|pre|td|ul|ol)[^>]*>)/g, '$1');
  text = text.replace(/\n<\/p>$/g, '</p>');

  // Replace placeholder <pre> tags with their original content.
  preTags.forEach(preTag => {
    const [name, original] = preTag;
    text = text.replace(name, original);
  });

  // Restore newlines in all elements.
  if (-1 !== text.indexOf('<!-- wpnl -->')) {
    text = text.replace(/\s?<!-- wpnl -->\s?/g, '\n');
  }
  return text;
}

/**
 * Replaces `<p>` tags with two line breaks. "Opposite" of autop().
 *
 * Replaces `<p>` tags with two line breaks except where the `<p>` has attributes.
 * Unifies whitespace. Indents `<li>`, `<dt>` and `<dd>` for better readability.
 *
 * @param html The content from the editor.
 *
 * @example
 * ```js
 * import { removep } from '@wordpress/autop';
 * removep( '<p>my text</p>' ); // "my text"
 * ```
 *
 * @return The content with stripped paragraph tags.
 */
function build_module_removep(html) {
  const blocklist = 'blockquote|ul|ol|li|dl|dt|dd|table|thead|tbody|tfoot|tr|th|td|h[1-6]|fieldset|figure';
  const blocklist1 = blocklist + '|div|p';
  const blocklist2 = blocklist + '|pre';
  const preserve = [];
  let preserveLinebreaks = false;
  let preserveBr = false;
  if (!html) {
    return '';
  }

  // Protect script and style tags.
  if (html.indexOf('<script') !== -1 || html.indexOf('<style') !== -1) {
    html = html.replace(/<(script|style)[^>]*>[\s\S]*?<\/\1>/g, match => {
      preserve.push(match);
      return '<wp-preserve>';
    });
  }

  // Protect pre tags.
  if (html.indexOf('<pre') !== -1) {
    preserveLinebreaks = true;
    html = html.replace(/<pre[^>]*>[\s\S]+?<\/pre>/g, a => {
      a = a.replace(/<br ?\/?>(\r\n|\n)?/g, '<wp-line-break>');
      a = a.replace(/<\/?p( [^>]*)?>(\r\n|\n)?/g, '<wp-line-break>');
      return a.replace(/\r?\n/g, '<wp-line-break>');
    });
  }

  // Remove line breaks but keep <br> tags inside image captions.
  if (html.indexOf('[caption') !== -1) {
    preserveBr = true;
    html = html.replace(/\[caption[\s\S]+?\[\/caption\]/g, a => {
      return a.replace(/<br([^>]*)>/g, '<wp-temp-br$1>').replace(/[\r\n\t]+/, '');
    });
  }

  // Normalize white space characters before and after block tags.
  html = html.replace(new RegExp('\\s*</(' + blocklist1 + ')>\\s*', 'g'), '</$1>\n');
  html = html.replace(new RegExp('\\s*<((?:' + blocklist1 + ')(?: [^>]*)?)>', 'g'), '\n<$1>');

  // Mark </p> if it has any attributes.
  html = html.replace(/(<p [^>]+>[\s\S]*?)<\/p>/g, '$1</p#>');

  // Preserve the first <p> inside a <div>.
  html = html.replace(/<div( [^>]*)?>\s*<p>/gi, '<div$1>\n\n');

  // Remove paragraph tags.
  html = html.replace(/\s*<p>/gi, '');
  html = html.replace(/\s*<\/p>\s*/gi, '\n\n');

  // Normalize white space chars and remove multiple line breaks.
  html = html.replace(/\n[\s\u00a0]+\n/g, '\n\n');

  // Replace <br> tags with line breaks.
  html = html.replace(/(\s*)<br ?\/?>\s*/gi, (_, space) => {
    if (space && space.indexOf('\n') !== -1) {
      return '\n\n';
    }
    return '\n';
  });

  // Fix line breaks around <div>.
  html = html.replace(/\s*<div/g, '\n<div');
  html = html.replace(/<\/div>\s*/g, '</div>\n');

  // Fix line breaks around caption shortcodes.
  html = html.replace(/\s*\[caption([^\[]+)\[\/caption\]\s*/gi, '\n\n[caption$1[/caption]\n\n');
  html = html.replace(/caption\]\n\n+\[caption/g, 'caption]\n\n[caption');

  // Pad block elements tags with a line break.
  html = html.replace(new RegExp('\\s*<((?:' + blocklist2 + ')(?: [^>]*)?)\\s*>', 'g'), '\n<$1>');
  html = html.replace(new RegExp('\\s*</(' + blocklist2 + ')>\\s*', 'g'), '</$1>\n');

  // Indent <li>, <dt> and <dd> tags.
  html = html.replace(/<((li|dt|dd)[^>]*)>/g, ' \t<$1>');

  // Fix line breaks around <select> and <option>.
  if (html.indexOf('<option') !== -1) {
    html = html.replace(/\s*<option/g, '\n<option');
    html = html.replace(/\s*<\/select>/g, '\n</select>');
  }

  // Pad <hr> with two line breaks.
  if (html.indexOf('<hr') !== -1) {
    html = html.replace(/\s*<hr( [^>]*)?>\s*/g, '\n\n<hr$1>\n\n');
  }

  // Remove line breaks in <object> tags.
  if (html.indexOf('<object') !== -1) {
    html = html.replace(/<object[\s\S]+?<\/object>/g, a => {
      return a.replace(/[\r\n]+/g, '');
    });
  }

  // Unmark special paragraph closing tags.
  html = html.replace(/<\/p#>/g, '</p>\n');

  // Pad remaining <p> tags whit a line break.
  html = html.replace(/\s*(<p [^>]+>[\s\S]*?<\/p>)/g, '\n$1');

  // Trim.
  html = html.replace(/^\s+/, '');
  html = html.replace(/[\s\u00a0]+$/, '');
  if (preserveLinebreaks) {
    html = html.replace(/<wp-line-break>/g, '\n');
  }
  if (preserveBr) {
    html = html.replace(/<wp-temp-br([^>]*)>/g, '<br$1>');
  }

  // Restore preserved tags.
  if (preserve.length) {
    html = html.replace(/<wp-preserve>/g, () => {
      return preserve.shift();
    });
  }
  return html;
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/raw-html.js
var raw_html = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/raw-html.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/serialize.js
var serialize = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/serialize.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.10.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js + 1 modules
var is_shallow_equal_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.10.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/parser/serialize-raw-block.js
/**
 * Internal dependencies
 */


/**
 * @typedef {Object}   Options                   Serialization options.
 * @property {boolean} [isCommentDelimited=true] Whether to output HTML comments around blocks.
 */

/** @typedef {import("./").WPRawBlock} WPRawBlock */

/**
 * Serializes a block node into the native HTML-comment-powered block format.
 * CAVEAT: This function is intended for re-serializing blocks as parsed by
 * valid parsers and skips any validation steps. This is NOT a generic
 * serialization function for in-memory blocks. For most purposes, see the
 * following functions available in the `@wordpress/blocks` package:
 *
 * @see serializeBlock
 * @see serialize
 *
 * For more on the format of block nodes as returned by valid parsers:
 *
 * @see `@wordpress/block-serialization-default-parser` package
 * @see `@wordpress/block-serialization-spec-parser` package
 *
 * @param {WPRawBlock} rawBlock     A block node as returned by a valid parser.
 * @param {Options}    [options={}] Serialization options.
 *
 * @return {string} An HTML string representing a block.
 */
function serializeRawBlock(rawBlock, options = {}) {
  const {
    isCommentDelimited = true
  } = options;
  const {
    blockName,
    attrs = {},
    innerBlocks = [],
    innerContent = []
  } = rawBlock;
  let childIndex = 0;
  const content = innerContent.map(item =>
  // `null` denotes a nested block, otherwise we have an HTML fragment.
  item !== null ? item : serializeRawBlock(innerBlocks[childIndex++], options)).join('\n').replace(/\n+/g, '\n').trim();
  return isCommentDelimited ? getCommentDelimitedContent(blockName, attrs, content) : content;
}
//# sourceMappingURL=serialize-raw-block.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/serializer.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




/** @typedef {import('./parser').WPBlock} WPBlock */

/**
 * @typedef {Object} WPBlockSerializationOptions Serialization Options.
 *
 * @property {boolean} isInnerBlocks Whether we are serializing inner blocks.
 */

/**
 * Returns the block's default classname from its name.
 *
 * @param {string} blockName The block name.
 *
 * @return {string} The block's default class.
 */

function getBlockDefaultClassName(blockName) {
  // Generated HTML classes for blocks follow the `wp-block-{name}` nomenclature.
  // Blocks provided by WordPress drop the prefixes 'core/' or 'core-' (historically used in 'core-embed/').
  const className = 'wp-block-' + blockName.replace(/\//, '-').replace(/^core-/, '');
  return (0,hooks_build_module/* applyFilters */.W5)('blocks.getBlockDefaultClassName', className, blockName);
}

/**
 * Returns the block's default menu item classname from its name.
 *
 * @param {string} blockName The block name.
 *
 * @return {string} The block's default menu item class.
 */
function getBlockMenuDefaultClassName(blockName) {
  // Generated HTML classes for blocks follow the `editor-block-list-item-{name}` nomenclature.
  // Blocks provided by WordPress drop the prefixes 'core/' or 'core-' (historically used in 'core-embed/').
  const className = 'editor-block-list-item-' + blockName.replace(/\//, '-').replace(/^core-/, '');
  return (0,hooks_build_module/* applyFilters */.W5)('blocks.getBlockMenuDefaultClassName', className, blockName);
}
const blockPropsProvider = {};
const innerBlocksPropsProvider = {};

/**
 * Call within a save function to get the props for the block wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */
function getBlockProps(props = {}) {
  const {
    blockType,
    attributes
  } = blockPropsProvider;
  return getBlockProps.skipFilters ? props : (0,hooks_build_module/* applyFilters */.W5)('blocks.getSaveContent.extraProps', {
    ...props
  }, blockType, attributes);
}

/**
 * Call within a save function to get the props for the inner blocks wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */
function getInnerBlocksProps(props = {}) {
  const {
    innerBlocks
  } = innerBlocksPropsProvider;
  // Allow a different component to be passed to getSaveElement to handle
  // inner blocks, bypassing the default serialisation.
  if (!Array.isArray(innerBlocks)) {
    return {
      ...props,
      children: innerBlocks
    };
  }
  // Value is an array of blocks, so defer to block serializer.
  const html = serializer_serialize(innerBlocks, {
    isInnerBlocks: true
  });
  // Use special-cased raw HTML tag to avoid default escaping.
  const children = /*#__PURE__*/(0,jsx_runtime.jsx)(raw_html/* default */.A, {
    children: html
  });
  return {
    ...props,
    children
  };
}

/**
 * Given a block type containing a save render implementation and attributes, returns the
 * enhanced element to be saved or string when raw HTML expected.
 *
 * @param {string|Object} blockTypeOrName Block type or name.
 * @param {Object}        attributes      Block attributes.
 * @param {?Array}        innerBlocks     Nested blocks.
 *
 * @return {Object|string} Save element or raw HTML string.
 */
function getSaveElement(blockTypeOrName, attributes, innerBlocks = []) {
  const blockType = utils_normalizeBlockType(blockTypeOrName);
  if (!blockType?.save) {
    return null;
  }
  let {
    save
  } = blockType;

  // Component classes are unsupported for save since serialization must
  // occur synchronously. For improved interoperability with higher-order
  // components which often return component class, emulate basic support.
  if (save.prototype instanceof react.Component) {
    const instance = new save({
      attributes
    });
    save = instance.render.bind(instance);
  }
  blockPropsProvider.blockType = blockType;
  blockPropsProvider.attributes = attributes;
  innerBlocksPropsProvider.innerBlocks = innerBlocks;
  let element = save({
    attributes,
    innerBlocks
  });
  if (element !== null && typeof element === 'object' && (0,hooks_build_module/* hasFilter */.FC)('blocks.getSaveContent.extraProps') && !(blockType.apiVersion > 1)) {
    /**
     * Filters the props applied to the block save result element.
     *
     * @param {Object}  props      Props applied to save element.
     * @param {WPBlock} blockType  Block type definition.
     * @param {Object}  attributes Block attributes.
     */
    const props = (0,hooks_build_module/* applyFilters */.W5)('blocks.getSaveContent.extraProps', {
      ...element.props
    }, blockType, attributes);
    if (!(0,is_shallow_equal_build_module/* default */.Ay)(props, element.props)) {
      element = (0,react.cloneElement)(element, props);
    }
  }

  /**
   * Filters the save result of a block during serialization.
   *
   * @param {Element} element    Block save result.
   * @param {WPBlock} blockType  Block type definition.
   * @param {Object}  attributes Block attributes.
   */
  return (0,hooks_build_module/* applyFilters */.W5)('blocks.getSaveElement', element, blockType, attributes);
}

/**
 * Given a block type containing a save render implementation and attributes, returns the
 * static markup to be saved.
 *
 * @param {string|Object} blockTypeOrName Block type or name.
 * @param {Object}        attributes      Block attributes.
 * @param {?Array}        innerBlocks     Nested blocks.
 *
 * @return {string} Save content.
 */
function getSaveContent(blockTypeOrName, attributes, innerBlocks) {
  const blockType = utils_normalizeBlockType(blockTypeOrName);
  return (0,serialize/* default */.Ay)(getSaveElement(blockType, attributes, innerBlocks));
}

/**
 * Returns attributes which are to be saved and serialized into the block
 * comment delimiter.
 *
 * When a block exists in memory it contains as its attributes both those
 * parsed the block comment delimiter _and_ those which matched from the
 * contents of the block.
 *
 * This function returns only those attributes which are needed to persist and
 * which cannot be matched from the block content.
 *
 * @param {Object<string,*>} blockType  Block type.
 * @param {Object<string,*>} attributes Attributes from in-memory block data.
 *
 * @return {Object<string,*>} Subset of attributes for comment serialization.
 */
function getCommentAttributes(blockType, attributes) {
  var _blockType$attributes;
  return Object.entries((_blockType$attributes = blockType.attributes) !== null && _blockType$attributes !== void 0 ? _blockType$attributes : {}).reduce((accumulator, [key, attributeSchema]) => {
    const value = attributes[key];
    // Ignore undefined values.
    if (undefined === value) {
      return accumulator;
    }

    // Ignore all attributes but the ones with an "undefined" source
    // "undefined" source refers to attributes saved in the block comment.
    if (attributeSchema.source !== undefined) {
      return accumulator;
    }

    // Ignore default value.
    if ('default' in attributeSchema && JSON.stringify(attributeSchema.default) === JSON.stringify(value)) {
      return accumulator;
    }

    // Otherwise, include in comment set.
    accumulator[key] = value;
    return accumulator;
  }, {});
}

/**
 * Given an attributes object, returns a string in the serialized attributes
 * format prepared for post content.
 *
 * @param {Object} attributes Attributes object.
 *
 * @return {string} Serialized attributes.
 */
function serializeAttributes(attributes) {
  return JSON.stringify(attributes)
  // Don't break HTML comments.
  .replace(/--/g, '\\u002d\\u002d')

  // Don't break non-standard-compliant tools.
  .replace(/</g, '\\u003c').replace(/>/g, '\\u003e').replace(/&/g, '\\u0026')

  // Bypass server stripslashes behavior which would unescape stringify's
  // escaping of quotation mark.
  //
  // See: https://developer.wordpress.org/reference/functions/wp_kses_stripslashes/
  .replace(/\\"/g, '\\u0022');
}

/**
 * Given a block object, returns the Block's Inner HTML markup.
 *
 * @param {Object} block Block instance.
 *
 * @return {string} HTML.
 */
function getBlockInnerHTML(block) {
  // If block was parsed as invalid or encounters an error while generating
  // save content, use original content instead to avoid content loss. If a
  // block contains nested content, exempt it from this condition because we
  // otherwise have no access to its original content and content loss would
  // still occur.
  let saveContent = block.originalContent;
  if (block.isValid || block.innerBlocks.length) {
    try {
      saveContent = getSaveContent(block.name, block.attributes, block.innerBlocks);
    } catch (error) {}
  }
  return saveContent;
}

/**
 * Returns the content of a block, including comment delimiters.
 *
 * @param {string} rawBlockName Block name.
 * @param {Object} attributes   Block attributes.
 * @param {string} content      Block save content.
 *
 * @return {string} Comment-delimited block content.
 */
function getCommentDelimitedContent(rawBlockName, attributes, content) {
  const serializedAttributes = attributes && Object.entries(attributes).length ? serializeAttributes(attributes) + ' ' : '';

  // Strip core blocks of their namespace prefix.
  const blockName = rawBlockName?.startsWith('core/') ? rawBlockName.slice(5) : rawBlockName;

  // @todo make the `wp:` prefix potentially configurable.

  if (!content) {
    return `<!-- wp:${blockName} ${serializedAttributes}/-->`;
  }
  return `<!-- wp:${blockName} ${serializedAttributes}-->\n` + content + `\n<!-- /wp:${blockName} -->`;
}

/**
 * Returns the content of a block, including comment delimiters, determining
 * serialized attributes and content form from the current state of the block.
 *
 * @param {WPBlock}                     block   Block instance.
 * @param {WPBlockSerializationOptions} options Serialization options.
 *
 * @return {string} Serialized block.
 */
function serializeBlock(block, {
  isInnerBlocks = false
} = {}) {
  if (!block.isValid && block.__unstableBlockSource) {
    return serializeRawBlock(block.__unstableBlockSource);
  }
  const blockName = block.name;
  const saveContent = getBlockInnerHTML(block);
  if (blockName === getUnregisteredTypeHandlerName() || !isInnerBlocks && blockName === registration_getFreeformContentHandlerName()) {
    return saveContent;
  }
  const blockType = getBlockType(blockName);
  if (!blockType) {
    return saveContent;
  }
  const saveAttributes = getCommentAttributes(blockType, block.attributes);
  return getCommentDelimitedContent(blockName, saveAttributes, saveContent);
}
function __unstableSerializeAndClean(blocks) {
  // A single unmodified default block is assumed to
  // be equivalent to an empty post.
  if (blocks.length === 1 && isUnmodifiedDefaultBlock(blocks[0])) {
    blocks = [];
  }
  let content = serializer_serialize(blocks);

  // For compatibility, treat a post consisting of a
  // single freeform block as legacy content and apply
  // pre-block-editor removep'd content formatting.
  if (blocks.length === 1 && blocks[0].name === getFreeformContentHandlerName() && blocks[0].name === 'core/freeform') {
    content = removep(content);
  }
  return content;
}

/**
 * Takes a block or set of blocks and returns the serialized post content.
 *
 * @param {Array}                       blocks  Block(s) to serialize.
 * @param {WPBlockSerializationOptions} options Serialization options.
 *
 * @return {string} The post content.
 */
function serializer_serialize(blocks, options) {
  const blocksArray = Array.isArray(blocks) ? blocks : [blocks];
  return blocksArray.map(block => serializeBlock(block, options)).join('\n\n');
}
//# sourceMappingURL=serializer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/simple-html-tokenizer@0.5.11/node_modules/simple-html-tokenizer/dist/es6/index.js
/**
 * generated from https://raw.githubusercontent.com/w3c/html/26b5126f96f736f796b9e29718138919dd513744/entities.json
 * do not edit
 */
var namedCharRefs = {
    Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "\u2061", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "\u2061", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "\u2063", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "\u2062", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "\u200e", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: "\u000a", nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "\u2060", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: "\"", QUOT: "\"", rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "\u200f", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "\u00ad", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "\u0009", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "\u200d", zwnj: "\u200c"
};

var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
var CHARCODE = /^#([0-9]+)$/;
var NAMED = /^([A-Za-z0-9]+)$/;
var EntityParser = /** @class */ (function () {
    function EntityParser(named) {
        this.named = named;
    }
    EntityParser.prototype.parse = function (entity) {
        if (!entity) {
            return;
        }
        var matches = entity.match(HEXCHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 16));
        }
        matches = entity.match(CHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 10));
        }
        matches = entity.match(NAMED);
        if (matches) {
            return this.named[matches[1]];
        }
    };
    return EntityParser;
}());

var WSP = /[\t\n\f ]/;
var ALPHA = /[A-Za-z]/;
var CRLF = /\r\n?/g;
function isSpace(char) {
    return WSP.test(char);
}
function isAlpha(char) {
    return ALPHA.test(char);
}
function preprocessInput(input) {
    return input.replace(CRLF, '\n');
}

var EventedTokenizer = /** @class */ (function () {
    function EventedTokenizer(delegate, entityParser, mode) {
        if (mode === void 0) { mode = 'precompile'; }
        this.delegate = delegate;
        this.entityParser = entityParser;
        this.mode = mode;
        this.state = "beforeData" /* beforeData */;
        this.line = -1;
        this.column = -1;
        this.input = '';
        this.index = -1;
        this.tagNameBuffer = '';
        this.states = {
            beforeData: function () {
                var char = this.peek();
                if (char === '<' && !this.isIgnoredEndTag()) {
                    this.transitionTo("tagOpen" /* tagOpen */);
                    this.markTagStart();
                    this.consume();
                }
                else {
                    if (this.mode === 'precompile' && char === '\n') {
                        var tag = this.tagNameBuffer.toLowerCase();
                        if (tag === 'pre' || tag === 'textarea') {
                            this.consume();
                        }
                    }
                    this.transitionTo("data" /* data */);
                    this.delegate.beginData();
                }
            },
            data: function () {
                var char = this.peek();
                var tag = this.tagNameBuffer;
                if (char === '<' && !this.isIgnoredEndTag()) {
                    this.delegate.finishData();
                    this.transitionTo("tagOpen" /* tagOpen */);
                    this.markTagStart();
                    this.consume();
                }
                else if (char === '&' && tag !== 'script' && tag !== 'style') {
                    this.consume();
                    this.delegate.appendToData(this.consumeCharRef() || '&');
                }
                else {
                    this.consume();
                    this.delegate.appendToData(char);
                }
            },
            tagOpen: function () {
                var char = this.consume();
                if (char === '!') {
                    this.transitionTo("markupDeclarationOpen" /* markupDeclarationOpen */);
                }
                else if (char === '/') {
                    this.transitionTo("endTagOpen" /* endTagOpen */);
                }
                else if (char === '@' || char === ':' || isAlpha(char)) {
                    this.transitionTo("tagName" /* tagName */);
                    this.tagNameBuffer = '';
                    this.delegate.beginStartTag();
                    this.appendToTagName(char);
                }
            },
            markupDeclarationOpen: function () {
                var char = this.consume();
                if (char === '-' && this.peek() === '-') {
                    this.consume();
                    this.transitionTo("commentStart" /* commentStart */);
                    this.delegate.beginComment();
                }
                else {
                    var maybeDoctype = char.toUpperCase() + this.input.substring(this.index, this.index + 6).toUpperCase();
                    if (maybeDoctype === 'DOCTYPE') {
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.transitionTo("doctype" /* doctype */);
                        if (this.delegate.beginDoctype)
                            this.delegate.beginDoctype();
                    }
                }
            },
            doctype: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("beforeDoctypeName" /* beforeDoctypeName */);
                }
            },
            beforeDoctypeName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    return;
                }
                else {
                    this.transitionTo("doctypeName" /* doctypeName */);
                    if (this.delegate.appendToDoctypeName)
                        this.delegate.appendToDoctypeName(char.toLowerCase());
                }
            },
            doctypeName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("afterDoctypeName" /* afterDoctypeName */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypeName)
                        this.delegate.appendToDoctypeName(char.toLowerCase());
                }
            },
            afterDoctypeName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    return;
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    var nextSixChars = char.toUpperCase() + this.input.substring(this.index, this.index + 5).toUpperCase();
                    var isPublic = nextSixChars.toUpperCase() === 'PUBLIC';
                    var isSystem = nextSixChars.toUpperCase() === 'SYSTEM';
                    if (isPublic || isSystem) {
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                    }
                    if (isPublic) {
                        this.transitionTo("afterDoctypePublicKeyword" /* afterDoctypePublicKeyword */);
                    }
                    else if (isSystem) {
                        this.transitionTo("afterDoctypeSystemKeyword" /* afterDoctypeSystemKeyword */);
                    }
                }
            },
            afterDoctypePublicKeyword: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.transitionTo("beforeDoctypePublicIdentifier" /* beforeDoctypePublicIdentifier */);
                    this.consume();
                }
                else if (char === '"') {
                    this.transitionTo("doctypePublicIdentifierDoubleQuoted" /* doctypePublicIdentifierDoubleQuoted */);
                    this.consume();
                }
                else if (char === "'") {
                    this.transitionTo("doctypePublicIdentifierSingleQuoted" /* doctypePublicIdentifierSingleQuoted */);
                    this.consume();
                }
                else if (char === '>') {
                    this.consume();
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
            },
            doctypePublicIdentifierDoubleQuoted: function () {
                var char = this.consume();
                if (char === '"') {
                    this.transitionTo("afterDoctypePublicIdentifier" /* afterDoctypePublicIdentifier */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypePublicIdentifier)
                        this.delegate.appendToDoctypePublicIdentifier(char);
                }
            },
            doctypePublicIdentifierSingleQuoted: function () {
                var char = this.consume();
                if (char === "'") {
                    this.transitionTo("afterDoctypePublicIdentifier" /* afterDoctypePublicIdentifier */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypePublicIdentifier)
                        this.delegate.appendToDoctypePublicIdentifier(char);
                }
            },
            afterDoctypePublicIdentifier: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("betweenDoctypePublicAndSystemIdentifiers" /* betweenDoctypePublicAndSystemIdentifiers */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else if (char === '"') {
                    this.transitionTo("doctypeSystemIdentifierDoubleQuoted" /* doctypeSystemIdentifierDoubleQuoted */);
                }
                else if (char === "'") {
                    this.transitionTo("doctypeSystemIdentifierSingleQuoted" /* doctypeSystemIdentifierSingleQuoted */);
                }
            },
            betweenDoctypePublicAndSystemIdentifiers: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    return;
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else if (char === '"') {
                    this.transitionTo("doctypeSystemIdentifierDoubleQuoted" /* doctypeSystemIdentifierDoubleQuoted */);
                }
                else if (char === "'") {
                    this.transitionTo("doctypeSystemIdentifierSingleQuoted" /* doctypeSystemIdentifierSingleQuoted */);
                }
            },
            doctypeSystemIdentifierDoubleQuoted: function () {
                var char = this.consume();
                if (char === '"') {
                    this.transitionTo("afterDoctypeSystemIdentifier" /* afterDoctypeSystemIdentifier */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypeSystemIdentifier)
                        this.delegate.appendToDoctypeSystemIdentifier(char);
                }
            },
            doctypeSystemIdentifierSingleQuoted: function () {
                var char = this.consume();
                if (char === "'") {
                    this.transitionTo("afterDoctypeSystemIdentifier" /* afterDoctypeSystemIdentifier */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypeSystemIdentifier)
                        this.delegate.appendToDoctypeSystemIdentifier(char);
                }
            },
            afterDoctypeSystemIdentifier: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    return;
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
            },
            commentStart: function () {
                var char = this.consume();
                if (char === '-') {
                    this.transitionTo("commentStartDash" /* commentStartDash */);
                }
                else if (char === '>') {
                    this.delegate.finishComment();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.delegate.appendToCommentData(char);
                    this.transitionTo("comment" /* comment */);
                }
            },
            commentStartDash: function () {
                var char = this.consume();
                if (char === '-') {
                    this.transitionTo("commentEnd" /* commentEnd */);
                }
                else if (char === '>') {
                    this.delegate.finishComment();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.delegate.appendToCommentData('-');
                    this.transitionTo("comment" /* comment */);
                }
            },
            comment: function () {
                var char = this.consume();
                if (char === '-') {
                    this.transitionTo("commentEndDash" /* commentEndDash */);
                }
                else {
                    this.delegate.appendToCommentData(char);
                }
            },
            commentEndDash: function () {
                var char = this.consume();
                if (char === '-') {
                    this.transitionTo("commentEnd" /* commentEnd */);
                }
                else {
                    this.delegate.appendToCommentData('-' + char);
                    this.transitionTo("comment" /* comment */);
                }
            },
            commentEnd: function () {
                var char = this.consume();
                if (char === '>') {
                    this.delegate.finishComment();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.delegate.appendToCommentData('--' + char);
                    this.transitionTo("comment" /* comment */);
                }
            },
            tagName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
                else if (char === '/') {
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '>') {
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.appendToTagName(char);
                }
            },
            endTagName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                    this.tagNameBuffer = '';
                }
                else if (char === '/') {
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                    this.tagNameBuffer = '';
                }
                else if (char === '>') {
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                    this.tagNameBuffer = '';
                }
                else {
                    this.appendToTagName(char);
                }
            },
            beforeAttributeName: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                    return;
                }
                else if (char === '/') {
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                    this.consume();
                }
                else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else if (char === '=') {
                    this.delegate.reportSyntaxError('attribute name cannot start with equals sign');
                    this.transitionTo("attributeName" /* attributeName */);
                    this.delegate.beginAttribute();
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
                else {
                    this.transitionTo("attributeName" /* attributeName */);
                    this.delegate.beginAttribute();
                }
            },
            attributeName: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.transitionTo("afterAttributeName" /* afterAttributeName */);
                    this.consume();
                }
                else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '=') {
                    this.transitionTo("beforeAttributeValue" /* beforeAttributeValue */);
                    this.consume();
                }
                else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else if (char === '"' || char === "'" || char === '<') {
                    this.delegate.reportSyntaxError(char + ' is not a valid character within attribute names');
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
                else {
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            afterAttributeName: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                    return;
                }
                else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '=') {
                    this.consume();
                    this.transitionTo("beforeAttributeValue" /* beforeAttributeValue */);
                }
                else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.transitionTo("attributeName" /* attributeName */);
                    this.delegate.beginAttribute();
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            beforeAttributeValue: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                }
                else if (char === '"') {
                    this.transitionTo("attributeValueDoubleQuoted" /* attributeValueDoubleQuoted */);
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                }
                else if (char === "'") {
                    this.transitionTo("attributeValueSingleQuoted" /* attributeValueSingleQuoted */);
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                }
                else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.transitionTo("attributeValueUnquoted" /* attributeValueUnquoted */);
                    this.delegate.beginAttributeValue(false);
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueDoubleQuoted: function () {
                var char = this.consume();
                if (char === '"') {
                    this.delegate.finishAttributeValue();
                    this.transitionTo("afterAttributeValueQuoted" /* afterAttributeValueQuoted */);
                }
                else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');
                }
                else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueSingleQuoted: function () {
                var char = this.consume();
                if (char === "'") {
                    this.delegate.finishAttributeValue();
                    this.transitionTo("afterAttributeValueQuoted" /* afterAttributeValueQuoted */);
                }
                else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');
                }
                else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueUnquoted: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
                else if (char === '/') {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '&') {
                    this.consume();
                    this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');
                }
                else if (char === '>') {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            afterAttributeValueQuoted: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
                else if (char === '/') {
                    this.consume();
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
            },
            selfClosingStartTag: function () {
                var char = this.peek();
                if (char === '>') {
                    this.consume();
                    this.delegate.markTagAsSelfClosing();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
            },
            endTagOpen: function () {
                var char = this.consume();
                if (char === '@' || char === ':' || isAlpha(char)) {
                    this.transitionTo("endTagName" /* endTagName */);
                    this.tagNameBuffer = '';
                    this.delegate.beginEndTag();
                    this.appendToTagName(char);
                }
            }
        };
        this.reset();
    }
    EventedTokenizer.prototype.reset = function () {
        this.transitionTo("beforeData" /* beforeData */);
        this.input = '';
        this.tagNameBuffer = '';
        this.index = 0;
        this.line = 1;
        this.column = 0;
        this.delegate.reset();
    };
    EventedTokenizer.prototype.transitionTo = function (state) {
        this.state = state;
    };
    EventedTokenizer.prototype.tokenize = function (input) {
        this.reset();
        this.tokenizePart(input);
        this.tokenizeEOF();
    };
    EventedTokenizer.prototype.tokenizePart = function (input) {
        this.input += preprocessInput(input);
        while (this.index < this.input.length) {
            var handler = this.states[this.state];
            if (handler !== undefined) {
                handler.call(this);
            }
            else {
                throw new Error("unhandled state " + this.state);
            }
        }
    };
    EventedTokenizer.prototype.tokenizeEOF = function () {
        this.flushData();
    };
    EventedTokenizer.prototype.flushData = function () {
        if (this.state === 'data') {
            this.delegate.finishData();
            this.transitionTo("beforeData" /* beforeData */);
        }
    };
    EventedTokenizer.prototype.peek = function () {
        return this.input.charAt(this.index);
    };
    EventedTokenizer.prototype.consume = function () {
        var char = this.peek();
        this.index++;
        if (char === '\n') {
            this.line++;
            this.column = 0;
        }
        else {
            this.column++;
        }
        return char;
    };
    EventedTokenizer.prototype.consumeCharRef = function () {
        var endIndex = this.input.indexOf(';', this.index);
        if (endIndex === -1) {
            return;
        }
        var entity = this.input.slice(this.index, endIndex);
        var chars = this.entityParser.parse(entity);
        if (chars) {
            var count = entity.length;
            // consume the entity chars
            while (count) {
                this.consume();
                count--;
            }
            // consume the `;`
            this.consume();
            return chars;
        }
    };
    EventedTokenizer.prototype.markTagStart = function () {
        this.delegate.tagOpen();
    };
    EventedTokenizer.prototype.appendToTagName = function (char) {
        this.tagNameBuffer += char;
        this.delegate.appendToTagName(char);
    };
    EventedTokenizer.prototype.isIgnoredEndTag = function () {
        var tag = this.tagNameBuffer;
        return (tag === 'title' && this.input.substring(this.index, this.index + 8) !== '</title>') ||
            (tag === 'style' && this.input.substring(this.index, this.index + 8) !== '</style>') ||
            (tag === 'script' && this.input.substring(this.index, this.index + 9) !== '</script>');
    };
    return EventedTokenizer;
}());

var Tokenizer = /** @class */ (function () {
    function Tokenizer(entityParser, options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
        this.tokens = [];
        this.tokenizer = new EventedTokenizer(this, entityParser, options.mode);
        this._currentAttribute = undefined;
    }
    Tokenizer.prototype.tokenize = function (input) {
        this.tokens = [];
        this.tokenizer.tokenize(input);
        return this.tokens;
    };
    Tokenizer.prototype.tokenizePart = function (input) {
        this.tokens = [];
        this.tokenizer.tokenizePart(input);
        return this.tokens;
    };
    Tokenizer.prototype.tokenizeEOF = function () {
        this.tokens = [];
        this.tokenizer.tokenizeEOF();
        return this.tokens[0];
    };
    Tokenizer.prototype.reset = function () {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
    };
    Tokenizer.prototype.current = function () {
        var token = this.token;
        if (token === null) {
            throw new Error('token was unexpectedly null');
        }
        if (arguments.length === 0) {
            return token;
        }
        for (var i = 0; i < arguments.length; i++) {
            if (token.type === arguments[i]) {
                return token;
            }
        }
        throw new Error("token type was unexpectedly " + token.type);
    };
    Tokenizer.prototype.push = function (token) {
        this.token = token;
        this.tokens.push(token);
    };
    Tokenizer.prototype.currentAttribute = function () {
        return this._currentAttribute;
    };
    Tokenizer.prototype.addLocInfo = function () {
        if (this.options.loc) {
            this.current().loc = {
                start: {
                    line: this.startLine,
                    column: this.startColumn
                },
                end: {
                    line: this.tokenizer.line,
                    column: this.tokenizer.column
                }
            };
        }
        this.startLine = this.tokenizer.line;
        this.startColumn = this.tokenizer.column;
    };
    // Data
    Tokenizer.prototype.beginDoctype = function () {
        this.push({
            type: "Doctype" /* Doctype */,
            name: '',
        });
    };
    Tokenizer.prototype.appendToDoctypeName = function (char) {
        this.current("Doctype" /* Doctype */).name += char;
    };
    Tokenizer.prototype.appendToDoctypePublicIdentifier = function (char) {
        var doctype = this.current("Doctype" /* Doctype */);
        if (doctype.publicIdentifier === undefined) {
            doctype.publicIdentifier = char;
        }
        else {
            doctype.publicIdentifier += char;
        }
    };
    Tokenizer.prototype.appendToDoctypeSystemIdentifier = function (char) {
        var doctype = this.current("Doctype" /* Doctype */);
        if (doctype.systemIdentifier === undefined) {
            doctype.systemIdentifier = char;
        }
        else {
            doctype.systemIdentifier += char;
        }
    };
    Tokenizer.prototype.endDoctype = function () {
        this.addLocInfo();
    };
    Tokenizer.prototype.beginData = function () {
        this.push({
            type: "Chars" /* Chars */,
            chars: ''
        });
    };
    Tokenizer.prototype.appendToData = function (char) {
        this.current("Chars" /* Chars */).chars += char;
    };
    Tokenizer.prototype.finishData = function () {
        this.addLocInfo();
    };
    // Comment
    Tokenizer.prototype.beginComment = function () {
        this.push({
            type: "Comment" /* Comment */,
            chars: ''
        });
    };
    Tokenizer.prototype.appendToCommentData = function (char) {
        this.current("Comment" /* Comment */).chars += char;
    };
    Tokenizer.prototype.finishComment = function () {
        this.addLocInfo();
    };
    // Tags - basic
    Tokenizer.prototype.tagOpen = function () { };
    Tokenizer.prototype.beginStartTag = function () {
        this.push({
            type: "StartTag" /* StartTag */,
            tagName: '',
            attributes: [],
            selfClosing: false
        });
    };
    Tokenizer.prototype.beginEndTag = function () {
        this.push({
            type: "EndTag" /* EndTag */,
            tagName: ''
        });
    };
    Tokenizer.prototype.finishTag = function () {
        this.addLocInfo();
    };
    Tokenizer.prototype.markTagAsSelfClosing = function () {
        this.current("StartTag" /* StartTag */).selfClosing = true;
    };
    // Tags - name
    Tokenizer.prototype.appendToTagName = function (char) {
        this.current("StartTag" /* StartTag */, "EndTag" /* EndTag */).tagName += char;
    };
    // Tags - attributes
    Tokenizer.prototype.beginAttribute = function () {
        this._currentAttribute = ['', '', false];
    };
    Tokenizer.prototype.appendToAttributeName = function (char) {
        this.currentAttribute()[0] += char;
    };
    Tokenizer.prototype.beginAttributeValue = function (isQuoted) {
        this.currentAttribute()[2] = isQuoted;
    };
    Tokenizer.prototype.appendToAttributeValue = function (char) {
        this.currentAttribute()[1] += char;
    };
    Tokenizer.prototype.finishAttributeValue = function () {
        this.current("StartTag" /* StartTag */).attributes.push(this._currentAttribute);
    };
    Tokenizer.prototype.reportSyntaxError = function (message) {
        this.current().syntaxError = message;
    };
    return Tokenizer;
}());

function tokenize(input, options) {
    var tokenizer = new Tokenizer(new EntityParser(namedCharRefs), options);
    return tokenizer.tokenize(input);
}


//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/es6/index.js
var es6 = __webpack_require__("../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/es6/index.js");
var es6_default = /*#__PURE__*/__webpack_require__.n(es6);
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+html-entities@4.0.1/node_modules/@wordpress/html-entities/build-module/index.js
var html_entities_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+html-entities@4.0.1/node_modules/@wordpress/html-entities/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/validation/logger.js
/**
 * @typedef LoggerItem
 * @property {Function}   log  Which logger recorded the message
 * @property {Array<any>} args White arguments were supplied to the logger
 */

function createLogger() {
  /**
   * Creates a log handler with block validation prefix.
   *
   * @param {Function} logger Original logger function.
   *
   * @return {Function} Augmented logger function.
   */
  function createLogHandler(logger) {
    let log = (message, ...args) => logger('Block validation: ' + message, ...args);

    // In test environments, pre-process string substitutions to improve
    // readability of error messages. We'd prefer to avoid pulling in this
    // dependency in runtime environments, and it can be dropped by a combo
    // of Webpack env substitution + UglifyJS dead code elimination.
    if (false) {}
    return log;
  }
  return {
    // eslint-disable-next-line no-console
    error: createLogHandler(console.error),
    // eslint-disable-next-line no-console
    warning: createLogHandler(console.warn),
    getItems() {
      return [];
    }
  };
}
function createQueuedLogger() {
  /**
   * The list of enqueued log actions to print.
   *
   * @type {Array<LoggerItem>}
   */
  const queue = [];
  const logger = createLogger();
  return {
    error(...args) {
      queue.push({
        log: logger.error,
        args
      });
    },
    warning(...args) {
      queue.push({
        log: logger.warning,
        args
      });
    },
    getItems() {
      return queue;
    }
  };
}
//# sourceMappingURL=logger.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/validation/index.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





/** @typedef {import('../parser').WPBlock} WPBlock */
/** @typedef {import('../registration').WPBlockType} WPBlockType */
/** @typedef {import('./logger').LoggerItem} LoggerItem */

const identity = x => x;

/**
 * Globally matches any consecutive whitespace
 *
 * @type {RegExp}
 */
const REGEXP_WHITESPACE = /[\t\n\r\v\f ]+/g;

/**
 * Matches a string containing only whitespace
 *
 * @type {RegExp}
 */
const REGEXP_ONLY_WHITESPACE = /^[\t\n\r\v\f ]*$/;

/**
 * Matches a CSS URL type value
 *
 * @type {RegExp}
 */
const REGEXP_STYLE_URL_TYPE = /^url\s*\(['"\s]*(.*?)['"\s]*\)$/;

/**
 * Boolean attributes are attributes whose presence as being assigned is
 * meaningful, even if only empty.
 *
 * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes
 * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3
 *
 * Object.keys( Array.from( document.querySelectorAll( '#attributes-1 > tbody > tr' ) )
 *     .filter( ( tr ) => tr.lastChild.textContent.indexOf( 'Boolean attribute' ) !== -1 )
 *     .reduce( ( result, tr ) => Object.assign( result, {
 *         [ tr.firstChild.textContent.trim() ]: true
 *     } ), {} ) ).sort();
 *
 * @type {Array}
 */
const BOOLEAN_ATTRIBUTES = ['allowfullscreen', 'allowpaymentrequest', 'allowusermedia', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default', 'defer', 'disabled', 'download', 'formnovalidate', 'hidden', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'selected', 'typemustmatch'];

/**
 * Enumerated attributes are attributes which must be of a specific value form.
 * Like boolean attributes, these are meaningful if specified, even if not of a
 * valid enumerated value.
 *
 * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#enumerated-attribute
 * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3
 *
 * Object.keys( Array.from( document.querySelectorAll( '#attributes-1 > tbody > tr' ) )
 *     .filter( ( tr ) => /^("(.+?)";?\s*)+/.test( tr.lastChild.textContent.trim() ) )
 *     .reduce( ( result, tr ) => Object.assign( result, {
 *         [ tr.firstChild.textContent.trim() ]: true
 *     } ), {} ) ).sort();
 *
 * @type {Array}
 */
const ENUMERATED_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'charset', 'contenteditable', 'crossorigin', 'decoding', 'dir', 'draggable', 'enctype', 'formenctype', 'formmethod', 'http-equiv', 'inputmode', 'kind', 'method', 'preload', 'scope', 'shape', 'spellcheck', 'translate', 'type', 'wrap'];

/**
 * Meaningful attributes are those who cannot be safely ignored when omitted in
 * one HTML markup string and not another.
 *
 * @type {Array}
 */
const MEANINGFUL_ATTRIBUTES = [...BOOLEAN_ATTRIBUTES, ...ENUMERATED_ATTRIBUTES];

/**
 * Array of functions which receive a text string on which to apply normalizing
 * behavior for consideration in text token equivalence, carefully ordered from
 * least-to-most expensive operations.
 *
 * @type {Array}
 */
const TEXT_NORMALIZATIONS = [identity, getTextWithCollapsedWhitespace];

/**
 * Regular expression matching a named character reference. In lieu of bundling
 * a full set of references, the pattern covers the minimal necessary to test
 * positively against the full set.
 *
 * "The ampersand must be followed by one of the names given in the named
 * character references section, using the same case."
 *
 * Tested aginst "12.5 Named character references":
 *
 * ```
 * const references = Array.from( document.querySelectorAll(
 *     '#named-character-references-table tr[id^=entity-] td:first-child'
 * ) ).map( ( code ) => code.textContent )
 * references.every( ( reference ) => /^[\da-z]+$/i.test( reference ) )
 * ```
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references
 * @see https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references
 *
 * @type {RegExp}
 */
const REGEXP_NAMED_CHARACTER_REFERENCE = /^[\da-z]+$/i;

/**
 * Regular expression matching a decimal character reference.
 *
 * "The ampersand must be followed by a U+0023 NUMBER SIGN character (#),
 * followed by one or more ASCII digits, representing a base-ten integer"
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references
 *
 * @type {RegExp}
 */
const REGEXP_DECIMAL_CHARACTER_REFERENCE = /^#\d+$/;

/**
 * Regular expression matching a hexadecimal character reference.
 *
 * "The ampersand must be followed by a U+0023 NUMBER SIGN character (#), which
 * must be followed by either a U+0078 LATIN SMALL LETTER X character (x) or a
 * U+0058 LATIN CAPITAL LETTER X character (X), which must then be followed by
 * one or more ASCII hex digits, representing a hexadecimal integer"
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references
 *
 * @type {RegExp}
 */
const REGEXP_HEXADECIMAL_CHARACTER_REFERENCE = /^#x[\da-f]+$/i;

/**
 * Returns true if the given string is a valid character reference segment, or
 * false otherwise. The text should be stripped of `&` and `;` demarcations.
 *
 * @param {string} text Text to test.
 *
 * @return {boolean} Whether text is valid character reference.
 */
function isValidCharacterReference(text) {
  return REGEXP_NAMED_CHARACTER_REFERENCE.test(text) || REGEXP_DECIMAL_CHARACTER_REFERENCE.test(text) || REGEXP_HEXADECIMAL_CHARACTER_REFERENCE.test(text);
}

/**
 * Subsitute EntityParser class for `simple-html-tokenizer` which uses the
 * implementation of `decodeEntities` from `html-entities`, in order to avoid
 * bundling a massive named character reference.
 *
 * @see https://github.com/tildeio/simple-html-tokenizer/tree/HEAD/src/entity-parser.ts
 */
class DecodeEntityParser {
  /**
   * Returns a substitute string for an entity string sequence between `&`
   * and `;`, or undefined if no substitution should occur.
   *
   * @param {string} entity Entity fragment discovered in HTML.
   *
   * @return {string | undefined} Entity substitute value.
   */
  parse(entity) {
    if (isValidCharacterReference(entity)) {
      return (0,html_entities_build_module/* decodeEntities */.S)('&' + entity + ';');
    }
  }
}

/**
 * Given a specified string, returns an array of strings split by consecutive
 * whitespace, ignoring leading or trailing whitespace.
 *
 * @param {string} text Original text.
 *
 * @return {string[]} Text pieces split on whitespace.
 */
function getTextPiecesSplitOnWhitespace(text) {
  return text.trim().split(REGEXP_WHITESPACE);
}

/**
 * Given a specified string, returns a new trimmed string where all consecutive
 * whitespace is collapsed to a single space.
 *
 * @param {string} text Original text.
 *
 * @return {string} Trimmed text with consecutive whitespace collapsed.
 */
function getTextWithCollapsedWhitespace(text) {
  // This is an overly simplified whitespace comparison. The specification is
  // more prescriptive of whitespace behavior in inline and block contexts.
  //
  // See: https://medium.com/@patrickbrosset/when-does-white-space-matter-in-html-b90e8a7cdd33
  return getTextPiecesSplitOnWhitespace(text).join(' ');
}

/**
 * Returns attribute pairs of the given StartTag token, including only pairs
 * where the value is non-empty or the attribute is a boolean attribute, an
 * enumerated attribute, or a custom data- attribute.
 *
 * @see MEANINGFUL_ATTRIBUTES
 *
 * @param {Object} token StartTag token.
 *
 * @return {Array[]} Attribute pairs.
 */
function getMeaningfulAttributePairs(token) {
  return token.attributes.filter(pair => {
    const [key, value] = pair;
    return value || key.indexOf('data-') === 0 || MEANINGFUL_ATTRIBUTES.includes(key);
  });
}

/**
 * Returns true if two text tokens (with `chars` property) are equivalent, or
 * false otherwise.
 *
 * @param {Object} actual   Actual token.
 * @param {Object} expected Expected token.
 * @param {Object} logger   Validation logger object.
 *
 * @return {boolean} Whether two text tokens are equivalent.
 */
function isEquivalentTextTokens(actual, expected, logger = createLogger()) {
  // This function is intentionally written as syntactically "ugly" as a hot
  // path optimization. Text is progressively normalized in order from least-
  // to-most operationally expensive, until the earliest point at which text
  // can be confidently inferred as being equal.
  let actualChars = actual.chars;
  let expectedChars = expected.chars;
  for (let i = 0; i < TEXT_NORMALIZATIONS.length; i++) {
    const normalize = TEXT_NORMALIZATIONS[i];
    actualChars = normalize(actualChars);
    expectedChars = normalize(expectedChars);
    if (actualChars === expectedChars) {
      return true;
    }
  }
  logger.warning('Expected text `%s`, saw `%s`.', expected.chars, actual.chars);
  return false;
}

/**
 * Given a CSS length value, returns a normalized CSS length value for strict equality
 * comparison.
 *
 * @param {string} value CSS length value.
 *
 * @return {string} Normalized CSS length value.
 */
function getNormalizedLength(value) {
  if (0 === parseFloat(value)) {
    return '0';
  }
  // Normalize strings with floats to always include a leading zero.
  if (value.indexOf('.') === 0) {
    return '0' + value;
  }
  return value;
}

/**
 * Given a style value, returns a normalized style value for strict equality
 * comparison.
 *
 * @param {string} value Style value.
 *
 * @return {string} Normalized style value.
 */
function getNormalizedStyleValue(value) {
  const textPieces = getTextPiecesSplitOnWhitespace(value);
  const normalizedPieces = textPieces.map(getNormalizedLength);
  const result = normalizedPieces.join(' ');
  return result
  // Normalize URL type to omit whitespace or quotes.
  .replace(REGEXP_STYLE_URL_TYPE, 'url($1)');
}

/**
 * Given a style attribute string, returns an object of style properties.
 *
 * @param {string} text Style attribute.
 *
 * @return {Object} Style properties.
 */
function getStyleProperties(text) {
  const pairs = text
  // Trim ending semicolon (avoid including in split)
  .replace(/;?\s*$/, '')
  // Split on property assignment.
  .split(';')
  // For each property assignment...
  .map(style => {
    // ...split further into key-value pairs.
    const [key, ...valueParts] = style.split(':');
    const value = valueParts.join(':');
    return [key.trim(), getNormalizedStyleValue(value.trim())];
  });
  return Object.fromEntries(pairs);
}

/**
 * Attribute-specific equality handlers
 *
 * @type {Object}
 */
const isEqualAttributesOfName = {
  class: (actual, expected) => {
    // Class matches if members are the same, even if out of order or
    // superfluous whitespace between.
    const [actualPieces, expectedPieces] = [actual, expected].map(getTextPiecesSplitOnWhitespace);
    const actualDiff = actualPieces.filter(c => !expectedPieces.includes(c));
    const expectedDiff = expectedPieces.filter(c => !actualPieces.includes(c));
    return actualDiff.length === 0 && expectedDiff.length === 0;
  },
  style: (actual, expected) => {
    return es6_default()(...[actual, expected].map(getStyleProperties));
  },
  // For each boolean attribute, mere presence of attribute in both is enough
  // to assume equivalence.
  ...Object.fromEntries(BOOLEAN_ATTRIBUTES.map(attribute => [attribute, () => true]))
};

/**
 * Given two sets of attribute tuples, returns true if the attribute sets are
 * equivalent.
 *
 * @param {Array[]} actual   Actual attributes tuples.
 * @param {Array[]} expected Expected attributes tuples.
 * @param {Object}  logger   Validation logger object.
 *
 * @return {boolean} Whether attributes are equivalent.
 */
function isEqualTagAttributePairs(actual, expected, logger = createLogger()) {
  // Attributes is tokenized as tuples. Their lengths should match. This also
  // avoids us needing to check both attributes sets, since if A has any keys
  // which do not exist in B, we know the sets to be different.
  if (actual.length !== expected.length) {
    logger.warning('Expected attributes %o, instead saw %o.', expected, actual);
    return false;
  }

  // Attributes are not guaranteed to occur in the same order. For validating
  // actual attributes, first convert the set of expected attribute values to
  // an object, for lookup by key.
  const expectedAttributes = {};
  for (let i = 0; i < expected.length; i++) {
    expectedAttributes[expected[i][0].toLowerCase()] = expected[i][1];
  }
  for (let i = 0; i < actual.length; i++) {
    const [name, actualValue] = actual[i];
    const nameLower = name.toLowerCase();

    // As noted above, if missing member in B, assume different.
    if (!expectedAttributes.hasOwnProperty(nameLower)) {
      logger.warning('Encountered unexpected attribute `%s`.', name);
      return false;
    }
    const expectedValue = expectedAttributes[nameLower];
    const isEqualAttributes = isEqualAttributesOfName[nameLower];
    if (isEqualAttributes) {
      // Defer custom attribute equality handling.
      if (!isEqualAttributes(actualValue, expectedValue)) {
        logger.warning('Expected attribute `%s` of value `%s`, saw `%s`.', name, expectedValue, actualValue);
        return false;
      }
    } else if (actualValue !== expectedValue) {
      // Otherwise strict inequality should bail.
      logger.warning('Expected attribute `%s` of value `%s`, saw `%s`.', name, expectedValue, actualValue);
      return false;
    }
  }
  return true;
}

/**
 * Token-type-specific equality handlers
 *
 * @type {Object}
 */
const isEqualTokensOfType = {
  StartTag: (actual, expected, logger = createLogger()) => {
    if (actual.tagName !== expected.tagName &&
    // Optimization: Use short-circuit evaluation to defer case-
    // insensitive check on the assumption that the majority case will
    // have exactly equal tag names.
    actual.tagName.toLowerCase() !== expected.tagName.toLowerCase()) {
      logger.warning('Expected tag name `%s`, instead saw `%s`.', expected.tagName, actual.tagName);
      return false;
    }
    return isEqualTagAttributePairs(...[actual, expected].map(getMeaningfulAttributePairs), logger);
  },
  Chars: isEquivalentTextTokens,
  Comment: isEquivalentTextTokens
};

/**
 * Given an array of tokens, returns the first token which is not purely
 * whitespace.
 *
 * Mutates the tokens array.
 *
 * @param {Object[]} tokens Set of tokens to search.
 *
 * @return {Object | undefined} Next non-whitespace token.
 */
function getNextNonWhitespaceToken(tokens) {
  let token;
  while (token = tokens.shift()) {
    if (token.type !== 'Chars') {
      return token;
    }
    if (!REGEXP_ONLY_WHITESPACE.test(token.chars)) {
      return token;
    }
  }
}

/**
 * Tokenize an HTML string, gracefully handling any errors thrown during
 * underlying tokenization.
 *
 * @param {string} html   HTML string to tokenize.
 * @param {Object} logger Validation logger object.
 *
 * @return {Object[]|null} Array of valid tokenized HTML elements, or null on error
 */
function getHTMLTokens(html, logger = createLogger()) {
  try {
    return new Tokenizer(new DecodeEntityParser()).tokenize(html);
  } catch (e) {
    logger.warning('Malformed HTML detected: %s', html);
  }
  return null;
}

/**
 * Returns true if the next HTML token closes the current token.
 *
 * @param {Object}           currentToken Current token to compare with.
 * @param {Object|undefined} nextToken    Next token to compare against.
 *
 * @return {boolean} true if `nextToken` closes `currentToken`, false otherwise
 */
function isClosedByToken(currentToken, nextToken) {
  // Ensure this is a self closed token.
  if (!currentToken.selfClosing) {
    return false;
  }

  // Check token names and determine if nextToken is the closing tag for currentToken.
  if (nextToken && nextToken.tagName === currentToken.tagName && nextToken.type === 'EndTag') {
    return true;
  }
  return false;
}

/**
 * Returns true if the given HTML strings are effectively equivalent, or
 * false otherwise. Invalid HTML is not considered equivalent, even if the
 * strings directly match.
 *
 * @param {string} actual   Actual HTML string.
 * @param {string} expected Expected HTML string.
 * @param {Object} logger   Validation logger object.
 *
 * @return {boolean} Whether HTML strings are equivalent.
 */
function isEquivalentHTML(actual, expected, logger = createLogger()) {
  // Short-circuit if markup is identical.
  if (actual === expected) {
    return true;
  }

  // Tokenize input content and reserialized save content.
  const [actualTokens, expectedTokens] = [actual, expected].map(html => getHTMLTokens(html, logger));

  // If either is malformed then stop comparing - the strings are not equivalent.
  if (!actualTokens || !expectedTokens) {
    return false;
  }
  let actualToken, expectedToken;
  while (actualToken = getNextNonWhitespaceToken(actualTokens)) {
    expectedToken = getNextNonWhitespaceToken(expectedTokens);

    // Inequal if exhausted all expected tokens.
    if (!expectedToken) {
      logger.warning('Expected end of content, instead saw %o.', actualToken);
      return false;
    }

    // Inequal if next non-whitespace token of each set are not same type.
    if (actualToken.type !== expectedToken.type) {
      logger.warning('Expected token of type `%s` (%o), instead saw `%s` (%o).', expectedToken.type, expectedToken, actualToken.type, actualToken);
      return false;
    }

    // Defer custom token type equality handling, otherwise continue and
    // assume as equal.
    const isEqualTokens = isEqualTokensOfType[actualToken.type];
    if (isEqualTokens && !isEqualTokens(actualToken, expectedToken, logger)) {
      return false;
    }

    // Peek at the next tokens (actual and expected) to see if they close
    // a self-closing tag.
    if (isClosedByToken(actualToken, expectedTokens[0])) {
      // Consume the next expected token that closes the current actual
      // self-closing token.
      getNextNonWhitespaceToken(expectedTokens);
    } else if (isClosedByToken(expectedToken, actualTokens[0])) {
      // Consume the next actual token that closes the current expected
      // self-closing token.
      getNextNonWhitespaceToken(actualTokens);
    }
  }
  if (expectedToken = getNextNonWhitespaceToken(expectedTokens)) {
    // If any non-whitespace tokens remain in expected token set, this
    // indicates inequality.
    logger.warning('Expected %o, instead saw end of content.', expectedToken);
    return false;
  }
  return true;
}

/**
 * Returns an object with `isValid` property set to `true` if the parsed block
 * is valid given the input content. A block is considered valid if, when serialized
 * with assumed attributes, the content matches the original value. If block is
 * invalid, this function returns all validations issues as well.
 *
 * @param {string|Object} blockTypeOrName      Block type.
 * @param {Object}        attributes           Parsed block attributes.
 * @param {string}        originalBlockContent Original block content.
 * @param {Object}        logger               Validation logger object.
 *
 * @return {Object} Whether block is valid and contains validation messages.
 */

/**
 * Returns an object with `isValid` property set to `true` if the parsed block
 * is valid given the input content. A block is considered valid if, when serialized
 * with assumed attributes, the content matches the original value. If block is
 * invalid, this function returns all validations issues as well.
 *
 * @param {WPBlock}            block                          block object.
 * @param {WPBlockType|string} [blockTypeOrName = block.name] Block type or name, inferred from block if not given.
 *
 * @return {[boolean,Array<LoggerItem>]} validation results.
 */
function validateBlock(block, blockTypeOrName = block.name) {
  const isFallbackBlock = block.name === registration_getFreeformContentHandlerName() || block.name === getUnregisteredTypeHandlerName();

  // Shortcut to avoid costly validation.
  if (isFallbackBlock) {
    return [true, []];
  }
  const logger = createQueuedLogger();
  const blockType = utils_normalizeBlockType(blockTypeOrName);
  let generatedBlockContent;
  try {
    generatedBlockContent = getSaveContent(blockType, block.attributes);
  } catch (error) {
    logger.error('Block validation failed because an error occurred while generating block content:\n\n%s', error.toString());
    return [false, logger.getItems()];
  }
  const isValid = isEquivalentHTML(block.originalContent, generatedBlockContent, logger);
  if (!isValid) {
    logger.error('Block validation failed for `%s` (%o).\n\nContent generated by `save` function:\n\n%s\n\nContent retrieved from post body:\n\n%s', blockType.name, blockType, generatedBlockContent, block.originalContent);
  }
  return [isValid, logger.getItems()];
}

/**
 * Returns true if the parsed block is valid given the input content. A block
 * is considered valid if, when serialized with assumed attributes, the content
 * matches the original value.
 *
 * Logs to console in development environments when invalid.
 *
 * @deprecated Use validateBlock instead to avoid data loss.
 *
 * @param {string|Object} blockTypeOrName      Block type.
 * @param {Object}        attributes           Parsed block attributes.
 * @param {string}        originalBlockContent Original block content.
 *
 * @return {boolean} Whether block is valid.
 */
function isValidBlockContent(blockTypeOrName, attributes, originalBlockContent) {
  deprecated('isValidBlockContent introduces opportunity for data loss', {
    since: '12.6',
    plugin: 'Gutenberg',
    alternative: 'validateBlock'
  });
  const blockType = normalizeBlockType(blockTypeOrName);
  const block = {
    name: blockType.name,
    attributes,
    innerBlocks: [],
    originalContent: originalBlockContent
  };
  const [isValid] = validateBlock(block, blockType);
  return isValid;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/parser/convert-legacy-block.js
/**
 * Convert legacy blocks to their canonical form. This function is used
 * both in the parser level for previous content and to convert such blocks
 * used in Custom Post Types templates.
 *
 * @param {string} name       The block's name
 * @param {Object} attributes The block's attributes
 *
 * @return {[string, Object]} The block's name and attributes, changed accordingly if a match was found
 */
function convertLegacyBlockNameAndAttributes(name, attributes) {
  const newAttributes = {
    ...attributes
  };
  // Convert 'core/cover-image' block in existing content to 'core/cover'.
  if ('core/cover-image' === name) {
    name = 'core/cover';
  }

  // Convert 'core/text' blocks in existing content to 'core/paragraph'.
  if ('core/text' === name || 'core/cover-text' === name) {
    name = 'core/paragraph';
  }

  // Convert derivative blocks such as 'core/social-link-wordpress' to the
  // canonical form 'core/social-link'.
  if (name && name.indexOf('core/social-link-') === 0) {
    // Capture `social-link-wordpress` into `{"service":"wordpress"}`
    newAttributes.service = name.substring(17);
    name = 'core/social-link';
  }

  // Convert derivative blocks such as 'core-embed/instagram' to the
  // canonical form 'core/embed'.
  if (name && name.indexOf('core-embed/') === 0) {
    // Capture `core-embed/instagram` into `{"providerNameSlug":"instagram"}`
    const providerSlug = name.substring(11);
    const deprecated = {
      speaker: 'speaker-deck',
      polldaddy: 'crowdsignal'
    };
    newAttributes.providerNameSlug = providerSlug in deprecated ? deprecated[providerSlug] : providerSlug;
    // This is needed as the `responsive` attribute was passed
    // in a different way before the refactoring to block variations.
    if (!['amazon-kindle', 'wordpress'].includes(providerSlug)) {
      newAttributes.responsive = true;
    }
    name = 'core/embed';
  }

  // Convert Post Comment blocks in existing content to Comment blocks.
  // TODO: Remove these checks when WordPress 6.0 is released.
  if (name === 'core/post-comment-author') {
    name = 'core/comment-author-name';
  }
  if (name === 'core/post-comment-content') {
    name = 'core/comment-content';
  }
  if (name === 'core/post-comment-date') {
    name = 'core/comment-date';
  }
  if (name === 'core/comments-query-loop') {
    name = 'core/comments';
    const {
      className = ''
    } = newAttributes;
    if (!className.includes('wp-block-comments-query-loop')) {
      newAttributes.className = ['wp-block-comments-query-loop', className].join(' ');
    }
    // Note that we also had to add a deprecation to the block in order
    // for the ID change to work.
  }
  if (name === 'core/post-comments') {
    name = 'core/comments';
    newAttributes.legacy = true;
  }

  // The following code is only relevant for the Gutenberg plugin.
  // It's a stand-alone if statement for dead-code elimination.
  if (globalThis.IS_GUTENBERG_PLUGIN) {
    // Convert pattern overrides added during experimental phase.
    // Only four blocks were supported initially.
    // These checks can be removed in WordPress 6.6.
    if (newAttributes.metadata?.bindings && (name === 'core/paragraph' || name === 'core/heading' || name === 'core/image' || name === 'core/button') && newAttributes.metadata.bindings.__default?.source !== 'core/pattern-overrides') {
      const bindings = ['content', 'url', 'title', 'id', 'alt', 'text', 'linkTarget'];
      // Delete any existing individual bindings and add a default binding.
      // It was only possible to add all the default attributes through the UI,
      // So as soon as we find an attribute, we can assume all default attributes are overridable.
      let hasPatternOverrides = false;
      bindings.forEach(binding => {
        if (newAttributes.metadata.bindings[binding]?.source === 'core/pattern-overrides') {
          hasPatternOverrides = true;
          newAttributes.metadata = {
            ...newAttributes.metadata,
            bindings: {
              ...newAttributes.metadata.bindings
            }
          };
          delete newAttributes.metadata.bindings[binding];
        }
      });
      if (hasPatternOverrides) {
        newAttributes.metadata.bindings.__default = {
          source: 'core/pattern-overrides'
        };
      }
    }
  }
  return [name, newAttributes];
}
//# sourceMappingURL=convert-legacy-block.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/hpq@1.4.0/node_modules/hpq/es/get-path.js
/**
 * Given object and string of dot-delimited path segments, returns value at
 * path or undefined if path cannot be resolved.
 *
 * @param object Lookup object
 * @param path   Path to resolve
 * @return       Resolved value
 */
function getPath(object, path) {
  var segments = path.split('.');
  var segment;
  while (segment = segments.shift()) {
    if (!(segment in object)) {
      return;
    }
    object = object[segment];
  }
  return object;
}
;// CONCATENATED MODULE: ../../node_modules/.pnpm/hpq@1.4.0/node_modules/hpq/es/index.js
/**
 * Internal dependencies
 */

/**
 * Function returning a DOM document created by `createHTMLDocument`. The same
 * document is returned between invocations.
 *
 * @return DOM document.
 */
var getDocument = function () {
  var doc;
  return function () {
    if (!doc) {
      doc = document.implementation.createHTMLDocument('');
    }
    return doc;
  };
}();

/**
 * Given a markup string or DOM element, creates an object aligning with the
 * shape of the matchers object, or the value returned by the matcher.
 *
 * @param source Source content
 * @param matchers Matcher function or object of matchers
 */

/**
 * Given a markup string or DOM element, creates an object aligning with the
 * shape of the matchers object, or the value returned by the matcher.
 *
 * @param source Source content
 * @param matchers Matcher function or object of matchers
 */
function es_parse(source, matchers) {
  if (!matchers) {
    return;
  }

  // Coerce to element
  if ('string' === typeof source) {
    var doc = getDocument();
    doc.body.innerHTML = source;
    source = doc.body;
  }

  // Return singular value
  if (typeof matchers === 'function') {
    return matchers(source);
  }

  // Bail if we can't handle matchers
  if (Object !== matchers.constructor) {
    return;
  }

  // Shape result by matcher object
  return Object.keys(matchers).reduce(function (memo, key) {
    var inner = matchers[key];
    memo[key] = es_parse(source, inner);
    return memo;
  }, {});
}

/**
 * Generates a function which matches node of type selector, returning an
 * attribute by property if the attribute exists. If no selector is passed,
 * returns property of the query element.
 *
 * @param name Property name
 * @return Property value
 */

/**
 * Generates a function which matches node of type selector, returning an
 * attribute by property if the attribute exists. If no selector is passed,
 * returns property of the query element.
 *
 * @param selector Optional selector
 * @param name Property name
 * @return Property value
 */
function prop(arg1, arg2) {
  var name;
  var selector;
  if (1 === arguments.length) {
    name = arg1;
    selector = undefined;
  } else {
    name = arg2;
    selector = arg1;
  }
  return function (node) {
    var match = node;
    if (selector) {
      match = node.querySelector(selector);
    }
    if (match) {
      return getPath(match, name);
    }
  };
}

/**
 * Generates a function which matches node of type selector, returning an
 * attribute by name if the attribute exists. If no selector is passed,
 * returns attribute of the query element.
 *
 * @param name Attribute name
 * @return Attribute value
 */

/**
 * Generates a function which matches node of type selector, returning an
 * attribute by name if the attribute exists. If no selector is passed,
 * returns attribute of the query element.
 *
 * @param selector Optional selector
 * @param name Attribute name
 * @return Attribute value
 */
function attr(arg1, arg2) {
  var name;
  var selector;
  if (1 === arguments.length) {
    name = arg1;
    selector = undefined;
  } else {
    name = arg2;
    selector = arg1;
  }
  return function (node) {
    var attributes = prop(selector, 'attributes')(node);
    if (attributes && Object.prototype.hasOwnProperty.call(attributes, name)) {
      return attributes[name].value;
    }
  };
}

/**
 * Convenience for `prop( selector, 'innerHTML' )`.
 *
 * @see prop()
 *
 * @param selector Optional selector
 * @return Inner HTML
 */
function html(selector) {
  return prop(selector, 'innerHTML');
}

/**
 * Convenience for `prop( selector, 'textContent' )`.
 *
 * @see prop()
 *
 * @param selector Optional selector
 * @return Text content
 */
function es_text(selector) {
  return prop(selector, 'textContent');
}

/**
 * Creates a new matching context by first finding elements matching selector
 * using querySelectorAll before then running another `parse` on `matchers`
 * scoped to the matched elements.
 *
 * @see parse()
 *
 * @param selector Selector to match
 * @param matchers Matcher function or object of matchers
 * @return Matcher function which returns an array of matched value(s)
 */
function query(selector, matchers) {
  return function (node) {
    var matches = node.querySelectorAll(selector);
    return [].map.call(matches, function (match) {
      return es_parse(match, matchers);
    });
  };
}
// EXTERNAL MODULE: ../../node_modules/.pnpm/memize@2.1.0/node_modules/memize/dist/index.js
var dist = __webpack_require__("../../node_modules/.pnpm/memize@2.1.0/node_modules/memize/dist/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/matchers.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function matchers_html(selector, multilineTag) {
  return domNode => {
    let match = domNode;
    if (selector) {
      match = domNode.querySelector(selector);
    }
    if (!match) {
      return '';
    }
    if (multilineTag) {
      let value = '';
      const length = match.children.length;
      for (let index = 0; index < length; index++) {
        const child = match.children[index];
        if (child.nodeName.toLowerCase() !== multilineTag) {
          continue;
        }
        value += child.outerHTML;
      }
      return value;
    }
    return match.innerHTML;
  };
}
const richText = (selector, preserveWhiteSpace) => el => {
  const target = selector ? el.querySelector(selector) : el;
  return target ? rich_text_build_module/* RichTextData */.EF.fromHTMLElement(target, {
    preserveWhiteSpace
  }) : rich_text_build_module/* RichTextData */.EF.empty();
};
//# sourceMappingURL=matchers.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/node.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * A representation of a single node within a block's rich text value. If
 * representing a text node, the value is simply a string of the node value.
 * As representing an element node, it is an object of:
 *
 * 1. `type` (string): Tag name.
 * 2. `props` (object): Attributes and children array of WPBlockNode.
 *
 * @typedef {string|Object} WPBlockNode
 */

/**
 * Given a single node and a node type (e.g. `'br'`), returns true if the node
 * corresponds to that type, false otherwise.
 *
 * @param {WPBlockNode} node Block node to test
 * @param {string}      type Node to type to test against.
 *
 * @return {boolean} Whether node is of intended type.
 */
function isNodeOfType(node, type) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.node.isNodeOfType', {
    since: '6.1',
    version: '6.3',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  return node && node.type === type;
}

/**
 * Given an object implementing the NamedNodeMap interface, returns a plain
 * object equivalent value of name, value key-value pairs.
 *
 * @see https://dom.spec.whatwg.org/#interface-namednodemap
 *
 * @param {NamedNodeMap} nodeMap NamedNodeMap to convert to object.
 *
 * @return {Object} Object equivalent value of NamedNodeMap.
 */
function getNamedNodeMapAsObject(nodeMap) {
  const result = {};
  for (let i = 0; i < nodeMap.length; i++) {
    const {
      name,
      value
    } = nodeMap[i];
    result[name] = value;
  }
  return result;
}

/**
 * Given a DOM Element or Text node, returns an equivalent block node. Throws
 * if passed any node type other than element or text.
 *
 * @throws {TypeError} If non-element/text node is passed.
 *
 * @param {Node} domNode DOM node to convert.
 *
 * @return {WPBlockNode} Block node equivalent to DOM node.
 */
function fromDOM(domNode) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.node.fromDOM', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.create',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  if (domNode.nodeType === domNode.TEXT_NODE) {
    return domNode.nodeValue;
  }
  if (domNode.nodeType !== domNode.ELEMENT_NODE) {
    throw new TypeError('A block node can only be created from a node of type text or ' + 'element.');
  }
  return {
    type: domNode.nodeName.toLowerCase(),
    props: {
      ...getNamedNodeMapAsObject(domNode.attributes),
      children: children_fromDOM(domNode.childNodes)
    }
  };
}

/**
 * Given a block node, returns its HTML string representation.
 *
 * @param {WPBlockNode} node Block node to convert to string.
 *
 * @return {string} String HTML representation of block node.
 */
function toHTML(node) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.node.toHTML', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.toHTMLString',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  return children_toHTML([node]);
}

/**
 * Given a selector, returns an hpq matcher generating a WPBlockNode value
 * matching the selector result.
 *
 * @param {string} selector DOM selector.
 *
 * @return {Function} hpq matcher.
 */
function matcher(selector) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.node.matcher', {
    since: '6.1',
    version: '6.3',
    alternative: 'html source',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  return domNode => {
    let match = domNode;
    if (selector) {
      match = domNode.querySelector(selector);
    }
    try {
      return fromDOM(match);
    } catch (error) {
      return null;
    }
  };
}

/**
 * Object of utility functions used in managing block attribute values of
 * source `node`.
 *
 * @see https://github.com/WordPress/gutenberg/pull/10439
 *
 * @deprecated since 4.0. The `node` source should not be used, and can be
 *             replaced by the `html` source.
 *
 * @private
 */
/* harmony default export */ const node = ({
  isNodeOfType,
  fromDOM,
  toHTML,
  matcher
});
//# sourceMappingURL=node.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/children.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * A representation of a block's rich text value.
 *
 * @typedef {WPBlockNode[]} WPBlockChildren
 */

/**
 * Given block children, returns a serialize-capable WordPress element.
 *
 * @param {WPBlockChildren} children Block children object to convert.
 *
 * @return {Element} A serialize-capable element.
 */
function getSerializeCapableElement(children) {
  // The fact that block children are compatible with the element serializer is
  // merely an implementation detail that currently serves to be true, but
  // should not be mistaken as being a guarantee on the external API. The
  // public API only offers guarantees to work with strings (toHTML) and DOM
  // elements (fromDOM), and should provide utilities to manipulate the value
  // rather than expect consumers to inspect or construct its shape (concat).
  return children;
}

/**
 * Given block children, returns an array of block nodes.
 *
 * @param {WPBlockChildren} children Block children object to convert.
 *
 * @return {Array<WPBlockNode>} An array of individual block nodes.
 */
function getChildrenArray(children) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.getChildrenArray', {
    since: '6.1',
    version: '6.3',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });

  // The fact that block children are compatible with the element serializer
  // is merely an implementation detail that currently serves to be true, but
  // should not be mistaken as being a guarantee on the external API.
  return children;
}

/**
 * Given two or more block nodes, returns a new block node representing a
 * concatenation of its values.
 *
 * @param {...WPBlockChildren} blockNodes Block nodes to concatenate.
 *
 * @return {WPBlockChildren} Concatenated block node.
 */
function concat(...blockNodes) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.concat', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.concat',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  const result = [];
  for (let i = 0; i < blockNodes.length; i++) {
    const blockNode = Array.isArray(blockNodes[i]) ? blockNodes[i] : [blockNodes[i]];
    for (let j = 0; j < blockNode.length; j++) {
      const child = blockNode[j];
      const canConcatToPreviousString = typeof child === 'string' && typeof result[result.length - 1] === 'string';
      if (canConcatToPreviousString) {
        result[result.length - 1] += child;
      } else {
        result.push(child);
      }
    }
  }
  return result;
}

/**
 * Given an iterable set of DOM nodes, returns equivalent block children.
 * Ignores any non-element/text nodes included in set.
 *
 * @param {Iterable.<Node>} domNodes Iterable set of DOM nodes to convert.
 *
 * @return {WPBlockChildren} Block children equivalent to DOM nodes.
 */
function children_fromDOM(domNodes) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.fromDOM', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.create',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  const result = [];
  for (let i = 0; i < domNodes.length; i++) {
    try {
      result.push(fromDOM(domNodes[i]));
    } catch (error) {
      // Simply ignore if DOM node could not be converted.
    }
  }
  return result;
}

/**
 * Given a block node, returns its HTML string representation.
 *
 * @param {WPBlockChildren} children Block node(s) to convert to string.
 *
 * @return {string} String HTML representation of block node.
 */
function children_toHTML(children) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.toHTML', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.toHTMLString',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  const element = getSerializeCapableElement(children);
  return (0,serialize/* default */.Ay)(element);
}

/**
 * Given a selector, returns an hpq matcher generating a WPBlockChildren value
 * matching the selector result.
 *
 * @param {string} selector DOM selector.
 *
 * @return {Function} hpq matcher.
 */
function children_matcher(selector) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.matcher', {
    since: '6.1',
    version: '6.3',
    alternative: 'html source',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  return domNode => {
    let match = domNode;
    if (selector) {
      match = domNode.querySelector(selector);
    }
    if (match) {
      return children_fromDOM(match.childNodes);
    }
    return [];
  };
}

/**
 * Object of utility functions used in managing block attribute values of
 * source `children`.
 *
 * @see https://github.com/WordPress/gutenberg/pull/10439
 *
 * @deprecated since 4.0. The `children` source should not be used, and can be
 *             replaced by the `html` source.
 *
 * @private
 */
/* harmony default export */ const children = ({
  concat,
  getChildrenArray,
  fromDOM: children_fromDOM,
  toHTML: children_toHTML,
  matcher: children_matcher
});
//# sourceMappingURL=children.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/parser/get-block-attributes.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * Higher-order hpq matcher which enhances an attribute matcher to return true
 * or false depending on whether the original matcher returns undefined. This
 * is useful for boolean attributes (e.g. disabled) whose attribute values may
 * be technically falsey (empty string), though their mere presence should be
 * enough to infer as true.
 *
 * @param {Function} matcher Original hpq matcher.
 *
 * @return {Function} Enhanced hpq matcher.
 */
const toBooleanAttributeMatcher = matcher => value => matcher(value) !== undefined;

/**
 * Returns true if value is of the given JSON schema type, or false otherwise.
 *
 * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25
 *
 * @param {*}      value Value to test.
 * @param {string} type  Type to test.
 *
 * @return {boolean} Whether value is of type.
 */
function isOfType(value, type) {
  switch (type) {
    case 'rich-text':
      return value instanceof rich_text_build_module/* RichTextData */.EF;
    case 'string':
      return typeof value === 'string';
    case 'boolean':
      return typeof value === 'boolean';
    case 'object':
      return !!value && value.constructor === Object;
    case 'null':
      return value === null;
    case 'array':
      return Array.isArray(value);
    case 'integer':
    case 'number':
      return typeof value === 'number';
  }
  return true;
}

/**
 * Returns true if value is of an array of given JSON schema types, or false
 * otherwise.
 *
 * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25
 *
 * @param {*}        value Value to test.
 * @param {string[]} types Types to test.
 *
 * @return {boolean} Whether value is of types.
 */
function isOfTypes(value, types) {
  return types.some(type => isOfType(value, type));
}

/**
 * Given an attribute key, an attribute's schema, a block's raw content and the
 * commentAttributes returns the attribute value depending on its source
 * definition of the given attribute key.
 *
 * @param {string} attributeKey      Attribute key.
 * @param {Object} attributeSchema   Attribute's schema.
 * @param {Node}   innerDOM          Parsed DOM of block's inner HTML.
 * @param {Object} commentAttributes Block's comment attributes.
 * @param {string} innerHTML         Raw HTML from block node's innerHTML property.
 *
 * @return {*} Attribute value.
 */
function getBlockAttribute(attributeKey, attributeSchema, innerDOM, commentAttributes, innerHTML) {
  let value;
  switch (attributeSchema.source) {
    // An undefined source means that it's an attribute serialized to the
    // block's "comment".
    case undefined:
      value = commentAttributes ? commentAttributes[attributeKey] : undefined;
      break;
    // raw source means that it's the original raw block content.
    case 'raw':
      value = innerHTML;
      break;
    case 'attribute':
    case 'property':
    case 'html':
    case 'text':
    case 'rich-text':
    case 'children':
    case 'node':
    case 'query':
    case 'tag':
      value = parseWithAttributeSchema(innerDOM, attributeSchema);
      break;
  }
  if (!isValidByType(value, attributeSchema.type) || !isValidByEnum(value, attributeSchema.enum)) {
    // Reject the value if it is not valid. Reverting to the undefined
    // value ensures the default is respected, if applicable.
    value = undefined;
  }
  if (value === undefined) {
    value = getDefault(attributeSchema);
  }
  return value;
}

/**
 * Returns true if value is valid per the given block attribute schema type
 * definition, or false otherwise.
 *
 * @see https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.1
 *
 * @param {*}                       value Value to test.
 * @param {?(Array<string>|string)} type  Block attribute schema type.
 *
 * @return {boolean} Whether value is valid.
 */
function isValidByType(value, type) {
  return type === undefined || isOfTypes(value, Array.isArray(type) ? type : [type]);
}

/**
 * Returns true if value is valid per the given block attribute schema enum
 * definition, or false otherwise.
 *
 * @see https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.2
 *
 * @param {*}      value   Value to test.
 * @param {?Array} enumSet Block attribute schema enum.
 *
 * @return {boolean} Whether value is valid.
 */
function isValidByEnum(value, enumSet) {
  return !Array.isArray(enumSet) || enumSet.includes(value);
}

/**
 * Returns an hpq matcher given a source object.
 *
 * @param {Object} sourceConfig Attribute Source object.
 *
 * @return {Function} A hpq Matcher.
 */
const matcherFromSource = (0,dist/* default */.A)(sourceConfig => {
  switch (sourceConfig.source) {
    case 'attribute':
      {
        let matcher = attr(sourceConfig.selector, sourceConfig.attribute);
        if (sourceConfig.type === 'boolean') {
          matcher = toBooleanAttributeMatcher(matcher);
        }
        return matcher;
      }
    case 'html':
      return matchers_html(sourceConfig.selector, sourceConfig.multiline);
    case 'text':
      return es_text(sourceConfig.selector);
    case 'rich-text':
      return richText(sourceConfig.selector, sourceConfig.__unstablePreserveWhiteSpace);
    case 'children':
      return children_matcher(sourceConfig.selector);
    case 'node':
      return matcher(sourceConfig.selector);
    case 'query':
      const subMatchers = Object.fromEntries(Object.entries(sourceConfig.query).map(([key, subSourceConfig]) => [key, matcherFromSource(subSourceConfig)]));
      return query(sourceConfig.selector, subMatchers);
    case 'tag':
      {
        const matcher = prop(sourceConfig.selector, 'nodeName');
        return domNode => matcher(domNode)?.toLowerCase();
      }
    default:
      // eslint-disable-next-line no-console
      console.error(`Unknown source type "${sourceConfig.source}"`);
  }
});

/**
 * Parse a HTML string into DOM tree.
 *
 * @param {string|Node} innerHTML HTML string or already parsed DOM node.
 *
 * @return {Node} Parsed DOM node.
 */
function parseHtml(innerHTML) {
  return es_parse(innerHTML, h => h);
}

/**
 * Given a block's raw content and an attribute's schema returns the attribute's
 * value depending on its source.
 *
 * @param {string|Node} innerHTML       Block's raw content.
 * @param {Object}      attributeSchema Attribute's schema.
 *
 * @return {*} Attribute value.
 */
function parseWithAttributeSchema(innerHTML, attributeSchema) {
  return matcherFromSource(attributeSchema)(parseHtml(innerHTML));
}

/**
 * Returns the block attributes of a registered block node given its type.
 *
 * @param {string|Object} blockTypeOrName Block type or name.
 * @param {string|Node}   innerHTML       Raw block content.
 * @param {?Object}       attributes      Known block attributes (from delimiters).
 *
 * @return {Object} All block attributes.
 */
function getBlockAttributes(blockTypeOrName, innerHTML, attributes = {}) {
  var _blockType$attributes;
  const doc = parseHtml(innerHTML);
  const blockType = utils_normalizeBlockType(blockTypeOrName);
  const blockAttributes = Object.fromEntries(Object.entries((_blockType$attributes = blockType.attributes) !== null && _blockType$attributes !== void 0 ? _blockType$attributes : {}).map(([key, schema]) => [key, getBlockAttribute(key, schema, doc, attributes, innerHTML)]));
  return (0,hooks_build_module/* applyFilters */.W5)('blocks.getBlockAttributes', blockAttributes, blockType, innerHTML, attributes);
}
//# sourceMappingURL=get-block-attributes.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/parser/fix-custom-classname.js
/**
 * Internal dependencies
 */



const CLASS_ATTR_SCHEMA = {
  type: 'string',
  source: 'attribute',
  selector: '[data-custom-class-name] > *',
  attribute: 'class'
};

/**
 * Given an HTML string, returns an array of class names assigned to the root
 * element in the markup.
 *
 * @param {string} innerHTML Markup string from which to extract classes.
 *
 * @return {string[]} Array of class names assigned to the root element.
 */
function getHTMLRootElementClasses(innerHTML) {
  const parsed = parseWithAttributeSchema(`<div data-custom-class-name>${innerHTML}</div>`, CLASS_ATTR_SCHEMA);
  return parsed ? parsed.trim().split(/\s+/) : [];
}

/**
 * Given a parsed set of block attributes, if the block supports custom class
 * names and an unknown class (per the block's serialization behavior) is
 * found, the unknown classes are treated as custom classes. This prevents the
 * block from being considered as invalid.
 *
 * @param {Object} blockAttributes Original block attributes.
 * @param {Object} blockType       Block type settings.
 * @param {string} innerHTML       Original block markup.
 *
 * @return {Object} Filtered block attributes.
 */
function fixCustomClassname(blockAttributes, blockType, innerHTML) {
  if (hasBlockSupport(blockType, 'customClassName', true)) {
    // To determine difference, serialize block given the known set of
    // attributes, with the exception of `className`. This will determine
    // the default set of classes. From there, any difference in innerHTML
    // can be considered as custom classes.
    const {
      className: omittedClassName,
      ...attributesSansClassName
    } = blockAttributes;
    const serialized = getSaveContent(blockType, attributesSansClassName);
    const defaultClasses = getHTMLRootElementClasses(serialized);
    const actualClasses = getHTMLRootElementClasses(innerHTML);
    const customClasses = actualClasses.filter(className => !defaultClasses.includes(className));
    if (customClasses.length) {
      blockAttributes.className = customClasses.join(' ');
    } else if (serialized) {
      delete blockAttributes.className;
    }
  }
  return blockAttributes;
}
//# sourceMappingURL=fix-custom-classname.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/parser/apply-built-in-validation-fixes.js
/**
 * Internal dependencies
 */


/**
 * Attempts to fix block invalidation by applying build-in validation fixes
 * like moving all extra classNames to the className attribute.
 *
 * @param {WPBlock}                               block     block object.
 * @param {import('../registration').WPBlockType} blockType Block type. This is normalize not necessary and
 *                                                          can be inferred from the block name,
 *                                                          but it's here for performance reasons.
 *
 * @return {WPBlock} Fixed block object
 */
function applyBuiltInValidationFixes(block, blockType) {
  const updatedBlockAttributes = fixCustomClassname(block.attributes, blockType, block.originalContent);
  return {
    ...block,
    attributes: updatedBlockAttributes
  };
}
//# sourceMappingURL=apply-built-in-validation-fixes.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/parser/apply-block-deprecated-versions.js
/**
 * Internal dependencies
 */






/**
 * Function that takes no arguments and always returns false.
 *
 * @return {boolean} Always returns false.
 */
function stubFalse() {
  return false;
}

/**
 * Given a block object, returns a new copy of the block with any applicable
 * deprecated migrations applied, or the original block if it was both valid
 * and no eligible migrations exist.
 *
 * @param {import(".").WPBlock}                   block     Parsed and invalid block object.
 * @param {import(".").WPRawBlock}                rawBlock  Raw block object.
 * @param {import('../registration').WPBlockType} blockType Block type. This is normalize not necessary and
 *                                                          can be inferred from the block name,
 *                                                          but it's here for performance reasons.
 *
 * @return {import(".").WPBlock} Migrated block object.
 */
function applyBlockDeprecatedVersions(block, rawBlock, blockType) {
  const parsedAttributes = rawBlock.attrs;
  const {
    deprecated: deprecatedDefinitions
  } = blockType;
  // Bail early if there are no registered deprecations to be handled.
  if (!deprecatedDefinitions || !deprecatedDefinitions.length) {
    return block;
  }

  // By design, blocks lack any sort of version tracking. Instead, to process
  // outdated content the system operates a queue out of all the defined
  // attribute shapes and tries each definition until the input produces a
  // valid result. This mechanism seeks to avoid polluting the user-space with
  // machine-specific code. An invalid block is thus a block that could not be
  // matched successfully with any of the registered deprecation definitions.
  for (let i = 0; i < deprecatedDefinitions.length; i++) {
    // A block can opt into a migration even if the block is valid by
    // defining `isEligible` on its deprecation. If the block is both valid
    // and does not opt to migrate, skip.
    const {
      isEligible = stubFalse
    } = deprecatedDefinitions[i];
    if (block.isValid && !isEligible(parsedAttributes, block.innerBlocks, {
      blockNode: rawBlock,
      block
    })) {
      continue;
    }

    // Block type properties which could impact either serialization or
    // parsing are not considered in the deprecated block type by default,
    // and must be explicitly provided.
    const deprecatedBlockType = Object.assign(omit(blockType, DEPRECATED_ENTRY_KEYS), deprecatedDefinitions[i]);
    let migratedBlock = {
      ...block,
      attributes: getBlockAttributes(deprecatedBlockType, block.originalContent, parsedAttributes)
    };

    // Ignore the deprecation if it produces a block which is not valid.
    let [isValid] = validateBlock(migratedBlock, deprecatedBlockType);

    // If the migrated block is not valid initially, try the built-in fixes.
    if (!isValid) {
      migratedBlock = applyBuiltInValidationFixes(migratedBlock, deprecatedBlockType);
      [isValid] = validateBlock(migratedBlock, deprecatedBlockType);
    }

    // An invalid block does not imply incorrect HTML but the fact block
    // source information could be lost on re-serialization.
    if (!isValid) {
      continue;
    }
    let migratedInnerBlocks = migratedBlock.innerBlocks;
    let migratedAttributes = migratedBlock.attributes;

    // A block may provide custom behavior to assign new attributes and/or
    // inner blocks.
    const {
      migrate
    } = deprecatedBlockType;
    if (migrate) {
      let migrated = migrate(migratedAttributes, block.innerBlocks);
      if (!Array.isArray(migrated)) {
        migrated = [migrated];
      }
      [migratedAttributes = parsedAttributes, migratedInnerBlocks = block.innerBlocks] = migrated;
    }
    block = {
      ...block,
      attributes: migratedAttributes,
      innerBlocks: migratedInnerBlocks,
      isValid: true,
      validationIssues: []
    };
  }
  return block;
}
//# sourceMappingURL=apply-block-deprecated-versions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/parser/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */










/**
 * The raw structure of a block includes its attributes, inner
 * blocks, and inner HTML. It is important to distinguish inner blocks from
 * the HTML content of the block as only the latter is relevant for block
 * validation and edit operations.
 *
 * @typedef WPRawBlock
 *
 * @property {string=}         blockName    Block name
 * @property {Object=}         attrs        Block raw or comment attributes.
 * @property {string}          innerHTML    HTML content of the block.
 * @property {(string|null)[]} innerContent Content without inner blocks.
 * @property {WPRawBlock[]}    innerBlocks  Inner Blocks.
 */

/**
 * Fully parsed block object.
 *
 * @typedef WPBlock
 *
 * @property {string}     name                    Block name
 * @property {Object}     attributes              Block raw or comment attributes.
 * @property {WPBlock[]}  innerBlocks             Inner Blocks.
 * @property {string}     originalContent         Original content of the block before validation fixes.
 * @property {boolean}    isValid                 Whether the block is valid.
 * @property {Object[]}   validationIssues        Validation issues.
 * @property {WPRawBlock} [__unstableBlockSource] Un-processed original copy of block if created through parser.
 */

/**
 * @typedef  {Object}  ParseOptions
 * @property {boolean?} __unstableSkipMigrationLogs If a block is migrated from a deprecated version, skip logging the migration details.
 * @property {boolean?} __unstableSkipAutop         Whether to skip autop when processing freeform content.
 */

/**
 * Convert legacy blocks to their canonical form. This function is used
 * both in the parser level for previous content and to convert such blocks
 * used in Custom Post Types templates.
 *
 * @param {WPRawBlock} rawBlock
 *
 * @return {WPRawBlock} The block's name and attributes, changed accordingly if a match was found
 */
function convertLegacyBlocks(rawBlock) {
  const [correctName, correctedAttributes] = convertLegacyBlockNameAndAttributes(rawBlock.blockName, rawBlock.attrs);
  return {
    ...rawBlock,
    blockName: correctName,
    attrs: correctedAttributes
  };
}

/**
 * Normalize the raw block by applying the fallback block name if none given,
 * sanitize the parsed HTML...
 *
 * @param {WPRawBlock}    rawBlock The raw block object.
 * @param {ParseOptions?} options  Extra options for handling block parsing.
 *
 * @return {WPRawBlock} The normalized block object.
 */
function normalizeRawBlock(rawBlock, options) {
  const fallbackBlockName = registration_getFreeformContentHandlerName();

  // If the grammar parsing don't produce any block name, use the freeform block.
  const rawBlockName = rawBlock.blockName || registration_getFreeformContentHandlerName();
  const rawAttributes = rawBlock.attrs || {};
  const rawInnerBlocks = rawBlock.innerBlocks || [];
  let rawInnerHTML = rawBlock.innerHTML.trim();

  // Fallback content may be upgraded from classic content expecting implicit
  // automatic paragraphs, so preserve them. Assumes wpautop is idempotent,
  // meaning there are no negative consequences to repeated autop calls.
  if (rawBlockName === fallbackBlockName && rawBlockName === 'core/freeform' && !options?.__unstableSkipAutop) {
    rawInnerHTML = autop(rawInnerHTML).trim();
  }
  return {
    ...rawBlock,
    blockName: rawBlockName,
    attrs: rawAttributes,
    innerHTML: rawInnerHTML,
    innerBlocks: rawInnerBlocks
  };
}

/**
 * Uses the "unregistered blockType" to create a block object.
 *
 * @param {WPRawBlock} rawBlock block.
 *
 * @return {WPRawBlock} The unregistered block object.
 */
function createMissingBlockType(rawBlock) {
  const unregisteredFallbackBlock = getUnregisteredTypeHandlerName() || registration_getFreeformContentHandlerName();

  // Preserve undelimited content for use by the unregistered type
  // handler. A block node's `innerHTML` isn't enough, as that field only
  // carries the block's own HTML and not its nested blocks.
  const originalUndelimitedContent = serializeRawBlock(rawBlock, {
    isCommentDelimited: false
  });

  // Preserve full block content for use by the unregistered type
  // handler, block boundaries included.
  const originalContent = serializeRawBlock(rawBlock, {
    isCommentDelimited: true
  });
  return {
    blockName: unregisteredFallbackBlock,
    attrs: {
      originalName: rawBlock.blockName,
      originalContent,
      originalUndelimitedContent
    },
    innerHTML: rawBlock.blockName ? originalContent : rawBlock.innerHTML,
    innerBlocks: rawBlock.innerBlocks,
    innerContent: rawBlock.innerContent
  };
}

/**
 * Validates a block and wraps with validation meta.
 *
 * The name here is regrettable but `validateBlock` is already taken.
 *
 * @param {WPBlock}                               unvalidatedBlock
 * @param {import('../registration').WPBlockType} blockType
 * @return {WPBlock}                              validated block, with auto-fixes if initially invalid
 */
function applyBlockValidation(unvalidatedBlock, blockType) {
  // Attempt to validate the block.
  const [isValid] = validateBlock(unvalidatedBlock, blockType);
  if (isValid) {
    return {
      ...unvalidatedBlock,
      isValid,
      validationIssues: []
    };
  }

  // If the block is invalid, attempt some built-in fixes
  // like custom classNames handling.
  const fixedBlock = applyBuiltInValidationFixes(unvalidatedBlock, blockType);
  // Attempt to validate the block once again after the built-in fixes.
  const [isFixedValid, validationIssues] = validateBlock(unvalidatedBlock, blockType);
  return {
    ...fixedBlock,
    isValid: isFixedValid,
    validationIssues
  };
}

/**
 * Given a raw block returned by grammar parsing, returns a fully parsed block.
 *
 * @param {WPRawBlock}   rawBlock The raw block object.
 * @param {ParseOptions} options  Extra options for handling block parsing.
 *
 * @return {WPBlock | undefined} Fully parsed block.
 */
function parseRawBlock(rawBlock, options) {
  let normalizedBlock = normalizeRawBlock(rawBlock, options);

  // During the lifecycle of the project, we renamed some old blocks
  // and transformed others to new blocks. To avoid breaking existing content,
  // we added this function to properly parse the old content.
  normalizedBlock = convertLegacyBlocks(normalizedBlock);

  // Try finding the type for known block name.
  let blockType = getBlockType(normalizedBlock.blockName);

  // If not blockType is found for the specified name, fallback to the "unregistedBlockType".
  if (!blockType) {
    normalizedBlock = createMissingBlockType(normalizedBlock);
    blockType = getBlockType(normalizedBlock.blockName);
  }

  // If it's an empty freeform block or there's no blockType (no missing block handler)
  // Then, just ignore the block.
  // It might be a good idea to throw a warning here.
  // TODO: I'm unsure about the unregisteredFallbackBlock check,
  // it might ignore some dynamic unregistered third party blocks wrongly.
  const isFallbackBlock = normalizedBlock.blockName === registration_getFreeformContentHandlerName() || normalizedBlock.blockName === getUnregisteredTypeHandlerName();
  if (!blockType || !normalizedBlock.innerHTML && isFallbackBlock) {
    return;
  }

  // Parse inner blocks recursively.
  const parsedInnerBlocks = normalizedBlock.innerBlocks.map(innerBlock => parseRawBlock(innerBlock, options))
  // See https://github.com/WordPress/gutenberg/pull/17164.
  .filter(innerBlock => !!innerBlock);

  // Get the fully parsed block.
  const parsedBlock = createBlock(normalizedBlock.blockName, getBlockAttributes(blockType, normalizedBlock.innerHTML, normalizedBlock.attrs), parsedInnerBlocks);
  parsedBlock.originalContent = normalizedBlock.innerHTML;
  const validatedBlock = applyBlockValidation(parsedBlock, blockType);
  const {
    validationIssues
  } = validatedBlock;

  // Run the block deprecation and migrations.
  // This is performed on both invalid and valid blocks because
  // migration using the `migrate` functions should run even
  // if the output is deemed valid.
  const updatedBlock = applyBlockDeprecatedVersions(validatedBlock, normalizedBlock, blockType);
  if (!updatedBlock.isValid) {
    // Preserve the original unprocessed version of the block
    // that we received (no fixes, no deprecations) so that
    // we can save it as close to exactly the same way as
    // we loaded it. This is important to avoid corruption
    // and data loss caused by block implementations trying
    // to process data that isn't fully recognized.
    updatedBlock.__unstableBlockSource = rawBlock;
  }
  if (!validatedBlock.isValid && updatedBlock.isValid && !options?.__unstableSkipMigrationLogs) {
    /* eslint-disable no-console */
    console.groupCollapsed('Updated Block: %s', blockType.name);
    console.info('Block successfully updated for `%s` (%o).\n\nNew content generated by `save` function:\n\n%s\n\nContent retrieved from post body:\n\n%s', blockType.name, blockType, getSaveContent(blockType, updatedBlock.attributes), updatedBlock.originalContent);
    console.groupEnd();
    /* eslint-enable no-console */
  } else if (!validatedBlock.isValid && !updatedBlock.isValid) {
    validationIssues.forEach(({
      log,
      args
    }) => log(...args));
  }
  return updatedBlock;
}

/**
 * Utilizes an optimized token-driven parser based on the Gutenberg grammar spec
 * defined through a parsing expression grammar to take advantage of the regular
 * cadence provided by block delimiters -- composed syntactically through HTML
 * comments -- which, given a general HTML document as an input, returns a block
 * list array representation.
 *
 * This is a recursive-descent parser that scans linearly once through the input
 * document. Instead of directly recursing it utilizes a trampoline mechanism to
 * prevent stack overflow. This initial pass is mainly interested in separating
 * and isolating the blocks serialized in the document and manifestly not in the
 * content within the blocks.
 *
 * @see
 * https://developer.wordpress.org/block-editor/packages/packages-block-serialization-default-parser/
 *
 * @param {string}       content The post content.
 * @param {ParseOptions} options Extra options for handling block parsing.
 *
 * @return {Array} Block list.
 */
function parser_parse(content, options) {
  return parse(content).reduce((accumulator, rawBlock) => {
    const block = parseRawBlock(rawBlock, options);
    if (block) {
      accumulator.push(block);
    }
    return accumulator;
  }, []);
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/platform.js
var platform = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/platform.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/get-raw-transforms.js
/**
 * Internal dependencies
 */

function getRawTransforms() {
  return getBlockTransforms('from').filter(({
    type
  }) => type === 'raw').map(transform => {
    return transform.isMatch ? transform : {
      ...transform,
      isMatch: node => transform.selector && node.matches(transform.selector)
    };
  });
}
//# sourceMappingURL=get-raw-transforms.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/html-to-blocks.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





/**
 * Converts HTML directly to blocks. Looks for a matching transform for each
 * top-level tag. The HTML should be filtered to not have any text between
 * top-level tags and formatted in a way that blocks can handle the HTML.
 *
 * @param {string}   html    HTML to convert.
 * @param {Function} handler The handler calling htmlToBlocks: either rawHandler
 *                           or pasteHandler.
 *
 * @return {Array} An array of blocks.
 */
function htmlToBlocks(html, handler) {
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = html;
  return Array.from(doc.body.children).flatMap(node => {
    const rawTransform = findTransform(getRawTransforms(), ({
      isMatch
    }) => isMatch(node));
    if (!rawTransform) {
      // Until the HTML block is supported in the native version, we'll parse it
      // instead of creating the block to generate it as an unsupported block.
      if (platform/* default */.A.isNative) {
        return parser_parse(`<!-- wp:html -->${node.outerHTML}<!-- /wp:html -->`);
      }
      return createBlock(
      // Should not be hardcoded.
      'core/html', getBlockAttributes('core/html', node.outerHTML));
    }
    const {
      transform,
      blockName
    } = rawTransform;
    if (transform) {
      const block = transform(node, handler);
      if (node.hasAttribute('class')) {
        block.attributes.className = node.getAttribute('class');
      }
      return block;
    }
    return createBlock(blockName, getBlockAttributes(blockName, node.outerHTML));
  });
}
//# sourceMappingURL=html-to-blocks.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-empty.js
/**
 * Recursively checks if an element is empty. An element is not empty if it
 * contains text or contains elements with attributes such as images.
 *
 * @param {Element} element The element to check.
 *
 * @return {boolean} Whether or not the element is empty.
 */
function isEmpty(element) {
  switch (element.nodeType) {
    case element.TEXT_NODE:
      // We cannot use \s since it includes special spaces which we want
      // to preserve.
      return /^[ \f\n\r\t\v\u00a0]*$/.test(element.nodeValue || '');
    case element.ELEMENT_NODE:
      if (element.hasAttributes()) {
        return false;
      } else if (!element.hasChildNodes()) {
        return true;
      }
      return /** @type {Element[]} */Array.from(element.childNodes).every(isEmpty);
    default:
      return true;
  }
}
//# sourceMappingURL=is-empty.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/phrasing-content.js
/**
 * All phrasing content elements.
 *
 * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0
 */

/**
 * @typedef {Record<string,SemanticElementDefinition>} ContentSchema
 */

/**
 * @typedef SemanticElementDefinition
 * @property {string[]}      [attributes] Content attributes
 * @property {ContentSchema} [children]   Content attributes
 */

/**
 * All text-level semantic elements.
 *
 * @see https://html.spec.whatwg.org/multipage/text-level-semantics.html
 *
 * @type {ContentSchema}
 */
const textContentSchema = {
  strong: {},
  em: {},
  s: {},
  del: {},
  ins: {},
  a: {
    attributes: ['href', 'target', 'rel', 'id']
  },
  code: {},
  abbr: {
    attributes: ['title']
  },
  sub: {},
  sup: {},
  br: {},
  small: {},
  // To do: fix blockquote.
  // cite: {},
  q: {
    attributes: ['cite']
  },
  dfn: {
    attributes: ['title']
  },
  data: {
    attributes: ['value']
  },
  time: {
    attributes: ['datetime']
  },
  var: {},
  samp: {},
  kbd: {},
  i: {},
  b: {},
  u: {},
  mark: {},
  ruby: {},
  rt: {},
  rp: {},
  bdi: {
    attributes: ['dir']
  },
  bdo: {
    attributes: ['dir']
  },
  wbr: {},
  '#text': {}
};

// Recursion is needed.
// Possible: strong > em > strong.
// Impossible: strong > strong.
const excludedElements = ['#text', 'br'];
Object.keys(textContentSchema).filter(element => !excludedElements.includes(element)).forEach(tag => {
  const {
    [tag]: removedTag,
    ...restSchema
  } = textContentSchema;
  textContentSchema[tag].children = restSchema;
});

/**
 * Embedded content elements.
 *
 * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#embedded-content-0
 *
 * @type {ContentSchema}
 */
const embeddedContentSchema = {
  audio: {
    attributes: ['src', 'preload', 'autoplay', 'mediagroup', 'loop', 'muted']
  },
  canvas: {
    attributes: ['width', 'height']
  },
  embed: {
    attributes: ['src', 'type', 'width', 'height']
  },
  img: {
    attributes: ['alt', 'src', 'srcset', 'usemap', 'ismap', 'width', 'height']
  },
  object: {
    attributes: ['data', 'type', 'name', 'usemap', 'form', 'width', 'height']
  },
  video: {
    attributes: ['src', 'poster', 'preload', 'playsinline', 'autoplay', 'mediagroup', 'loop', 'muted', 'controls', 'width', 'height']
  }
};

/**
 * Phrasing content elements.
 *
 * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0
 */
const phrasingContentSchema = {
  ...textContentSchema,
  ...embeddedContentSchema
};

/**
 * Get schema of possible paths for phrasing content.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
 *
 * @param {string} [context] Set to "paste" to exclude invisible elements and
 *                           sensitive data.
 *
 * @return {Partial<ContentSchema>} Schema.
 */
function phrasing_content_getPhrasingContentSchema(context) {
  if (context !== 'paste') {
    return phrasingContentSchema;
  }

  /**
   * @type {Partial<ContentSchema>}
   */
  const {
    u,
    // Used to mark misspelling. Shouldn't be pasted.
    abbr,
    // Invisible.
    data,
    // Invisible.
    time,
    // Invisible.
    wbr,
    // Invisible.
    bdi,
    // Invisible.
    bdo,
    // Invisible.
    ...remainingContentSchema
  } = {
    ...phrasingContentSchema,
    // We shouldn't paste potentially sensitive information which is not
    // visible to the user when pasted, so strip the attributes.
    ins: {
      children: phrasingContentSchema.ins.children
    },
    del: {
      children: phrasingContentSchema.del.children
    }
  };
  return remainingContentSchema;
}

/**
 * Find out whether or not the given node is phrasing content.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
 *
 * @param {Node} node The node to test.
 *
 * @return {boolean} True if phrasing content, false if not.
 */
function isPhrasingContent(node) {
  const tag = node.nodeName.toLowerCase();
  return phrasing_content_getPhrasingContentSchema().hasOwnProperty(tag) || tag === 'span';
}

/**
 * @param {Node} node
 * @return {boolean} Node is text content
 */
function isTextContent(node) {
  const tag = node.nodeName.toLowerCase();
  return textContentSchema.hasOwnProperty(tag) || tag === 'span';
}
//# sourceMappingURL=phrasing-content.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/normalise-blocks.js
/**
 * WordPress dependencies
 */

function normaliseBlocks(HTML, options = {}) {
  const decuDoc = document.implementation.createHTMLDocument('');
  const accuDoc = document.implementation.createHTMLDocument('');
  const decu = decuDoc.body;
  const accu = accuDoc.body;
  decu.innerHTML = HTML;
  while (decu.firstChild) {
    const node = decu.firstChild;

    // Text nodes: wrap in a paragraph, or append to previous.
    if (node.nodeType === node.TEXT_NODE) {
      if (isEmpty(node)) {
        decu.removeChild(node);
      } else {
        if (!accu.lastChild || accu.lastChild.nodeName !== 'P') {
          accu.appendChild(accuDoc.createElement('P'));
        }
        accu.lastChild.appendChild(node);
      }
      // Element nodes.
    } else if (node.nodeType === node.ELEMENT_NODE) {
      // BR nodes: create a new paragraph on double, or append to previous.
      if (node.nodeName === 'BR') {
        if (node.nextSibling && node.nextSibling.nodeName === 'BR') {
          accu.appendChild(accuDoc.createElement('P'));
          decu.removeChild(node.nextSibling);
        }

        // Don't append to an empty paragraph.
        if (accu.lastChild && accu.lastChild.nodeName === 'P' && accu.lastChild.hasChildNodes()) {
          accu.lastChild.appendChild(node);
        } else {
          decu.removeChild(node);
        }
      } else if (node.nodeName === 'P') {
        // Only append non-empty paragraph nodes.
        if (isEmpty(node) && !options.raw) {
          decu.removeChild(node);
        } else {
          accu.appendChild(node);
        }
      } else if (isPhrasingContent(node)) {
        if (!accu.lastChild || accu.lastChild.nodeName !== 'P') {
          accu.appendChild(accuDoc.createElement('P'));
        }
        accu.lastChild.appendChild(node);
      } else {
        accu.appendChild(node);
      }
    } else {
      decu.removeChild(node);
    }
  }
  return accu.innerHTML;
}
//# sourceMappingURL=normalise-blocks.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js
var assert_is_defined = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/insert-after.js
/**
 * Internal dependencies
 */


/**
 * Given two DOM nodes, inserts the former in the DOM as the next sibling of
 * the latter.
 *
 * @param {Node} newNode       Node to be inserted.
 * @param {Node} referenceNode Node after which to perform the insertion.
 * @return {void}
 */
function insertAfter(newNode, referenceNode) {
  (0,assert_is_defined/* assertIsDefined */.e)(referenceNode.parentNode, 'referenceNode.parentNode');
  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}
//# sourceMappingURL=insert-after.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/remove.js
var remove = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/remove.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/replace.js
/**
 * Internal dependencies
 */




/**
 * Given two DOM nodes, replaces the former with the latter in the DOM.
 *
 * @param {Element} processedNode Node to be removed.
 * @param {Element} newNode       Node to be inserted in its place.
 * @return {void}
 */
function replace(processedNode, newNode) {
  (0,assert_is_defined/* assertIsDefined */.e)(processedNode.parentNode, 'processedNode.parentNode');
  insertAfter(newNode, processedNode.parentNode);
  (0,remove/* default */.A)(processedNode);
}
//# sourceMappingURL=replace.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/special-comment-converter.js
/**
 * WordPress dependencies
 */


/**
 * Looks for `<!--nextpage-->` and `<!--more-->` comments and
 * replaces them with a custom element representing a future block.
 *
 * The custom element is a way to bypass the rest of the `raw-handling`
 * transforms, which would eliminate other kinds of node with which to carry
 * `<!--more-->`'s data: nodes with `data` attributes, empty paragraphs, etc.
 *
 * The custom element is then expected to be recognized by any registered
 * block's `raw` transform.
 *
 * @param {Node}     node The node to be processed.
 * @param {Document} doc  The document of the node.
 * @return {void}
 */
function specialCommentConverter(node, doc) {
  if (node.nodeType !== node.COMMENT_NODE) {
    return;
  }
  if (node.nodeValue !== 'nextpage' && node.nodeValue.indexOf('more') !== 0) {
    return;
  }
  const block = special_comment_converter_createBlock(node, doc);

  // If our `<!--more-->` comment is in the middle of a paragraph, we should
  // split the paragraph in two and insert the more block in between. If it's
  // inside an empty paragraph, we should still move it out of the paragraph
  // and remove the paragraph. If there's no paragraph, fall back to simply
  // replacing the comment.
  if (!node.parentNode || node.parentNode.nodeName !== 'P') {
    replace(node, block);
  } else {
    const childNodes = Array.from(node.parentNode.childNodes);
    const nodeIndex = childNodes.indexOf(node);
    const wrapperNode = node.parentNode.parentNode || doc.body;
    const paragraphBuilder = (acc, child) => {
      if (!acc) {
        acc = doc.createElement('p');
      }
      acc.appendChild(child);
      return acc;
    };

    // Split the original parent node and insert our more block
    [childNodes.slice(0, nodeIndex).reduce(paragraphBuilder, null), block, childNodes.slice(nodeIndex + 1).reduce(paragraphBuilder, null)].forEach(element => element && wrapperNode.insertBefore(element, node.parentNode));

    // Remove the old parent paragraph
    (0,remove/* default */.A)(node.parentNode);
  }
}
function special_comment_converter_createBlock(commentNode, doc) {
  if (commentNode.nodeValue === 'nextpage') {
    return createNextpage(doc);
  }

  // Grab any custom text in the comment.
  const customText = commentNode.nodeValue.slice(4).trim();

  /*
   * When a `<!--more-->` comment is found, we need to look for any
   * `<!--noteaser-->` sibling, but it may not be a direct sibling
   * (whitespace typically lies in between)
   */
  let sibling = commentNode;
  let noTeaser = false;
  while (sibling = sibling.nextSibling) {
    if (sibling.nodeType === sibling.COMMENT_NODE && sibling.nodeValue === 'noteaser') {
      noTeaser = true;
      (0,remove/* default */.A)(sibling);
      break;
    }
  }
  return createMore(customText, noTeaser, doc);
}
function createMore(customText, noTeaser, doc) {
  const node = doc.createElement('wp-block');
  node.dataset.block = 'core/more';
  if (customText) {
    node.dataset.customText = customText;
  }
  if (noTeaser) {
    // "Boolean" data attribute.
    node.dataset.noTeaser = '';
  }
  return node;
}
function createNextpage(doc) {
  const node = doc.createElement('wp-block');
  node.dataset.block = 'core/nextpage';
  return node;
}
//# sourceMappingURL=special-comment-converter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/unwrap.js
/**
 * Internal dependencies
 */


/**
 * Unwrap the given node. This means any child nodes are moved to the parent.
 *
 * @param {Node} node The node to unwrap.
 *
 * @return {void}
 */
function unwrap(node) {
  const parent = node.parentNode;
  (0,assert_is_defined/* assertIsDefined */.e)(parent, 'node.parentNode');
  while (node.firstChild) {
    parent.insertBefore(node.firstChild, node);
  }
  parent.removeChild(node);
}
//# sourceMappingURL=unwrap.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/list-reducer.js
/**
 * WordPress dependencies
 */

function isList(node) {
  return node.nodeName === 'OL' || node.nodeName === 'UL';
}
function shallowTextContent(element) {
  return Array.from(element.childNodes).map(({
    nodeValue = ''
  }) => nodeValue).join('');
}
function listReducer(node) {
  if (!isList(node)) {
    return;
  }
  const list = node;
  const prevElement = node.previousElementSibling;

  // Merge with previous list if:
  // * There is a previous list of the same type.
  // * There is only one list item.
  if (prevElement && prevElement.nodeName === node.nodeName && list.children.length === 1) {
    // Move all child nodes, including any text nodes, if any.
    while (list.firstChild) {
      prevElement.appendChild(list.firstChild);
    }
    list.parentNode.removeChild(list);
  }
  const parentElement = node.parentNode;

  // Nested list with empty parent item.
  if (parentElement && parentElement.nodeName === 'LI' && parentElement.children.length === 1 && !/\S/.test(shallowTextContent(parentElement))) {
    const parentListItem = parentElement;
    const prevListItem = parentListItem.previousElementSibling;
    const parentList = parentListItem.parentNode;
    if (prevListItem) {
      prevListItem.appendChild(list);
      parentList.removeChild(parentListItem);
    }
  }

  // Invalid: OL/UL > OL/UL.
  if (parentElement && isList(parentElement)) {
    const prevListItem = node.previousElementSibling;
    if (prevListItem) {
      prevListItem.appendChild(node);
    } else {
      unwrap(node);
    }
  }
}
//# sourceMappingURL=list-reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/blockquote-normaliser.js
/**
 * Internal dependencies
 */

function blockquoteNormaliser(options) {
  return node => {
    if (node.nodeName !== 'BLOCKQUOTE') {
      return;
    }
    node.innerHTML = normaliseBlocks(node.innerHTML, options);
  };
}
//# sourceMappingURL=blockquote-normaliser.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/figure-content-reducer.js
/**
 * WordPress dependencies
 */


/**
 * Whether or not the given node is figure content.
 *
 * @param {Node}   node   The node to check.
 * @param {Object} schema The schema to use.
 *
 * @return {boolean} True if figure content, false if not.
 */
function isFigureContent(node, schema) {
  var _schema$figure$childr;
  const tag = node.nodeName.toLowerCase();

  // We are looking for tags that can be a child of the figure tag, excluding
  // `figcaption` and any phrasing content.
  if (tag === 'figcaption' || isTextContent(node)) {
    return false;
  }
  return tag in ((_schema$figure$childr = schema?.figure?.children) !== null && _schema$figure$childr !== void 0 ? _schema$figure$childr : {});
}

/**
 * Whether or not the given node can have an anchor.
 *
 * @param {Node}   node   The node to check.
 * @param {Object} schema The schema to use.
 *
 * @return {boolean} True if it can, false if not.
 */
function canHaveAnchor(node, schema) {
  var _schema$figure$childr2;
  const tag = node.nodeName.toLowerCase();
  return tag in ((_schema$figure$childr2 = schema?.figure?.children?.a?.children) !== null && _schema$figure$childr2 !== void 0 ? _schema$figure$childr2 : {});
}

/**
 * Wraps the given element in a figure element.
 *
 * @param {Element} element       The element to wrap.
 * @param {Element} beforeElement The element before which to place the figure.
 */
function wrapFigureContent(element, beforeElement = element) {
  const figure = element.ownerDocument.createElement('figure');
  beforeElement.parentNode.insertBefore(figure, beforeElement);
  figure.appendChild(element);
}

/**
 * This filter takes figure content out of paragraphs, wraps it in a figure
 * element, and moves any anchors with it if needed.
 *
 * @param {Node}     node   The node to filter.
 * @param {Document} doc    The document of the node.
 * @param {Object}   schema The schema to use.
 *
 * @return {void}
 */
function figureContentReducer(node, doc, schema) {
  if (!isFigureContent(node, schema)) {
    return;
  }
  let nodeToInsert = node;
  const parentNode = node.parentNode;

  // If the figure content can have an anchor and its parent is an anchor with
  // only the figure content, take the anchor out instead of just the content.
  if (canHaveAnchor(node, schema) && parentNode.nodeName === 'A' && parentNode.childNodes.length === 1) {
    nodeToInsert = node.parentNode;
  }
  const wrapper = nodeToInsert.closest('p,div');

  // If wrapped in a paragraph or div, only extract if it's aligned or if
  // there is no text content.
  // Otherwise, if directly at the root, wrap in a figure element.
  if (wrapper) {
    // In jsdom-jscore, 'node.classList' can be undefined.
    // In this case, default to extract as it offers a better UI experience on mobile.
    if (!node.classList) {
      wrapFigureContent(nodeToInsert, wrapper);
    } else if (node.classList.contains('alignright') || node.classList.contains('alignleft') || node.classList.contains('aligncenter') || !wrapper.textContent.trim()) {
      wrapFigureContent(nodeToInsert, wrapper);
    }
  } else if (nodeToInsert.parentNode.nodeName === 'BODY') {
    wrapFigureContent(nodeToInsert);
  }
}
//# sourceMappingURL=figure-content-reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+shortcode@4.10.0/node_modules/@wordpress/shortcode/build-module/index.js
/**
 * External dependencies
 */


/**
 * Shortcode attributes object.
 *
 * @typedef {Object} WPShortcodeAttrs
 *
 * @property {Object} named   Object with named attributes.
 * @property {Array}  numeric Array with numeric attributes.
 */

/**
 * Shortcode object.
 *
 * @typedef {Object} WPShortcode
 *
 * @property {string}           tag     Shortcode tag.
 * @property {WPShortcodeAttrs} attrs   Shortcode attributes.
 * @property {string}           content Shortcode content.
 * @property {string}           type    Shortcode type: `self-closing`,
 *                                      `closed`, or `single`.
 */

/**
 * @typedef {Object} WPShortcodeMatch
 *
 * @property {number}      index     Index the shortcode is found at.
 * @property {string}      content   Matched content.
 * @property {WPShortcode} shortcode Shortcode instance of the match.
 */

/**
 * Find the next matching shortcode.
 *
 * @param {string} tag   Shortcode tag.
 * @param {string} text  Text to search.
 * @param {number} index Index to start search from.
 *
 * @return {WPShortcodeMatch | undefined} Matched information.
 */
function next(tag, text, index = 0) {
  const re = regexp(tag);
  re.lastIndex = index;
  const match = re.exec(text);
  if (!match) {
    return;
  }

  // If we matched an escaped shortcode, try again.
  if ('[' === match[1] && ']' === match[7]) {
    return next(tag, text, re.lastIndex);
  }
  const result = {
    index: match.index,
    content: match[0],
    shortcode: fromMatch(match)
  };

  // If we matched a leading `[`, strip it from the match and increment the
  // index accordingly.
  if (match[1]) {
    result.content = result.content.slice(1);
    result.index++;
  }

  // If we matched a trailing `]`, strip it from the match.
  if (match[7]) {
    result.content = result.content.slice(0, -1);
  }
  return result;
}

/**
 * Replace matching shortcodes in a block of text.
 *
 * @param {string}   tag      Shortcode tag.
 * @param {string}   text     Text to search.
 * @param {Function} callback Function to process the match and return
 *                            replacement string.
 *
 * @return {string} Text with shortcodes replaced.
 */
function build_module_replace(tag, text, callback) {
  return text.replace(regexp(tag), function (match, left, $3, attrs, slash, content, closing, right) {
    // If both extra brackets exist, the shortcode has been properly
    // escaped.
    if (left === '[' && right === ']') {
      return match;
    }

    // Create the match object and pass it through the callback.
    const result = callback(fromMatch(arguments));

    // Make sure to return any of the extra brackets if they weren't used to
    // escape the shortcode.
    return result || result === '' ? left + result + right : match;
  });
}

/**
 * Generate a string from shortcode parameters.
 *
 * Creates a shortcode instance and returns a string.
 *
 * Accepts the same `options` as the `shortcode()` constructor, containing a
 * `tag` string, a string or object of `attrs`, a boolean indicating whether to
 * format the shortcode using a `single` tag, and a `content` string.
 *
 * @param {Object} options
 *
 * @return {string} String representation of the shortcode.
 */
function string(options) {
  return new shortcode(options).string();
}

/**
 * Generate a RegExp to identify a shortcode.
 *
 * The base regex is functionally equivalent to the one found in
 * `get_shortcode_regex()` in `wp-includes/shortcodes.php`.
 *
 * Capture groups:
 *
 * 1. An extra `[` to allow for escaping shortcodes with double `[[]]`
 * 2. The shortcode name
 * 3. The shortcode argument list
 * 4. The self closing `/`
 * 5. The content of a shortcode when it wraps some content.
 * 6. The closing tag.
 * 7. An extra `]` to allow for escaping shortcodes with double `[[]]`
 *
 * @param {string} tag Shortcode tag.
 *
 * @return {RegExp} Shortcode RegExp.
 */
function regexp(tag) {
  return new RegExp('\\[(\\[?)(' + tag + ')(?![\\w-])([^\\]\\/]*(?:\\/(?!\\])[^\\]\\/]*)*?)(?:(\\/)\\]|\\](?:([^\\[]*(?:\\[(?!\\/\\2\\])[^\\[]*)*)(\\[\\/\\2\\]))?)(\\]?)', 'g');
}

/**
 * Parse shortcode attributes.
 *
 * Shortcodes accept many types of attributes. These can chiefly be divided into
 * named and numeric attributes:
 *
 * Named attributes are assigned on a key/value basis, while numeric attributes
 * are treated as an array.
 *
 * Named attributes can be formatted as either `name="value"`, `name='value'`,
 * or `name=value`. Numeric attributes can be formatted as `"value"` or just
 * `value`.
 *
 * @param {string} text Serialised shortcode attributes.
 *
 * @return {WPShortcodeAttrs} Parsed shortcode attributes.
 */
const attrs = (0,dist/* default */.A)(text => {
  const named = {};
  const numeric = [];

  // This regular expression is reused from `shortcode_parse_atts()` in
  // `wp-includes/shortcodes.php`.
  //
  // Capture groups:
  //
  // 1. An attribute name, that corresponds to...
  // 2. a value in double quotes.
  // 3. An attribute name, that corresponds to...
  // 4. a value in single quotes.
  // 5. An attribute name, that corresponds to...
  // 6. an unquoted value.
  // 7. A numeric attribute in double quotes.
  // 8. A numeric attribute in single quotes.
  // 9. An unquoted numeric attribute.
  const pattern = /([\w-]+)\s*=\s*"([^"]*)"(?:\s|$)|([\w-]+)\s*=\s*'([^']*)'(?:\s|$)|([\w-]+)\s*=\s*([^\s'"]+)(?:\s|$)|"([^"]*)"(?:\s|$)|'([^']*)'(?:\s|$)|(\S+)(?:\s|$)/g;

  // Map zero-width spaces to actual spaces.
  text = text.replace(/[\u00a0\u200b]/g, ' ');
  let match;

  // Match and normalize attributes.
  while (match = pattern.exec(text)) {
    if (match[1]) {
      named[match[1].toLowerCase()] = match[2];
    } else if (match[3]) {
      named[match[3].toLowerCase()] = match[4];
    } else if (match[5]) {
      named[match[5].toLowerCase()] = match[6];
    } else if (match[7]) {
      numeric.push(match[7]);
    } else if (match[8]) {
      numeric.push(match[8]);
    } else if (match[9]) {
      numeric.push(match[9]);
    }
  }
  return {
    named,
    numeric
  };
});

/**
 * Generate a Shortcode Object from a RegExp match.
 *
 * Accepts a `match` object from calling `regexp.exec()` on a `RegExp` generated
 * by `regexp()`. `match` can also be set to the `arguments` from a callback
 * passed to `regexp.replace()`.
 *
 * @param {Array} match Match array.
 *
 * @return {WPShortcode} Shortcode instance.
 */
function fromMatch(match) {
  let type;
  if (match[4]) {
    type = 'self-closing';
  } else if (match[6]) {
    type = 'closed';
  } else {
    type = 'single';
  }
  return new shortcode({
    tag: match[2],
    attrs: match[3],
    type,
    content: match[5]
  });
}

/**
 * Creates a shortcode instance.
 *
 * To access a raw representation of a shortcode, pass an `options` object,
 * containing a `tag` string, a string or object of `attrs`, a string indicating
 * the `type` of the shortcode ('single', 'self-closing', or 'closed'), and a
 * `content` string.
 *
 * @param {Object} options Options as described.
 *
 * @return {WPShortcode} Shortcode instance.
 */
const shortcode = Object.assign(function (options) {
  const {
    tag,
    attrs: attributes,
    type,
    content
  } = options || {};
  Object.assign(this, {
    tag,
    type,
    content
  });

  // Ensure we have a correctly formatted `attrs` object.
  this.attrs = {
    named: {},
    numeric: []
  };
  if (!attributes) {
    return;
  }
  const attributeTypes = ['named', 'numeric'];

  // Parse a string of attributes.
  if (typeof attributes === 'string') {
    this.attrs = attrs(attributes);
    // Identify a correctly formatted `attrs` object.
  } else if (attributes.length === attributeTypes.length && attributeTypes.every((t, key) => t === attributes[key])) {
    this.attrs = attributes;
    // Handle a flat object of attributes.
  } else {
    Object.entries(attributes).forEach(([key, value]) => {
      this.set(key, value);
    });
  }
}, {
  next,
  replace: build_module_replace,
  string,
  regexp,
  attrs,
  fromMatch
});
Object.assign(shortcode.prototype, {
  /**
   * Get a shortcode attribute.
   *
   * Automatically detects whether `attr` is named or numeric and routes it
   * accordingly.
   *
   * @param {(number|string)} attr Attribute key.
   *
   * @return {string} Attribute value.
   */
  get(attr) {
    return this.attrs[typeof attr === 'number' ? 'numeric' : 'named'][attr];
  },
  /**
   * Set a shortcode attribute.
   *
   * Automatically detects whether `attr` is named or numeric and routes it
   * accordingly.
   *
   * @param {(number|string)} attr  Attribute key.
   * @param {string}          value Attribute value.
   *
   * @return {WPShortcode} Shortcode instance.
   */
  set(attr, value) {
    this.attrs[typeof attr === 'number' ? 'numeric' : 'named'][attr] = value;
    return this;
  },
  /**
   * Transform the shortcode into a string.
   *
   * @return {string} String representation of the shortcode.
   */
  string() {
    let text = '[' + this.tag;
    this.attrs.numeric.forEach(value => {
      if (/\s/.test(value)) {
        text += ' "' + value + '"';
      } else {
        text += ' ' + value;
      }
    });
    Object.entries(this.attrs.named).forEach(([name, value]) => {
      text += ' ' + name + '="' + value + '"';
    });

    // If the tag is marked as `single` or `self-closing`, close the tag and
    // ignore any additional content.
    if ('single' === this.type) {
      return text + ']';
    } else if ('self-closing' === this.type) {
      return text + ' /]';
    }

    // Complete the opening tag.
    text += ']';
    if (this.content) {
      text += this.content;
    }

    // Add the closing tag.
    return text + '[/' + this.tag + ']';
  }
});
/* harmony default export */ const shortcode_build_module = ((/* unused pure expression or super */ null && (shortcode)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/shortcode-converter.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




const castArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
const beforeLineRegexp = /(\n|<p>)\s*$/;
const afterLineRegexp = /^\s*(\n|<\/p>)/;
function segmentHTMLToShortcodeBlock(HTML, lastIndex = 0, excludedBlockNames = []) {
  // Get all matches.
  const transformsFrom = getBlockTransforms('from');
  const transformation = findTransform(transformsFrom, transform => excludedBlockNames.indexOf(transform.blockName) === -1 && transform.type === 'shortcode' && castArray(transform.tag).some(tag => regexp(tag).test(HTML)));
  if (!transformation) {
    return [HTML];
  }
  const transformTags = castArray(transformation.tag);
  const transformTag = transformTags.find(tag => regexp(tag).test(HTML));
  let match;
  const previousIndex = lastIndex;
  if (match = next(transformTag, HTML, lastIndex)) {
    lastIndex = match.index + match.content.length;
    const beforeHTML = HTML.substr(0, match.index);
    const afterHTML = HTML.substr(lastIndex);

    // If the shortcode content does not contain HTML and the shortcode is
    // not on a new line (or in paragraph from Markdown converter),
    // consider the shortcode as inline text, and thus skip conversion for
    // this segment.
    if (!match.shortcode.content?.includes('<') && !(beforeLineRegexp.test(beforeHTML) && afterLineRegexp.test(afterHTML))) {
      return segmentHTMLToShortcodeBlock(HTML, lastIndex);
    }

    // If a transformation's `isMatch` predicate fails for the inbound
    // shortcode, try again by excluding the current block type.
    //
    // This is the only call to `segmentHTMLToShortcodeBlock` that should
    // ever carry over `excludedBlockNames`. Other calls in the module
    // should skip that argument as a way to reset the exclusion state, so
    // that one `isMatch` fail in an HTML fragment doesn't prevent any
    // valid matches in subsequent fragments.
    if (transformation.isMatch && !transformation.isMatch(match.shortcode.attrs)) {
      return segmentHTMLToShortcodeBlock(HTML, previousIndex, [...excludedBlockNames, transformation.blockName]);
    }
    let blocks = [];
    if (typeof transformation.transform === 'function') {
      // Passing all of `match` as second argument is intentionally broad
      // but shouldn't be too relied upon.
      //
      // See: https://github.com/WordPress/gutenberg/pull/3610#discussion_r152546926
      blocks = [].concat(transformation.transform(match.shortcode.attrs, match));

      // Applying the built-in fixes can enhance the attributes with missing content like "className".
      blocks = blocks.map(block => {
        block.originalContent = match.shortcode.content;
        return applyBuiltInValidationFixes(block, getBlockType(block.name));
      });
    } else {
      const attributes = Object.fromEntries(Object.entries(transformation.attributes).filter(([, schema]) => schema.shortcode)
      // Passing all of `match` as second argument is intentionally broad
      // but shouldn't be too relied upon.
      //
      // See: https://github.com/WordPress/gutenberg/pull/3610#discussion_r152546926
      .map(([key, schema]) => [key, schema.shortcode(match.shortcode.attrs, match)]));
      const blockType = getBlockType(transformation.blockName);
      if (!blockType) {
        return [HTML];
      }
      const transformationBlockType = {
        ...blockType,
        attributes: transformation.attributes
      };
      let block = createBlock(transformation.blockName, getBlockAttributes(transformationBlockType, match.shortcode.content, attributes));

      // Applying the built-in fixes can enhance the attributes with missing content like "className".
      block.originalContent = match.shortcode.content;
      block = applyBuiltInValidationFixes(block, transformationBlockType);
      blocks = [block];
    }
    return [...segmentHTMLToShortcodeBlock(beforeHTML.replace(beforeLineRegexp, '')), ...blocks, ...segmentHTMLToShortcodeBlock(afterHTML.replace(afterLineRegexp, ''))];
  }
  return [HTML];
}
/* harmony default export */ const shortcode_converter = (segmentHTMLToShortcodeBlock);
//# sourceMappingURL=shortcode-converter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/utils.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function getBlockContentSchemaFromTransforms(transforms, context) {
  const phrasingContentSchema = phrasing_content_getPhrasingContentSchema(context);
  const schemaArgs = {
    phrasingContentSchema,
    isPaste: context === 'paste'
  };
  const schemas = transforms.map(({
    isMatch,
    blockName,
    schema
  }) => {
    const hasAnchorSupport = hasBlockSupport(blockName, 'anchor');
    schema = typeof schema === 'function' ? schema(schemaArgs) : schema;

    // If the block does not has anchor support and the transform does not
    // provides an isMatch we can return the schema right away.
    if (!hasAnchorSupport && !isMatch) {
      return schema;
    }
    if (!schema) {
      return {};
    }
    return Object.fromEntries(Object.entries(schema).map(([key, value]) => {
      let attributes = value.attributes || [];
      // If the block supports the "anchor" functionality, it needs to keep its ID attribute.
      if (hasAnchorSupport) {
        attributes = [...attributes, 'id'];
      }
      return [key, {
        ...value,
        attributes,
        isMatch: isMatch ? isMatch : undefined
      }];
    }));
  });
  function mergeTagNameSchemaProperties(objValue, srcValue, key) {
    switch (key) {
      case 'children':
        {
          if (objValue === '*' || srcValue === '*') {
            return '*';
          }
          return {
            ...objValue,
            ...srcValue
          };
        }
      case 'attributes':
      case 'require':
        {
          return [...(objValue || []), ...(srcValue || [])];
        }
      case 'isMatch':
        {
          // If one of the values being merge is undefined (matches everything),
          // the result of the merge will be undefined.
          if (!objValue || !srcValue) {
            return undefined;
          }
          // When merging two isMatch functions, the result is a new function
          // that returns if one of the source functions returns true.
          return (...args) => {
            return objValue(...args) || srcValue(...args);
          };
        }
    }
  }

  // A tagName schema is an object with children, attributes, require, and
  // isMatch properties.
  function mergeTagNameSchemas(a, b) {
    for (const key in b) {
      a[key] = a[key] ? mergeTagNameSchemaProperties(a[key], b[key], key) : {
        ...b[key]
      };
    }
    return a;
  }

  // A schema is an object with tagName schemas by tag name.
  function mergeSchemas(a, b) {
    for (const key in b) {
      a[key] = a[key] ? mergeTagNameSchemas(a[key], b[key]) : {
        ...b[key]
      };
    }
    return a;
  }
  return schemas.reduce(mergeSchemas, {});
}

/**
 * Gets the block content schema, which is extracted and merged from all
 * registered blocks with raw transfroms.
 *
 * @param {string} context Set to "paste" when in paste context, where the
 *                         schema is more strict.
 *
 * @return {Object} A complete block content schema.
 */
function getBlockContentSchema(context) {
  return getBlockContentSchemaFromTransforms(getRawTransforms(), context);
}

/**
 * Checks whether HTML can be considered plain text. That is, it does not contain
 * any elements that are not line breaks.
 *
 * @param {string} HTML The HTML to check.
 *
 * @return {boolean} Whether the HTML can be considered plain text.
 */
function isPlain(HTML) {
  return !/<(?!br[ />])/i.test(HTML);
}

/**
 * Given node filters, deeply filters and mutates a NodeList.
 *
 * @param {NodeList} nodeList The nodeList to filter.
 * @param {Array}    filters  An array of functions that can mutate with the provided node.
 * @param {Document} doc      The document of the nodeList.
 * @param {Object}   schema   The schema to use.
 */
function deepFilterNodeList(nodeList, filters, doc, schema) {
  Array.from(nodeList).forEach(node => {
    deepFilterNodeList(node.childNodes, filters, doc, schema);
    filters.forEach(item => {
      // Make sure the node is still attached to the document.
      if (!doc.contains(node)) {
        return;
      }
      item(node, doc, schema);
    });
  });
}

/**
 * Given node filters, deeply filters HTML tags.
 * Filters from the deepest nodes to the top.
 *
 * @param {string} HTML    The HTML to filter.
 * @param {Array}  filters An array of functions that can mutate with the provided node.
 * @param {Object} schema  The schema to use.
 *
 * @return {string} The filtered HTML.
 */
function deepFilterHTML(HTML, filters = [], schema) {
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = HTML;
  deepFilterNodeList(doc.body.childNodes, filters, doc, schema);
  return doc.body.innerHTML;
}

/**
 * Gets a sibling within text-level context.
 *
 * @param {Element} node  The subject node.
 * @param {string}  which "next" or "previous".
 */
function getSibling(node, which) {
  const sibling = node[`${which}Sibling`];
  if (sibling && isPhrasingContent(sibling)) {
    return sibling;
  }
  const {
    parentNode
  } = node;
  if (!parentNode || !isPhrasingContent(parentNode)) {
    return;
  }
  return getSibling(parentNode, which);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */










function deprecatedGetPhrasingContentSchema(context) {
  deprecated('wp.blocks.getPhrasingContentSchema', {
    since: '5.6',
    alternative: 'wp.dom.getPhrasingContentSchema'
  });
  return getPhrasingContentSchema(context);
}

/**
 * Converts an HTML string to known blocks.
 *
 * @param {Object} $1
 * @param {string} $1.HTML The HTML to convert.
 *
 * @return {Array} A list of blocks.
 */
function rawHandler({
  HTML = ''
}) {
  // If we detect block delimiters, parse entirely as blocks.
  if (HTML.indexOf('<!-- wp:') !== -1) {
    const parseResult = parser_parse(HTML);
    const isSingleFreeFormBlock = parseResult.length === 1 && parseResult[0].name === 'core/freeform';
    if (!isSingleFreeFormBlock) {
      return parseResult;
    }
  }

  // An array of HTML strings and block objects. The blocks replace matched
  // shortcodes.
  const pieces = shortcode_converter(HTML);
  const blockContentSchema = getBlockContentSchema();
  return pieces.map(piece => {
    // Already a block from shortcode.
    if (typeof piece !== 'string') {
      return piece;
    }

    // These filters are essential for some blocks to be able to transform
    // from raw HTML. These filters move around some content or add
    // additional tags, they do not remove any content.
    const filters = [
    // Needed to adjust invalid lists.
    listReducer,
    // Needed to create more and nextpage blocks.
    specialCommentConverter,
    // Needed to create media blocks.
    figureContentReducer,
    // Needed to create the quote block, which cannot handle text
    // without wrapper paragraphs.
    blockquoteNormaliser({
      raw: true
    })];
    piece = deepFilterHTML(piece, filters, blockContentSchema);
    piece = normaliseBlocks(piece, {
      raw: true
    });
    return htmlToBlocks(piece, rawHandler);
  }).flat().filter(Boolean);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/is-element.js
/* eslint-disable jsdoc/valid-types */
/**
 * @param {Node | null | undefined} node
 * @return {node is Element} True if node is an Element node
 */
function isElement(node) {
  /* eslint-enable jsdoc/valid-types */
  return !!node && node.nodeType === node.ELEMENT_NODE;
}
//# sourceMappingURL=is-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/clean-node-list.js
/**
 * Internal dependencies
 */






const noop = () => {};

/* eslint-disable jsdoc/valid-types */
/**
 * @typedef SchemaItem
 * @property {string[]}                            [attributes] Attributes.
 * @property {(string | RegExp)[]}                 [classes]    Classnames or RegExp to test against.
 * @property {'*' | { [tag: string]: SchemaItem }} [children]   Child schemas.
 * @property {string[]}                            [require]    Selectors to test required children against. Leave empty or undefined if there are no requirements.
 * @property {boolean}                             allowEmpty   Whether to allow nodes without children.
 * @property {(node: Node) => boolean}             [isMatch]    Function to test whether a node is a match. If left undefined any node will be assumed to match.
 */

/** @typedef {{ [tag: string]: SchemaItem }} Schema */
/* eslint-enable jsdoc/valid-types */

/**
 * Given a schema, unwraps or removes nodes, attributes and classes on a node
 * list.
 *
 * @param {NodeList} nodeList The nodeList to filter.
 * @param {Document} doc      The document of the nodeList.
 * @param {Schema}   schema   An array of functions that can mutate with the provided node.
 * @param {boolean}  inline   Whether to clean for inline mode.
 */
function cleanNodeList(nodeList, doc, schema, inline) {
  Array.from(nodeList).forEach(( /** @type {Node & { nextElementSibling?: unknown }} */node) => {
    const tag = node.nodeName.toLowerCase();

    // It's a valid child, if the tag exists in the schema without an isMatch
    // function, or with an isMatch function that matches the node.
    if (schema.hasOwnProperty(tag) && (!schema[tag].isMatch || schema[tag].isMatch?.(node))) {
      if (isElement(node)) {
        const {
          attributes = [],
          classes = [],
          children,
          require = [],
          allowEmpty
        } = schema[tag];

        // If the node is empty and it's supposed to have children,
        // remove the node.
        if (children && !allowEmpty && isEmpty(node)) {
          (0,remove/* default */.A)(node);
          return;
        }
        if (node.hasAttributes()) {
          // Strip invalid attributes.
          Array.from(node.attributes).forEach(({
            name
          }) => {
            if (name !== 'class' && !attributes.includes(name)) {
              node.removeAttribute(name);
            }
          });

          // Strip invalid classes.
          // In jsdom-jscore, 'node.classList' can be undefined.
          // TODO: Explore patching this in jsdom-jscore.
          if (node.classList && node.classList.length) {
            const mattchers = classes.map(item => {
              if (typeof item === 'string') {
                return ( /** @type {string} */className) => className === item;
              } else if (item instanceof RegExp) {
                return ( /** @type {string} */className) => item.test(className);
              }
              return noop;
            });
            Array.from(node.classList).forEach(name => {
              if (!mattchers.some(isMatch => isMatch(name))) {
                node.classList.remove(name);
              }
            });
            if (!node.classList.length) {
              node.removeAttribute('class');
            }
          }
        }
        if (node.hasChildNodes()) {
          // Do not filter any content.
          if (children === '*') {
            return;
          }

          // Continue if the node is supposed to have children.
          if (children) {
            // If a parent requires certain children, but it does
            // not have them, drop the parent and continue.
            if (require.length && !node.querySelector(require.join(','))) {
              cleanNodeList(node.childNodes, doc, schema, inline);
              unwrap(node);
              // If the node is at the top, phrasing content, and
              // contains children that are block content, unwrap
              // the node because it is invalid.
            } else if (node.parentNode && node.parentNode.nodeName === 'BODY' && isPhrasingContent(node)) {
              cleanNodeList(node.childNodes, doc, schema, inline);
              if (Array.from(node.childNodes).some(child => !isPhrasingContent(child))) {
                unwrap(node);
              }
            } else {
              cleanNodeList(node.childNodes, doc, children, inline);
            }
            // Remove children if the node is not supposed to have any.
          } else {
            while (node.firstChild) {
              (0,remove/* default */.A)(node.firstChild);
            }
          }
        }
      }
      // Invalid child. Continue with schema at the same place and unwrap.
    } else {
      cleanNodeList(node.childNodes, doc, schema, inline);

      // For inline mode, insert a line break when unwrapping nodes that
      // are not phrasing content.
      if (inline && !isPhrasingContent(node) && node.nextElementSibling) {
        insertAfter(doc.createElement('br'), node);
      }
      unwrap(node);
    }
  });
}
//# sourceMappingURL=clean-node-list.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/remove-invalid-html.js
/**
 * Internal dependencies
 */


/**
 * Given a schema, unwraps or removes nodes, attributes and classes on HTML.
 *
 * @param {string}                             HTML   The HTML to clean up.
 * @param {import('./clean-node-list').Schema} schema Schema for the HTML.
 * @param {boolean}                            inline Whether to clean for inline mode.
 *
 * @return {string} The cleaned up HTML.
 */
function removeInvalidHTML(HTML, schema, inline) {
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = HTML;
  cleanNodeList(doc.body.childNodes, doc, schema, inline);
  return doc.body.innerHTML;
}
//# sourceMappingURL=remove-invalid-html.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/comment-remover.js
/**
 * WordPress dependencies
 */


/**
 * Looks for comments, and removes them.
 *
 * @param {Node} node The node to be processed.
 * @return {void}
 */
function commentRemover(node) {
  if (node.nodeType === node.COMMENT_NODE) {
    (0,remove/* default */.A)(node);
  }
}
//# sourceMappingURL=comment-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/is-inline-content.js
/**
 * WordPress dependencies
 */


/**
 * Checks if the given node should be considered inline content, optionally
 * depending on a context tag.
 *
 * @param {Node}   node       Node name.
 * @param {string} contextTag Tag name.
 *
 * @return {boolean} True if the node is inline content, false if nohe.
 */
function isInline(node, contextTag) {
  if (isTextContent(node)) {
    return true;
  }
  if (!contextTag) {
    return false;
  }
  const tag = node.nodeName.toLowerCase();
  const inlineAllowedTagGroups = [['ul', 'li', 'ol'], ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']];
  return inlineAllowedTagGroups.some(tagGroup => [tag, contextTag].filter(t => !tagGroup.includes(t)).length === 0);
}
function deepCheck(nodes, contextTag) {
  return nodes.every(node => isInline(node, contextTag) && deepCheck(Array.from(node.children), contextTag));
}
function isDoubleBR(node) {
  return node.nodeName === 'BR' && node.previousSibling && node.previousSibling.nodeName === 'BR';
}
function isInlineContent(HTML, contextTag) {
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = HTML;
  const nodes = Array.from(doc.body.children);
  return !nodes.some(isDoubleBR) && deepCheck(nodes, contextTag);
}
//# sourceMappingURL=is-inline-content.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/wrap.js
/**
 * Internal dependencies
 */


/**
 * Wraps the given node with a new node with the given tag name.
 *
 * @param {Element} newNode       The node to insert.
 * @param {Element} referenceNode The node to wrap.
 */
function wrap(newNode, referenceNode) {
  (0,assert_is_defined/* assertIsDefined */.e)(referenceNode.parentNode, 'referenceNode.parentNode');
  referenceNode.parentNode.insertBefore(newNode, referenceNode);
  newNode.appendChild(referenceNode);
}
//# sourceMappingURL=wrap.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/replace-tag.js
/**
 * Internal dependencies
 */


/**
 * Replaces the given node with a new node with the given tag name.
 *
 * @param {Element} node    The node to replace
 * @param {string}  tagName The new tag name.
 *
 * @return {Element} The new node.
 */
function replaceTag(node, tagName) {
  const newNode = node.ownerDocument.createElement(tagName);
  while (node.firstChild) {
    newNode.appendChild(node.firstChild);
  }
  (0,assert_is_defined/* assertIsDefined */.e)(node.parentNode, 'node.parentNode');
  node.parentNode.replaceChild(newNode, node);
  return newNode;
}
//# sourceMappingURL=replace-tag.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/phrasing-content-reducer.js
/**
 * WordPress dependencies
 */

function phrasingContentReducer(node, doc) {
  // In jsdom-jscore, 'node.style' can be null.
  // TODO: Explore fixing this by patching jsdom-jscore.
  if (node.nodeName === 'SPAN' && node.style) {
    const {
      fontWeight,
      fontStyle,
      textDecorationLine,
      textDecoration,
      verticalAlign
    } = node.style;
    if (fontWeight === 'bold' || fontWeight === '700') {
      wrap(doc.createElement('strong'), node);
    }
    if (fontStyle === 'italic') {
      wrap(doc.createElement('em'), node);
    }

    // Some DOM implementations (Safari, JSDom) don't support
    // style.textDecorationLine, so we check style.textDecoration as a
    // fallback.
    if (textDecorationLine === 'line-through' || textDecoration.includes('line-through')) {
      wrap(doc.createElement('s'), node);
    }
    if (verticalAlign === 'super') {
      wrap(doc.createElement('sup'), node);
    } else if (verticalAlign === 'sub') {
      wrap(doc.createElement('sub'), node);
    }
  } else if (node.nodeName === 'B') {
    node = replaceTag(node, 'strong');
  } else if (node.nodeName === 'I') {
    node = replaceTag(node, 'em');
  } else if (node.nodeName === 'A') {
    // In jsdom-jscore, 'node.target' can be null.
    // TODO: Explore fixing this by patching jsdom-jscore.
    if (node.target && node.target.toLowerCase() === '_blank') {
      node.rel = 'noreferrer noopener';
    } else {
      node.removeAttribute('target');
      node.removeAttribute('rel');
    }

    // Saves anchor elements name attribute as id
    if (node.name && !node.id) {
      node.id = node.name;
    }

    // Keeps id only if there is an internal link pointing to it
    if (node.id && !node.ownerDocument.querySelector(`[href="#${node.id}"]`)) {
      node.removeAttribute('id');
    }
  }
}
//# sourceMappingURL=phrasing-content-reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/head-remover.js
function headRemover(node) {
  if (node.nodeName !== 'SCRIPT' && node.nodeName !== 'NOSCRIPT' && node.nodeName !== 'TEMPLATE' && node.nodeName !== 'STYLE') {
    return;
  }
  node.parentNode.removeChild(node);
}
//# sourceMappingURL=head-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/ms-list-ignore.js
/**
 * Looks for comments, and removes them.
 *
 * @param {Node} node The node to be processed.
 * @return {void}
 */
function msListIgnore(node) {
  if (node.nodeType !== node.ELEMENT_NODE) {
    return;
  }
  const style = node.getAttribute('style');
  if (!style || !style.includes('mso-list')) {
    return;
  }
  const rules = style.split(';').reduce((acc, rule) => {
    const [key, value] = rule.split(':');
    if (key && value) {
      acc[key.trim().toLowerCase()] = value.trim().toLowerCase();
    }
    return acc;
  }, {});
  if (rules['mso-list'] === 'ignore') {
    node.remove();
  }
}
//# sourceMappingURL=ms-list-ignore.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/ms-list-converter.js
/**
 * Internal dependencies
 */


function ms_list_converter_isList(node) {
  return node.nodeName === 'OL' || node.nodeName === 'UL';
}
function msListConverter(node, doc) {
  if (node.nodeName !== 'P') {
    return;
  }
  const style = node.getAttribute('style');
  if (!style || !style.includes('mso-list')) {
    return;
  }
  const prevNode = node.previousElementSibling;

  // Add new list if no previous.
  if (!prevNode || !ms_list_converter_isList(prevNode)) {
    // See https://html.spec.whatwg.org/multipage/grouping-content.html#attr-ol-type.
    const type = node.textContent.trim().slice(0, 1);
    const isNumeric = /[1iIaA]/.test(type);
    const newListNode = doc.createElement(isNumeric ? 'ol' : 'ul');
    if (isNumeric) {
      newListNode.setAttribute('type', type);
    }
    node.parentNode.insertBefore(newListNode, node);
  }
  const listNode = node.previousElementSibling;
  const listType = listNode.nodeName;
  const listItem = doc.createElement('li');
  let receivingNode = listNode;

  // Add content.
  listItem.innerHTML = deepFilterHTML(node.innerHTML, [msListIgnore]);
  const matches = /mso-list\s*:[^;]+level([0-9]+)/i.exec(style);
  let level = matches ? parseInt(matches[1], 10) - 1 || 0 : 0;

  // Change pointer depending on indentation level.
  while (level--) {
    receivingNode = receivingNode.lastChild || receivingNode;

    // If it's a list, move pointer to the last item.
    if (ms_list_converter_isList(receivingNode)) {
      receivingNode = receivingNode.lastChild || receivingNode;
    }
  }

  // Make sure we append to a list.
  if (!ms_list_converter_isList(receivingNode)) {
    receivingNode = receivingNode.appendChild(doc.createElement(listType));
  }

  // Append the list item to the list.
  receivingNode.appendChild(listItem);

  // Remove the wrapper paragraph.
  node.parentNode.removeChild(node);
}
//# sourceMappingURL=ms-list-converter.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+blob@4.0.1/node_modules/@wordpress/blob/build-module/index.js
var blob_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+blob@4.0.1/node_modules/@wordpress/blob/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/image-corrector.js
/**
 * WordPress dependencies
 */

function imageCorrector(node) {
  if (node.nodeName !== 'IMG') {
    return;
  }
  if (node.src.indexOf('file:') === 0) {
    node.src = '';
  }

  // This piece cannot be tested outside a browser env.
  if (node.src.indexOf('data:') === 0) {
    const [properties, data] = node.src.split(',');
    const [type] = properties.slice(5).split(';');
    if (!data || !type) {
      node.src = '';
      return;
    }
    let decoded;

    // Can throw DOMException!
    try {
      decoded = atob(data);
    } catch (e) {
      node.src = '';
      return;
    }
    const uint8Array = new Uint8Array(decoded.length);
    for (let i = 0; i < uint8Array.length; i++) {
      uint8Array[i] = decoded.charCodeAt(i);
    }
    const name = type.replace('/', '.');
    const file = new window.File([uint8Array], name, {
      type
    });
    node.src = (0,blob_build_module/* createBlobURL */.bW)(file);
  }

  // Remove trackers and hardly visible images.
  if (node.height === 1 || node.width === 1) {
    node.parentNode.removeChild(node);
  }
}
//# sourceMappingURL=image-corrector.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/div-normaliser.js
/**
 * Internal dependencies
 */

function divNormaliser(node) {
  if (node.nodeName !== 'DIV') {
    return;
  }
  node.innerHTML = normaliseBlocks(node.innerHTML);
}
//# sourceMappingURL=div-normaliser.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/showdown@1.9.1/node_modules/showdown/dist/showdown.js
var showdown = __webpack_require__("../../node_modules/.pnpm/showdown@1.9.1/node_modules/showdown/dist/showdown.js");
var showdown_default = /*#__PURE__*/__webpack_require__.n(showdown);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/markdown-converter.js
/**
 * External dependencies
 */


// Reuse the same showdown converter.
const converter = new (showdown_default()).Converter({
  noHeaderId: true,
  tables: true,
  literalMidWordUnderscores: true,
  omitExtraWLInCodeBlocks: true,
  simpleLineBreaks: true,
  strikethrough: true
});

/**
 * Corrects the Slack Markdown variant of the code block.
 * If uncorrected, it will be converted to inline code.
 *
 * @see https://get.slack.help/hc/en-us/articles/202288908-how-can-i-add-formatting-to-my-messages-#code-blocks
 *
 * @param {string} text The potential Markdown text to correct.
 *
 * @return {string} The corrected Markdown.
 */
function slackMarkdownVariantCorrector(text) {
  return text.replace(/((?:^|\n)```)([^\n`]+)(```(?:$|\n))/, (match, p1, p2, p3) => `${p1}\n${p2}\n${p3}`);
}
function bulletsToAsterisks(text) {
  return text.replace(/(^|\n)•( +)/g, '$1*$2');
}

/**
 * Converts a piece of text into HTML based on any Markdown present.
 * Also decodes any encoded HTML.
 *
 * @param {string} text The plain text to convert.
 *
 * @return {string} HTML.
 */
function markdownConverter(text) {
  return converter.makeHtml(slackMarkdownVariantCorrector(bulletsToAsterisks(text)));
}
//# sourceMappingURL=markdown-converter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/iframe-remover.js
/**
 * Removes iframes.
 *
 * @param {Node} node The node to check.
 *
 * @return {void}
 */
function iframeRemover(node) {
  if (node.nodeName === 'IFRAME') {
    const text = node.ownerDocument.createTextNode(node.src);
    node.parentNode.replaceChild(text, node);
  }
}
//# sourceMappingURL=iframe-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/google-docs-uid-remover.js
/**
 * WordPress dependencies
 */

function googleDocsUIdRemover(node) {
  if (!node.id || node.id.indexOf('docs-internal-guid-') !== 0) {
    return;
  }

  // Google Docs sometimes wraps the content in a B tag. We don't want to keep
  // this.
  if (node.tagName === 'B') {
    unwrap(node);
  } else {
    node.removeAttribute('id');
  }
}
//# sourceMappingURL=google-docs-uid-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/html-formatting-remover.js
/**
 * Internal dependencies
 */

function isFormattingSpace(character) {
  return character === ' ' || character === '\r' || character === '\n' || character === '\t';
}

/**
 * Removes spacing that formats HTML.
 *
 * @see https://www.w3.org/TR/css-text-3/#white-space-processing
 *
 * @param {Node} node The node to be processed.
 * @return {void}
 */
function htmlFormattingRemover(node) {
  if (node.nodeType !== node.TEXT_NODE) {
    return;
  }

  // Ignore pre content. Note that this does not use Element#closest due to
  // a combination of (a) node may not be Element and (b) node.parentElement
  // does not have full support in all browsers (Internet Exporer).
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/API/Node/parentElement#Browser_compatibility

  /** @type {Node?} */
  let parent = node;
  while (parent = parent.parentNode) {
    if (parent.nodeType === parent.ELEMENT_NODE && parent.nodeName === 'PRE') {
      return;
    }
  }

  // First, replace any sequence of HTML formatting space with a single space.
  let newData = node.data.replace(/[ \r\n\t]+/g, ' ');

  // Remove the leading space if the text element is at the start of a block,
  // is preceded by a line break element, or has a space in the previous
  // node.
  if (newData[0] === ' ') {
    const previousSibling = getSibling(node, 'previous');
    if (!previousSibling || previousSibling.nodeName === 'BR' || previousSibling.textContent.slice(-1) === ' ') {
      newData = newData.slice(1);
    }
  }

  // Remove the trailing space if the text element is at the end of a block,
  // is succeded by a line break element, or has a space in the next text
  // node.
  if (newData[newData.length - 1] === ' ') {
    const nextSibling = getSibling(node, 'next');
    if (!nextSibling || nextSibling.nodeName === 'BR' || nextSibling.nodeType === nextSibling.TEXT_NODE && isFormattingSpace(nextSibling.textContent[0])) {
      newData = newData.slice(0, -1);
    }
  }

  // If there's no data left, remove the node, so `previousSibling` stays
  // accurate. Otherwise, update the node data.
  if (!newData) {
    node.parentNode.removeChild(node);
  } else {
    node.data = newData;
  }
}
//# sourceMappingURL=html-formatting-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/br-remover.js
/**
 * Internal dependencies
 */


/**
 * Removes trailing br elements from text-level content.
 *
 * @param {Element} node Node to check.
 */
function brRemover(node) {
  if (node.nodeName !== 'BR') {
    return;
  }
  if (getSibling(node, 'next')) {
    return;
  }
  node.parentNode.removeChild(node);
}
//# sourceMappingURL=br-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/empty-paragraph-remover.js
/**
 * Removes empty paragraph elements.
 *
 * @param {Element} node Node to check.
 */
function emptyParagraphRemover(node) {
  if (node.nodeName !== 'P') {
    return;
  }
  if (node.hasChildNodes()) {
    return;
  }
  node.parentNode.removeChild(node);
}
//# sourceMappingURL=empty-paragraph-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/slack-paragraph-corrector.js
/**
 * Replaces Slack paragraph markup with a double line break (later converted to
 * a proper paragraph).
 *
 * @param {Element} node Node to check.
 */
function slackParagraphCorrector(node) {
  if (node.nodeName !== 'SPAN') {
    return;
  }
  if (node.getAttribute('data-stringify-type') !== 'paragraph-break') {
    return;
  }
  const {
    parentNode
  } = node;
  parentNode.insertBefore(node.ownerDocument.createElement('br'), node);
  parentNode.insertBefore(node.ownerDocument.createElement('br'), node);
  parentNode.removeChild(node);
}
//# sourceMappingURL=slack-paragraph-corrector.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/raw-handling/paste-handler.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


























const log = (...args) => window?.console?.log?.(...args);

/**
 * Filters HTML to only contain phrasing content.
 *
 * @param {string} HTML The HTML to filter.
 *
 * @return {string} HTML only containing phrasing content.
 */
function filterInlineHTML(HTML) {
  HTML = deepFilterHTML(HTML, [headRemover, googleDocsUIdRemover, msListIgnore, phrasingContentReducer, commentRemover]);
  HTML = removeInvalidHTML(HTML, phrasing_content_getPhrasingContentSchema('paste'), {
    inline: true
  });
  HTML = deepFilterHTML(HTML, [htmlFormattingRemover, brRemover]);

  // Allows us to ask for this information when we get a report.
  log('Processed inline HTML:\n\n', HTML);
  return HTML;
}

/**
 * Converts an HTML string to known blocks. Strips everything else.
 *
 * @param {Object} options
 * @param {string} [options.HTML]      The HTML to convert.
 * @param {string} [options.plainText] Plain text version.
 * @param {string} [options.mode]      Handle content as blocks or inline content.
 *                                     * 'AUTO': Decide based on the content passed.
 *                                     * 'INLINE': Always handle as inline content, and return string.
 *                                     * 'BLOCKS': Always handle as blocks, and return array of blocks.
 * @param {Array}  [options.tagName]   The tag into which content will be inserted.
 *
 * @return {Array|string} A list of blocks or a string, depending on `handlerMode`.
 */
function pasteHandler({
  HTML = '',
  plainText = '',
  mode = 'AUTO',
  tagName
}) {
  // First of all, strip any meta tags.
  HTML = HTML.replace(/<meta[^>]+>/g, '');
  // Strip Windows markers.
  HTML = HTML.replace(/^\s*<html[^>]*>\s*<body[^>]*>(?:\s*<!--\s*StartFragment\s*-->)?/i, '');
  HTML = HTML.replace(/(?:<!--\s*EndFragment\s*-->\s*)?<\/body>\s*<\/html>\s*$/i, '');

  // If we detect block delimiters in HTML, parse entirely as blocks.
  if (mode !== 'INLINE') {
    // Check plain text if there is no HTML.
    const content = HTML ? HTML : plainText;
    if (content.indexOf('<!-- wp:') !== -1) {
      const parseResult = parser_parse(content);
      const isSingleFreeFormBlock = parseResult.length === 1 && parseResult[0].name === 'core/freeform';
      if (!isSingleFreeFormBlock) {
        return parseResult;
      }
    }
  }

  // Normalize unicode to use composed characters.
  // This is unsupported in IE 11 but it's a nice-to-have feature, not mandatory.
  // Not normalizing the content will only affect older browsers and won't
  // entirely break the app.
  // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
  // See: https://core.trac.wordpress.org/ticket/30130
  // See: https://github.com/WordPress/gutenberg/pull/6983#pullrequestreview-125151075
  if (String.prototype.normalize) {
    HTML = HTML.normalize();
  }

  // Must be run before checking if it's inline content.
  HTML = deepFilterHTML(HTML, [slackParagraphCorrector]);

  // Consider plain text if:
  // * There is a plain text version.
  // * There is no HTML version, or it has no formatting.
  const isPlainText = plainText && (!HTML || isPlain(HTML));

  // Parse Markdown (and encoded HTML) if it's considered plain text.
  if (isPlainText) {
    HTML = plainText;

    // The markdown converter (Showdown) trims whitespace.
    if (!/^\s+$/.test(plainText)) {
      HTML = markdownConverter(HTML);
    }
  }

  // An array of HTML strings and block objects. The blocks replace matched
  // shortcodes.
  const pieces = shortcode_converter(HTML);

  // The call to shortcodeConverter will always return more than one element
  // if shortcodes are matched. The reason is when shortcodes are matched
  // empty HTML strings are included.
  const hasShortcodes = pieces.length > 1;
  if (isPlainText && !hasShortcodes) {
    // Switch to inline mode if:
    // * The current mode is AUTO.
    // * The original plain text had no line breaks.
    // * The original plain text was not an HTML paragraph.
    // * The converted text is just a paragraph.
    if (mode === 'AUTO' && plainText.indexOf('\n') === -1 && plainText.indexOf('<p>') !== 0 && HTML.indexOf('<p>') === 0) {
      mode = 'INLINE';
    }
  }
  if (mode === 'INLINE') {
    return filterInlineHTML(HTML);
  }
  if (mode === 'AUTO' && !hasShortcodes && isInlineContent(HTML, tagName)) {
    return filterInlineHTML(HTML);
  }
  const phrasingContentSchema = phrasing_content_getPhrasingContentSchema('paste');
  const blockContentSchema = getBlockContentSchema('paste');
  const blocks = pieces.map(piece => {
    // Already a block from shortcode.
    if (typeof piece !== 'string') {
      return piece;
    }
    const filters = [googleDocsUIdRemover, msListConverter, headRemover, listReducer, imageCorrector, phrasingContentReducer, specialCommentConverter, commentRemover, iframeRemover, figureContentReducer, blockquoteNormaliser(), divNormaliser];
    const schema = {
      ...blockContentSchema,
      // Keep top-level phrasing content, normalised by `normaliseBlocks`.
      ...phrasingContentSchema
    };
    piece = deepFilterHTML(piece, filters, blockContentSchema);
    piece = removeInvalidHTML(piece, schema);
    piece = normaliseBlocks(piece);
    piece = deepFilterHTML(piece, [htmlFormattingRemover, brRemover, emptyParagraphRemover], blockContentSchema);

    // Allows us to ask for this information when we get a report.
    log('Processed HTML piece:\n\n', piece);
    return htmlToBlocks(piece, pasteHandler);
  }).flat().filter(Boolean);

  // If we're allowed to return inline content, and there is only one
  // inlineable block, and the original plain text content does not have any
  // line breaks, then treat it as inline paste.
  if (mode === 'AUTO' && blocks.length === 1 && hasBlockSupport(blocks[0].name, '__unstablePasteTextInline', false)) {
    const trimRegex = /^[\n]+|[\n]+$/g;
    // Don't catch line breaks at the start or end.
    const trimmedPlainText = plainText.replace(trimRegex, '');
    if (trimmedPlainText !== '' && trimmedPlainText.indexOf('\n') === -1) {
      return removeInvalidHTML(getBlockInnerHTML(blocks[0]), phrasingContentSchema).replace(trimRegex, '');
    }
  }
  return blocks;
}
//# sourceMappingURL=paste-handler.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/templates.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




/**
 * Checks whether a list of blocks matches a template by comparing the block names.
 *
 * @param {Array} blocks   Block list.
 * @param {Array} template Block template.
 *
 * @return {boolean} Whether the list of blocks matches a templates.
 */
function doBlocksMatchTemplate(blocks = [], template = []) {
  return blocks.length === template.length && template.every(([name,, innerBlocksTemplate], index) => {
    const block = blocks[index];
    return name === block.name && doBlocksMatchTemplate(block.innerBlocks, innerBlocksTemplate);
  });
}
const isHTMLAttribute = attributeDefinition => attributeDefinition?.source === 'html';
const isQueryAttribute = attributeDefinition => attributeDefinition?.source === 'query';
function normalizeAttributes(schema, values) {
  if (!values) {
    return {};
  }
  return Object.fromEntries(Object.entries(values).map(([key, value]) => [key, normalizeAttribute(schema[key], value)]));
}
function normalizeAttribute(definition, value) {
  if (isHTMLAttribute(definition) && Array.isArray(value)) {
    // Introduce a deprecated call at this point
    // When we're confident that "children" format should be removed from the templates.

    return (0,serialize/* default */.Ay)(value);
  }
  if (isQueryAttribute(definition) && value) {
    return value.map(subValues => {
      return normalizeAttributes(definition.query, subValues);
    });
  }
  return value;
}

/**
 * Synchronize a block list with a block template.
 *
 * Synchronizing a block list with a block template means that we loop over the blocks
 * keep the block as is if it matches the block at the same position in the template
 * (If it has the same name) and if doesn't match, we create a new block based on the template.
 * Extra blocks not present in the template are removed.
 *
 * @param {Array} blocks   Block list.
 * @param {Array} template Block template.
 *
 * @return {Array} Updated Block list.
 */
function synchronizeBlocksWithTemplate(blocks = [], template) {
  // If no template is provided, return blocks unmodified.
  if (!template) {
    return blocks;
  }
  return template.map(([name, attributes, innerBlocksTemplate], index) => {
    var _blockType$attributes;
    const block = blocks[index];
    if (block && block.name === name) {
      const innerBlocks = synchronizeBlocksWithTemplate(block.innerBlocks, innerBlocksTemplate);
      return {
        ...block,
        innerBlocks
      };
    }

    // To support old templates that were using the "children" format
    // for the attributes using "html" strings now, we normalize the template attributes
    // before creating the blocks.

    const blockType = getBlockType(name);
    const normalizedAttributes = normalizeAttributes((_blockType$attributes = blockType?.attributes) !== null && _blockType$attributes !== void 0 ? _blockType$attributes : {}, attributes);
    let [blockName, blockAttributes] = convertLegacyBlockNameAndAttributes(name, normalizedAttributes);

    // If a Block is undefined at this point, use the core/missing block as
    // a placeholder for a better user experience.
    if (undefined === getBlockType(blockName)) {
      blockAttributes = {
        originalName: name,
        originalContent: '',
        originalUndelimitedContent: ''
      };
      blockName = 'core/missing';
    }
    return createBlock(blockName, blockAttributes, synchronizeBlocksWithTemplate([], innerBlocksTemplate));
  });
}
//# sourceMappingURL=templates.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/api/index.js
// The blocktype is the most important concept within the block API. It defines
// all aspects of the block configuration and its interfaces, including `edit`
// and `save`. The transforms specification allows converting one blocktype to
// another through formulas defined by either the source or the destination.
// Switching a blocktype is to be considered a one-way operation implying a
// transformation in the opposite way has to be handled explicitly.


// The block tree is composed of a collection of block nodes. Blocks contained
// within other blocks are called inner blocks. An important design
// consideration is that inner blocks are -- conceptually -- not part of the
// territory established by the parent block that contains them.
//
// This has multiple practical implications: when parsing, we can safely dispose
// of any block boundary found within a block from the innerHTML property when
// transfering to state. Not doing so would have a compounding effect on memory
// and uncertainty over the source of truth. This can be illustrated in how,
// given a tree of `n` nested blocks, the entry node would have to contain the
// actual content of each block while each subsequent block node in the state
// tree would replicate the entire chain `n-1`, meaning the extreme end node
// would have been replicated `n` times as the tree is traversed and would
// generate uncertainty as to which one is to hold the current value of the
// block. For composition, it also means inner blocks can effectively be child
// components whose mechanisms can be shielded from the `edit` implementation
// and just passed along.




// While block transformations account for a specific surface of the API, there
// are also raw transformations which handle arbitrary sources not made out of
// blocks but producing block basaed on various heursitics. This includes
// pasting rich text or HTML data.


// The process of serialization aims to deflate the internal memory of the block
// editor and its state representation back into an HTML valid string. This
// process restores the document integrity and inserts invisible delimiters
// around each block with HTML comment boundaries which can contain any extra
// attributes needed to operate with the block later on.


// Validation is the process of comparing a block source with its output before
// there is any user input or interaction with a block. When this operation
// fails -- for whatever reason -- the block is to be considered invalid. As
// part of validating a block the system will attempt to run the source against
// any provided deprecation definitions.
//
// Worth emphasizing that validation is not a case of whether the markup is
// merely HTML spec-compliant but about how the editor knows to create such
// markup and that its inability to create an identical result can be a strong
// indicator of potential data loss (the invalidation is then a protective
// measure).
//
// The invalidation process can also be deconstructed in phases: 1) validate the
// block exists; 2) validate the source matches the output; 3) validate the
// source matches deprecated outputs; 4) work through the significance of
// differences. These are stacked in a way that favors performance and optimizes
// for the majority of cases. That is to say, the evaluation logic can become
// more sophisticated the further down it goes in the process as the cost is
// accounted for. The first logic checks have to be extremely efficient since
// they will be run for all valid and invalid blocks alike. However, once a
// block is detected as invalid -- failing the three first steps -- it is
// adequate to spend more time determining validity before throwing a conflict.



// Blocks are inherently indifferent about where the data they operate with ends
// up being saved. For example, all blocks can have a static and dynamic aspect
// to them depending on the needs. The static nature of a block is the `save()`
// definition that is meant to be serialized into HTML and which can be left
// void. Any block can also register a `render_callback` on the server, which
// makes its output dynamic either in part or in its totality.
//
// Child blocks are defined as a relationship that builds on top of the inner
// blocks mechanism. A child block is a block node of a particular type that can
// only exist within the inner block boundaries of a specific parent type. This
// allows block authors to compose specific blocks that are not meant to be used
// outside of a specified parent block context. Thus, child blocks extend the
// concept of inner blocks to support a more direct relationship between sets of
// blocks. The addition of parent–child would be a subset of the inner block
// functionality under the premise that certain blocks only make sense as
// children of another block.



// Templates are, in a general sense, a basic collection of block nodes with any
// given set of predefined attributes that are supplied as the initial state of
// an inner blocks group. These nodes can, in turn, contain any number of nested
// blocks within their definition. Templates allow both to specify a default
// state for an editor session or a default set of blocks for any inner block
// implementation within a specific block.




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@13.0.3_react@18.3.1/node_modules/@wordpress/blocks/build-module/index.js
// A "block" is the abstract term used to describe units of markup that,
// when composed together, form the content or layout of a page.
// The API for blocks is exposed via `wp.blocks`.
//
// Supported blocks are registered by calling `registerBlockType`. Once registered,
// the block is made available as an option to the editor interface.
//
// Blocks are inferred from the HTML source of a post through a parsing mechanism
// and then stored as objects in state, from which it is then rendered for editing.




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/button-group/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export ButtonGroup */
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

function UnforwardedButtonGroup(props, ref) {
  const {
    className,
    ...restProps
  } = props;
  const classes = (0,clsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)('components-button-group', className);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
    ref: ref,
    role: "group",
    className: classes,
    ...restProps
  });
}

/**
 * ButtonGroup can be used to group any related buttons together. To emphasize
 * related buttons, a group should share a common container.
 *
 * ```jsx
 * import { Button, ButtonGroup } from '@wordpress/components';
 *
 * const MyButtonGroup = () => (
 *   <ButtonGroup>
 *     <Button variant="primary">Button 1</Button>
 *     <Button variant="primary">Button 2</Button>
 *   </ButtonGroup>
 * );
 * ```
 */
const ButtonGroup = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(UnforwardedButtonGroup);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ButtonGroup);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/checkbox-control/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export CheckboxControl */
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-ref-effect/index.js");
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js");
/* harmony import */ var _wordpress_deprecated__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+deprecated@4.0.1/node_modules/@wordpress/deprecated/build-module/index.js");
/* harmony import */ var _wordpress_icons__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/icon/index.js");
/* harmony import */ var _wordpress_icons__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/reset.js");
/* harmony import */ var _wordpress_icons__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/check.js");
/* harmony import */ var _base_control__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/base-control/index.js");
/* harmony import */ var _h_stack__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/h-stack/component.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




/**
 * Checkboxes allow the user to select one or more items from a set.
 *
 * ```jsx
 * import { CheckboxControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyCheckboxControl = () => {
 *   const [ isChecked, setChecked ] = useState( true );
 *   return (
 *     <CheckboxControl
 *       label="Is author"
 *       help="Is the user a author or not?"
 *       checked={ isChecked }
 *       onChange={ setChecked }
 *     />
 *   );
 * };
 * ```
 */
function CheckboxControl(props) {
  const {
    __nextHasNoMarginBottom,
    label,
    className,
    heading,
    checked,
    indeterminate,
    help,
    id: idProp,
    onChange,
    ...additionalProps
  } = props;
  if (heading) {
    (0,_wordpress_deprecated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)('`heading` prop in `CheckboxControl`', {
      alternative: 'a separate element to implement a heading',
      since: '5.8'
    });
  }
  const [showCheckedIcon, setShowCheckedIcon] = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_2__.useState)(false);
  const [showIndeterminateIcon, setShowIndeterminateIcon] = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_2__.useState)(false);

  // Run the following callback every time the `ref` (and the additional
  // dependencies) change.
  const ref = (0,_wordpress_compose__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(node => {
    if (!node) {
      return;
    }

    // It cannot be set using an HTML attribute.
    node.indeterminate = !!indeterminate;
    setShowCheckedIcon(node.matches(':checked'));
    setShowIndeterminateIcon(node.matches(':indeterminate'));
  }, [checked, indeterminate]);
  const id = (0,_wordpress_compose__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(CheckboxControl, 'inspector-checkbox-control', idProp);
  const onChangeValue = event => onChange(event.target.checked);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_base_control__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Ay, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    label: heading,
    id: id,
    help: help && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {
      className: "components-checkbox-control__help",
      children: help
    }),
    className: (0,clsx__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)('components-checkbox-control', className),
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_h_stack__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, {
      spacing: 0,
      justify: "start",
      alignment: "top",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", {
        className: "components-checkbox-control__input-container",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", {
          ref: ref,
          id: id,
          className: "components-checkbox-control__input",
          type: "checkbox",
          value: "1",
          onChange: onChangeValue,
          checked: checked,
          "aria-describedby": !!help ? id + '__help' : undefined,
          ...additionalProps
        }), showIndeterminateIcon ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_icons__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, {
          icon: _wordpress_icons__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A,
          className: "components-checkbox-control__indeterminate",
          role: "presentation"
        }) : null, showCheckedIcon ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_icons__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, {
          icon: _wordpress_icons__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A,
          className: "components-checkbox-control__checked",
          role: "presentation"
        }) : null]
      }), label && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", {
        className: "components-checkbox-control__label",
        htmlFor: id,
        children: label
      })]
    })
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CheckboxControl);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/draggable/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export Draggable */
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/throttle/index.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const dragImageClass = 'components-draggable__invisible-drag-image';
const cloneWrapperClass = 'components-draggable__clone';
const clonePadding = 0;
const bodyClass = 'is-dragging-components-draggable';

/**
 * `Draggable` is a Component that provides a way to set up a cross-browser
 * (including IE) customizable drag image and the transfer data for the drag
 * event. It decouples the drag handle and the element to drag: use it by
 * wrapping the component that will become the drag handle and providing the DOM
 * ID of the element to drag.
 *
 * Note that the drag handle needs to declare the `draggable="true"` property
 * and bind the `Draggable`s `onDraggableStart` and `onDraggableEnd` event
 * handlers to its own `onDragStart` and `onDragEnd` respectively. `Draggable`
 * takes care of the logic to setup the drag image and the transfer data, but is
 * not concerned with creating an actual DOM element that is draggable.
 *
 * ```jsx
 * import { Draggable, Panel, PanelBody } from '@wordpress/components';
 * import { Icon, more } from '@wordpress/icons';
 *
 * const MyDraggable = () => (
 *   <div id="draggable-panel">
 *     <Panel header="Draggable panel">
 *       <PanelBody>
 *         <Draggable elementId="draggable-panel" transferData={ {} }>
 *           { ( { onDraggableStart, onDraggableEnd } ) => (
 *             <div
 *               className="example-drag-handle"
 *               draggable
 *               onDragStart={ onDraggableStart }
 *               onDragEnd={ onDraggableEnd }
 *             >
 *               <Icon icon={ more } />
 *             </div>
 *           ) }
 *         </Draggable>
 *       </PanelBody>
 *     </Panel>
 *   </div>
 * );
 * ```
 */
function Draggable({
  children,
  onDragStart,
  onDragOver,
  onDragEnd,
  appendToOwnerDocument = false,
  cloneClassname,
  elementId,
  transferData,
  __experimentalTransferDataType: transferDataType = 'text',
  __experimentalDragComponent: dragComponent
}) {
  const dragComponentRef = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  const cleanup = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_1__.useRef)(() => {});

  /**
   * Removes the element clone, resets cursor, and removes drag listener.
   *
   * @param event The non-custom DragEvent.
   */
  function end(event) {
    event.preventDefault();
    cleanup.current();
    if (onDragEnd) {
      onDragEnd(event);
    }
  }

  /**
   * This method does a couple of things:
   *
   * - Clones the current element and spawns clone over original element.
   * - Adds a fake temporary drag image to avoid browser defaults.
   * - Sets transfer data.
   * - Adds dragover listener.
   *
   * @param event The non-custom DragEvent.
   */
  function start(event) {
    const {
      ownerDocument
    } = event.target;
    event.dataTransfer.setData(transferDataType, JSON.stringify(transferData));
    const cloneWrapper = ownerDocument.createElement('div');
    // Reset position to 0,0. Natural stacking order will position this lower, even with a transform otherwise.
    cloneWrapper.style.top = '0';
    cloneWrapper.style.left = '0';
    const dragImage = ownerDocument.createElement('div');

    // Set a fake drag image to avoid browser defaults. Remove from DOM
    // right after. event.dataTransfer.setDragImage is not supported yet in
    // IE, we need to check for its existence first.
    if ('function' === typeof event.dataTransfer.setDragImage) {
      dragImage.classList.add(dragImageClass);
      ownerDocument.body.appendChild(dragImage);
      event.dataTransfer.setDragImage(dragImage, 0, 0);
    }
    cloneWrapper.classList.add(cloneWrapperClass);
    if (cloneClassname) {
      cloneWrapper.classList.add(cloneClassname);
    }
    let x = 0;
    let y = 0;
    // If a dragComponent is defined, the following logic will clone the
    // HTML node and inject it into the cloneWrapper.
    if (dragComponentRef.current) {
      // Position dragComponent at the same position as the cursor.
      x = event.clientX;
      y = event.clientY;
      cloneWrapper.style.transform = `translate( ${x}px, ${y}px )`;
      const clonedDragComponent = ownerDocument.createElement('div');
      clonedDragComponent.innerHTML = dragComponentRef.current.innerHTML;
      cloneWrapper.appendChild(clonedDragComponent);

      // Inject the cloneWrapper into the DOM.
      ownerDocument.body.appendChild(cloneWrapper);
    } else {
      const element = ownerDocument.getElementById(elementId);

      // Prepare element clone and append to element wrapper.
      const elementRect = element.getBoundingClientRect();
      const elementWrapper = element.parentNode;
      const elementTopOffset = elementRect.top;
      const elementLeftOffset = elementRect.left;
      cloneWrapper.style.width = `${elementRect.width + clonePadding * 2}px`;
      const clone = element.cloneNode(true);
      clone.id = `clone-${elementId}`;

      // Position clone right over the original element (20px padding).
      x = elementLeftOffset - clonePadding;
      y = elementTopOffset - clonePadding;
      cloneWrapper.style.transform = `translate( ${x}px, ${y}px )`;

      // Hack: Remove iFrames as it's causing the embeds drag clone to freeze.
      Array.from(clone.querySelectorAll('iframe')).forEach(child => child.parentNode?.removeChild(child));
      cloneWrapper.appendChild(clone);

      // Inject the cloneWrapper into the DOM.
      if (appendToOwnerDocument) {
        ownerDocument.body.appendChild(cloneWrapper);
      } else {
        elementWrapper?.appendChild(cloneWrapper);
      }
    }

    // Mark the current cursor coordinates.
    let cursorLeft = event.clientX;
    let cursorTop = event.clientY;
    function over(e) {
      // Skip doing any work if mouse has not moved.
      if (cursorLeft === e.clientX && cursorTop === e.clientY) {
        return;
      }
      const nextX = x + e.clientX - cursorLeft;
      const nextY = y + e.clientY - cursorTop;
      cloneWrapper.style.transform = `translate( ${nextX}px, ${nextY}px )`;
      cursorLeft = e.clientX;
      cursorTop = e.clientY;
      x = nextX;
      y = nextY;
      if (onDragOver) {
        onDragOver(e);
      }
    }

    // Aim for 60fps (16 ms per frame) for now. We can potentially use requestAnimationFrame (raf) instead,
    // note that browsers may throttle raf below 60fps in certain conditions.
    // @ts-ignore
    const throttledDragOver = (0,_wordpress_compose__WEBPACK_IMPORTED_MODULE_2__/* .throttle */ .n)(over, 16);
    ownerDocument.addEventListener('dragover', throttledDragOver);

    // Update cursor to 'grabbing', document wide.
    ownerDocument.body.classList.add(bodyClass);
    if (onDragStart) {
      onDragStart(event);
    }
    cleanup.current = () => {
      // Remove drag clone.
      if (cloneWrapper && cloneWrapper.parentNode) {
        cloneWrapper.parentNode.removeChild(cloneWrapper);
      }
      if (dragImage && dragImage.parentNode) {
        dragImage.parentNode.removeChild(dragImage);
      }

      // Reset cursor.
      ownerDocument.body.classList.remove(bodyClass);
      ownerDocument.removeEventListener('dragover', throttledDragOver);
    };
  }
  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => () => {
    cleanup.current();
  }, []);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [children({
      onDraggableStart: start,
      onDraggableEnd: end
    }), dragComponent && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
      className: "components-draggable-drag-component-root",
      style: {
        display: 'none'
      },
      ref: dragComponentRef,
      children: dragComponent
    })]
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Draggable);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/drop-zone/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export DropZoneComponent */
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+i18n@5.0.1/node_modules/@wordpress/i18n/build-module/index.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _wordpress_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/icon/index.js");
/* harmony import */ var _wordpress_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/upload.js");
/* harmony import */ var _wordpress_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/data-transfer.js");
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-reduced-motion/index.js");
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-drop-zone/index.js");
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/render/dom/motion.mjs");
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



const backdrop = {
  hidden: {
    opacity: 0
  },
  show: {
    opacity: 1,
    transition: {
      type: 'tween',
      duration: 0.2,
      delay: 0,
      delayChildren: 0.1
    }
  },
  exit: {
    opacity: 0,
    transition: {
      duration: 0.2,
      delayChildren: 0
    }
  }
};
const foreground = {
  hidden: {
    opacity: 0,
    scale: 0.9
  },
  show: {
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.1
    }
  },
  exit: {
    opacity: 0,
    scale: 0.9
  }
};
function DropIndicator({
  label
}) {
  const disableMotion = (0,_wordpress_compose__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)();
  const children = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_animation__WEBPACK_IMPORTED_MODULE_3__/* .motion */ .P.div, {
    variants: backdrop,
    initial: disableMotion ? 'show' : 'hidden',
    animate: "show",
    exit: disableMotion ? 'show' : 'exit',
    className: "components-drop-zone__content"
    // Without this, when this div is shown,
    // Safari calls a onDropZoneLeave causing a loop because of this bug
    // https://bugs.webkit.org/show_bug.cgi?id=66547
    ,
    style: {
      pointerEvents: 'none'
    },
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_animation__WEBPACK_IMPORTED_MODULE_3__/* .motion */ .P.div, {
      variants: foreground,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_wordpress_icons__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
        icon: _wordpress_icons__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A,
        className: "components-drop-zone__content-icon"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("span", {
        className: "components-drop-zone__content-text",
        children: label ? label : (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('Drop files to upload')
      })]
    })
  });
  if (disableMotion) {
    return children;
  }
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_animation__WEBPACK_IMPORTED_MODULE_6__/* .AnimatePresence */ .N, {
    children: children
  });
}

/**
 * `DropZone` is a component creating a drop zone area taking the full size of its parent element. It supports dropping files, HTML content or any other HTML drop event.
 *
 * ```jsx
 * import { DropZone } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyDropZone = () => {
 *   const [ hasDropped, setHasDropped ] = useState( false );
 *
 *   return (
 *     <div>
 *       { hasDropped ? 'Dropped!' : 'Drop something here' }
 *       <DropZone
 *         onFilesDrop={ () => setHasDropped( true ) }
 *         onHTMLDrop={ () => setHasDropped( true ) }
 *         onDrop={ () => setHasDropped( true ) }
 *       />
 *     </div>
 *   );
 * }
 * ```
 */
function DropZoneComponent({
  className,
  label,
  onFilesDrop,
  onHTMLDrop,
  onDrop,
  ...restProps
}) {
  const [isDraggingOverDocument, setIsDraggingOverDocument] = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_7__.useState)();
  const [isDraggingOverElement, setIsDraggingOverElement] = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_7__.useState)();
  const [type, setType] = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_7__.useState)();
  const ref = (0,_wordpress_compose__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)({
    onDrop(event) {
      const files = event.dataTransfer ? (0,_wordpress_dom__WEBPACK_IMPORTED_MODULE_9__/* .getFilesFromDataTransfer */ .$)(event.dataTransfer) : [];
      const html = event.dataTransfer?.getData('text/html');

      /**
       * From Windows Chrome 96, the `event.dataTransfer` returns both file object and HTML.
       * The order of the checks is important to recognise the HTML drop.
       */
      if (html && onHTMLDrop) {
        onHTMLDrop(html);
      } else if (files.length && onFilesDrop) {
        onFilesDrop(files);
      } else if (onDrop) {
        onDrop(event);
      }
    },
    onDragStart(event) {
      setIsDraggingOverDocument(true);
      let _type = 'default';

      /**
       * From Windows Chrome 96, the `event.dataTransfer` returns both file object and HTML.
       * The order of the checks is important to recognise the HTML drop.
       */
      if (event.dataTransfer?.types.includes('text/html')) {
        _type = 'html';
      } else if (
      // Check for the types because sometimes the files themselves
      // are only available on drop.
      event.dataTransfer?.types.includes('Files') || (event.dataTransfer ? (0,_wordpress_dom__WEBPACK_IMPORTED_MODULE_9__/* .getFilesFromDataTransfer */ .$)(event.dataTransfer) : []).length > 0) {
        _type = 'file';
      }
      setType(_type);
    },
    onDragEnd() {
      setIsDraggingOverDocument(false);
      setType(undefined);
    },
    onDragEnter() {
      setIsDraggingOverElement(true);
    },
    onDragLeave() {
      setIsDraggingOverElement(false);
    }
  });
  const classes = (0,clsx__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)('components-drop-zone', className, {
    'is-active': (isDraggingOverDocument || isDraggingOverElement) && (type === 'file' && onFilesDrop || type === 'html' && onHTMLDrop || type === 'default' && onDrop),
    'is-dragging-over-document': isDraggingOverDocument,
    'is-dragging-over-element': isDraggingOverElement,
    [`is-dragging-${type}`]: !!type
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
    ...restProps,
    ref: ref,
    className: classes,
    children: isDraggingOverElement && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DropIndicator, {
      label: label
    })
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DropZoneComponent);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-block/component.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ flex_block_component)
});

// UNUSED EXPORTS: FlexBlock

// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-connect.js
var context_connect = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-connect.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/view/component.js
var component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/view/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/use-context-system.js + 1 modules
var use_context_system = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/use-context-system.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-item/hook.js
var hook = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-item/hook.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-block/hook.js
/**
 * Internal dependencies
 */



function useFlexBlock(props) {
  const otherProps = (0,use_context_system/* useContextSystem */.A)(props, 'FlexBlock');
  const flexItemProps = (0,hook/* useFlexItem */.K)({
    isBlock: true,
    ...otherProps
  });
  return flexItemProps;
}
//# sourceMappingURL=hook.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-block/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function UnconnectedFlexBlock(props, forwardedRef) {
  const flexBlockProps = useFlexBlock(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
    ...flexBlockProps,
    ref: forwardedRef
  });
}

/**
 * `FlexBlock` is a primitive layout component that adaptively resizes content
 * within layout containers like `Flex`.
 *
 * ```jsx
 * import { Flex, FlexBlock } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <Flex>
 *       <FlexBlock>...</FlexBlock>
 *     </Flex>
 *   );
 * }
 * ```
 */
const FlexBlock = (0,context_connect/* contextConnect */.KZ)(UnconnectedFlexBlock, 'FlexBlock');
/* harmony default export */ const flex_block_component = (FlexBlock);
//# sourceMappingURL=component.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/form-file-upload/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export FormFileUpload */
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/button/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * FormFileUpload is a component that allows users to select files from their local device.
 *
 * ```jsx
 * import { FormFileUpload } from '@wordpress/components';
 *
 * const MyFormFileUpload = () => (
 *   <FormFileUpload
 *     accept="image/*"
 *     onChange={ ( event ) => console.log( event.currentTarget.files ) }
 *   >
 *     Upload
 *   </FormFileUpload>
 * );
 * ```
 */
function FormFileUpload({
  accept,
  children,
  multiple = false,
  onChange,
  onClick,
  render,
  ...props
}) {
  const ref = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  const openFileDialog = () => {
    ref.current?.click();
  };
  const ui = render ? render({
    openFileDialog
  }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_button__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay, {
    onClick: openFileDialog,
    ...props,
    children: children
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
    className: "components-form-file-upload",
    children: [ui, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", {
      type: "file",
      ref: ref,
      multiple: multiple,
      style: {
        display: 'none'
      },
      accept: accept,
      onChange: onChange,
      onClick: onClick,
      "data-testid": "form-file-upload-input"
    })]
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FormFileUpload);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/form-toggle/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports noop, FormToggle */
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const noop = () => {};

/**
 * FormToggle switches a single setting on or off.
 *
 * ```jsx
 * import { FormToggle } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyFormToggle = () => {
 *   const [ isChecked, setChecked ] = useState( true );
 *
 *   return (
 *     <FormToggle
 *       checked={ isChecked }
 *       onChange={ () => setChecked( ( state ) => ! state ) }
 *     />
 *   );
 * };
 * ```
 */
function FormToggle(props, ref) {
  const {
    className,
    checked,
    id,
    disabled,
    onChange = noop,
    ...additionalProps
  } = props;
  const wrapperClasses = (0,clsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)('components-form-toggle', className, {
    'is-checked': checked,
    'is-disabled': disabled
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", {
    className: wrapperClasses,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", {
      className: "components-form-toggle__input",
      id: id,
      type: "checkbox",
      checked: checked,
      onChange: onChange,
      disabled: disabled,
      ...additionalProps,
      ref: ref
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {
      className: "components-form-toggle__track"
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {
      className: "components-form-toggle__thumb"
    })]
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_wordpress_element__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(FormToggle));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/heading/component.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ heading_component)
});

// UNUSED EXPORTS: Heading

// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-connect.js
var context_connect = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-connect.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/view/component.js
var component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/view/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/use-context-system.js + 1 modules
var use_context_system = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/use-context-system.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/text/hook.js + 4 modules
var hook = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/text/hook.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/font-size.js
var font_size = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/font-size.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/colors-values.js
var colors_values = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/colors-values.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/config-values.js
var config_values = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/config-values.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/heading/hook.js
/**
 * Internal dependencies
 */





function useHeading(props) {
  const {
    as: asProp,
    level = 2,
    color = colors_values/* COLORS */.l.gray[900],
    isBlock = true,
    weight = config_values/* default */.A.fontWeightHeading,
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'Heading');
  const as = asProp || `h${level}`;
  const a11yProps = {};
  if (typeof as === 'string' && as[0] !== 'h') {
    // If not a semantic `h` element, add a11y props:
    a11yProps.role = 'heading';
    a11yProps['aria-level'] = typeof level === 'string' ? parseInt(level) : level;
  }
  const textProps = (0,hook/* default */.A)({
    color,
    isBlock,
    weight,
    size: (0,font_size/* getHeadingFontSize */.fM)(level),
    ...otherProps
  });
  return {
    ...textProps,
    ...a11yProps,
    as
  };
}
//# sourceMappingURL=hook.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/heading/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function UnconnectedHeading(props, forwardedRef) {
  const headerProps = useHeading(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
    ...headerProps,
    ref: forwardedRef
  });
}

/**
 * `Heading` renders headings and titles using the library's typography system.
 *
 * ```jsx
 * import { __experimentalHeading as Heading } from "@wordpress/components";
 *
 * function Example() {
 *   return <Heading>Code is Poetry</Heading>;
 * }
 * ```
 */
const Heading = (0,context_connect/* contextConnect */.KZ)(UnconnectedHeading, 'Heading');
/* harmony default export */ const heading_component = (Heading);
//# sourceMappingURL=component.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ey: () => (/* binding */ InputControl),
  Ay: () => (/* binding */ input_control)
});

// UNUSED EXPORTS: UnforwardedInputControl

// EXTERNAL MODULE: ../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js
var use_instance_id = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/input-base.js + 2 modules
var input_base = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/input-base.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@use-gesture+react@10.3.1_react@18.3.1/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js + 3 modules
var use_gesture_react_esm = __webpack_require__("../../node_modules/.pnpm/@use-gesture+react@10.3.1_react@18.3.1/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

/**
 * Gets a CSS cursor value based on a drag direction.
 *
 * @param dragDirection The drag direction.
 * @return  The CSS cursor value.
 */
function getDragCursor(dragDirection) {
  let dragCursor = 'ns-resize';
  switch (dragDirection) {
    case 'n':
    case 's':
      dragCursor = 'ns-resize';
      break;
    case 'e':
    case 'w':
      dragCursor = 'ew-resize';
      break;
  }
  return dragCursor;
}

/**
 * Custom hook that renders a drag cursor when dragging.
 *
 * @param {boolean} isDragging    The dragging state.
 * @param {string}  dragDirection The drag direction.
 *
 * @return {string} The CSS cursor value.
 */
function useDragCursor(isDragging, dragDirection) {
  const dragCursor = getDragCursor(dragDirection);
  (0,react.useEffect)(() => {
    if (isDragging) {
      document.documentElement.style.cursor = dragCursor;
    } else {
      // @ts-expect-error
      document.documentElement.style.cursor = null;
    }
  }, [isDragging, dragCursor]);
  return dragCursor;
}
function useDraft(props) {
  const refPreviousValue = (0,react.useRef)(props.value);
  const [draft, setDraft] = (0,react.useState)({});
  const value = draft.value !== undefined ? draft.value : props.value;

  // Determines when to discard the draft value to restore controlled status.
  // To do so, it tracks the previous value and marks the draft value as stale
  // after each render.
  (0,react.useLayoutEffect)(() => {
    const {
      current: previousValue
    } = refPreviousValue;
    refPreviousValue.current = props.value;
    if (draft.value !== undefined && !draft.isStale) {
      setDraft({
        ...draft,
        isStale: true
      });
    } else if (draft.isStale && props.value !== previousValue) {
      setDraft({});
    }
  }, [props.value, draft]);
  const onChange = (nextValue, extra) => {
    // Mutates the draft value to avoid an extra effect run.
    setDraft(current => Object.assign(current, {
      value: nextValue,
      isStale: false
    }));
    props.onChange(nextValue, extra);
  };
  const onBlur = event => {
    setDraft({});
    props.onBlur?.(event);
  };
  return {
    value,
    onBlur,
    onChange
  };
}
//# sourceMappingURL=utils.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/styles/input-control-styles.js
var input_control_styles = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/styles/input-control-styles.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/reducer/state.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const initialStateReducer = state => state;
const initialInputControlState = {
  error: null,
  initialValue: '',
  isDirty: false,
  isDragEnabled: false,
  isDragging: false,
  isPressEnterToChange: false,
  value: ''
};
//# sourceMappingURL=state.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/reducer/actions.js
var actions = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/reducer/actions.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/reducer/reducer.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Prepares initialState for the reducer.
 *
 * @param initialState The initial state.
 * @return Prepared initialState for the reducer
 */
function mergeInitialState(initialState = initialInputControlState) {
  const {
    value
  } = initialState;
  return {
    ...initialInputControlState,
    ...initialState,
    initialValue: value
  };
}

/**
 * Creates the base reducer which may be coupled to a specializing reducer.
 * As its final step, for all actions other than CONTROL, the base reducer
 * passes the state and action on through the specializing reducer. The
 * exception for CONTROL actions is because they represent controlled updates
 * from props and no case has yet presented for their specialization.
 *
 * @param composedStateReducers A reducer to specialize state changes.
 * @return The reducer.
 */
function inputControlStateReducer(composedStateReducers) {
  return (state, action) => {
    const nextState = {
      ...state
    };
    switch (action.type) {
      /*
       * Controlled updates
       */
      case actions/* CONTROL */.W3:
        nextState.value = action.payload.value;
        nextState.isDirty = false;
        nextState._event = undefined;
        // Returns immediately to avoid invoking additional reducers.
        return nextState;

      /**
       * Keyboard events
       */
      case actions/* PRESS_UP */.wX:
        nextState.isDirty = false;
        break;
      case actions/* PRESS_DOWN */.r7:
        nextState.isDirty = false;
        break;

      /**
       * Drag events
       */
      case actions/* DRAG_START */.Qf:
        nextState.isDragging = true;
        break;
      case actions/* DRAG_END */.Ry:
        nextState.isDragging = false;
        break;

      /**
       * Input events
       */
      case actions/* CHANGE */.PL:
        nextState.error = null;
        nextState.value = action.payload.value;
        if (state.isPressEnterToChange) {
          nextState.isDirty = true;
        }
        break;
      case actions/* COMMIT */.cJ:
        nextState.value = action.payload.value;
        nextState.isDirty = false;
        break;
      case actions/* RESET */.Ut:
        nextState.error = null;
        nextState.isDirty = false;
        nextState.value = action.payload.value || state.initialValue;
        break;

      /**
       * Validation
       */
      case actions/* INVALIDATE */.uY:
        nextState.error = action.payload.error;
        break;
    }
    nextState._event = action.payload.event;

    /**
     * Send the nextState + action to the composedReducers via
     * this "bridge" mechanism. This allows external stateReducers
     * to hook into actions, and modify state if needed.
     */
    return composedStateReducers(nextState, action);
  };
}

/**
 * A custom hook that connects and external stateReducer with an internal
 * reducer. This hook manages the internal state of InputControl.
 * However, by connecting an external stateReducer function, other
 * components can react to actions as well as modify state before it is
 * applied.
 *
 * This technique uses the "stateReducer" design pattern:
 * https://kentcdodds.com/blog/the-state-reducer-pattern/
 *
 * @param stateReducer    An external state reducer.
 * @param initialState    The initial state for the reducer.
 * @param onChangeHandler A handler for the onChange event.
 * @return State, dispatch, and a collection of actions.
 */
function useInputControlStateReducer(stateReducer = initialStateReducer, initialState = initialInputControlState, onChangeHandler) {
  const [state, dispatch] = (0,react.useReducer)(inputControlStateReducer(stateReducer), mergeInitialState(initialState));
  const createChangeEvent = type => (nextValue, event) => {
    dispatch({
      type,
      payload: {
        value: nextValue,
        event
      }
    });
  };
  const createKeyEvent = type => event => {
    dispatch({
      type,
      payload: {
        event
      }
    });
  };
  const createDragEvent = type => payload => {
    dispatch({
      type,
      payload
    });
  };

  /**
   * Actions for the reducer
   */
  const change = createChangeEvent(actions/* CHANGE */.PL);
  const invalidate = (error, event) => dispatch({
    type: actions/* INVALIDATE */.uY,
    payload: {
      error,
      event
    }
  });
  const reset = createChangeEvent(actions/* RESET */.Ut);
  const commit = createChangeEvent(actions/* COMMIT */.cJ);
  const dragStart = createDragEvent(actions/* DRAG_START */.Qf);
  const drag = createDragEvent(actions/* DRAG */.j);
  const dragEnd = createDragEvent(actions/* DRAG_END */.Ry);
  const pressUp = createKeyEvent(actions/* PRESS_UP */.wX);
  const pressDown = createKeyEvent(actions/* PRESS_DOWN */.r7);
  const pressEnter = createKeyEvent(actions/* PRESS_ENTER */.bR);
  const currentState = (0,react.useRef)(state);
  const refProps = (0,react.useRef)({
    value: initialState.value,
    onChangeHandler
  });

  // Freshens refs to props and state so that subsequent effects have access
  // to their latest values without their changes causing effect runs.
  (0,react.useLayoutEffect)(() => {
    currentState.current = state;
    refProps.current = {
      value: initialState.value,
      onChangeHandler
    };
  });

  // Propagates the latest state through onChange.
  (0,react.useLayoutEffect)(() => {
    if (currentState.current._event !== undefined && state.value !== refProps.current.value && !state.isDirty) {
      var _state$value;
      refProps.current.onChangeHandler((_state$value = state.value) !== null && _state$value !== void 0 ? _state$value : '', {
        event: currentState.current._event
      });
    }
  }, [state.value, state.isDirty]);

  // Updates the state from props.
  (0,react.useLayoutEffect)(() => {
    if (initialState.value !== currentState.current.value && !currentState.current.isDirty) {
      var _initialState$value;
      dispatch({
        type: actions/* CONTROL */.W3,
        payload: {
          value: (_initialState$value = initialState.value) !== null && _initialState$value !== void 0 ? _initialState$value : ''
        }
      });
    }
  }, [initialState.value]);
  return {
    change,
    commit,
    dispatch,
    drag,
    dragEnd,
    dragStart,
    invalidate,
    pressDown,
    pressEnter,
    pressUp,
    reset,
    state
  };
}
//# sourceMappingURL=reducer.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/with-ignore-ime-events.js
var with_ignore_ime_events = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/with-ignore-ime-events.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/input-field.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */






const noop = () => {};
function InputField({
  disabled = false,
  dragDirection = 'n',
  dragThreshold = 10,
  id,
  isDragEnabled = false,
  isPressEnterToChange = false,
  onBlur = noop,
  onChange = noop,
  onDrag = noop,
  onDragEnd = noop,
  onDragStart = noop,
  onKeyDown = noop,
  onValidate = noop,
  size = 'default',
  stateReducer = state => state,
  value: valueProp,
  type,
  ...props
}, ref) {
  const {
    // State.
    state,
    // Actions.
    change,
    commit,
    drag,
    dragEnd,
    dragStart,
    invalidate,
    pressDown,
    pressEnter,
    pressUp,
    reset
  } = useInputControlStateReducer(stateReducer, {
    isDragEnabled,
    value: valueProp,
    isPressEnterToChange
  }, onChange);
  const {
    value,
    isDragging,
    isDirty
  } = state;
  const wasDirtyOnBlur = (0,react.useRef)(false);
  const dragCursor = useDragCursor(isDragging, dragDirection);
  const handleOnBlur = event => {
    onBlur(event);

    /**
     * If isPressEnterToChange is set, this commits the value to
     * the onChange callback.
     */
    if (isDirty || !event.target.validity.valid) {
      wasDirtyOnBlur.current = true;
      handleOnCommit(event);
    }
  };
  const handleOnChange = event => {
    const nextValue = event.target.value;
    change(nextValue, event);
  };
  const handleOnCommit = event => {
    const nextValue = event.currentTarget.value;
    try {
      onValidate(nextValue);
      commit(nextValue, event);
    } catch (err) {
      invalidate(err, event);
    }
  };
  const handleOnKeyDown = event => {
    const {
      key
    } = event;
    onKeyDown(event);
    switch (key) {
      case 'ArrowUp':
        pressUp(event);
        break;
      case 'ArrowDown':
        pressDown(event);
        break;
      case 'Enter':
        pressEnter(event);
        if (isPressEnterToChange) {
          event.preventDefault();
          handleOnCommit(event);
        }
        break;
      case 'Escape':
        if (isPressEnterToChange && isDirty) {
          event.preventDefault();
          reset(valueProp, event);
        }
        break;
    }
  };
  const dragGestureProps = (0,use_gesture_react_esm.useDrag)(dragProps => {
    const {
      distance,
      dragging,
      event,
      target
    } = dragProps;

    // The `target` prop always references the `input` element while, by
    // default, the `dragProps.event.target` property would reference the real
    // event target (i.e. any DOM element that the pointer is hovering while
    // dragging). Ensuring that the `target` is always the `input` element
    // allows consumers of `InputControl` (or any higher-level control) to
    // check the input's validity by accessing `event.target.validity.valid`.
    dragProps.event = {
      ...dragProps.event,
      target
    };
    if (!distance) {
      return;
    }
    event.stopPropagation();

    /**
     * Quick return if no longer dragging.
     * This prevents unnecessary value calculations.
     */
    if (!dragging) {
      onDragEnd(dragProps);
      dragEnd(dragProps);
      return;
    }
    onDrag(dragProps);
    drag(dragProps);
    if (!isDragging) {
      onDragStart(dragProps);
      dragStart(dragProps);
    }
  }, {
    axis: dragDirection === 'e' || dragDirection === 'w' ? 'x' : 'y',
    threshold: dragThreshold,
    enabled: isDragEnabled,
    pointer: {
      capture: false
    }
  });
  const dragProps = isDragEnabled ? dragGestureProps() : {};
  /*
   * Works around the odd UA (e.g. Firefox) that does not focus inputs of
   * type=number when their spinner arrows are pressed.
   */
  let handleOnMouseDown;
  if (type === 'number') {
    handleOnMouseDown = event => {
      props.onMouseDown?.(event);
      if (event.currentTarget !== event.currentTarget.ownerDocument.activeElement) {
        event.currentTarget.focus();
      }
    };
  }
  return /*#__PURE__*/(0,jsx_runtime.jsx)(input_control_styles/* Input */.pd, {
    ...props,
    ...dragProps,
    className: "components-input-control__input",
    disabled: disabled,
    dragCursor: dragCursor,
    isDragging: isDragging,
    id: id,
    onBlur: handleOnBlur,
    onChange: handleOnChange,
    onKeyDown: (0,with_ignore_ime_events/* withIgnoreIMEEvents */.n)(handleOnKeyDown),
    onMouseDown: handleOnMouseDown,
    ref: ref,
    inputSize: size
    // Fallback to `''` to avoid "uncontrolled to controlled" warning.
    // See https://github.com/WordPress/gutenberg/pull/47250 for details.
    ,
    value: value !== null && value !== void 0 ? value : '',
    type: type
  });
}
const ForwardedComponent = (0,react.forwardRef)(InputField);
/* harmony default export */ const input_field = (ForwardedComponent);
//# sourceMappingURL=input-field.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/space.js
var space = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/space.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/base-control/index.js
var base_control = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/base-control/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/use-deprecated-props.js
var use_deprecated_props = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/use-deprecated-props.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







const input_control_noop = () => {};
function useUniqueId(idProp) {
  const instanceId = (0,use_instance_id/* default */.A)(InputControl);
  const id = `inspector-input-control-${instanceId}`;
  return idProp || id;
}
function UnforwardedInputControl(props, ref) {
  const {
    __next40pxDefaultSize,
    __unstableStateReducer: stateReducer = state => state,
    __unstableInputWidth,
    className,
    disabled = false,
    help,
    hideLabelFromVision = false,
    id: idProp,
    isPressEnterToChange = false,
    label,
    labelPosition = 'top',
    onChange = input_control_noop,
    onValidate = input_control_noop,
    onKeyDown = input_control_noop,
    prefix,
    size = 'default',
    style,
    suffix,
    value,
    ...restProps
  } = (0,use_deprecated_props/* useDeprecated36pxDefaultSizeProp */.R)(props);
  const id = useUniqueId(idProp);
  const classes = (0,clsx/* default */.A)('components-input-control', className);
  const draftHookProps = useDraft({
    value,
    onBlur: restProps.onBlur,
    onChange
  });
  const helpProp = !!help ? {
    'aria-describedby': `${id}__help`
  } : {};
  return /*#__PURE__*/(0,jsx_runtime.jsx)(base_control/* default */.Ay, {
    className: classes,
    help: help,
    id: id,
    __nextHasNoMarginBottom: true,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(input_base/* default */.A, {
      __next40pxDefaultSize: __next40pxDefaultSize,
      __unstableInputWidth: __unstableInputWidth,
      disabled: disabled,
      gap: 3,
      hideLabelFromVision: hideLabelFromVision,
      id: id,
      justify: "left",
      label: label,
      labelPosition: labelPosition,
      prefix: prefix,
      size: size,
      style: style,
      suffix: suffix,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(input_field, {
        ...restProps,
        ...helpProp,
        __next40pxDefaultSize: __next40pxDefaultSize,
        className: "components-input-control__input",
        disabled: disabled,
        id: id,
        isPressEnterToChange: isPressEnterToChange,
        onKeyDown: onKeyDown,
        onValidate: onValidate,
        paddingInlineStart: prefix ? (0,space/* space */.x)(2) : undefined,
        paddingInlineEnd: suffix ? (0,space/* space */.x)(2) : undefined,
        ref: ref,
        size: size,
        stateReducer: stateReducer,
        ...draftHookProps
      })
    })
  });
}

/**
 * InputControl components let users enter and edit text. This is an experimental component
 * intended to (in time) merge with or replace `TextControl`.
 *
 * ```jsx
 * import { __experimentalInputControl as InputControl } from '@wordpress/components';
 * import { useState } from 'react';
 *
 * const Example = () => {
 *   const [ value, setValue ] = useState( '' );
 *
 *   return (
 *  	<InputControl
 *  		value={ value }
 *  		onChange={ ( nextValue ) => setValue( nextValue ?? '' ) }
 *  	/>
 *   );
 * };
 * ```
 */
const InputControl = (0,react.forwardRef)(UnforwardedInputControl);
/* harmony default export */ const input_control = (InputControl);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/reducer/actions.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PL: () => (/* binding */ CHANGE),
/* harmony export */   Qf: () => (/* binding */ DRAG_START),
/* harmony export */   Ry: () => (/* binding */ DRAG_END),
/* harmony export */   Ut: () => (/* binding */ RESET),
/* harmony export */   W3: () => (/* binding */ CONTROL),
/* harmony export */   bR: () => (/* binding */ PRESS_ENTER),
/* harmony export */   cJ: () => (/* binding */ COMMIT),
/* harmony export */   j: () => (/* binding */ DRAG),
/* harmony export */   r7: () => (/* binding */ PRESS_DOWN),
/* harmony export */   uY: () => (/* binding */ INVALIDATE),
/* harmony export */   wX: () => (/* binding */ PRESS_UP)
/* harmony export */ });
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const CHANGE = 'CHANGE';
const COMMIT = 'COMMIT';
const CONTROL = 'CONTROL';
const DRAG_END = 'DRAG_END';
const DRAG_START = 'DRAG_START';
const DRAG = 'DRAG';
const INVALIDATE = 'INVALIDATE';
const PRESS_DOWN = 'PRESS_DOWN';
const PRESS_ENTER = 'PRESS_ENTER';
const PRESS_UP = 'PRESS_UP';
const RESET = 'RESET';
//# sourceMappingURL=actions.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/number-control/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ number_control)
});

// UNUSED EXPORTS: NumberControl

// EXTERNAL MODULE: ../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+i18n@5.0.1/node_modules/@wordpress/i18n/build-module/index.js + 3 modules
var build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+i18n@5.0.1/node_modules/@wordpress/i18n/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/plus.js
var plus = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/plus.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/reset.js
var library_reset = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/reset.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-merge-refs/index.js
var use_merge_refs = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-merge-refs/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+deprecated@4.0.1/node_modules/@wordpress/deprecated/build-module/index.js
var deprecated_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+deprecated@4.0.1/node_modules/@wordpress/deprecated/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1__@types+react@18.3.16_react@18.3.1/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js + 1 modules
var emotion_styled_base_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1__@types+react@18.3.16_react@18.3.1/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1/node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var emotion_react_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1/node_modules/@emotion/react/dist/emotion-react.browser.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/index.js + 4 modules
var input_control = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/colors-values.js
var colors_values = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/colors-values.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/button/index.js
var build_module_button = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/button/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/space.js
var space = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/space.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/number-control/styles/number-control-styles.js

function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




var _ref =  true ? {
  name: "euqsgg",
  styles: "input[type='number']::-webkit-outer-spin-button,input[type='number']::-webkit-inner-spin-button{-webkit-appearance:none!important;margin:0!important;}input[type='number']{-moz-appearance:textfield;}"
} : 0;
const htmlArrowStyles = ({
  hideHTMLArrows
}) => {
  if (!hideHTMLArrows) {
    return ``;
  }
  return _ref;
};
const Input = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(input_control/* default */.Ay,  true ? {
  target: "ep09it41"
} : 0)(htmlArrowStyles, ";" + ( true ? "" : 0));
const SpinButton = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(build_module_button/* default */.Ay,  true ? {
  target: "ep09it40"
} : 0)("&&&&&{color:", colors_values/* COLORS */.l.theme.accent, ";}" + ( true ? "" : 0));
const smallSpinButtons = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("width:", (0,space/* space */.x)(5), ";min-width:", (0,space/* space */.x)(5), ";height:", (0,space/* space */.x)(5), ";" + ( true ? "" : 0),  true ? "" : 0);
const styles = {
  smallSpinButtons
};
//# sourceMappingURL=number-control-styles.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/reducer/actions.js
var actions = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/input-control/reducer/actions.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/math.js
var math = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/math.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/values.js
var values = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/values.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/h-stack/component.js
var component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/h-stack/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/spacer/component.js + 1 modules
var spacer_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/spacer/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-cx.js
var use_cx = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-cx.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/use-deprecated-props.js
var use_deprecated_props = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/use-deprecated-props.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/number-control/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */











const noop = () => {};
function UnforwardedNumberControl(props, forwardedRef) {
  const {
    __unstableStateReducer: stateReducerProp,
    className,
    dragDirection = 'n',
    hideHTMLArrows = false,
    spinControls = hideHTMLArrows ? 'none' : 'native',
    isDragEnabled = true,
    isShiftStepEnabled = true,
    label,
    max = Infinity,
    min = -Infinity,
    required = false,
    shiftStep = 10,
    step = 1,
    spinFactor = 1,
    type: typeProp = 'number',
    value: valueProp,
    size = 'default',
    suffix,
    onChange = noop,
    ...restProps
  } = (0,use_deprecated_props/* useDeprecated36pxDefaultSizeProp */.R)(props);
  if (hideHTMLArrows) {
    (0,deprecated_build_module/* default */.A)('wp.components.NumberControl hideHTMLArrows prop ', {
      alternative: 'spinControls="none"',
      since: '6.2',
      version: '6.3'
    });
  }
  const inputRef = (0,react.useRef)();
  const mergedRef = (0,use_merge_refs/* default */.A)([inputRef, forwardedRef]);
  const isStepAny = step === 'any';
  const baseStep = isStepAny ? 1 : (0,values/* ensureNumber */.GB)(step);
  const baseSpin = (0,values/* ensureNumber */.GB)(spinFactor) * baseStep;
  const baseValue = (0,math/* roundClamp */.ir)(0, min, max, baseStep);
  const constrainValue = (value, stepOverride) => {
    // When step is "any" clamp the value, otherwise round and clamp it.
    // Use '' + to convert to string for use in input value attribute.
    return isStepAny ? '' + Math.min(max, Math.max(min, (0,values/* ensureNumber */.GB)(value))) : '' + (0,math/* roundClamp */.ir)(value, min, max, stepOverride !== null && stepOverride !== void 0 ? stepOverride : baseStep);
  };
  const autoComplete = typeProp === 'number' ? 'off' : undefined;
  const classes = (0,clsx/* default */.A)('components-number-control', className);
  const cx = (0,use_cx/* useCx */.l)();
  const spinButtonClasses = cx(size === 'small' && styles.smallSpinButtons);
  const spinValue = (value, direction, event) => {
    event?.preventDefault();
    const shift = event?.shiftKey && isShiftStepEnabled;
    const delta = shift ? (0,values/* ensureNumber */.GB)(shiftStep) * baseSpin : baseSpin;
    let nextValue = (0,values/* isValueEmpty */.r6)(value) ? baseValue : value;
    if (direction === 'up') {
      nextValue = (0,math/* add */.WQ)(nextValue, delta);
    } else if (direction === 'down') {
      nextValue = (0,math/* subtract */.Re)(nextValue, delta);
    }
    return constrainValue(nextValue, shift ? delta : undefined);
  };

  /**
   * "Middleware" function that intercepts updates from InputControl.
   * This allows us to tap into actions to transform the (next) state for
   * InputControl.
   *
   * @return The updated state to apply to InputControl
   */
  const numberControlStateReducer = (state, action) => {
    const nextState = {
      ...state
    };
    const {
      type,
      payload
    } = action;
    const event = payload.event;
    const currentValue = nextState.value;

    /**
     * Handles custom UP and DOWN Keyboard events
     */
    if (type === actions/* PRESS_UP */.wX || type === actions/* PRESS_DOWN */.r7) {
      nextState.value = spinValue(currentValue, type === actions/* PRESS_UP */.wX ? 'up' : 'down', event);
    }

    /**
     * Handles drag to update events
     */
    if (type === actions/* DRAG */.j && isDragEnabled) {
      const [x, y] = payload.delta;
      const enableShift = payload.shiftKey && isShiftStepEnabled;
      const modifier = enableShift ? (0,values/* ensureNumber */.GB)(shiftStep) * baseSpin : baseSpin;
      let directionModifier;
      let delta;
      switch (dragDirection) {
        case 'n':
          delta = y;
          directionModifier = -1;
          break;
        case 'e':
          delta = x;
          directionModifier = (0,build_module/* isRTL */.V8)() ? -1 : 1;
          break;
        case 's':
          delta = y;
          directionModifier = 1;
          break;
        case 'w':
          delta = x;
          directionModifier = (0,build_module/* isRTL */.V8)() ? 1 : -1;
          break;
      }
      if (delta !== 0) {
        delta = Math.ceil(Math.abs(delta)) * Math.sign(delta);
        const distance = delta * modifier * directionModifier;
        nextState.value = constrainValue(
        // @ts-expect-error TODO: Investigate if it's ok for currentValue to be undefined
        (0,math/* add */.WQ)(currentValue, distance), enableShift ? modifier : undefined);
      }
    }

    /**
     * Handles commit (ENTER key press or blur)
     */
    if (type === actions/* PRESS_ENTER */.bR || type === actions/* COMMIT */.cJ) {
      const applyEmptyValue = required === false && currentValue === '';
      nextState.value = applyEmptyValue ? currentValue :
      // @ts-expect-error TODO: Investigate if it's ok for currentValue to be undefined
      constrainValue(currentValue);
    }
    return nextState;
  };
  const buildSpinButtonClickHandler = direction => event => onChange(String(spinValue(valueProp, direction, event)), {
    // Set event.target to the <input> so that consumers can use
    // e.g. event.target.validity.
    event: {
      ...event,
      target: inputRef.current
    }
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Input, {
    autoComplete: autoComplete,
    inputMode: "numeric",
    ...restProps,
    className: classes,
    dragDirection: dragDirection,
    hideHTMLArrows: spinControls !== 'native',
    isDragEnabled: isDragEnabled,
    label: label,
    max: max,
    min: min,
    ref: mergedRef,
    required: required,
    step: step,
    type: typeProp
    // @ts-expect-error TODO: Resolve discrepancy between `value` types in InputControl based components
    ,
    value: valueProp,
    __unstableStateReducer: (state, action) => {
      var _stateReducerProp;
      const baseState = numberControlStateReducer(state, action);
      return (_stateReducerProp = stateReducerProp?.(baseState, action)) !== null && _stateReducerProp !== void 0 ? _stateReducerProp : baseState;
    },
    size: size,
    suffix: spinControls === 'custom' ? /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [suffix, /*#__PURE__*/(0,jsx_runtime.jsx)(spacer_component/* default */.A, {
        marginBottom: 0,
        marginRight: 2,
        children: /*#__PURE__*/(0,jsx_runtime.jsxs)(component/* default */.A, {
          spacing: 1,
          children: [/*#__PURE__*/(0,jsx_runtime.jsx)(SpinButton, {
            className: spinButtonClasses,
            icon: plus/* default */.A,
            size: "small",
            label: (0,build_module.__)('Increment'),
            onClick: buildSpinButtonClickHandler('up')
          }), /*#__PURE__*/(0,jsx_runtime.jsx)(SpinButton, {
            className: spinButtonClasses,
            icon: library_reset/* default */.A,
            size: "small",
            label: (0,build_module.__)('Decrement'),
            onClick: buildSpinButtonClickHandler('down')
          })]
        })
      })]
    }) : suffix,
    onChange: onChange
  });
}
const NumberControl = (0,react.forwardRef)(UnforwardedNumberControl);
/* harmony default export */ const number_control = (NumberControl);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/spinner/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ spinner)
});

// UNUSED EXPORTS: Spinner, UnforwardedSpinner

// EXTERNAL MODULE: ../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1__@types+react@18.3.16_react@18.3.1/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js + 1 modules
var emotion_styled_base_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1__@types+react@18.3.16_react@18.3.1/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1/node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var emotion_react_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1/node_modules/@emotion/react/dist/emotion-react.browser.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/config-values.js
var config_values = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/config-values.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/colors-values.js
var colors_values = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/colors-values.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/spinner/styles.js

function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }
/**
 * External dependencies
 */



/**
 * Internal dependencies
 */

const spinAnimation = (0,emotion_react_browser_esm/* keyframes */.i7)`
	from {
		transform: rotate(0deg);
	}
	to {
		transform: rotate(360deg);
	}
 `;
const StyledSpinner = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("svg",  true ? {
  target: "ea4tfvq2"
} : 0)("width:", config_values/* default */.A.spinnerSize, "px;height:", config_values/* default */.A.spinnerSize, "px;display:inline-block;margin:5px 11px 0;position:relative;color:", colors_values/* COLORS */.l.theme.accent, ";overflow:visible;opacity:1;background-color:transparent;" + ( true ? "" : 0));
const commonPathProps =  true ? {
  name: "9s4963",
  styles: "fill:transparent;stroke-width:1.5px"
} : 0;
const SpinnerTrack = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("circle",  true ? {
  target: "ea4tfvq1"
} : 0)(commonPathProps, ";stroke:", colors_values/* COLORS */.l.gray[300], ";" + ( true ? "" : 0));
const SpinnerIndicator = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)("path",  true ? {
  target: "ea4tfvq0"
} : 0)(commonPathProps, ";stroke:currentColor;stroke-linecap:round;transform-origin:50% 50%;animation:1.4s linear infinite both ", spinAnimation, ";" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/spinner/index.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

/**
 * WordPress dependencies
 */



function UnforwardedSpinner({
  className,
  ...props
}, forwardedRef) {
  return /*#__PURE__*/(0,jsx_runtime.jsxs)(StyledSpinner, {
    className: (0,clsx/* default */.A)('components-spinner', className),
    viewBox: "0 0 100 100",
    width: "16",
    height: "16",
    xmlns: "http://www.w3.org/2000/svg",
    role: "presentation",
    focusable: "false",
    ...props,
    ref: forwardedRef,
    children: [/*#__PURE__*/(0,jsx_runtime.jsx)(SpinnerTrack, {
      cx: "50",
      cy: "50",
      r: "50",
      vectorEffect: "non-scaling-stroke"
    }), /*#__PURE__*/(0,jsx_runtime.jsx)(SpinnerIndicator, {
      d: "m 50 0 a 50 50 0 0 1 50 50",
      vectorEffect: "non-scaling-stroke"
    })]
  });
}
/**
 * `Spinner` is a component used to notify users that their action is being processed.
 *
 * ```js
 *   import { Spinner } from '@wordpress/components';
 *
 *   function Example() {
 *     return <Spinner />;
 *   }
 * ```
 */
const Spinner = (0,react.forwardRef)(UnforwardedSpinner);
/* harmony default export */ const spinner = (Spinner);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/text-control/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export TextControl */
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs");
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _base_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/base-control/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function UnforwardedTextControl(props, ref) {
  const {
    __nextHasNoMarginBottom,
    __next40pxDefaultSize = false,
    label,
    hideLabelFromVision,
    value,
    help,
    id: idProp,
    className,
    onChange,
    type = 'text',
    ...additionalProps
  } = props;
  const id = (0,_wordpress_compose__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(TextControl, 'inspector-text-control', idProp);
  const onChangeValue = event => onChange(event.target.value);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_base_control__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    label: label,
    hideLabelFromVision: hideLabelFromVision,
    id: id,
    help: help,
    className: className,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", {
      className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)('components-text-control__input', {
        'is-next-40px-default-size': __next40pxDefaultSize
      }),
      type: type,
      id: id,
      value: value,
      onChange: onChangeValue,
      "aria-describedby": !!help ? id + '__help' : undefined,
      ref: ref,
      ...additionalProps
    })
  });
}

/**
 * TextControl components let users enter and edit text.
 *
 * ```jsx
 * import { TextControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyTextControl = () => {
 *   const [ className, setClassName ] = useState( '' );
 *
 *   return (
 *     <TextControl
 *       label="Additional CSS Class"
 *       value={ className }
 *       onChange={ ( value ) => setClassName( value ) }
 *     />
 *   );
 * };
 * ```
 */
const TextControl = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_4__.forwardRef)(UnforwardedTextControl);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextControl);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/toggle-control/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export ToggleControl */
/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@18.3.16_react@18.3.1/node_modules/@emotion/react/dist/emotion-react.browser.esm.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js");
/* harmony import */ var _flex__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/flex/flex-block/component.js");
/* harmony import */ var _form_toggle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/form-toggle/index.js");
/* harmony import */ var _base_control__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/base-control/index.js");
/* harmony import */ var _h_stack__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/h-stack/component.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/hooks/use-cx.js");
/* harmony import */ var _utils_space__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/space.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







/**
 * ToggleControl is used to generate a toggle user interface.
 *
 * ```jsx
 * import { ToggleControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyToggleControl = () => {
 *   const [ value, setValue ] = useState( false );
 *
 *   return (
 *     <ToggleControl
 *       label="Fixed Background"
 *       checked={ value }
 *       onChange={ () => setValue( ( state ) => ! state ) }
 *     />
 *   );
 * };
 * ```
 */


function ToggleControl({
  __nextHasNoMarginBottom,
  label,
  checked,
  help,
  className,
  onChange,
  disabled
}, ref) {
  function onChangeToggle(event) {
    onChange(event.target.checked);
  }
  const instanceId = (0,_wordpress_compose__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(ToggleControl);
  const id = `inspector-toggle-control-${instanceId}`;
  const cx = (0,_utils__WEBPACK_IMPORTED_MODULE_2__/* .useCx */ .l)();
  const classes = cx('components-toggle-control', className, !__nextHasNoMarginBottom && /*#__PURE__*/(0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__/* .css */ .AH)({
    marginBottom: (0,_utils_space__WEBPACK_IMPORTED_MODULE_4__/* .space */ .x)(3)
  },  true ? "" : 0,  true ? "" : 0));
  let describedBy, helpLabel;
  if (help) {
    if (typeof help === 'function') {
      // `help` as a function works only for controlled components where
      // `checked` is passed down from parent component. Uncontrolled
      // component can show only a static help label.
      if (checked !== undefined) {
        helpLabel = help(checked);
      }
    } else {
      helpLabel = help;
    }
    if (helpLabel) {
      describedBy = id + '__help';
    }
  }
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_base_control__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Ay, {
    id: id,
    help: helpLabel,
    className: classes,
    __nextHasNoMarginBottom: true,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_h_stack__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, {
      justify: "flex-start",
      spacing: 3,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_form_toggle__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Ay, {
        id: id,
        checked: checked,
        onChange: onChangeToggle,
        "aria-describedby": describedBy,
        disabled: disabled,
        ref: ref
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_flex__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A, {
        as: "label",
        htmlFor: id,
        className: "components-toggle-control__label",
        children: label
      })]
    })
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_wordpress_element__WEBPACK_IMPORTED_MODULE_9__.forwardRef)(ToggleControl));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/math.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Re: () => (/* binding */ subtract),
/* harmony export */   WQ: () => (/* binding */ add),
/* harmony export */   ir: () => (/* binding */ roundClamp),
/* harmony export */   qE: () => (/* binding */ clamp)
/* harmony export */ });
/* unused harmony export getNumber */
/**
 * Parses and retrieves a number value.
 *
 * @param {unknown} value The incoming value.
 *
 * @return {number} The parsed number value.
 */
function getNumber(value) {
  const number = Number(value);
  return isNaN(number) ? 0 : number;
}

/**
 * Safely adds 2 values.
 *
 * @param {Array<number|string>} args Values to add together.
 *
 * @return {number} The sum of values.
 */
function add(...args) {
  return args.reduce( /** @type {(sum:number, arg: number|string) => number} */
  (sum, arg) => sum + getNumber(arg), 0);
}

/**
 * Safely subtracts 2 values.
 *
 * @param {Array<number|string>} args Values to subtract together.
 *
 * @return {number} The difference of the values.
 */
function subtract(...args) {
  return args.reduce( /** @type {(diff:number, arg: number|string, index:number) => number} */
  (diff, arg, index) => {
    const value = getNumber(arg);
    return index === 0 ? value : diff - value;
  }, 0);
}

/**
 * Determines the decimal position of a number value.
 *
 * @param {number} value The number to evaluate.
 *
 * @return {number} The number of decimal places.
 */
function getPrecision(value) {
  const split = (value + '').split('.');
  return split[1] !== undefined ? split[1].length : 0;
}

/**
 * Clamps a value based on a min/max range.
 *
 * @param {number} value The value.
 * @param {number} min   The minimum range.
 * @param {number} max   The maximum range.
 *
 * @return {number} The clamped value.
 */
function clamp(value, min, max) {
  const baseValue = getNumber(value);
  return Math.max(min, Math.min(baseValue, max));
}

/**
 * Clamps a value based on a min/max range with rounding
 *
 * @param {number | string} value The value.
 * @param {number}          min   The minimum range.
 * @param {number}          max   The maximum range.
 * @param {number}          step  A multiplier for the value.
 *
 * @return {number} The rounded and clamped value.
 */
function roundClamp(value = 0, min = Infinity, max = Infinity, step = 1) {
  const baseValue = getNumber(value);
  const stepValue = getNumber(step);
  const precision = getPrecision(step);
  const rounded = Math.round(baseValue / stepValue) * stepValue;
  const clampedValue = clamp(rounded, min, max);
  return precision ? getNumber(clampedValue.toFixed(precision)) : clampedValue;
}
//# sourceMappingURL=math.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/utils/strings.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Aq: () => (/* binding */ normalizeTextString),
/* harmony export */   Nt: () => (/* binding */ escapeRegExp),
/* harmony export */   kW: () => (/* binding */ kebabCase)
/* harmony export */ });
/* harmony import */ var remove_accents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/remove-accents@0.5.0/node_modules/remove-accents/index.js");
/* harmony import */ var remove_accents__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(remove_accents__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var change_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/param-case@3.0.4/node_modules/param-case/dist.es2015/index.js");
/**
 * External dependencies
 */



/**
 * All unicode characters that we consider "dash-like":
 * - `\u007e`: ~ (tilde)
 * - `\u00ad`: ­ (soft hyphen)
 * - `\u2053`: ⁓ (swung dash)
 * - `\u207b`: ⁻ (superscript minus)
 * - `\u208b`: ₋ (subscript minus)
 * - `\u2212`: − (minus sign)
 * - `\\p{Pd}`: any other Unicode dash character
 */
const ALL_UNICODE_DASH_CHARACTERS = new RegExp(/[\u007e\u00ad\u2053\u207b\u208b\u2212\p{Pd}]/gu);
const normalizeTextString = value => {
  return remove_accents__WEBPACK_IMPORTED_MODULE_0___default()(value).toLocaleLowerCase().replace(ALL_UNICODE_DASH_CHARACTERS, '-');
};

/**
 * Converts any string to kebab case.
 * Backwards compatible with Lodash's `_.kebabCase()`.
 * Backwards compatible with `_wp_to_kebab_case()`.
 *
 * @see https://lodash.com/docs/4.17.15#kebabCase
 * @see https://developer.wordpress.org/reference/functions/_wp_to_kebab_case/
 *
 * @param str String to convert.
 * @return Kebab-cased string
 */
function kebabCase(str) {
  var _str$toString;
  let input = (_str$toString = str?.toString?.()) !== null && _str$toString !== void 0 ? _str$toString : '';

  // See https://github.com/lodash/lodash/blob/b185fcee26b2133bd071f4aaca14b455c2ed1008/lodash.js#L4970
  input = input.replace(/['\u2019]/, '');
  return (0,change_case__WEBPACK_IMPORTED_MODULE_1__/* .paramCase */ .c)(input, {
    splitRegexp: [/(?!(?:1ST|2ND|3RD|[4-9]TH)(?![a-z]))([a-z0-9])([A-Z])/g,
    // fooBar => foo-bar, 3Bar => 3-bar
    /(?!(?:1st|2nd|3rd|[4-9]th)(?![a-z]))([0-9])([a-z])/g,
    // 3bar => 3-bar
    /([A-Za-z])([0-9])/g,
    // Foo3 => foo-3, foo3 => foo-3
    /([A-Z])([A-Z][a-z])/g // FOOBar => foo-bar
    ]
  });
}

/**
 * Escapes the RegExp special characters.
 *
 * @param string Input string.
 *
 * @return Regex-escaped string.
 */
function escapeRegExp(string) {
  return string.replace(/[\\^$.*+?()[\]{}|]/g, '\\$&');
}
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/v-stack/component.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ v_stack_component)
});

// UNUSED EXPORTS: VStack

// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-connect.js
var context_connect = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/context-connect.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/view/component.js
var component = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/view/component.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/use-context-system.js + 1 modules
var use_context_system = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/context/use-context-system.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/h-stack/hook.js + 1 modules
var hook = __webpack_require__("../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/h-stack/hook.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/v-stack/hook.js
/**
 * Internal dependencies
 */



function useVStack(props) {
  const {
    expanded = false,
    alignment = 'stretch',
    ...otherProps
  } = (0,use_context_system/* useContextSystem */.A)(props, 'VStack');
  const hStackProps = (0,hook/* useHStack */.A)({
    direction: 'column',
    expanded,
    alignment,
    ...otherProps
  });
  return hStackProps;
}
//# sourceMappingURL=hook.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@28.0.3_@emotion+is-prop-valid@1.2.1_@types+react@18.3.16_react-dom@18.3_mbjd55jx3gsragjgwncwdigc7u/node_modules/@wordpress/components/build-module/v-stack/component.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function UnconnectedVStack(props, forwardedRef) {
  const vStackProps = useVStack(props);
  return /*#__PURE__*/(0,jsx_runtime.jsx)(component/* default */.A, {
    ...vStackProps,
    ref: forwardedRef
  });
}

/**
 * `VStack` (or Vertical Stack) is a layout component that arranges child
 * elements in a vertical line.
 *
 * `VStack` can render anything inside.
 *
 * ```jsx
 * import {
 * 	__experimentalText as Text,
 * 	__experimentalVStack as VStack,
 * } from `@wordpress/components`;
 *
 * function Example() {
 * 	return (
 * 		<VStack>
 * 			<Text>Code</Text>
 * 			<Text>is</Text>
 * 			<Text>Poetry</Text>
 * 		</VStack>
 * 	);
 * }
 * ```
 */
const VStack = (0,context_connect/* contextConnect */.KZ)(UnconnectedVStack, 'VStack');
/* harmony default export */ const v_stack_component = (VStack);
//# sourceMappingURL=component.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/higher-order/pure/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_is_shallow_equal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.10.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _utils_create_higher_order_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/create-higher-order-component/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Given a component returns the enhanced component augmented with a component
 * only re-rendering when its props/state change
 *
 * @deprecated Use `memo` or `PureComponent` instead.
 */

const pure = (0,_utils_create_higher_order_component__WEBPACK_IMPORTED_MODULE_1__/* .createHigherOrderComponent */ .f)(function (WrappedComponent) {
  if (WrappedComponent.prototype instanceof _wordpress_element__WEBPACK_IMPORTED_MODULE_2__.Component) {
    return class extends WrappedComponent {
      shouldComponentUpdate(nextProps, nextState) {
        return !(0,_wordpress_is_shallow_equal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay)(nextProps, this.props) || !(0,_wordpress_is_shallow_equal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay)(nextState, this.state);
      }
    };
  }
  return class extends _wordpress_element__WEBPACK_IMPORTED_MODULE_2__.Component {
    shouldComponentUpdate(nextProps) {
      return !(0,_wordpress_is_shallow_equal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay)(nextProps, this.props);
    }
    render() {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WrappedComponent, {
        ...this.props
      });
    }
  };
}, 'pure');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pure);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-drop-zone/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ useDropZone)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _use_ref_effect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-ref-effect/index.js");
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/* eslint-disable jsdoc/valid-types */
/**
 * @template T
 * @param {T} value
 * @return {import('react').MutableRefObject<T|null>} A ref with the value.
 */
function useFreshRef(value) {
  /* eslint-enable jsdoc/valid-types */
  /* eslint-disable jsdoc/no-undefined-types */
  /** @type {import('react').MutableRefObject<T>} */
  /* eslint-enable jsdoc/no-undefined-types */
  // Disable reason: We're doing something pretty JavaScript-y here where the
  // ref will always have a current value that is not null or undefined but it
  // needs to start as undefined. We don't want to change the return type so
  // it's easier to just ts-ignore this specific line that's complaining about
  // undefined not being part of T.
  // @ts-ignore
  const ref = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  ref.current = value;
  return ref;
}

/**
 * A hook to facilitate drag and drop handling.
 *
 * @param {Object}                  props                   Named parameters.
 * @param {?HTMLElement}            [props.dropZoneElement] Optional element to be used as the drop zone.
 * @param {boolean}                 [props.isDisabled]      Whether or not to disable the drop zone.
 * @param {(e: DragEvent) => void}  [props.onDragStart]     Called when dragging has started.
 * @param {(e: DragEvent) => void}  [props.onDragEnter]     Called when the zone is entered.
 * @param {(e: DragEvent) => void}  [props.onDragOver]      Called when the zone is moved within.
 * @param {(e: DragEvent) => void}  [props.onDragLeave]     Called when the zone is left.
 * @param {(e: MouseEvent) => void} [props.onDragEnd]       Called when dragging has ended.
 * @param {(e: DragEvent) => void}  [props.onDrop]          Called when dropping in the zone.
 *
 * @return {import('react').RefCallback<HTMLElement>} Ref callback to be passed to the drop zone element.
 */
function useDropZone({
  dropZoneElement,
  isDisabled,
  onDrop: _onDrop,
  onDragStart: _onDragStart,
  onDragEnter: _onDragEnter,
  onDragLeave: _onDragLeave,
  onDragEnd: _onDragEnd,
  onDragOver: _onDragOver
}) {
  const onDropRef = useFreshRef(_onDrop);
  const onDragStartRef = useFreshRef(_onDragStart);
  const onDragEnterRef = useFreshRef(_onDragEnter);
  const onDragLeaveRef = useFreshRef(_onDragLeave);
  const onDragEndRef = useFreshRef(_onDragEnd);
  const onDragOverRef = useFreshRef(_onDragOver);
  return (0,_use_ref_effect__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(elem => {
    if (isDisabled) {
      return;
    }

    // If a custom dropZoneRef is passed, use that instead of the element.
    // This allows the dropzone to cover an expanded area, rather than
    // be restricted to the area of the ref returned by this hook.
    const element = dropZoneElement !== null && dropZoneElement !== void 0 ? dropZoneElement : elem;
    let isDragging = false;
    const {
      ownerDocument
    } = element;

    /**
     * Checks if an element is in the drop zone.
     *
     * @param {EventTarget|null} targetToCheck
     *
     * @return {boolean} True if in drop zone, false if not.
     */
    function isElementInZone(targetToCheck) {
      const {
        defaultView
      } = ownerDocument;
      if (!targetToCheck || !defaultView || !(targetToCheck instanceof defaultView.HTMLElement) || !element.contains(targetToCheck)) {
        return false;
      }

      /** @type {HTMLElement|null} */
      let elementToCheck = targetToCheck;
      do {
        if (elementToCheck.dataset.isDropZone) {
          return elementToCheck === element;
        }
      } while (elementToCheck = elementToCheck.parentElement);
      return false;
    }
    function maybeDragStart( /** @type {DragEvent} */event) {
      if (isDragging) {
        return;
      }
      isDragging = true;

      // Note that `dragend` doesn't fire consistently for file and
      // HTML drag events where the drag origin is outside the browser
      // window. In Firefox it may also not fire if the originating
      // node is removed.
      ownerDocument.addEventListener('dragend', maybeDragEnd);
      ownerDocument.addEventListener('mousemove', maybeDragEnd);
      if (onDragStartRef.current) {
        onDragStartRef.current(event);
      }
    }
    function onDragEnter( /** @type {DragEvent} */event) {
      event.preventDefault();

      // The `dragenter` event will also fire when entering child
      // elements, but we only want to call `onDragEnter` when
      // entering the drop zone, which means the `relatedTarget`
      // (element that has been left) should be outside the drop zone.
      if (element.contains( /** @type {Node} */event.relatedTarget)) {
        return;
      }
      if (onDragEnterRef.current) {
        onDragEnterRef.current(event);
      }
    }
    function onDragOver( /** @type {DragEvent} */event) {
      // Only call onDragOver for the innermost hovered drop zones.
      if (!event.defaultPrevented && onDragOverRef.current) {
        onDragOverRef.current(event);
      }

      // Prevent the browser default while also signalling to parent
      // drop zones that `onDragOver` is already handled.
      event.preventDefault();
    }
    function onDragLeave( /** @type {DragEvent} */event) {
      // The `dragleave` event will also fire when leaving child
      // elements, but we only want to call `onDragLeave` when
      // leaving the drop zone, which means the `relatedTarget`
      // (element that has been entered) should be outside the drop
      // zone.
      // Note: This is not entirely reliable in Safari due to this bug
      // https://bugs.webkit.org/show_bug.cgi?id=66547
      if (isElementInZone(event.relatedTarget)) {
        return;
      }
      if (onDragLeaveRef.current) {
        onDragLeaveRef.current(event);
      }
    }
    function onDrop( /** @type {DragEvent} */event) {
      // Don't handle drop if an inner drop zone already handled it.
      if (event.defaultPrevented) {
        return;
      }

      // Prevent the browser default while also signalling to parent
      // drop zones that `onDrop` is already handled.
      event.preventDefault();

      // This seemingly useless line has been shown to resolve a
      // Safari issue where files dragged directly from the dock are
      // not recognized.
      // eslint-disable-next-line no-unused-expressions
      event.dataTransfer && event.dataTransfer.files.length;
      if (onDropRef.current) {
        onDropRef.current(event);
      }
      maybeDragEnd(event);
    }
    function maybeDragEnd( /** @type {MouseEvent} */event) {
      if (!isDragging) {
        return;
      }
      isDragging = false;
      ownerDocument.removeEventListener('dragend', maybeDragEnd);
      ownerDocument.removeEventListener('mousemove', maybeDragEnd);
      if (onDragEndRef.current) {
        onDragEndRef.current(event);
      }
    }
    element.dataset.isDropZone = 'true';
    element.addEventListener('drop', onDrop);
    element.addEventListener('dragenter', onDragEnter);
    element.addEventListener('dragover', onDragOver);
    element.addEventListener('dragleave', onDragLeave);
    // The `dragstart` event doesn't fire if the drag started outside
    // the document.
    ownerDocument.addEventListener('dragenter', maybeDragStart);
    return () => {
      delete element.dataset.isDropZone;
      element.removeEventListener('drop', onDrop);
      element.removeEventListener('dragenter', onDragEnter);
      element.removeEventListener('dragover', onDragOver);
      element.removeEventListener('dragleave', onDragLeave);
      ownerDocument.removeEventListener('dragend', maybeDragEnd);
      ownerDocument.removeEventListener('mousemove', maybeDragEnd);
      ownerDocument.removeEventListener('dragenter', maybeDragStart);
    };
  }, [isDisabled, dropZoneElement] // Refresh when the passed in dropZoneElement changes.
  );
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/hooks/use-previous/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ usePrevious)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * WordPress dependencies
 */


/**
 * Use something's value from the previous render.
 * Based on https://usehooks.com/usePrevious/.
 *
 * @param value The value to track.
 *
 * @return The value from the previous render.
 */
function usePrevious(value) {
  const ref = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  // Store current value in ref.
  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    ref.current = value;
  }, [value]); // Re-run when value changes.

  // Return previous value (happens before update in useEffect above).
  return ref.current;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/throttle/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ throttle)
/* harmony export */ });
/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@7.0.1_react@18.3.1/node_modules/@wordpress/compose/build-module/utils/debounce/index.js");
/**
 * Parts of this source were derived and modified from lodash,
 * released under the MIT license.
 *
 * https://github.com/lodash/lodash
 *
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 *
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 * DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>
 *
 * This software consists of voluntary contributions made by many
 * individuals. For exact contribution history, see the revision history
 * available at https://github.com/lodash/lodash
 *
 * The following license applies to all parts of this software except as
 * documented below:
 *
 * ====
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Internal dependencies
 */

/**
 * A simplified and properly typed version of lodash's `throttle`, that
 * always uses timers instead of sometimes using rAF.
 *
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return
 * the result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * @param {Function}                   func             The function to throttle.
 * @param {number}                     wait             The number of milliseconds to throttle invocations to.
 * @param {Partial< ThrottleOptions >} options          The options object.
 * @param {boolean}                    options.leading  Specify invoking on the leading edge of the timeout.
 * @param {boolean}                    options.trailing Specify invoking on the trailing edge of the timeout.
 * @return Returns the new throttled function.
 */
const throttle = (func, wait, options) => {
  let leading = true;
  let trailing = true;
  if (options) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return (0,_debounce__WEBPACK_IMPORTED_MODULE_0__/* .debounce */ .s)(func, wait, {
    leading,
    trailing,
    maxWait: wait
  });
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/data-transfer.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ getFilesFromDataTransfer)
/* harmony export */ });
/**
 * Gets all files from a DataTransfer object.
 *
 * @param {DataTransfer} dataTransfer DataTransfer object to inspect.
 *
 * @return {File[]} An array containing all files.
 */
function getFilesFromDataTransfer(dataTransfer) {
  const files = Array.from(dataTransfer.files);
  Array.from(dataTransfer.items).forEach(item => {
    const file = item.getAsFile();
    if (file && !files.find(({
      name,
      type,
      size
    }) => name === file.name && type === file.type && size === file.size)) {
      files.push(file);
    }
  });
  return files;
}
//# sourceMappingURL=data-transfer.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/remove.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ remove)
/* harmony export */ });
/* harmony import */ var _utils_assert_is_defined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js");
/**
 * Internal dependencies
 */


/**
 * Given a DOM node, removes it from the DOM.
 *
 * @param {Node} node Node to be removed.
 * @return {void}
 */
function remove(node) {
  (0,_utils_assert_is_defined__WEBPACK_IMPORTED_MODULE_0__/* .assertIsDefined */ .e)(node.parentNode, 'node.parentNode');
  node.parentNode.removeChild(node);
}
//# sourceMappingURL=remove.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/safe-html.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ safeHTML)
/* harmony export */ });
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/remove.js");
/**
 * Internal dependencies
 */


/**
 * Strips scripts and on* attributes from HTML.
 *
 * @param {string} html HTML to sanitize.
 *
 * @return {string} The sanitized HTML.
 */
function safeHTML(html) {
  const {
    body
  } = document.implementation.createHTMLDocument('');
  body.innerHTML = html;
  const elements = body.getElementsByTagName('*');
  let elementIndex = elements.length;
  while (elementIndex--) {
    const element = elements[elementIndex];
    if (element.tagName === 'SCRIPT') {
      (0,_remove__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(element);
    } else {
      let attributeIndex = element.attributes.length;
      while (attributeIndex--) {
        const {
          name: key
        } = element.attributes[attributeIndex];
        if (key.startsWith('on')) {
          element.removeAttribute(key);
        }
      }
    }
  }
  return body.innerHTML;
}
//# sourceMappingURL=safe-html.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/strip-html.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ stripHTML)
/* harmony export */ });
/* harmony import */ var _safe_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@4.0.1/node_modules/@wordpress/dom/build-module/dom/safe-html.js");
/**
 * Internal dependencies
 */


/**
 * Removes any HTML tags from the provided string.
 *
 * @param {string} html The string containing html.
 *
 * @return {string} The text content with any html removed.
 */
function stripHTML(html) {
  // Remove any script tags or on* attributes otherwise their *contents* will be left
  // in place following removal of HTML tags.
  html = (0,_safe_html__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(html);
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = html;
  return doc.body.textContent || '';
}
//# sourceMappingURL=strip-html.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/create-interpolate-element.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * Internal dependencies
 */


/**
 * Object containing a React element.
 *
 * @typedef {import('react').ReactElement} Element
 */

let indoc, offset, output, stack;

/**
 * Matches tags in the localized string
 *
 * This is used for extracting the tag pattern groups for parsing the localized
 * string and along with the map converting it to a react element.
 *
 * There are four references extracted using this tokenizer:
 *
 * match: Full match of the tag (i.e. <strong>, </strong>, <br/>)
 * isClosing: The closing slash, if it exists.
 * name: The name portion of the tag (strong, br) (if )
 * isSelfClosed: The slash on a self closing tag, if it exists.
 *
 * @type {RegExp}
 */
const tokenizer = /<(\/)?(\w+)\s*(\/)?>/g;

/**
 * The stack frame tracking parse progress.
 *
 * @typedef Frame
 *
 * @property {Element}   element            A parent element which may still have
 * @property {number}    tokenStart         Offset at which parent element first
 *                                          appears.
 * @property {number}    tokenLength        Length of string marking start of parent
 *                                          element.
 * @property {number}    [prevOffset]       Running offset at which parsing should
 *                                          continue.
 * @property {number}    [leadingTextStart] Offset at which last closing element
 *                                          finished, used for finding text between
 *                                          elements.
 * @property {Element[]} children           Children.
 */

/**
 * Tracks recursive-descent parse state.
 *
 * This is a Stack frame holding parent elements until all children have been
 * parsed.
 *
 * @private
 * @param {Element} element            A parent element which may still have
 *                                     nested children not yet parsed.
 * @param {number}  tokenStart         Offset at which parent element first
 *                                     appears.
 * @param {number}  tokenLength        Length of string marking start of parent
 *                                     element.
 * @param {number}  [prevOffset]       Running offset at which parsing should
 *                                     continue.
 * @param {number}  [leadingTextStart] Offset at which last closing element
 *                                     finished, used for finding text between
 *                                     elements.
 *
 * @return {Frame} The stack frame tracking parse progress.
 */
function createFrame(element, tokenStart, tokenLength, prevOffset, leadingTextStart) {
  return {
    element,
    tokenStart,
    tokenLength,
    prevOffset,
    leadingTextStart,
    children: []
  };
}

/**
 * This function creates an interpolated element from a passed in string with
 * specific tags matching how the string should be converted to an element via
 * the conversion map value.
 *
 * @example
 * For example, for the given string:
 *
 * "This is a <span>string</span> with <a>a link</a> and a self-closing
 * <CustomComponentB/> tag"
 *
 * You would have something like this as the conversionMap value:
 *
 * ```js
 * {
 *     span: <span />,
 *     a: <a href={ 'https://github.com' } />,
 *     CustomComponentB: <CustomComponent />,
 * }
 * ```
 *
 * @param {string}                  interpolatedString The interpolation string to be parsed.
 * @param {Record<string, Element>} conversionMap      The map used to convert the string to
 *                                                     a react element.
 * @throws {TypeError}
 * @return {Element}  A wp element.
 */
const createInterpolateElement = (interpolatedString, conversionMap) => {
  indoc = interpolatedString;
  offset = 0;
  output = [];
  stack = [];
  tokenizer.lastIndex = 0;
  if (!isValidConversionMap(conversionMap)) {
    throw new TypeError('The conversionMap provided is not valid. It must be an object with values that are React Elements');
  }
  do {
    // twiddle our thumbs
  } while (proceed(conversionMap));
  return (0,_react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, ...output);
};

/**
 * Validate conversion map.
 *
 * A map is considered valid if it's an object and every value in the object
 * is a React Element
 *
 * @private
 *
 * @param {Object} conversionMap The map being validated.
 *
 * @return {boolean}  True means the map is valid.
 */
const isValidConversionMap = conversionMap => {
  const isObject = typeof conversionMap === 'object';
  const values = isObject && Object.values(conversionMap);
  return isObject && values.length && values.every(element => (0,_react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(element));
};

/**
 * This is the iterator over the matches in the string.
 *
 * @private
 *
 * @param {Object} conversionMap The conversion map for the string.
 *
 * @return {boolean} true for continuing to iterate, false for finished.
 */
function proceed(conversionMap) {
  const next = nextToken();
  const [tokenType, name, startOffset, tokenLength] = next;
  const stackDepth = stack.length;
  const leadingTextStart = startOffset > offset ? offset : null;
  if (!conversionMap[name]) {
    addText();
    return false;
  }
  switch (tokenType) {
    case 'no-more-tokens':
      if (stackDepth !== 0) {
        const {
          leadingTextStart: stackLeadingText,
          tokenStart
        } = stack.pop();
        output.push(indoc.substr(stackLeadingText, tokenStart));
      }
      addText();
      return false;
    case 'self-closed':
      if (0 === stackDepth) {
        if (null !== leadingTextStart) {
          output.push(indoc.substr(leadingTextStart, startOffset - leadingTextStart));
        }
        output.push(conversionMap[name]);
        offset = startOffset + tokenLength;
        return true;
      }

      // Otherwise we found an inner element.
      addChild(createFrame(conversionMap[name], startOffset, tokenLength));
      offset = startOffset + tokenLength;
      return true;
    case 'opener':
      stack.push(createFrame(conversionMap[name], startOffset, tokenLength, startOffset + tokenLength, leadingTextStart));
      offset = startOffset + tokenLength;
      return true;
    case 'closer':
      // If we're not nesting then this is easy - close the block.
      if (1 === stackDepth) {
        closeOuterElement(startOffset);
        offset = startOffset + tokenLength;
        return true;
      }

      // Otherwise we're nested and we have to close out the current
      // block and add it as a innerBlock to the parent.
      const stackTop = stack.pop();
      const text = indoc.substr(stackTop.prevOffset, startOffset - stackTop.prevOffset);
      stackTop.children.push(text);
      stackTop.prevOffset = startOffset + tokenLength;
      const frame = createFrame(stackTop.element, stackTop.tokenStart, stackTop.tokenLength, startOffset + tokenLength);
      frame.children = stackTop.children;
      addChild(frame);
      offset = startOffset + tokenLength;
      return true;
    default:
      addText();
      return false;
  }
}

/**
 * Grabs the next token match in the string and returns it's details.
 *
 * @private
 *
 * @return {Array}  An array of details for the token matched.
 */
function nextToken() {
  const matches = tokenizer.exec(indoc);
  // We have no more tokens.
  if (null === matches) {
    return ['no-more-tokens'];
  }
  const startedAt = matches.index;
  const [match, isClosing, name, isSelfClosed] = matches;
  const length = match.length;
  if (isSelfClosed) {
    return ['self-closed', name, startedAt, length];
  }
  if (isClosing) {
    return ['closer', name, startedAt, length];
  }
  return ['opener', name, startedAt, length];
}

/**
 * Pushes text extracted from the indoc string to the output stack given the
 * current rawLength value and offset (if rawLength is provided ) or the
 * indoc.length and offset.
 *
 * @private
 */
function addText() {
  const length = indoc.length - offset;
  if (0 === length) {
    return;
  }
  output.push(indoc.substr(offset, length));
}

/**
 * Pushes a child element to the associated parent element's children for the
 * parent currently active in the stack.
 *
 * @private
 *
 * @param {Frame} frame The Frame containing the child element and it's
 *                      token information.
 */
function addChild(frame) {
  const {
    element,
    tokenStart,
    tokenLength,
    prevOffset,
    children
  } = frame;
  const parent = stack[stack.length - 1];
  const text = indoc.substr(parent.prevOffset, tokenStart - parent.prevOffset);
  if (text) {
    parent.children.push(text);
  }
  parent.children.push((0,_react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, null, ...children));
  parent.prevOffset = prevOffset ? prevOffset : tokenStart + tokenLength;
}

/**
 * This is called for closing tags. It creates the element currently active in
 * the stack.
 *
 * @private
 *
 * @param {number} endOffset Offset at which the closing tag for the element
 *                           begins in the string. If this is greater than the
 *                           prevOffset attached to the element, then this
 *                           helps capture any remaining nested text nodes in
 *                           the element.
 */
function closeOuterElement(endOffset) {
  const {
    element,
    leadingTextStart,
    prevOffset,
    tokenStart,
    children
  } = stack.pop();
  const text = endOffset ? indoc.substr(prevOffset, endOffset - prevOffset) : indoc.substr(prevOffset);
  if (text) {
    children.push(text);
  }
  if (null !== leadingTextStart) {
    output.push(indoc.substr(leadingTextStart, tokenStart - leadingTextStart));
  }
  output.push((0,_react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, null, ...children));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createInterpolateElement);
//# sourceMappingURL=create-interpolate-element.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+element@6.0.1/node_modules/@wordpress/element/build-module/platform.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Parts of this source were derived and modified from react-native-web,
 * released under the MIT license.
 *
 * Copyright (c) 2016-present, Nicolas Gallagher.
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 */
const Platform = {
  OS: 'web',
  select: spec => 'web' in spec ? spec.web : spec.default,
  isWeb: true
};
/**
 * Component used to detect the current Platform being used.
 * Use Platform.OS === 'web' to detect if running on web enviroment.
 *
 * This is the same concept as the React Native implementation.
 *
 * @see https://reactnative.dev/docs/platform-specific-code#platform-module
 *
 * Here is an example of how to use the select method:
 * @example
 * ```js
 * import { Platform } from '@wordpress/element';
 *
 * const placeholderLabel = Platform.select( {
 *   native: __( 'Add media' ),
 *   web: __( 'Drag images, upload new ones or select files from your library.' ),
 * } );
 * ```
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Platform);
//# sourceMappingURL=platform.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/arrow-down.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const arrowDown = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "m16.5 13.5-3.7 3.7V4h-1.5v13.2l-3.8-3.7-1 1 5.5 5.6 5.5-5.6z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrowDown);
//# sourceMappingURL=arrow-down.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/arrow-right.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const arrowRight = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "m14.5 6.5-1 1 3.7 3.7H4v1.6h13.2l-3.7 3.7 1 1 5.6-5.5z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrowRight);
//# sourceMappingURL=arrow-right.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/category.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const category = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M6 5.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5H6a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5zM4 6a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2H6a2 2 0 01-2-2V6zm11-.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5h-3a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5zM13 6a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2h-3a2 2 0 01-2-2V6zm5 8.5h-3a.5.5 0 00-.5.5v3a.5.5 0 00.5.5h3a.5.5 0 00.5-.5v-3a.5.5 0 00-.5-.5zM15 13a2 2 0 00-2 2v3a2 2 0 002 2h3a2 2 0 002-2v-3a2 2 0 00-2-2h-3zm-9 1.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5H6a.5.5 0 01-.5-.5v-3a.5.5 0 01.5-.5zM4 15a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2H6a2 2 0 01-2-2v-3z",
    fillRule: "evenodd",
    clipRule: "evenodd"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (category);
//# sourceMappingURL=category.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/check.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const check = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M16.7 7.1l-6.3 8.5-3.3-2.5-.9 1.2 4.5 3.4L17.9 8z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (check);
//# sourceMappingURL=check.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-right-small.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const chevronRightSmall = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M10.8622 8.04053L14.2805 12.0286L10.8622 16.0167L9.72327 15.0405L12.3049 12.0286L9.72327 9.01672L10.8622 8.04053Z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (chevronRightSmall);
//# sourceMappingURL=chevron-right-small.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-right.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const chevronRight = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M10.6 6L9.4 7l4.6 5-4.6 5 1.2 1 5.4-6z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (chevronRight);
//# sourceMappingURL=chevron-right.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/chevron-up.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const chevronUp = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M6.5 12.4L12 8l5.5 4.4-.9 1.2L12 10l-4.5 3.6-1-1.2z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (chevronUp);
//# sourceMappingURL=chevron-up.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/close-small.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const closeSmall = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M12 13.06l3.712 3.713 1.061-1.06L13.061 12l3.712-3.712-1.06-1.06L12 10.938 8.288 7.227l-1.061 1.06L10.939 12l-3.712 3.712 1.06 1.061L12 13.061z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (closeSmall);
//# sourceMappingURL=close-small.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/more-vertical.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const moreVertical = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M13 19h-2v-2h2v2zm0-6h-2v-2h2v2zm0-6h-2V5h2v2z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (moreVertical);
//# sourceMappingURL=more-vertical.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/plus.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const plus = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M11 12.5V17.5H12.5V12.5H17.5V11H12.5V6H11V11H6V12.5H11Z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plus);
//# sourceMappingURL=plus.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/search.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const search = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M13 5c-3.3 0-6 2.7-6 6 0 1.4.5 2.7 1.3 3.7l-3.8 3.8 1.1 1.1 3.8-3.8c1 .8 2.3 1.3 3.7 1.3 3.3 0 6-2.7 6-6S16.3 5 13 5zm0 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (search);
//# sourceMappingURL=search.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@10.11.0/node_modules/@wordpress/icons/build-module/library/upload.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.4.1/node_modules/@wordpress/primitives/build-module/svg/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
/**
 * WordPress dependencies
 */


const upload = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
    d: "M18.5 15v3.5H13V6.7l4.5 4.1 1-1.1-6.2-5.8-5.8 5.8 1 1.1 4-4v11.7h-6V15H4v5h16v-5z"
  })
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (upload);
//# sourceMappingURL=upload.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ee: () => (/* reexport */ ShortcutProvider),
  ZK: () => (/* reexport */ useShortcutEventMatch),
  M_: () => (/* reexport */ store),
  wk: () => (/* reexport */ useShortcut)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/store/actions.js
var actions_namespaceObject = {};
__webpack_require__.r(actions_namespaceObject);
__webpack_require__.d(actions_namespaceObject, {
  registerShortcut: () => (registerShortcut),
  unregisterShortcut: () => (unregisterShortcut)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/store/selectors.js
var selectors_namespaceObject = {};
__webpack_require__.r(selectors_namespaceObject);
__webpack_require__.d(selectors_namespaceObject, {
  getAllShortcutKeyCombinations: () => (getAllShortcutKeyCombinations),
  getAllShortcutRawKeyCombinations: () => (getAllShortcutRawKeyCombinations),
  getCategoryShortcuts: () => (getCategoryShortcuts),
  getShortcutAliases: () => (getShortcutAliases),
  getShortcutDescription: () => (getShortcutDescription),
  getShortcutKeyCombination: () => (getShortcutKeyCombination),
  getShortcutRepresentation: () => (getShortcutRepresentation)
});

// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/redux-store/index.js + 18 modules
var redux_store = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/redux-store/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/index.js
var build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/store/reducer.js
/**
 * Reducer returning the registered shortcuts
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function reducer(state = {}, action) {
  switch (action.type) {
    case 'REGISTER_SHORTCUT':
      return {
        ...state,
        [action.name]: {
          category: action.category,
          keyCombination: action.keyCombination,
          aliases: action.aliases,
          description: action.description
        }
      };
    case 'UNREGISTER_SHORTCUT':
      const {
        [action.name]: actionName,
        ...remainingState
      } = state;
      return remainingState;
  }
  return state;
}
/* harmony default export */ const store_reducer = (reducer);
//# sourceMappingURL=reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/store/actions.js
/** @typedef {import('@wordpress/keycodes').WPKeycodeModifier} WPKeycodeModifier */

/**
 * Keyboard key combination.
 *
 * @typedef {Object} WPShortcutKeyCombination
 *
 * @property {string}                      character Character.
 * @property {WPKeycodeModifier|undefined} modifier  Modifier.
 */

/**
 * Configuration of a registered keyboard shortcut.
 *
 * @typedef {Object} WPShortcutConfig
 *
 * @property {string}                     name           Shortcut name.
 * @property {string}                     category       Shortcut category.
 * @property {string}                     description    Shortcut description.
 * @property {WPShortcutKeyCombination}   keyCombination Shortcut key combination.
 * @property {WPShortcutKeyCombination[]} [aliases]      Shortcut aliases.
 */

/**
 * Returns an action object used to register a new keyboard shortcut.
 *
 * @param {WPShortcutConfig} config Shortcut config.
 *
 * @example
 *
 *```js
 * import { useEffect } from 'react';
 * import { store as keyboardShortcutsStore } from '@wordpress/keyboard-shortcuts';
 * import { useSelect, useDispatch } from '@wordpress/data';
 * import { __ } from '@wordpress/i18n';
 *
 * const ExampleComponent = () => {
 *     const { registerShortcut } = useDispatch( keyboardShortcutsStore );
 *
 *     useEffect( () => {
 *         registerShortcut( {
 *             name: 'custom/my-custom-shortcut',
 *             category: 'my-category',
 *             description: __( 'My custom shortcut' ),
 *             keyCombination: {
 *                 modifier: 'primary',
 *                 character: 'j',
 *             },
 *         } );
 *     }, [] );
 *
 *     const shortcut = useSelect(
 *         ( select ) =>
 *             select( keyboardShortcutsStore ).getShortcutKeyCombination(
 *                 'custom/my-custom-shortcut'
 *             ),
 *         []
 *     );
 *
 *     return shortcut ? (
 *         <p>{ __( 'Shortcut is registered.' ) }</p>
 *     ) : (
 *         <p>{ __( 'Shortcut is not registered.' ) }</p>
 *     );
 * };
 *```
 * @return {Object} action.
 */
function registerShortcut({
  name,
  category,
  description,
  keyCombination,
  aliases
}) {
  return {
    type: 'REGISTER_SHORTCUT',
    name,
    category,
    keyCombination,
    aliases,
    description
  };
}

/**
 * Returns an action object used to unregister a keyboard shortcut.
 *
 * @param {string} name Shortcut name.
 *
 * @example
 *
 *```js
 * import { useEffect } from 'react';
 * import { store as keyboardShortcutsStore } from '@wordpress/keyboard-shortcuts';
 * import { useSelect, useDispatch } from '@wordpress/data';
 * import { __ } from '@wordpress/i18n';
 *
 * const ExampleComponent = () => {
 *     const { unregisterShortcut } = useDispatch( keyboardShortcutsStore );
 *
 *     useEffect( () => {
 *         unregisterShortcut( 'core/editor/next-region' );
 *     }, [] );
 *
 *     const shortcut = useSelect(
 *         ( select ) =>
 *             select( keyboardShortcutsStore ).getShortcutKeyCombination(
 *                 'core/editor/next-region'
 *             ),
 *         []
 *     );
 *
 *     return shortcut ? (
 *         <p>{ __( 'Shortcut is not unregistered.' ) }</p>
 *     ) : (
 *         <p>{ __( 'Shortcut is unregistered.' ) }</p>
 *     );
 * };
 *```
 * @return {Object} action.
 */
function unregisterShortcut(name) {
  return {
    type: 'UNREGISTER_SHORTCUT',
    name
  };
}
//# sourceMappingURL=actions.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js
var rememo = __webpack_require__("../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+keycodes@4.0.1/node_modules/@wordpress/keycodes/build-module/index.js
var keycodes_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+keycodes@4.0.1/node_modules/@wordpress/keycodes/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/store/selectors.js
/**
 * WordPress dependencies
 */



/** @typedef {import('./actions').WPShortcutKeyCombination} WPShortcutKeyCombination */

/** @typedef {import('@wordpress/keycodes').WPKeycodeHandlerByModifier} WPKeycodeHandlerByModifier */

/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation.
 *
 * @type {Array<any>}
 */
const EMPTY_ARRAY = [];

/**
 * Shortcut formatting methods.
 *
 * @property {WPKeycodeHandlerByModifier} display     Display formatting.
 * @property {WPKeycodeHandlerByModifier} rawShortcut Raw shortcut formatting.
 * @property {WPKeycodeHandlerByModifier} ariaLabel   ARIA label formatting.
 */
const FORMATTING_METHODS = {
  display: keycodes_build_module/* displayShortcut */.dz,
  raw: keycodes_build_module/* rawShortcut */.JF,
  ariaLabel: keycodes_build_module/* shortcutAriaLabel */._A
};

/**
 * Returns a string representing the key combination.
 *
 * @param {?WPShortcutKeyCombination} shortcut       Key combination.
 * @param {keyof FORMATTING_METHODS}  representation Type of representation
 *                                                   (display, raw, ariaLabel).
 *
 * @return {string?} Shortcut representation.
 */
function getKeyCombinationRepresentation(shortcut, representation) {
  if (!shortcut) {
    return null;
  }
  return shortcut.modifier ? FORMATTING_METHODS[representation][shortcut.modifier](shortcut.character) : shortcut.character;
}

/**
 * Returns the main key combination for a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @example
 *
 *```js
 * import { store as keyboardShortcutsStore } from '@wordpress/keyboard-shortcuts';
 * import { useSelect } from '@wordpress/data';
 * import { createInterpolateElement } from '@wordpress/element';
 * import { sprintf } from '@wordpress/i18n';
 * const ExampleComponent = () => {
 *     const {character, modifier} = useSelect(
 *         ( select ) =>
 *             select( keyboardShortcutsStore ).getShortcutKeyCombination(
 *                 'core/editor/next-region'
 *             ),
 *         []
 *     );
 *
 *     return (
 *         <div>
 *             { createInterpolateElement(
 *                 sprintf(
 *                     'Character: <code>%s</code> / Modifier: <code>%s</code>',
 *                     character,
 *                     modifier
 *                 ),
 *                 {
 *                     code: <code />,
 *                 }
 *             ) }
 *         </div>
 *     );
 * };
 *```
 *
 * @return {WPShortcutKeyCombination?} Key combination.
 */
function getShortcutKeyCombination(state, name) {
  return state[name] ? state[name].keyCombination : null;
}

/**
 * Returns a string representing the main key combination for a given shortcut name.
 *
 * @param {Object}                   state          Global state.
 * @param {string}                   name           Shortcut name.
 * @param {keyof FORMATTING_METHODS} representation Type of representation
 *                                                  (display, raw, ariaLabel).
 * @example
 *
 *```js
 * import { store as keyboardShortcutsStore } from '@wordpress/keyboard-shortcuts';
 * import { useSelect } from '@wordpress/data';
 * import { sprintf } from '@wordpress/i18n';
 *
 * const ExampleComponent = () => {
 *     const {display, raw, ariaLabel} = useSelect(
 *         ( select ) =>{
 *             return {
 *                 display: select( keyboardShortcutsStore ).getShortcutRepresentation('core/editor/next-region' ),
 *                 raw: select( keyboardShortcutsStore ).getShortcutRepresentation('core/editor/next-region','raw' ),
 *                 ariaLabel: select( keyboardShortcutsStore ).getShortcutRepresentation('core/editor/next-region', 'ariaLabel')
 *             }
 *         },
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             <li>{ sprintf( 'display string: %s', display ) }</li>
 *             <li>{ sprintf( 'raw string: %s', raw ) }</li>
 *             <li>{ sprintf( 'ariaLabel string: %s', ariaLabel ) }</li>
 *         </ul>
 *     );
 * };
 *```
 *
 * @return {string?} Shortcut representation.
 */
function getShortcutRepresentation(state, name, representation = 'display') {
  const shortcut = getShortcutKeyCombination(state, name);
  return getKeyCombinationRepresentation(shortcut, representation);
}

/**
 * Returns the shortcut description given its name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @example
 *
 *```js
 * import { store as keyboardShortcutsStore } from '@wordpress/keyboard-shortcuts';
 * import { useSelect } from '@wordpress/data';
 * import { __ } from '@wordpress/i18n';
 * const ExampleComponent = () => {
 *     const shortcutDescription = useSelect(
 *         ( select ) =>
 *             select( keyboardShortcutsStore ).getShortcutDescription( 'core/editor/next-region' ),
 *         []
 *     );
 *
 *     return shortcutDescription ? (
 *         <div>{ shortcutDescription }</div>
 *     ) : (
 *         <div>{ __( 'No description.' ) }</div>
 *     );
 * };
 *```
 * @return {string?} Shortcut description.
 */
function getShortcutDescription(state, name) {
  return state[name] ? state[name].description : null;
}

/**
 * Returns the aliases for a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 * @example
 *
 *```js
 * import { store as keyboardShortcutsStore } from '@wordpress/keyboard-shortcuts';
 * import { useSelect } from '@wordpress/data';
 * import { createInterpolateElement } from '@wordpress/element';
 * import { sprintf } from '@wordpress/i18n';
 * const ExampleComponent = () => {
 *     const shortcutAliases = useSelect(
 *         ( select ) =>
 *             select( keyboardShortcutsStore ).getShortcutAliases(
 *                 'core/editor/next-region'
 *             ),
 *         []
 *     );
 *
 *     return (
 *         shortcutAliases.length > 0 && (
 *             <ul>
 *                 { shortcutAliases.map( ( { character, modifier }, index ) => (
 *                     <li key={ index }>
 *                         { createInterpolateElement(
 *                             sprintf(
 *                                 'Character: <code>%s</code> / Modifier: <code>%s</code>',
 *                                 character,
 *                                 modifier
 *                             ),
 *                             {
 *                                 code: <code />,
 *                             }
 *                         ) }
 *                     </li>
 *                 ) ) }
 *             </ul>
 *         )
 *     );
 * };
 *```
 *
 * @return {WPShortcutKeyCombination[]} Key combinations.
 */
function getShortcutAliases(state, name) {
  return state[name] && state[name].aliases ? state[name].aliases : EMPTY_ARRAY;
}

/**
 * Returns the shortcuts that include aliases for a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 * @example
 *
 *```js
 * import { store as keyboardShortcutsStore } from '@wordpress/keyboard-shortcuts';
 * import { useSelect } from '@wordpress/data';
 * import { createInterpolateElement } from '@wordpress/element';
 * import { sprintf } from '@wordpress/i18n';
 *
 * const ExampleComponent = () => {
 *     const allShortcutKeyCombinations = useSelect(
 *         ( select ) =>
 *             select( keyboardShortcutsStore ).getAllShortcutKeyCombinations(
 *                 'core/editor/next-region'
 *             ),
 *         []
 *     );
 *
 *     return (
 *         allShortcutKeyCombinations.length > 0 && (
 *             <ul>
 *                 { allShortcutKeyCombinations.map(
 *                     ( { character, modifier }, index ) => (
 *                         <li key={ index }>
 *                             { createInterpolateElement(
 *                                 sprintf(
 *                                     'Character: <code>%s</code> / Modifier: <code>%s</code>',
 *                                     character,
 *                                     modifier
 *                                 ),
 *                                 {
 *                                     code: <code />,
 *                                 }
 *                             ) }
 *                         </li>
 *                     )
 *                 ) }
 *             </ul>
 *         )
 *     );
 * };
 *```
 *
 * @return {WPShortcutKeyCombination[]} Key combinations.
 */
const getAllShortcutKeyCombinations = (0,rememo/* default */.A)((state, name) => {
  return [getShortcutKeyCombination(state, name), ...getShortcutAliases(state, name)].filter(Boolean);
}, (state, name) => [state[name]]);

/**
 * Returns the raw representation of all the keyboard combinations of a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @example
 *
 *```js
 * import { store as keyboardShortcutsStore } from '@wordpress/keyboard-shortcuts';
 * import { useSelect } from '@wordpress/data';
 * import { createInterpolateElement } from '@wordpress/element';
 * import { sprintf } from '@wordpress/i18n';
 *
 * const ExampleComponent = () => {
 *     const allShortcutRawKeyCombinations = useSelect(
 *         ( select ) =>
 *             select( keyboardShortcutsStore ).getAllShortcutRawKeyCombinations(
 *                 'core/editor/next-region'
 *             ),
 *         []
 *     );
 *
 *     return (
 *         allShortcutRawKeyCombinations.length > 0 && (
 *             <ul>
 *                 { allShortcutRawKeyCombinations.map(
 *                     ( shortcutRawKeyCombination, index ) => (
 *                         <li key={ index }>
 *                             { createInterpolateElement(
 *                                 sprintf(
 *                                     ' <code>%s</code>',
 *                                     shortcutRawKeyCombination
 *                                 ),
 *                                 {
 *                                     code: <code />,
 *                                 }
 *                             ) }
 *                         </li>
 *                     )
 *                 ) }
 *             </ul>
 *         )
 *     );
 * };
 *```
 *
 * @return {string[]} Shortcuts.
 */
const getAllShortcutRawKeyCombinations = (0,rememo/* default */.A)((state, name) => {
  return getAllShortcutKeyCombinations(state, name).map(combination => getKeyCombinationRepresentation(combination, 'raw'));
}, (state, name) => [state[name]]);

/**
 * Returns the shortcut names list for a given category name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Category name.
 * @example
 *
 *```js
 * import { store as keyboardShortcutsStore } from '@wordpress/keyboard-shortcuts';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const categoryShortcuts = useSelect(
 *         ( select ) =>
 *             select( keyboardShortcutsStore ).getCategoryShortcuts(
 *                 'block'
 *             ),
 *         []
 *     );
 *
 *     return (
 *         categoryShortcuts.length > 0 && (
 *             <ul>
 *                 { categoryShortcuts.map( ( categoryShortcut ) => (
 *                     <li key={ categoryShortcut }>{ categoryShortcut }</li>
 *                 ) ) }
 *             </ul>
 *         )
 *     );
 * };
 *```
 * @return {string[]} Shortcut names.
 */
const getCategoryShortcuts = (0,rememo/* default */.A)((state, categoryName) => {
  return Object.entries(state).filter(([, shortcut]) => shortcut.category === categoryName).map(([name]) => name);
}, state => [state]);
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/store/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const STORE_NAME = 'core/keyboard-shortcuts';

/**
 * Store definition for the keyboard shortcuts namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */
const store = (0,redux_store/* default */.A)(STORE_NAME, {
  reducer: store_reducer,
  actions: actions_namespaceObject,
  selectors: selectors_namespaceObject
});
(0,build_module/* register */.kz)(store);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/use-select/index.js + 1 modules
var use_select = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.0.2_react@18.3.1/node_modules/@wordpress/data/build-module/components/use-select/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/hooks/use-shortcut-event-match.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Returns a function to check if a keyboard event matches a shortcut name.
 *
 * @return {Function} A function to check if a keyboard event matches a
 *                    predefined shortcut combination.
 */
function useShortcutEventMatch() {
  const {
    getAllShortcutKeyCombinations
  } = (0,use_select/* default */.A)(store);

  /**
   * A function to check if a keyboard event matches a predefined shortcut
   * combination.
   *
   * @param {string}        name  Shortcut name.
   * @param {KeyboardEvent} event Event to check.
   *
   * @return {boolean} True if the event matches any shortcuts, false if not.
   */
  function isMatch(name, event) {
    return getAllShortcutKeyCombinations(name).some(({
      modifier,
      character
    }) => {
      return keycodes_build_module/* isKeyboardEvent */.kx[modifier](event, character);
    });
  }
  return isMatch;
}
//# sourceMappingURL=use-shortcut-event-match.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/context.js
/**
 * WordPress dependencies
 */

const globalShortcuts = new Set();
const globalListener = event => {
  for (const keyboardShortcut of globalShortcuts) {
    keyboardShortcut(event);
  }
};
const context = (0,react.createContext)({
  add: shortcut => {
    if (globalShortcuts.size === 0) {
      document.addEventListener('keydown', globalListener);
    }
    globalShortcuts.add(shortcut);
  },
  delete: shortcut => {
    globalShortcuts.delete(shortcut);
    if (globalShortcuts.size === 0) {
      document.removeEventListener('keydown', globalListener);
    }
  }
});
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/hooks/use-shortcut.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Attach a keyboard shortcut handler.
 *
 * @param {string}   name               Shortcut name.
 * @param {Function} callback           Shortcut callback.
 * @param {Object}   options            Shortcut options.
 * @param {boolean}  options.isDisabled Whether to disable to shortut.
 */
function useShortcut(name, callback, {
  isDisabled = false
} = {}) {
  const shortcuts = (0,react.useContext)(context);
  const isMatch = useShortcutEventMatch();
  const callbackRef = (0,react.useRef)();
  (0,react.useEffect)(() => {
    callbackRef.current = callback;
  }, [callback]);
  (0,react.useEffect)(() => {
    if (isDisabled) {
      return;
    }
    function _callback(event) {
      if (isMatch(name, event)) {
        callbackRef.current(event);
      }
    }
    shortcuts.add(_callback);
    return () => {
      shortcuts.delete(_callback);
    };
  }, [name, isDisabled, shortcuts]);
}
//# sourceMappingURL=use-shortcut.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/components/shortcut-provider.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const {
  Provider
} = context;

/**
 * Handles callbacks added to context by `useShortcut`.
 * Adding a provider allows to register contextual shortcuts
 * that are only active when a certain part of the UI is focused.
 *
 * @param {Object} props Props to pass to `div`.
 *
 * @return {Element} Component.
 */
function ShortcutProvider(props) {
  const [keyboardShortcuts] = (0,react.useState)(() => new Set());
  function onKeyDown(event) {
    if (props.onKeyDown) {
      props.onKeyDown(event);
    }
    for (const keyboardShortcut of keyboardShortcuts) {
      keyboardShortcut(event);
    }
  }

  /* eslint-disable jsx-a11y/no-static-element-interactions */
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Provider, {
    value: keyboardShortcuts,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      ...props,
      onKeyDown: onKeyDown
    })
  });
  /* eslint-enable jsx-a11y/no-static-element-interactions */
}
//# sourceMappingURL=shortcut-provider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@5.0.2_react@18.3.1/node_modules/@wordpress/keyboard-shortcuts/build-module/index.js




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/autosize@4.0.4/node_modules/autosize/dist/autosize.js":
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else { var mod; }
})(this, function (module, exports) {
	'use strict';

	var map = typeof Map === "function" ? new Map() : function () {
		var keys = [];
		var values = [];

		return {
			has: function has(key) {
				return keys.indexOf(key) > -1;
			},
			get: function get(key) {
				return values[keys.indexOf(key)];
			},
			set: function set(key, value) {
				if (keys.indexOf(key) === -1) {
					keys.push(key);
					values.push(value);
				}
			},
			delete: function _delete(key) {
				var index = keys.indexOf(key);
				if (index > -1) {
					keys.splice(index, 1);
					values.splice(index, 1);
				}
			}
		};
	}();

	var createEvent = function createEvent(name) {
		return new Event(name, { bubbles: true });
	};
	try {
		new Event('test');
	} catch (e) {
		// IE does not support `new Event()`
		createEvent = function createEvent(name) {
			var evt = document.createEvent('Event');
			evt.initEvent(name, true, false);
			return evt;
		};
	}

	function assign(ta) {
		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

		var heightOffset = null;
		var clientWidth = null;
		var cachedHeight = null;

		function init() {
			var style = window.getComputedStyle(ta, null);

			if (style.resize === 'vertical') {
				ta.style.resize = 'none';
			} else if (style.resize === 'both') {
				ta.style.resize = 'horizontal';
			}

			if (style.boxSizing === 'content-box') {
				heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
			} else {
				heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
			}
			// Fix when a textarea is not on document body and heightOffset is Not a Number
			if (isNaN(heightOffset)) {
				heightOffset = 0;
			}

			update();
		}

		function changeOverflow(value) {
			{
				// Chrome/Safari-specific fix:
				// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
				// made available by removing the scrollbar. The following forces the necessary text reflow.
				var width = ta.style.width;
				ta.style.width = '0px';
				// Force reflow:
				/* jshint ignore:start */
				ta.offsetWidth;
				/* jshint ignore:end */
				ta.style.width = width;
			}

			ta.style.overflowY = value;
		}

		function getParentOverflows(el) {
			var arr = [];

			while (el && el.parentNode && el.parentNode instanceof Element) {
				if (el.parentNode.scrollTop) {
					arr.push({
						node: el.parentNode,
						scrollTop: el.parentNode.scrollTop
					});
				}
				el = el.parentNode;
			}

			return arr;
		}

		function resize() {
			if (ta.scrollHeight === 0) {
				// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
				return;
			}

			var overflows = getParentOverflows(ta);
			var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

			ta.style.height = '';
			ta.style.height = ta.scrollHeight + heightOffset + 'px';

			// used to check if an update is actually necessary on window.resize
			clientWidth = ta.clientWidth;

			// prevents scroll-position jumping
			overflows.forEach(function (el) {
				el.node.scrollTop = el.scrollTop;
			});

			if (docTop) {
				document.documentElement.scrollTop = docTop;
			}
		}

		function update() {
			resize();

			var styleHeight = Math.round(parseFloat(ta.style.height));
			var computed = window.getComputedStyle(ta, null);

			// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
			var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

			// The actual height not matching the style height (set via the resize method) indicates that 
			// the max-height has been exceeded, in which case the overflow should be allowed.
			if (actualHeight < styleHeight) {
				if (computed.overflowY === 'hidden') {
					changeOverflow('scroll');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			} else {
				// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
				if (computed.overflowY !== 'hidden') {
					changeOverflow('hidden');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			}

			if (cachedHeight !== actualHeight) {
				cachedHeight = actualHeight;
				var evt = createEvent('autosize:resized');
				try {
					ta.dispatchEvent(evt);
				} catch (err) {
					// Firefox will throw an error on dispatchEvent for a detached element
					// https://bugzilla.mozilla.org/show_bug.cgi?id=889376
				}
			}
		}

		var pageResize = function pageResize() {
			if (ta.clientWidth !== clientWidth) {
				update();
			}
		};

		var destroy = function (style) {
			window.removeEventListener('resize', pageResize, false);
			ta.removeEventListener('input', update, false);
			ta.removeEventListener('keyup', update, false);
			ta.removeEventListener('autosize:destroy', destroy, false);
			ta.removeEventListener('autosize:update', update, false);

			Object.keys(style).forEach(function (key) {
				ta.style[key] = style[key];
			});

			map.delete(ta);
		}.bind(ta, {
			height: ta.style.height,
			resize: ta.style.resize,
			overflowY: ta.style.overflowY,
			overflowX: ta.style.overflowX,
			wordWrap: ta.style.wordWrap
		});

		ta.addEventListener('autosize:destroy', destroy, false);

		// IE9 does not fire onpropertychange or oninput for deletions,
		// so binding to onkeyup to catch most of those events.
		// There is no way that I know of to detect something like 'cut' in IE9.
		if ('onpropertychange' in ta && 'oninput' in ta) {
			ta.addEventListener('keyup', update, false);
		}

		window.addEventListener('resize', pageResize, false);
		ta.addEventListener('input', update, false);
		ta.addEventListener('autosize:update', update, false);
		ta.style.overflowX = 'hidden';
		ta.style.wordWrap = 'break-word';

		map.set(ta, {
			destroy: destroy,
			update: update
		});

		init();
	}

	function destroy(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.destroy();
		}
	}

	function update(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.update();
		}
	}

	var autosize = null;

	// Do nothing in Node.js environment and IE8 (or lower)
	if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
		autosize = function autosize(el) {
			return el;
		};
		autosize.destroy = function (el) {
			return el;
		};
		autosize.update = function (el) {
			return el;
		};
	} else {
		autosize = function autosize(el, options) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], function (x) {
					return assign(x, options);
				});
			}
			return el;
		};
		autosize.destroy = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], destroy);
			}
			return el;
		};
		autosize.update = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], update);
			}
			return el;
		};
	}

	exports.default = autosize;
	module.exports = exports['default'];
});

/***/ }),

/***/ "../../node_modules/.pnpm/clipboard@2.0.11/node_modules/clipboard/dist/clipboard.js":
/***/ (function(module) {

/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 686:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_623__) {

"use strict";

// EXPORTS
__nested_webpack_require_623__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ clipboard; }
});

// EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
var tiny_emitter = __nested_webpack_require_623__(279);
var tiny_emitter_default = /*#__PURE__*/__nested_webpack_require_623__.n(tiny_emitter);
// EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js
var listen = __nested_webpack_require_623__(370);
var listen_default = /*#__PURE__*/__nested_webpack_require_623__.n(listen);
// EXTERNAL MODULE: ./node_modules/select/src/select.js
var src_select = __nested_webpack_require_623__(817);
var select_default = /*#__PURE__*/__nested_webpack_require_623__.n(src_select);
;// CONCATENATED MODULE: ./src/common/command.js
/**
 * Executes a given operation type.
 * @param {String} type
 * @return {Boolean}
 */
function command(type) {
  try {
    return document.execCommand(type);
  } catch (err) {
    return false;
  }
}
;// CONCATENATED MODULE: ./src/actions/cut.js


/**
 * Cut action wrapper.
 * @param {String|HTMLElement} target
 * @return {String}
 */

var ClipboardActionCut = function ClipboardActionCut(target) {
  var selectedText = select_default()(target);
  command('cut');
  return selectedText;
};

/* harmony default export */ var actions_cut = (ClipboardActionCut);
;// CONCATENATED MODULE: ./src/common/create-fake-element.js
/**
 * Creates a fake textarea element with a value.
 * @param {String} value
 * @return {HTMLElement}
 */
function createFakeElement(value) {
  var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
  var fakeElement = document.createElement('textarea'); // Prevent zooming on iOS

  fakeElement.style.fontSize = '12pt'; // Reset box model

  fakeElement.style.border = '0';
  fakeElement.style.padding = '0';
  fakeElement.style.margin = '0'; // Move element out of screen horizontally

  fakeElement.style.position = 'absolute';
  fakeElement.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically

  var yPosition = window.pageYOffset || document.documentElement.scrollTop;
  fakeElement.style.top = "".concat(yPosition, "px");
  fakeElement.setAttribute('readonly', '');
  fakeElement.value = value;
  return fakeElement;
}
;// CONCATENATED MODULE: ./src/actions/copy.js



/**
 * Create fake copy action wrapper using a fake element.
 * @param {String} target
 * @param {Object} options
 * @return {String}
 */

var fakeCopyAction = function fakeCopyAction(value, options) {
  var fakeElement = createFakeElement(value);
  options.container.appendChild(fakeElement);
  var selectedText = select_default()(fakeElement);
  command('copy');
  fakeElement.remove();
  return selectedText;
};
/**
 * Copy action wrapper.
 * @param {String|HTMLElement} target
 * @param {Object} options
 * @return {String}
 */


var ClipboardActionCopy = function ClipboardActionCopy(target) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    container: document.body
  };
  var selectedText = '';

  if (typeof target === 'string') {
    selectedText = fakeCopyAction(target, options);
  } else if (target instanceof HTMLInputElement && !['text', 'search', 'url', 'tel', 'password'].includes(target === null || target === void 0 ? void 0 : target.type)) {
    // If input type doesn't support `setSelectionRange`. Simulate it. https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
    selectedText = fakeCopyAction(target.value, options);
  } else {
    selectedText = select_default()(target);
    command('copy');
  }

  return selectedText;
};

/* harmony default export */ var actions_copy = (ClipboardActionCopy);
;// CONCATENATED MODULE: ./src/actions/default.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/**
 * Inner function which performs selection from either `text` or `target`
 * properties and then executes copy or cut operations.
 * @param {Object} options
 */

var ClipboardActionDefault = function ClipboardActionDefault() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // Defines base properties passed from constructor.
  var _options$action = options.action,
      action = _options$action === void 0 ? 'copy' : _options$action,
      container = options.container,
      target = options.target,
      text = options.text; // Sets the `action` to be performed which can be either 'copy' or 'cut'.

  if (action !== 'copy' && action !== 'cut') {
    throw new Error('Invalid "action" value, use either "copy" or "cut"');
  } // Sets the `target` property using an element that will be have its content copied.


  if (target !== undefined) {
    if (target && _typeof(target) === 'object' && target.nodeType === 1) {
      if (action === 'copy' && target.hasAttribute('disabled')) {
        throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
      }

      if (action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
        throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
      }
    } else {
      throw new Error('Invalid "target" value, use a valid Element');
    }
  } // Define selection strategy based on `text` property.


  if (text) {
    return actions_copy(text, {
      container: container
    });
  } // Defines which selection strategy based on `target` property.


  if (target) {
    return action === 'cut' ? actions_cut(target) : actions_copy(target, {
      container: container
    });
  }
};

/* harmony default export */ var actions_default = (ClipboardActionDefault);
;// CONCATENATED MODULE: ./src/clipboard.js
function clipboard_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { clipboard_typeof = function _typeof(obj) { return typeof obj; }; } else { clipboard_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return clipboard_typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






/**
 * Helper function to retrieve attribute value.
 * @param {String} suffix
 * @param {Element} element
 */

function getAttributeValue(suffix, element) {
  var attribute = "data-clipboard-".concat(suffix);

  if (!element.hasAttribute(attribute)) {
    return;
  }

  return element.getAttribute(attribute);
}
/**
 * Base class which takes one or more elements, adds event listeners to them,
 * and instantiates a new `ClipboardAction` on each click.
 */


var Clipboard = /*#__PURE__*/function (_Emitter) {
  _inherits(Clipboard, _Emitter);

  var _super = _createSuper(Clipboard);

  /**
   * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
   * @param {Object} options
   */
  function Clipboard(trigger, options) {
    var _this;

    _classCallCheck(this, Clipboard);

    _this = _super.call(this);

    _this.resolveOptions(options);

    _this.listenClick(trigger);

    return _this;
  }
  /**
   * Defines if attributes would be resolved using internal setter functions
   * or custom functions that were passed in the constructor.
   * @param {Object} options
   */


  _createClass(Clipboard, [{
    key: "resolveOptions",
    value: function resolveOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
      this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
      this.text = typeof options.text === 'function' ? options.text : this.defaultText;
      this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;
    }
    /**
     * Adds a click event listener to the passed trigger.
     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
     */

  }, {
    key: "listenClick",
    value: function listenClick(trigger) {
      var _this2 = this;

      this.listener = listen_default()(trigger, 'click', function (e) {
        return _this2.onClick(e);
      });
    }
    /**
     * Defines a new `ClipboardAction` on each click event.
     * @param {Event} e
     */

  }, {
    key: "onClick",
    value: function onClick(e) {
      var trigger = e.delegateTarget || e.currentTarget;
      var action = this.action(trigger) || 'copy';
      var text = actions_default({
        action: action,
        container: this.container,
        target: this.target(trigger),
        text: this.text(trigger)
      }); // Fires an event based on the copy operation result.

      this.emit(text ? 'success' : 'error', {
        action: action,
        text: text,
        trigger: trigger,
        clearSelection: function clearSelection() {
          if (trigger) {
            trigger.focus();
          }

          window.getSelection().removeAllRanges();
        }
      });
    }
    /**
     * Default `action` lookup function.
     * @param {Element} trigger
     */

  }, {
    key: "defaultAction",
    value: function defaultAction(trigger) {
      return getAttributeValue('action', trigger);
    }
    /**
     * Default `target` lookup function.
     * @param {Element} trigger
     */

  }, {
    key: "defaultTarget",
    value: function defaultTarget(trigger) {
      var selector = getAttributeValue('target', trigger);

      if (selector) {
        return document.querySelector(selector);
      }
    }
    /**
     * Allow fire programmatically a copy action
     * @param {String|HTMLElement} target
     * @param {Object} options
     * @returns Text copied.
     */

  }, {
    key: "defaultText",

    /**
     * Default `text` lookup function.
     * @param {Element} trigger
     */
    value: function defaultText(trigger) {
      return getAttributeValue('text', trigger);
    }
    /**
     * Destroy lifecycle.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.listener.destroy();
    }
  }], [{
    key: "copy",
    value: function copy(target) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        container: document.body
      };
      return actions_copy(target, options);
    }
    /**
     * Allow fire programmatically a cut action
     * @param {String|HTMLElement} target
     * @returns Text cutted.
     */

  }, {
    key: "cut",
    value: function cut(target) {
      return actions_cut(target);
    }
    /**
     * Returns the support of the given action, or all actions if no action is
     * given.
     * @param {String} [action]
     */

  }, {
    key: "isSupported",
    value: function isSupported() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];
      var actions = typeof action === 'string' ? [action] : action;
      var support = !!document.queryCommandSupported;
      actions.forEach(function (action) {
        support = support && !!document.queryCommandSupported(action);
      });
      return support;
    }
  }]);

  return Clipboard;
}((tiny_emitter_default()));

/* harmony default export */ var clipboard = (Clipboard);

/***/ }),

/***/ 828:
/***/ (function(module) {

var DOCUMENT_NODE_TYPE = 9;

/**
 * A polyfill for Element.matches()
 */
if (typeof Element !== 'undefined' && !Element.prototype.matches) {
    var proto = Element.prototype;

    proto.matches = proto.matchesSelector ||
                    proto.mozMatchesSelector ||
                    proto.msMatchesSelector ||
                    proto.oMatchesSelector ||
                    proto.webkitMatchesSelector;
}

/**
 * Finds the closest parent that matches a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @return {Function}
 */
function closest (element, selector) {
    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
        if (typeof element.matches === 'function' &&
            element.matches(selector)) {
          return element;
        }
        element = element.parentNode;
    }
}

module.exports = closest;


/***/ }),

/***/ 438:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_15749__) {

var closest = __nested_webpack_require_15749__(828);

/**
 * Delegates event to a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function _delegate(element, selector, type, callback, useCapture) {
    var listenerFn = listener.apply(this, arguments);

    element.addEventListener(type, listenerFn, useCapture);

    return {
        destroy: function() {
            element.removeEventListener(type, listenerFn, useCapture);
        }
    }
}

/**
 * Delegates event to a selector.
 *
 * @param {Element|String|Array} [elements]
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function delegate(elements, selector, type, callback, useCapture) {
    // Handle the regular Element usage
    if (typeof elements.addEventListener === 'function') {
        return _delegate.apply(null, arguments);
    }

    // Handle Element-less usage, it defaults to global delegation
    if (typeof type === 'function') {
        // Use `document` as the first parameter, then apply arguments
        // This is a short way to .unshift `arguments` without running into deoptimizations
        return _delegate.bind(null, document).apply(null, arguments);
    }

    // Handle Selector-based usage
    if (typeof elements === 'string') {
        elements = document.querySelectorAll(elements);
    }

    // Handle Array-like based usage
    return Array.prototype.map.call(elements, function (element) {
        return _delegate(element, selector, type, callback, useCapture);
    });
}

/**
 * Finds closest match and invokes callback.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Function}
 */
function listener(element, selector, type, callback) {
    return function(e) {
        e.delegateTarget = closest(e.target, selector);

        if (e.delegateTarget) {
            callback.call(element, e);
        }
    }
}

module.exports = delegate;


/***/ }),

/***/ 879:
/***/ (function(__unused_webpack_module, exports) {

/**
 * Check if argument is a HTML element.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.node = function(value) {
    return value !== undefined
        && value instanceof HTMLElement
        && value.nodeType === 1;
};

/**
 * Check if argument is a list of HTML elements.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.nodeList = function(value) {
    var type = Object.prototype.toString.call(value);

    return value !== undefined
        && (type === '[object NodeList]' || type === '[object HTMLCollection]')
        && ('length' in value)
        && (value.length === 0 || exports.node(value[0]));
};

/**
 * Check if argument is a string.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.string = function(value) {
    return typeof value === 'string'
        || value instanceof String;
};

/**
 * Check if argument is a function.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.fn = function(value) {
    var type = Object.prototype.toString.call(value);

    return type === '[object Function]';
};


/***/ }),

/***/ 370:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_19113__) {

var is = __nested_webpack_require_19113__(879);
var delegate = __nested_webpack_require_19113__(438);

/**
 * Validates all params and calls the right
 * listener function based on its target type.
 *
 * @param {String|HTMLElement|HTMLCollection|NodeList} target
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listen(target, type, callback) {
    if (!target && !type && !callback) {
        throw new Error('Missing required arguments');
    }

    if (!is.string(type)) {
        throw new TypeError('Second argument must be a String');
    }

    if (!is.fn(callback)) {
        throw new TypeError('Third argument must be a Function');
    }

    if (is.node(target)) {
        return listenNode(target, type, callback);
    }
    else if (is.nodeList(target)) {
        return listenNodeList(target, type, callback);
    }
    else if (is.string(target)) {
        return listenSelector(target, type, callback);
    }
    else {
        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
    }
}

/**
 * Adds an event listener to a HTML element
 * and returns a remove listener function.
 *
 * @param {HTMLElement} node
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNode(node, type, callback) {
    node.addEventListener(type, callback);

    return {
        destroy: function() {
            node.removeEventListener(type, callback);
        }
    }
}

/**
 * Add an event listener to a list of HTML elements
 * and returns a remove listener function.
 *
 * @param {NodeList|HTMLCollection} nodeList
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNodeList(nodeList, type, callback) {
    Array.prototype.forEach.call(nodeList, function(node) {
        node.addEventListener(type, callback);
    });

    return {
        destroy: function() {
            Array.prototype.forEach.call(nodeList, function(node) {
                node.removeEventListener(type, callback);
            });
        }
    }
}

/**
 * Add an event listener to a selector
 * and returns a remove listener function.
 *
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenSelector(selector, type, callback) {
    return delegate(document.body, selector, type, callback);
}

module.exports = listen;


/***/ }),

/***/ 817:
/***/ (function(module) {

function select(element) {
    var selectedText;

    if (element.nodeName === 'SELECT') {
        element.focus();

        selectedText = element.value;
    }
    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
        var isReadOnly = element.hasAttribute('readonly');

        if (!isReadOnly) {
            element.setAttribute('readonly', '');
        }

        element.select();
        element.setSelectionRange(0, element.value.length);

        if (!isReadOnly) {
            element.removeAttribute('readonly');
        }

        selectedText = element.value;
    }
    else {
        if (element.hasAttribute('contenteditable')) {
            element.focus();
        }

        var selection = window.getSelection();
        var range = document.createRange();

        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);

        selectedText = selection.toString();
    }

    return selectedText;
}

module.exports = select;


/***/ }),

/***/ 279:
/***/ (function(module) {

function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;
module.exports.TinyEmitter = E;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_24495__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_24495__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_24495__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__nested_webpack_require_24495__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_24495__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_24495__.o(definition, key) && !__nested_webpack_require_24495__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_24495__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_24495__(686);
/******/ })()
.default;
});

/***/ }),

/***/ "../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var o=function(o){var t=o/255;return t<.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)},t=function(t){return.2126*o(t.r)+.7152*o(t.g)+.0722*o(t.b)};/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(o){o.prototype.luminance=function(){return o=t(this.rgba),void 0===(r=2)&&(r=0),void 0===n&&(n=Math.pow(10,r)),Math.round(n*o)/n+0;var o,r,n},o.prototype.contrast=function(r){void 0===r&&(r="#FFF");var n,a,i,e,v,u,d,c=r instanceof o?r:new o(r);return e=this.rgba,v=c.toRgb(),u=t(e),d=t(v),n=u>d?(u+.05)/(d+.05):(d+.05)/(u+.05),void 0===(a=2)&&(a=0),void 0===i&&(i=Math.pow(10,a)),Math.floor(i*n)/i+0},o.prototype.isReadable=function(o,t){return void 0===o&&(o="#FFF"),void 0===t&&(t={}),this.contrast(o)>=(e=void 0===(i=(r=t).size)?"normal":i,"AAA"===(a=void 0===(n=r.level)?"AA":n)&&"normal"===e?7:"AA"===a&&"large"===e?3:4.5);var r,n,a,i,e}}


/***/ }),

/***/ "../../node_modules/.pnpm/computed-style@0.1.4/node_modules/computed-style/dist/computedStyle.commonjs.js":
/***/ ((module) => {

// This code has been refactored for 140 bytes
// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js
var computedStyle = function (el, prop, getComputedStyle) {
  getComputedStyle = window.getComputedStyle;

  // In one fell swoop
  return (
    // If we have getComputedStyle
    getComputedStyle ?
      // Query it
      // TODO: From CSS-Query notes, we might need (node, null) for FF
      getComputedStyle(el) :

    // Otherwise, we are in IE and use currentStyle
      el.currentStyle
  )[
    // Switch to camelCase for CSSOM
    // DEV: Grabbed from jQuery
    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
    prop.replace(/-(\w)/gi, function (word, letter) {
      return letter.toUpperCase();
    })
  ];
};

module.exports = computedStyle;


/***/ }),

/***/ "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/base.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Diff;

/*istanbul ignore end*/
function Diff() {}

Diff.prototype = {
  /*istanbul ignore start*/

  /*istanbul ignore end*/
  diff: function diff(oldString, newString) {
    /*istanbul ignore start*/
    var
    /*istanbul ignore end*/
    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath =
        /*istanbul ignore start*/
        void 0
        /*istanbul ignore end*/
        ;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  castInput: function castInput(value) {
    return value;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  tokenize: function tokenize(value) {
    return value.split('');
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Jhc2UuanMiXSwibmFtZXMiOlsiRGlmZiIsInByb3RvdHlwZSIsImRpZmYiLCJvbGRTdHJpbmciLCJuZXdTdHJpbmciLCJvcHRpb25zIiwiY2FsbGJhY2siLCJzZWxmIiwiZG9uZSIsInZhbHVlIiwic2V0VGltZW91dCIsInVuZGVmaW5lZCIsImNhc3RJbnB1dCIsInJlbW92ZUVtcHR5IiwidG9rZW5pemUiLCJuZXdMZW4iLCJsZW5ndGgiLCJvbGRMZW4iLCJlZGl0TGVuZ3RoIiwibWF4RWRpdExlbmd0aCIsImJlc3RQYXRoIiwibmV3UG9zIiwiY29tcG9uZW50cyIsIm9sZFBvcyIsImV4dHJhY3RDb21tb24iLCJqb2luIiwiY291bnQiLCJleGVjRWRpdExlbmd0aCIsImRpYWdvbmFsUGF0aCIsImJhc2VQYXRoIiwiYWRkUGF0aCIsInJlbW92ZVBhdGgiLCJjYW5BZGQiLCJjYW5SZW1vdmUiLCJjbG9uZVBhdGgiLCJwdXNoQ29tcG9uZW50IiwiYnVpbGRWYWx1ZXMiLCJ1c2VMb25nZXN0VG9rZW4iLCJleGVjIiwicmV0IiwiYWRkZWQiLCJyZW1vdmVkIiwibGFzdCIsInB1c2giLCJjb21tb25Db3VudCIsImVxdWFscyIsImxlZnQiLCJyaWdodCIsImNvbXBhcmF0b3IiLCJpZ25vcmVDYXNlIiwidG9Mb3dlckNhc2UiLCJhcnJheSIsImkiLCJzcGxpdCIsImNoYXJzIiwiY29tcG9uZW50UG9zIiwiY29tcG9uZW50TGVuIiwiY29tcG9uZW50Iiwic2xpY2UiLCJtYXAiLCJvbGRWYWx1ZSIsInRtcCIsImxhc3RDb21wb25lbnQiLCJwb3AiLCJwYXRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZSxTQUFTQSxJQUFULEdBQWdCLENBQUU7O0FBRWpDQSxJQUFJLENBQUNDLFNBQUwsR0FBaUI7QUFBQTs7QUFBQTtBQUNmQyxFQUFBQSxJQURlLGdCQUNWQyxTQURVLEVBQ0NDLFNBREQsRUFDMEI7QUFBQTtBQUFBO0FBQUE7QUFBZEMsSUFBQUEsT0FBYyx1RUFBSixFQUFJO0FBQ3ZDLFFBQUlDLFFBQVEsR0FBR0QsT0FBTyxDQUFDQyxRQUF2Qjs7QUFDQSxRQUFJLE9BQU9ELE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakNDLE1BQUFBLFFBQVEsR0FBR0QsT0FBWDtBQUNBQSxNQUFBQSxPQUFPLEdBQUcsRUFBVjtBQUNEOztBQUNELFNBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUVBLFFBQUlFLElBQUksR0FBRyxJQUFYOztBQUVBLGFBQVNDLElBQVQsQ0FBY0MsS0FBZCxFQUFxQjtBQUNuQixVQUFJSCxRQUFKLEVBQWM7QUFDWkksUUFBQUEsVUFBVSxDQUFDLFlBQVc7QUFBRUosVUFBQUEsUUFBUSxDQUFDSyxTQUFELEVBQVlGLEtBQVosQ0FBUjtBQUE2QixTQUEzQyxFQUE2QyxDQUE3QyxDQUFWO0FBQ0EsZUFBTyxJQUFQO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsZUFBT0EsS0FBUDtBQUNEO0FBQ0YsS0FqQnNDLENBbUJ2Qzs7O0FBQ0FOLElBQUFBLFNBQVMsR0FBRyxLQUFLUyxTQUFMLENBQWVULFNBQWYsQ0FBWjtBQUNBQyxJQUFBQSxTQUFTLEdBQUcsS0FBS1EsU0FBTCxDQUFlUixTQUFmLENBQVo7QUFFQUQsSUFBQUEsU0FBUyxHQUFHLEtBQUtVLFdBQUwsQ0FBaUIsS0FBS0MsUUFBTCxDQUFjWCxTQUFkLENBQWpCLENBQVo7QUFDQUMsSUFBQUEsU0FBUyxHQUFHLEtBQUtTLFdBQUwsQ0FBaUIsS0FBS0MsUUFBTCxDQUFjVixTQUFkLENBQWpCLENBQVo7QUFFQSxRQUFJVyxNQUFNLEdBQUdYLFNBQVMsQ0FBQ1ksTUFBdkI7QUFBQSxRQUErQkMsTUFBTSxHQUFHZCxTQUFTLENBQUNhLE1BQWxEO0FBQ0EsUUFBSUUsVUFBVSxHQUFHLENBQWpCO0FBQ0EsUUFBSUMsYUFBYSxHQUFHSixNQUFNLEdBQUdFLE1BQTdCO0FBQ0EsUUFBSUcsUUFBUSxHQUFHLENBQUM7QUFBRUMsTUFBQUEsTUFBTSxFQUFFLENBQUMsQ0FBWDtBQUFjQyxNQUFBQSxVQUFVLEVBQUU7QUFBMUIsS0FBRCxDQUFmLENBN0J1QyxDQStCdkM7O0FBQ0EsUUFBSUMsTUFBTSxHQUFHLEtBQUtDLGFBQUwsQ0FBbUJKLFFBQVEsQ0FBQyxDQUFELENBQTNCLEVBQWdDaEIsU0FBaEMsRUFBMkNELFNBQTNDLEVBQXNELENBQXRELENBQWI7O0FBQ0EsUUFBSWlCLFFBQVEsQ0FBQyxDQUFELENBQVIsQ0FBWUMsTUFBWixHQUFxQixDQUFyQixJQUEwQk4sTUFBMUIsSUFBb0NRLE1BQU0sR0FBRyxDQUFULElBQWNOLE1BQXRELEVBQThEO0FBQzVEO0FBQ0EsYUFBT1QsSUFBSSxDQUFDLENBQUM7QUFBQ0MsUUFBQUEsS0FBSyxFQUFFLEtBQUtnQixJQUFMLENBQVVyQixTQUFWLENBQVI7QUFBOEJzQixRQUFBQSxLQUFLLEVBQUV0QixTQUFTLENBQUNZO0FBQS9DLE9BQUQsQ0FBRCxDQUFYO0FBQ0QsS0FwQ3NDLENBc0N2Qzs7O0FBQ0EsYUFBU1csY0FBVCxHQUEwQjtBQUN4QixXQUFLLElBQUlDLFlBQVksR0FBRyxDQUFDLENBQUQsR0FBS1YsVUFBN0IsRUFBeUNVLFlBQVksSUFBSVYsVUFBekQsRUFBcUVVLFlBQVksSUFBSSxDQUFyRixFQUF3RjtBQUN0RixZQUFJQyxRQUFRO0FBQUE7QUFBQTtBQUFaO0FBQUE7O0FBQ0EsWUFBSUMsT0FBTyxHQUFHVixRQUFRLENBQUNRLFlBQVksR0FBRyxDQUFoQixDQUF0QjtBQUFBLFlBQ0lHLFVBQVUsR0FBR1gsUUFBUSxDQUFDUSxZQUFZLEdBQUcsQ0FBaEIsQ0FEekI7QUFBQSxZQUVJTCxPQUFNLEdBQUcsQ0FBQ1EsVUFBVSxHQUFHQSxVQUFVLENBQUNWLE1BQWQsR0FBdUIsQ0FBbEMsSUFBdUNPLFlBRnBEOztBQUdBLFlBQUlFLE9BQUosRUFBYTtBQUNYO0FBQ0FWLFVBQUFBLFFBQVEsQ0FBQ1EsWUFBWSxHQUFHLENBQWhCLENBQVIsR0FBNkJqQixTQUE3QjtBQUNEOztBQUVELFlBQUlxQixNQUFNLEdBQUdGLE9BQU8sSUFBSUEsT0FBTyxDQUFDVCxNQUFSLEdBQWlCLENBQWpCLEdBQXFCTixNQUE3QztBQUFBLFlBQ0lrQixTQUFTLEdBQUdGLFVBQVUsSUFBSSxLQUFLUixPQUFuQixJQUE2QkEsT0FBTSxHQUFHTixNQUR0RDs7QUFFQSxZQUFJLENBQUNlLE1BQUQsSUFBVyxDQUFDQyxTQUFoQixFQUEyQjtBQUN6QjtBQUNBYixVQUFBQSxRQUFRLENBQUNRLFlBQUQsQ0FBUixHQUF5QmpCLFNBQXpCO0FBQ0E7QUFDRCxTQWhCcUYsQ0FrQnRGO0FBQ0E7QUFDQTs7O0FBQ0EsWUFBSSxDQUFDcUIsTUFBRCxJQUFZQyxTQUFTLElBQUlILE9BQU8sQ0FBQ1QsTUFBUixHQUFpQlUsVUFBVSxDQUFDVixNQUF6RCxFQUFrRTtBQUNoRVEsVUFBQUEsUUFBUSxHQUFHSyxTQUFTLENBQUNILFVBQUQsQ0FBcEI7QUFDQXhCLFVBQUFBLElBQUksQ0FBQzRCLGFBQUwsQ0FBbUJOLFFBQVEsQ0FBQ1AsVUFBNUIsRUFBd0NYLFNBQXhDLEVBQW1ELElBQW5EO0FBQ0QsU0FIRCxNQUdPO0FBQ0xrQixVQUFBQSxRQUFRLEdBQUdDLE9BQVgsQ0FESyxDQUNlOztBQUNwQkQsVUFBQUEsUUFBUSxDQUFDUixNQUFUO0FBQ0FkLFVBQUFBLElBQUksQ0FBQzRCLGFBQUwsQ0FBbUJOLFFBQVEsQ0FBQ1AsVUFBNUIsRUFBd0MsSUFBeEMsRUFBOENYLFNBQTlDO0FBQ0Q7O0FBRURZLFFBQUFBLE9BQU0sR0FBR2hCLElBQUksQ0FBQ2lCLGFBQUwsQ0FBbUJLLFFBQW5CLEVBQTZCekIsU0FBN0IsRUFBd0NELFNBQXhDLEVBQW1EeUIsWUFBbkQsQ0FBVCxDQTlCc0YsQ0FnQ3RGOztBQUNBLFlBQUlDLFFBQVEsQ0FBQ1IsTUFBVCxHQUFrQixDQUFsQixJQUF1Qk4sTUFBdkIsSUFBaUNRLE9BQU0sR0FBRyxDQUFULElBQWNOLE1BQW5ELEVBQTJEO0FBQ3pELGlCQUFPVCxJQUFJLENBQUM0QixXQUFXLENBQUM3QixJQUFELEVBQU9zQixRQUFRLENBQUNQLFVBQWhCLEVBQTRCbEIsU0FBNUIsRUFBdUNELFNBQXZDLEVBQWtESSxJQUFJLENBQUM4QixlQUF2RCxDQUFaLENBQVg7QUFDRCxTQUZELE1BRU87QUFDTDtBQUNBakIsVUFBQUEsUUFBUSxDQUFDUSxZQUFELENBQVIsR0FBeUJDLFFBQXpCO0FBQ0Q7QUFDRjs7QUFFRFgsTUFBQUEsVUFBVTtBQUNYLEtBbEZzQyxDQW9GdkM7QUFDQTtBQUNBOzs7QUFDQSxRQUFJWixRQUFKLEVBQWM7QUFDWCxnQkFBU2dDLElBQVQsR0FBZ0I7QUFDZjVCLFFBQUFBLFVBQVUsQ0FBQyxZQUFXO0FBQ3BCOztBQUNBO0FBQ0EsY0FBSVEsVUFBVSxHQUFHQyxhQUFqQixFQUFnQztBQUM5QixtQkFBT2IsUUFBUSxFQUFmO0FBQ0Q7O0FBRUQsY0FBSSxDQUFDcUIsY0FBYyxFQUFuQixFQUF1QjtBQUNyQlcsWUFBQUEsSUFBSTtBQUNMO0FBQ0YsU0FWUyxFQVVQLENBVk8sQ0FBVjtBQVdELE9BWkEsR0FBRDtBQWFELEtBZEQsTUFjTztBQUNMLGFBQU9wQixVQUFVLElBQUlDLGFBQXJCLEVBQW9DO0FBQ2xDLFlBQUlvQixHQUFHLEdBQUdaLGNBQWMsRUFBeEI7O0FBQ0EsWUFBSVksR0FBSixFQUFTO0FBQ1AsaUJBQU9BLEdBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRixHQTlHYzs7QUFBQTs7QUFBQTtBQWdIZkosRUFBQUEsYUFoSGUseUJBZ0hEYixVQWhIQyxFQWdIV2tCLEtBaEhYLEVBZ0hrQkMsT0FoSGxCLEVBZ0gyQjtBQUN4QyxRQUFJQyxJQUFJLEdBQUdwQixVQUFVLENBQUNBLFVBQVUsQ0FBQ04sTUFBWCxHQUFvQixDQUFyQixDQUFyQjs7QUFDQSxRQUFJMEIsSUFBSSxJQUFJQSxJQUFJLENBQUNGLEtBQUwsS0FBZUEsS0FBdkIsSUFBZ0NFLElBQUksQ0FBQ0QsT0FBTCxLQUFpQkEsT0FBckQsRUFBOEQ7QUFDNUQ7QUFDQTtBQUNBbkIsTUFBQUEsVUFBVSxDQUFDQSxVQUFVLENBQUNOLE1BQVgsR0FBb0IsQ0FBckIsQ0FBVixHQUFvQztBQUFDVSxRQUFBQSxLQUFLLEVBQUVnQixJQUFJLENBQUNoQixLQUFMLEdBQWEsQ0FBckI7QUFBd0JjLFFBQUFBLEtBQUssRUFBRUEsS0FBL0I7QUFBc0NDLFFBQUFBLE9BQU8sRUFBRUE7QUFBL0MsT0FBcEM7QUFDRCxLQUpELE1BSU87QUFDTG5CLE1BQUFBLFVBQVUsQ0FBQ3FCLElBQVgsQ0FBZ0I7QUFBQ2pCLFFBQUFBLEtBQUssRUFBRSxDQUFSO0FBQVdjLFFBQUFBLEtBQUssRUFBRUEsS0FBbEI7QUFBeUJDLFFBQUFBLE9BQU8sRUFBRUE7QUFBbEMsT0FBaEI7QUFDRDtBQUNGLEdBekhjOztBQUFBOztBQUFBO0FBMEhmakIsRUFBQUEsYUExSGUseUJBMEhESyxRQTFIQyxFQTBIU3pCLFNBMUhULEVBMEhvQkQsU0ExSHBCLEVBMEgrQnlCLFlBMUgvQixFQTBINkM7QUFDMUQsUUFBSWIsTUFBTSxHQUFHWCxTQUFTLENBQUNZLE1BQXZCO0FBQUEsUUFDSUMsTUFBTSxHQUFHZCxTQUFTLENBQUNhLE1BRHZCO0FBQUEsUUFFSUssTUFBTSxHQUFHUSxRQUFRLENBQUNSLE1BRnRCO0FBQUEsUUFHSUUsTUFBTSxHQUFHRixNQUFNLEdBQUdPLFlBSHRCO0FBQUEsUUFLSWdCLFdBQVcsR0FBRyxDQUxsQjs7QUFNQSxXQUFPdkIsTUFBTSxHQUFHLENBQVQsR0FBYU4sTUFBYixJQUF1QlEsTUFBTSxHQUFHLENBQVQsR0FBYU4sTUFBcEMsSUFBOEMsS0FBSzRCLE1BQUwsQ0FBWXpDLFNBQVMsQ0FBQ2lCLE1BQU0sR0FBRyxDQUFWLENBQXJCLEVBQW1DbEIsU0FBUyxDQUFDb0IsTUFBTSxHQUFHLENBQVYsQ0FBNUMsQ0FBckQsRUFBZ0g7QUFDOUdGLE1BQUFBLE1BQU07QUFDTkUsTUFBQUEsTUFBTTtBQUNOcUIsTUFBQUEsV0FBVztBQUNaOztBQUVELFFBQUlBLFdBQUosRUFBaUI7QUFDZmYsTUFBQUEsUUFBUSxDQUFDUCxVQUFULENBQW9CcUIsSUFBcEIsQ0FBeUI7QUFBQ2pCLFFBQUFBLEtBQUssRUFBRWtCO0FBQVIsT0FBekI7QUFDRDs7QUFFRGYsSUFBQUEsUUFBUSxDQUFDUixNQUFULEdBQWtCQSxNQUFsQjtBQUNBLFdBQU9FLE1BQVA7QUFDRCxHQTdJYzs7QUFBQTs7QUFBQTtBQStJZnNCLEVBQUFBLE1BL0llLGtCQStJUkMsSUEvSVEsRUErSUZDLEtBL0lFLEVBK0lLO0FBQ2xCLFFBQUksS0FBSzFDLE9BQUwsQ0FBYTJDLFVBQWpCLEVBQTZCO0FBQzNCLGFBQU8sS0FBSzNDLE9BQUwsQ0FBYTJDLFVBQWIsQ0FBd0JGLElBQXhCLEVBQThCQyxLQUE5QixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBT0QsSUFBSSxLQUFLQyxLQUFULElBQ0QsS0FBSzFDLE9BQUwsQ0FBYTRDLFVBQWIsSUFBMkJILElBQUksQ0FBQ0ksV0FBTCxPQUF1QkgsS0FBSyxDQUFDRyxXQUFOLEVBRHhEO0FBRUQ7QUFDRixHQXRKYzs7QUFBQTs7QUFBQTtBQXVKZnJDLEVBQUFBLFdBdkplLHVCQXVKSHNDLEtBdkpHLEVBdUpJO0FBQ2pCLFFBQUlaLEdBQUcsR0FBRyxFQUFWOztBQUNBLFNBQUssSUFBSWEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDbkMsTUFBMUIsRUFBa0NvQyxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLFVBQUlELEtBQUssQ0FBQ0MsQ0FBRCxDQUFULEVBQWM7QUFDWmIsUUFBQUEsR0FBRyxDQUFDSSxJQUFKLENBQVNRLEtBQUssQ0FBQ0MsQ0FBRCxDQUFkO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPYixHQUFQO0FBQ0QsR0EvSmM7O0FBQUE7O0FBQUE7QUFnS2YzQixFQUFBQSxTQWhLZSxxQkFnS0xILEtBaEtLLEVBZ0tFO0FBQ2YsV0FBT0EsS0FBUDtBQUNELEdBbEtjOztBQUFBOztBQUFBO0FBbUtmSyxFQUFBQSxRQW5LZSxvQkFtS05MLEtBbktNLEVBbUtDO0FBQ2QsV0FBT0EsS0FBSyxDQUFDNEMsS0FBTixDQUFZLEVBQVosQ0FBUDtBQUNELEdBcktjOztBQUFBOztBQUFBO0FBc0tmNUIsRUFBQUEsSUF0S2UsZ0JBc0tWNkIsS0F0S1UsRUFzS0g7QUFDVixXQUFPQSxLQUFLLENBQUM3QixJQUFOLENBQVcsRUFBWCxDQUFQO0FBQ0Q7QUF4S2MsQ0FBakI7O0FBMktBLFNBQVNXLFdBQVQsQ0FBcUJsQyxJQUFyQixFQUEyQm9CLFVBQTNCLEVBQXVDbEIsU0FBdkMsRUFBa0RELFNBQWxELEVBQTZEa0MsZUFBN0QsRUFBOEU7QUFDNUUsTUFBSWtCLFlBQVksR0FBRyxDQUFuQjtBQUFBLE1BQ0lDLFlBQVksR0FBR2xDLFVBQVUsQ0FBQ04sTUFEOUI7QUFBQSxNQUVJSyxNQUFNLEdBQUcsQ0FGYjtBQUFBLE1BR0lFLE1BQU0sR0FBRyxDQUhiOztBQUtBLFNBQU9nQyxZQUFZLEdBQUdDLFlBQXRCLEVBQW9DRCxZQUFZLEVBQWhELEVBQW9EO0FBQ2xELFFBQUlFLFNBQVMsR0FBR25DLFVBQVUsQ0FBQ2lDLFlBQUQsQ0FBMUI7O0FBQ0EsUUFBSSxDQUFDRSxTQUFTLENBQUNoQixPQUFmLEVBQXdCO0FBQ3RCLFVBQUksQ0FBQ2dCLFNBQVMsQ0FBQ2pCLEtBQVgsSUFBb0JILGVBQXhCLEVBQXlDO0FBQ3ZDLFlBQUk1QixLQUFLLEdBQUdMLFNBQVMsQ0FBQ3NELEtBQVYsQ0FBZ0JyQyxNQUFoQixFQUF3QkEsTUFBTSxHQUFHb0MsU0FBUyxDQUFDL0IsS0FBM0MsQ0FBWjtBQUNBakIsUUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUNrRCxHQUFOLENBQVUsVUFBU2xELEtBQVQsRUFBZ0IyQyxDQUFoQixFQUFtQjtBQUNuQyxjQUFJUSxRQUFRLEdBQUd6RCxTQUFTLENBQUNvQixNQUFNLEdBQUc2QixDQUFWLENBQXhCO0FBQ0EsaUJBQU9RLFFBQVEsQ0FBQzVDLE1BQVQsR0FBa0JQLEtBQUssQ0FBQ08sTUFBeEIsR0FBaUM0QyxRQUFqQyxHQUE0Q25ELEtBQW5EO0FBQ0QsU0FITyxDQUFSO0FBS0FnRCxRQUFBQSxTQUFTLENBQUNoRCxLQUFWLEdBQWtCUCxJQUFJLENBQUN1QixJQUFMLENBQVVoQixLQUFWLENBQWxCO0FBQ0QsT0FSRCxNQVFPO0FBQ0xnRCxRQUFBQSxTQUFTLENBQUNoRCxLQUFWLEdBQWtCUCxJQUFJLENBQUN1QixJQUFMLENBQVVyQixTQUFTLENBQUNzRCxLQUFWLENBQWdCckMsTUFBaEIsRUFBd0JBLE1BQU0sR0FBR29DLFNBQVMsQ0FBQy9CLEtBQTNDLENBQVYsQ0FBbEI7QUFDRDs7QUFDREwsTUFBQUEsTUFBTSxJQUFJb0MsU0FBUyxDQUFDL0IsS0FBcEIsQ0Fac0IsQ0FjdEI7O0FBQ0EsVUFBSSxDQUFDK0IsU0FBUyxDQUFDakIsS0FBZixFQUFzQjtBQUNwQmpCLFFBQUFBLE1BQU0sSUFBSWtDLFNBQVMsQ0FBQy9CLEtBQXBCO0FBQ0Q7QUFDRixLQWxCRCxNQWtCTztBQUNMK0IsTUFBQUEsU0FBUyxDQUFDaEQsS0FBVixHQUFrQlAsSUFBSSxDQUFDdUIsSUFBTCxDQUFVdEIsU0FBUyxDQUFDdUQsS0FBVixDQUFnQm5DLE1BQWhCLEVBQXdCQSxNQUFNLEdBQUdrQyxTQUFTLENBQUMvQixLQUEzQyxDQUFWLENBQWxCO0FBQ0FILE1BQUFBLE1BQU0sSUFBSWtDLFNBQVMsQ0FBQy9CLEtBQXBCLENBRkssQ0FJTDtBQUNBO0FBQ0E7O0FBQ0EsVUFBSTZCLFlBQVksSUFBSWpDLFVBQVUsQ0FBQ2lDLFlBQVksR0FBRyxDQUFoQixDQUFWLENBQTZCZixLQUFqRCxFQUF3RDtBQUN0RCxZQUFJcUIsR0FBRyxHQUFHdkMsVUFBVSxDQUFDaUMsWUFBWSxHQUFHLENBQWhCLENBQXBCO0FBQ0FqQyxRQUFBQSxVQUFVLENBQUNpQyxZQUFZLEdBQUcsQ0FBaEIsQ0FBVixHQUErQmpDLFVBQVUsQ0FBQ2lDLFlBQUQsQ0FBekM7QUFDQWpDLFFBQUFBLFVBQVUsQ0FBQ2lDLFlBQUQsQ0FBVixHQUEyQk0sR0FBM0I7QUFDRDtBQUNGO0FBQ0YsR0F2QzJFLENBeUM1RTtBQUNBO0FBQ0E7OztBQUNBLE1BQUlDLGFBQWEsR0FBR3hDLFVBQVUsQ0FBQ2tDLFlBQVksR0FBRyxDQUFoQixDQUE5Qjs7QUFDQSxNQUFJQSxZQUFZLEdBQUcsQ0FBZixJQUNHLE9BQU9NLGFBQWEsQ0FBQ3JELEtBQXJCLEtBQStCLFFBRGxDLEtBRUlxRCxhQUFhLENBQUN0QixLQUFkLElBQXVCc0IsYUFBYSxDQUFDckIsT0FGekMsS0FHR3ZDLElBQUksQ0FBQzJDLE1BQUwsQ0FBWSxFQUFaLEVBQWdCaUIsYUFBYSxDQUFDckQsS0FBOUIsQ0FIUCxFQUc2QztBQUMzQ2EsSUFBQUEsVUFBVSxDQUFDa0MsWUFBWSxHQUFHLENBQWhCLENBQVYsQ0FBNkIvQyxLQUE3QixJQUFzQ3FELGFBQWEsQ0FBQ3JELEtBQXBEO0FBQ0FhLElBQUFBLFVBQVUsQ0FBQ3lDLEdBQVg7QUFDRDs7QUFFRCxTQUFPekMsVUFBUDtBQUNEOztBQUVELFNBQVNZLFNBQVQsQ0FBbUI4QixJQUFuQixFQUF5QjtBQUN2QixTQUFPO0FBQUUzQyxJQUFBQSxNQUFNLEVBQUUyQyxJQUFJLENBQUMzQyxNQUFmO0FBQXVCQyxJQUFBQSxVQUFVLEVBQUUwQyxJQUFJLENBQUMxQyxVQUFMLENBQWdCb0MsS0FBaEIsQ0FBc0IsQ0FBdEI7QUFBbkMsR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGlmZigpIHt9XG5cbkRpZmYucHJvdG90eXBlID0ge1xuICBkaWZmKG9sZFN0cmluZywgbmV3U3RyaW5nLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXG4gICAgb2xkU3RyaW5nID0gdGhpcy5jYXN0SW5wdXQob2xkU3RyaW5nKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHJpbmcpO1xuXG4gICAgb2xkU3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG9sZFN0cmluZykpO1xuICAgIG5ld1N0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShuZXdTdHJpbmcpKTtcblxuICAgIGxldCBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLCBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xuICAgIGxldCBlZGl0TGVuZ3RoID0gMTtcbiAgICBsZXQgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcbiAgICBsZXQgYmVzdFBhdGggPSBbeyBuZXdQb3M6IC0xLCBjb21wb25lbnRzOiBbXSB9XTtcblxuICAgIC8vIFNlZWQgZWRpdExlbmd0aCA9IDAsIGkuZS4gdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzXG4gICAgbGV0IG9sZFBvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIDApO1xuICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG4gICAgICByZXR1cm4gZG9uZShbe3ZhbHVlOiB0aGlzLmpvaW4obmV3U3RyaW5nKSwgY291bnQ6IG5ld1N0cmluZy5sZW5ndGh9XSk7XG4gICAgfVxuXG4gICAgLy8gTWFpbiB3b3JrZXIgbWV0aG9kLiBjaGVja3MgYWxsIHBlcm11dGF0aW9ucyBvZiBhIGdpdmVuIGVkaXQgbGVuZ3RoIGZvciBhY2NlcHRhbmNlLlxuICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xuICAgICAgZm9yIChsZXQgZGlhZ29uYWxQYXRoID0gLTEgKiBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggPD0gZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoICs9IDIpIHtcbiAgICAgICAgbGV0IGJhc2VQYXRoO1xuICAgICAgICBsZXQgYWRkUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdLFxuICAgICAgICAgICAgcmVtb3ZlUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCArIDFdLFxuICAgICAgICAgICAgb2xkUG9zID0gKHJlbW92ZVBhdGggPyByZW1vdmVQYXRoLm5ld1BvcyA6IDApIC0gZGlhZ29uYWxQYXRoO1xuICAgICAgICBpZiAoYWRkUGF0aCkge1xuICAgICAgICAgIC8vIE5vIG9uZSBlbHNlIGlzIGdvaW5nIHRvIGF0dGVtcHQgdG8gdXNlIHRoaXMgdmFsdWUsIGNsZWFyIGl0XG4gICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2FuQWRkID0gYWRkUGF0aCAmJiBhZGRQYXRoLm5ld1BvcyArIDEgPCBuZXdMZW4sXG4gICAgICAgICAgICBjYW5SZW1vdmUgPSByZW1vdmVQYXRoICYmIDAgPD0gb2xkUG9zICYmIG9sZFBvcyA8IG9sZExlbjtcbiAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcbiAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXG4gICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcbiAgICAgICAgaWYgKCFjYW5BZGQgfHwgKGNhblJlbW92ZSAmJiBhZGRQYXRoLm5ld1BvcyA8IHJlbW92ZVBhdGgubmV3UG9zKSkge1xuICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICBiYXNlUGF0aC5uZXdQb3MrKztcbiAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdHJ1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiBib3RoIHN0cmluZ3MsIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgICAgaWYgKGJhc2VQYXRoLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIG9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoYnVpbGRWYWx1ZXMoc2VsZiwgYmFzZVBhdGguY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHNlbGYudXNlTG9uZ2VzdFRva2VuKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHRyYWNrIHRoaXMgcGF0aCBhcyBhIHBvdGVudGlhbCBjYW5kaWRhdGUgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZGl0TGVuZ3RoKys7XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXG4gICAgLy8gaXMgcHJvZHVjZWQuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAoZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgd2Ugd2FudCB0byBiZSBzYWZlLlxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgaWYgKGVkaXRMZW5ndGggPiBtYXhFZGl0TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWV4ZWNFZGl0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICBsZXQgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHVzaENvbXBvbmVudChjb21wb25lbnRzLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIGxldCBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcbiAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHtjb3VudDogbGFzdC5jb3VudCArIDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goe2NvdW50OiAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfSk7XG4gICAgfVxuICB9LFxuICBleHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKSB7XG4gICAgbGV0IG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXG4gICAgICAgIG5ld1BvcyA9IGJhc2VQYXRoLm5ld1BvcyxcbiAgICAgICAgb2xkUG9zID0gbmV3UG9zIC0gZGlhZ29uYWxQYXRoLFxuXG4gICAgICAgIGNvbW1vbkNvdW50ID0gMDtcbiAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG5ld1N0cmluZ1tuZXdQb3MgKyAxXSwgb2xkU3RyaW5nW29sZFBvcyArIDFdKSkge1xuICAgICAgbmV3UG9zKys7XG4gICAgICBvbGRQb3MrKztcbiAgICAgIGNvbW1vbkNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbkNvdW50KSB7XG4gICAgICBiYXNlUGF0aC5jb21wb25lbnRzLnB1c2goe2NvdW50OiBjb21tb25Db3VudH0pO1xuICAgIH1cblxuICAgIGJhc2VQYXRoLm5ld1BvcyA9IG5ld1BvcztcbiAgICByZXR1cm4gb2xkUG9zO1xuICB9LFxuXG4gIGVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0XG4gICAgICAgIHx8ICh0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlRW1wdHkoYXJyYXkpIHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycmF5W2ldKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgY2FzdElucHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB0b2tlbml6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJyk7XG4gIH0sXG4gIGpvaW4oY2hhcnMpIHtcbiAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcbiAgbGV0IGNvbXBvbmVudFBvcyA9IDAsXG4gICAgICBjb21wb25lbnRMZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcbiAgICAgIG5ld1BvcyA9IDAsXG4gICAgICBvbGRQb3MgPSAwO1xuXG4gIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XG4gICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICBpZiAoIWNvbXBvbmVudC5yZW1vdmVkKSB7XG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24odmFsdWUsIGkpIHtcbiAgICAgICAgICBsZXQgb2xkVmFsdWUgPSBvbGRTdHJpbmdbb2xkUG9zICsgaV07XG4gICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbih2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4obmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICB9XG4gICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuXG4gICAgICAvLyBDb21tb24gY2FzZVxuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcblxuICAgICAgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cbiAgICAgIC8vIFRoZSBkaWZmaW5nIGFsZ29yaXRobSBpcyB0aWVkIHRvIGFkZCB0aGVuIHJlbW92ZSBvdXRwdXQgYW5kIHRoaXMgaXMgdGhlIHNpbXBsZXN0XG4gICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cbiAgICAgIGlmIChjb21wb25lbnRQb3MgJiYgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXS5hZGRlZCkge1xuICAgICAgICBsZXQgdG1wID0gY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3NdID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQgKGkuZS4gd2hpdGVzcGFjZSkuXG4gIC8vIEZvciB0aGlzIGNhc2Ugd2UgbWVyZ2UgdGhlIHRlcm1pbmFsIGludG8gdGhlIHByaW9yIHN0cmluZyBhbmQgZHJvcCB0aGUgY2hhbmdlLlxuICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgbW9kZS5cbiAgbGV0IGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xuICBpZiAoY29tcG9uZW50TGVuID4gMVxuICAgICAgJiYgdHlwZW9mIGxhc3RDb21wb25lbnQudmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAmJiAobGFzdENvbXBvbmVudC5hZGRlZCB8fCBsYXN0Q29tcG9uZW50LnJlbW92ZWQpXG4gICAgICAmJiBkaWZmLmVxdWFscygnJywgbGFzdENvbXBvbmVudC52YWx1ZSkpIHtcbiAgICBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDJdLnZhbHVlICs9IGxhc3RDb21wb25lbnQudmFsdWU7XG4gICAgY29tcG9uZW50cy5wb3AoKTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xuICByZXR1cm4geyBuZXdQb3M6IHBhdGgubmV3UG9zLCBjb21wb25lbnRzOiBwYXRoLmNvbXBvbmVudHMuc2xpY2UoMCkgfTtcbn1cbiJdfQ==


/***/ }),

/***/ "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/character.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/*istanbul ignore start*/


__webpack_unused_export__ = ({
  value: true
});
exports.JJ = diffChars;
__webpack_unused_export__ = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__("../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/
var characterDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
.
/*istanbul ignore start*/
default
/*istanbul ignore end*/
();

/*istanbul ignore start*/
__webpack_unused_export__ = characterDiff;

/*istanbul ignore end*/
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2NoYXJhY3Rlci5qcyJdLCJuYW1lcyI6WyJjaGFyYWN0ZXJEaWZmIiwiRGlmZiIsImRpZmZDaGFycyIsIm9sZFN0ciIsIm5ld1N0ciIsIm9wdGlvbnMiLCJkaWZmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFTyxJQUFNQSxhQUFhLEdBQUc7QUFBSUM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBSjtBQUFBLEVBQXRCOzs7Ozs7QUFDQSxTQUFTQyxTQUFULENBQW1CQyxNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUNDLE9BQW5DLEVBQTRDO0FBQUUsU0FBT0wsYUFBYSxDQUFDTSxJQUFkLENBQW1CSCxNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUNDLE9BQW5DLENBQVA7QUFBcUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgY29uc3QgY2hhcmFjdGVyRGlmZiA9IG5ldyBEaWZmKCk7XG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoYXJzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7IHJldHVybiBjaGFyYWN0ZXJEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpOyB9XG4iXX0=


/***/ }),

/***/ "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js":
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ "../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  N: () => (/* binding */ AnimatePresence)
});

// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/PresenceContext.mjs
var PresenceContext = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/PresenceContext.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/use-constant.mjs
var use_constant = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/use-constant.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
var MotionConfigContext = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs





/**
 * Measurement functionality has to be within a separate component
 * to leverage snapshot lifecycle.
 */
class PopChildMeasure extends react.Component {
    getSnapshotBeforeUpdate(prevProps) {
        const element = this.props.childRef.current;
        if (element && prevProps.isPresent && !this.props.isPresent) {
            const size = this.props.sizeRef.current;
            size.height = element.offsetHeight || 0;
            size.width = element.offsetWidth || 0;
            size.top = element.offsetTop;
            size.left = element.offsetLeft;
        }
        return null;
    }
    /**
     * Required with getSnapshotBeforeUpdate to stop React complaining.
     */
    componentDidUpdate() { }
    render() {
        return this.props.children;
    }
}
function PopChild({ children, isPresent }) {
    const id = (0,react.useId)();
    const ref = (0,react.useRef)(null);
    const size = (0,react.useRef)({
        width: 0,
        height: 0,
        top: 0,
        left: 0,
    });
    const { nonce } = (0,react.useContext)(MotionConfigContext/* MotionConfigContext */.Q);
    /**
     * We create and inject a style block so we can apply this explicit
     * sizing in a non-destructive manner by just deleting the style block.
     *
     * We can't apply size via render as the measurement happens
     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the
     * styles directly on the DOM node, we might be overwriting
     * styles set via the style prop.
     */
    (0,react.useInsertionEffect)(() => {
        const { width, height, top, left } = size.current;
        if (isPresent || !ref.current || !width || !height)
            return;
        ref.current.dataset.motionPopId = id;
        const style = document.createElement("style");
        if (nonce)
            style.nonce = nonce;
        document.head.appendChild(style);
        if (style.sheet) {
            style.sheet.insertRule(`
          [data-motion-pop-id="${id}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
        }
        return () => {
            document.head.removeChild(style);
        };
    }, [isPresent]);
    return ((0,jsx_runtime.jsx)(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: react.cloneElement(children, { ref }) }));
}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs







const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {
    const presenceChildren = (0,use_constant/* useConstant */.M)(newChildrenMap);
    const id = (0,react.useId)();
    const context = (0,react.useMemo)(() => ({
        id,
        initial,
        isPresent,
        custom,
        onExitComplete: (childId) => {
            presenceChildren.set(childId, true);
            for (const isComplete of presenceChildren.values()) {
                if (!isComplete)
                    return; // can stop searching when any is incomplete
            }
            onExitComplete && onExitComplete();
        },
        register: (childId) => {
            presenceChildren.set(childId, false);
            return () => presenceChildren.delete(childId);
        },
    }), 
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? [Math.random()] : [isPresent]);
    (0,react.useMemo)(() => {
        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    /**
     * If there's no `motion` components to fire exit animations, we want to remove this
     * component immediately.
     */
    react.useEffect(() => {
        !isPresent &&
            !presenceChildren.size &&
            onExitComplete &&
            onExitComplete();
    }, [isPresent]);
    if (mode === "popLayout") {
        children = (0,jsx_runtime.jsx)(PopChild, { isPresent: isPresent, children: children });
    }
    return ((0,jsx_runtime.jsx)(PresenceContext/* PresenceContext */.t.Provider, { value: context, children: children }));
};
function newChildrenMap() {
    return new Map();
}



// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
var LayoutGroupContext = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/errors.mjs
var errors = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/errors.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs


const getChildKey = (child) => child.key || "";
function onlyElements(children) {
    const filtered = [];
    // We use forEach here instead of map as map mutates the component key by preprending `.$`
    react.Children.forEach(children, (child) => {
        if ((0,react.isValidElement)(child))
            filtered.push(child);
    });
    return filtered;
}



// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var use_isomorphic_effect = __webpack_require__("../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/framer-motion@11.3.30_@emotion+is-prop-valid@1.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs









/**
 * `AnimatePresence` enables the animation of components that have been removed from the tree.
 *
 * When adding/removing more than a single child, every child **must** be given a unique `key` prop.
 *
 * Any `motion` components that have an `exit` property defined will animate out when removed from
 * the tree.
 *
 * ```jsx
 * import { motion, AnimatePresence } from 'framer-motion'
 *
 * export const Items = ({ items }) => (
 *   <AnimatePresence>
 *     {items.map(item => (
 *       <motion.div
 *         key={item.id}
 *         initial={{ opacity: 0 }}
 *         animate={{ opacity: 1 }}
 *         exit={{ opacity: 0 }}
 *       />
 *     ))}
 *   </AnimatePresence>
 * )
 * ```
 *
 * You can sequence exit animations throughout a tree using variants.
 *
 * If a child contains multiple `motion` components with `exit` props, it will only unmount the child
 * once all `motion` components have finished animating out. Likewise, any components using
 * `usePresence` all need to call `safeToRemove`.
 *
 * @public
 */
const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", }) => {
    (0,errors/* invariant */.V)(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
    /**
     * Filter any children that aren't ReactElements. We can only track components
     * between renders with a props.key.
     */
    const presentChildren = (0,react.useMemo)(() => onlyElements(children), [children]);
    /**
     * Track the keys of the currently rendered children. This is used to
     * determine which children are exiting.
     */
    const presentKeys = presentChildren.map(getChildKey);
    /**
     * If `initial={false}` we only want to pass this to components in the first render.
     */
    const isInitialRender = (0,react.useRef)(true);
    /**
     * A ref containing the currently present children. When all exit animations
     * are complete, we use this to re-render the component with the latest children
     * *committed* rather than the latest children *rendered*.
     */
    const pendingPresentChildren = (0,react.useRef)(presentChildren);
    /**
     * Track which exiting children have finished animating out.
     */
    const exitComplete = (0,use_constant/* useConstant */.M)(() => new Map());
    /**
     * Save children to render as React state. To ensure this component is concurrent-safe,
     * we check for exiting children via an effect.
     */
    const [diffedChildren, setDiffedChildren] = (0,react.useState)(presentChildren);
    const [renderedChildren, setRenderedChildren] = (0,react.useState)(presentChildren);
    (0,use_isomorphic_effect/* useIsomorphicLayoutEffect */.E)(() => {
        isInitialRender.current = false;
        pendingPresentChildren.current = presentChildren;
        /**
         * Update complete status of exiting children.
         */
        for (let i = 0; i < renderedChildren.length; i++) {
            const key = getChildKey(renderedChildren[i]);
            if (!presentKeys.includes(key)) {
                if (exitComplete.get(key) !== true) {
                    exitComplete.set(key, false);
                }
            }
            else {
                exitComplete.delete(key);
            }
        }
    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
    const exitingChildren = [];
    if (presentChildren !== diffedChildren) {
        let nextChildren = [...presentChildren];
        /**
         * Loop through all the currently rendered components and decide which
         * are exiting.
         */
        for (let i = 0; i < renderedChildren.length; i++) {
            const child = renderedChildren[i];
            const key = getChildKey(child);
            if (!presentKeys.includes(key)) {
                nextChildren.splice(i, 0, child);
                exitingChildren.push(child);
            }
        }
        /**
         * If we're in "wait" mode, and we have exiting children, we want to
         * only render these until they've all exited.
         */
        if (mode === "wait" && exitingChildren.length) {
            nextChildren = exitingChildren;
        }
        setRenderedChildren(onlyElements(nextChildren));
        setDiffedChildren(presentChildren);
        /**
         * Early return to ensure once we've set state with the latest diffed
         * children, we can immediately re-render.
         */
        return;
    }
    if (false) {}
    /**
     * If we've been provided a forceRender function by the LayoutGroupContext,
     * we can use it to force a re-render amongst all surrounding components once
     * all components have finished animating out.
     */
    const { forceRender } = (0,react.useContext)(LayoutGroupContext/* LayoutGroupContext */.L);
    return ((0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: renderedChildren.map((child) => {
            const key = getChildKey(child);
            const isPresent = presentChildren === renderedChildren ||
                presentKeys.includes(key);
            const onExit = () => {
                if (exitComplete.has(key)) {
                    exitComplete.set(key, true);
                }
                else {
                    return;
                }
                let isEveryExitComplete = true;
                exitComplete.forEach((isExitComplete) => {
                    if (!isExitComplete)
                        isEveryExitComplete = false;
                });
                if (isEveryExitComplete) {
                    forceRender === null || forceRender === void 0 ? void 0 : forceRender();
                    setRenderedChildren(pendingPresentChildren.current);
                    onExitComplete && onExitComplete();
                }
            };
            return ((0,jsx_runtime.jsx)(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial
                    ? undefined
                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, children: child }, key));
        }) }));
};




/***/ }),

/***/ "../../node_modules/.pnpm/gradient-parser@0.1.5/node_modules/gradient-parser/build/node.js":
/***/ ((__unused_webpack_module, exports) => {

// Copyright (c) 2014 Rafael Caricio. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var GradientParser = {};

GradientParser.parse = (function() {

  var tokens = {
    linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
    repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
    radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
    repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };

  var input = '';

  function error(msg) {
    var err = new Error(input + ': ' + msg);
    err.source = input;
    throw err;
  }

  function getAST() {
    var ast = matchListDefinitions();

    if (input.length > 0) {
      error('Invalid input not EOF');
    }

    return ast;
  }

  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }

  function matchDefinition() {
    return matchGradient(
            'linear-gradient',
            tokens.linearGradient,
            matchLinearOrientation) ||

          matchGradient(
            'repeating-linear-gradient',
            tokens.repeatingLinearGradient,
            matchLinearOrientation) ||

          matchGradient(
            'radial-gradient',
            tokens.radialGradient,
            matchListRadialOrientations) ||

          matchGradient(
            'repeating-radial-gradient',
            tokens.repeatingRadialGradient,
            matchListRadialOrientations);
  }

  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {

      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error('Missing comma before color stops');
        }
      }

      return {
        type: gradientType,
        orientation: orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }

  function matchCall(pattern, callback) {
    var captures = scan(pattern);

    if (captures) {
      if (!scan(tokens.startCall)) {
        error('Missing (');
      }

      result = callback(captures);

      if (!scan(tokens.endCall)) {
        error('Missing )');
      }

      return result;
    }
  }

  function matchLinearOrientation() {
    return matchSideOrCorner() ||
      matchAngle();
  }

  function matchSideOrCorner() {
    return match('directional', tokens.sideOrCorner, 1);
  }

  function matchAngle() {
    return match('angular', tokens.angleValue, 1);
  }

  function matchListRadialOrientations() {
    var radialOrientations,
        radialOrientation = matchRadialOrientation(),
        lookaheadCache;

    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);

      lookaheadCache = input;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }

    return radialOrientations;
  }

  function matchRadialOrientation() {
    var radialType = matchCircle() ||
      matchEllipse();

    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var defaultPosition = matchPositioning();
      if (defaultPosition) {
        radialType = {
          type: 'default-radial',
          at: defaultPosition
        };
      }
    }

    return radialType;
  }

  function matchCircle() {
    var circle = match('shape', /^(circle)/i, 0);

    if (circle) {
      circle.style = matchLength() || matchExtentKeyword();
    }

    return circle;
  }

  function matchEllipse() {
    var ellipse = match('shape', /^(ellipse)/i, 0);

    if (ellipse) {
      ellipse.style =  matchDistance() || matchExtentKeyword();
    }

    return ellipse;
  }

  function matchExtentKeyword() {
    return match('extent-keyword', tokens.extentKeywords, 1);
  }

  function matchAtPosition() {
    if (match('position', /^at/, 0)) {
      var positioning = matchPositioning();

      if (!positioning) {
        error('Missing positioning value');
      }

      return positioning;
    }
  }

  function matchPositioning() {
    var location = matchCoordinates();

    if (location.x || location.y) {
      return {
        type: 'position',
        value: location
      };
    }
  }

  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }

  function matchListing(matcher) {
    var captures = matcher(),
      result = [];

    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error('One extra comma');
        }
      }
    }

    return result;
  }

  function matchColorStop() {
    var color = matchColor();

    if (!color) {
      error('Expected color definition');
    }

    color.length = matchDistance();
    return color;
  }

  function matchColor() {
    return matchHexColor() ||
      matchRGBAColor() ||
      matchRGBColor() ||
      matchLiteralColor();
  }

  function matchLiteralColor() {
    return match('literal', tokens.literalColor, 0);
  }

  function matchHexColor() {
    return match('hex', tokens.hexColor, 1);
  }

  function matchRGBColor() {
    return matchCall(tokens.rgbColor, function() {
      return  {
        type: 'rgb',
        value: matchListing(matchNumber)
      };
    });
  }

  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, function() {
      return  {
        type: 'rgba',
        value: matchListing(matchNumber)
      };
    });
  }

  function matchNumber() {
    return scan(tokens.number)[1];
  }

  function matchDistance() {
    return match('%', tokens.percentageValue, 1) ||
      matchPositionKeyword() ||
      matchLength();
  }

  function matchPositionKeyword() {
    return match('position-keyword', tokens.positionKeywords, 1);
  }

  function matchLength() {
    return match('px', tokens.pixelValue, 1) ||
      match('em', tokens.emValue, 1);
  }

  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type: type,
        value: captures[captureIndex]
      };
    }
  }

  function scan(regexp) {
    var captures,
        blankCaptures;

    blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
        consume(blankCaptures[0].length);
    }

    captures = regexp.exec(input);
    if (captures) {
        consume(captures[0].length);
    }

    return captures;
  }

  function consume(size) {
    input = input.substr(size);
  }

  return function(code) {
    input = code.toString();
    return getAST();
  };
})();

exports.parse = (GradientParser || {}).parse;


/***/ }),

/***/ "../../node_modules/.pnpm/line-height@0.3.1/node_modules/line-height/lib/line-height.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Load in dependencies
var computedStyle = __webpack_require__("../../node_modules/.pnpm/computed-style@0.1.4/node_modules/computed-style/dist/computedStyle.commonjs.js");

/**
 * Calculate the `line-height` of a given node
 * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.
 * @returns {Number} `line-height` of the element in pixels
 */
function lineHeight(node) {
  // Grab the line-height via style
  var lnHeightStr = computedStyle(node, 'line-height');
  var lnHeight = parseFloat(lnHeightStr, 10);

  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')
  if (lnHeightStr === lnHeight + '') {
    // Save the old lineHeight style and update the em unit to the element
    var _lnHeightStyle = node.style.lineHeight;
    node.style.lineHeight = lnHeightStr + 'em';

    // Calculate the em based height
    lnHeightStr = computedStyle(node, 'line-height');
    lnHeight = parseFloat(lnHeightStr, 10);

    // Revert the lineHeight style
    if (_lnHeightStyle) {
      node.style.lineHeight = _lnHeightStyle;
    } else {
      delete node.style.lineHeight;
    }
  }

  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)
  // DEV: `em` units are converted to `pt` in IE6
  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length
  if (lnHeightStr.indexOf('pt') !== -1) {
    lnHeight *= 4;
    lnHeight /= 3;
  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)
  } else if (lnHeightStr.indexOf('mm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 25.4;
  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)
  } else if (lnHeightStr.indexOf('cm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 2.54;
  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)
  } else if (lnHeightStr.indexOf('in') !== -1) {
    lnHeight *= 96;
  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)
  } else if (lnHeightStr.indexOf('pc') !== -1) {
    lnHeight *= 16;
  }

  // Continue our computation
  lnHeight = Math.round(lnHeight);

  // If the line-height is "normal", calculate by font-size
  if (lnHeightStr === 'normal') {
    // Create a temporary node
    var nodeName = node.nodeName;
    var _node = document.createElement(nodeName);
    _node.innerHTML = '&nbsp;';

    // If we have a text area, reset it to only 1 row
    // https://github.com/twolfson/line-height/issues/4
    if (nodeName.toUpperCase() === 'TEXTAREA') {
      _node.setAttribute('rows', '1');
    }

    // Set the font-size of the element
    var fontSizeStr = computedStyle(node, 'font-size');
    _node.style.fontSize = fontSizeStr;

    // Remove default padding/border which can affect offset height
    // https://github.com/twolfson/line-height/issues/4
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight
    _node.style.padding = '0px';
    _node.style.border = '0px';

    // Append it to the body
    var body = document.body;
    body.appendChild(_node);

    // Assume the line height of the element is the height
    var height = _node.offsetHeight;
    lnHeight = height;

    // Remove our child from the DOM
    body.removeChild(_node);
  }

  // Return the calculated height
  return lnHeight;
}

// Export lineHeight
module.exports = lineHeight;


/***/ }),

/***/ "../../node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.browser.js":
/***/ ((module) => {

var x=String;
var create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x}};
module.exports=create();
module.exports.createColors = create;


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/Types.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/index.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
__webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/Types.js");
const postcss_1 = __importDefault(__webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/postcss.js"));
const PostCSSPlugin_1 = __importDefault(__webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/plugin/PostCSSPlugin.js"));
module.exports = (0, PostCSSPlugin_1.default)(postcss_1.default);


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/internal/domain/CSSRuleWrapper.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prefixWrapCSSSelector = exports.prefixWrapCSSRule = void 0;
const CSSSelector_1 = __webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/internal/domain/CSSSelector.js");
const prefixWrapCSSRule = (cssRule, nested, ignoredSelectors, prefixSelector, prefixRootTags) => {
    // Check each rule to see if it exactly matches our prefix selector, when
    // this happens, don't try to prefix that selector.
    const rules = cssRule.selectors.filter((selector) => !(0, CSSSelector_1.cssRuleMatchesPrefixSelector)({ selector: selector }, prefixSelector));
    if (rules.length === 0) {
        return;
    }
    cssRule.selector = rules
        .map((cssSelector) => (0, exports.prefixWrapCSSSelector)(cssSelector, cssRule, nested, ignoredSelectors, prefixSelector, prefixRootTags))
        .filter(CSSSelector_1.isValidCSSSelector)
        .join(", ");
};
exports.prefixWrapCSSRule = prefixWrapCSSRule;
const prefixWrapCSSSelector = (cssSelector, cssRule, nested, ignoredSelectors, prefixSelector, prefixRootTags) => {
    const cleanedSelector = (0, CSSSelector_1.cleanSelector)(cssSelector);
    if (cleanedSelector === "") {
        return null;
    }
    // Don't prefix nested selected.
    if (nested !== null && cleanedSelector.startsWith(nested, 0)) {
        return cleanedSelector;
    }
    // Do not prefix keyframes rules.
    if ((0, CSSSelector_1.isKeyframes)(cssRule)) {
        return cleanedSelector;
    }
    // Check for matching ignored selectors
    if (ignoredSelectors.some((currentValue) => cleanedSelector.match(currentValue))) {
        return cleanedSelector;
    }
    // Anything other than a root tag is always prefixed.
    if ((0, CSSSelector_1.isNotRootTag)(cleanedSelector)) {
        return prefixSelector + " " + cleanedSelector;
    }
    // Handle special case where root tags should be converted into classes
    // rather than being replaced.
    if (prefixRootTags) {
        return prefixSelector + " ." + cleanedSelector;
    }
    // HTML and Body elements cannot be contained within our container so lets
    // extract their styles.
    return cleanedSelector.replace(/^(body|html|:root)/, prefixSelector);
};
exports.prefixWrapCSSSelector = prefixWrapCSSSelector;


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/internal/domain/CSSSelector.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cssRuleMatchesPrefixSelector = exports.isNotRootTag = exports.isKeyframes = exports.cleanSelector = exports.isValidCSSSelector = void 0;
const ANY_WHITESPACE_AT_BEGINNING_OR_END = /(^\s*|\s*$)/g;
const IS_ROOT_TAG = /^(body|html|:root).*$/;
const isValidCSSSelector = (cssSelector) => {
    return cssSelector !== null;
};
exports.isValidCSSSelector = isValidCSSSelector;
const cleanSelector = (cssSelector) => {
    return cssSelector.replace(ANY_WHITESPACE_AT_BEGINNING_OR_END, "");
};
exports.cleanSelector = cleanSelector;
const isKeyframes = (cssRule) => {
    const { parent } = cssRule;
    const parentReal = parent;
    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
    return (parent !== undefined &&
        parentReal.type === "atrule" &&
        parentReal.name !== undefined &&
        parentReal.name.match(/keyframes$/) !== null);
};
exports.isKeyframes = isKeyframes;
const isNotRootTag = (cleanSelector) => {
    return !cleanSelector.match(IS_ROOT_TAG);
};
exports.isNotRootTag = isNotRootTag;
const cssRuleMatchesPrefixSelector = (cssRule, prefixSelector) => {
    const escapedPrefixSelector = prefixSelector.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const isPrefixSelector = new RegExp(`^${escapedPrefixSelector}$`);
    return isPrefixSelector.test(cssRule.selector);
};
exports.cssRuleMatchesPrefixSelector = cssRuleMatchesPrefixSelector;


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/internal/domain/FileIncludeList.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shouldIncludeFilePath = void 0;
const shouldIncludeFilePath = (filePath, whitelist, blacklist) => {
    // If whitelist exists, check if rule is contained within it.
    if (whitelist.length > 0) {
        return (filePath != undefined &&
            whitelist.some((currentValue) => filePath.match(currentValue)));
    }
    // If blacklist exists, check if rule is not contained within it.
    if (blacklist.length > 0) {
        return !(filePath != undefined &&
            blacklist.some((currentValue) => filePath.match(currentValue)));
    }
    // In all other cases, presume rule should be prefixed.
    return true;
};
exports.shouldIncludeFilePath = shouldIncludeFilePath;


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/plugin/PostCSS7Plugin.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asPostCSSv7PluginGenerator = void 0;
const PostCSSPrefixWrap_1 = __importStar(__webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/plugin/PostCSSPrefixWrap.js"));
const asPostCSSv7PluginGenerator = (postcss) => {
    return postcss.plugin(PostCSSPrefixWrap_1.PLUGIN_NAME, (prefixSelector, options) => {
        return new PostCSSPrefixWrap_1.default(prefixSelector, options).prefix();
    });
};
exports.asPostCSSv7PluginGenerator = asPostCSSv7PluginGenerator;


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/plugin/PostCSS8Plugin.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asPostCSSv8PluginGenerator = exports.isPostCSSv8 = void 0;
const PostCSSPrefixWrap_1 = __importStar(__webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/plugin/PostCSSPrefixWrap.js"));
const isPostCSSv8 = (postcss) => postcss.Root !== undefined;
exports.isPostCSSv8 = isPostCSSv8;
const asPostCSSv8PluginGenerator = () => {
    return (prefixSelector, options) => {
        const plugin = new PostCSSPrefixWrap_1.default(prefixSelector, options);
        return {
            postcssPlugin: PostCSSPrefixWrap_1.PLUGIN_NAME,
            Once(root) {
                plugin.prefixRoot(root);
            },
        };
    };
};
exports.asPostCSSv8PluginGenerator = asPostCSSv8PluginGenerator;


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/plugin/PostCSSPlugin.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const PostCSS8Plugin_1 = __webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/plugin/PostCSS8Plugin.js");
const PostCSS7Plugin_1 = __webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/plugin/PostCSS7Plugin.js");
module.exports = (postcss) => {
    if ((0, PostCSS8Plugin_1.isPostCSSv8)(postcss)) {
        return (0, PostCSS8Plugin_1.asPostCSSv8PluginGenerator)();
    }
    else {
        return (0, PostCSS7Plugin_1.asPostCSSv7PluginGenerator)(postcss);
    }
};


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/plugin/PostCSSPrefixWrap.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PLUGIN_NAME = void 0;
const CSSRuleWrapper_1 = __webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/internal/domain/CSSRuleWrapper.js");
const FileIncludeList_1 = __webpack_require__("../../node_modules/.pnpm/postcss-prefixwrap@1.53.0_postcss@8.4.32/node_modules/postcss-prefixwrap/build/internal/domain/FileIncludeList.js");
exports.PLUGIN_NAME = "postcss-prefixwrap";
class PostCSSPrefixWrap {
    blacklist;
    ignoredSelectors;
    isPrefixSelector;
    prefixRootTags;
    prefixSelector;
    whitelist;
    nested;
    constructor(prefixSelector, options = {}) {
        this.blacklist = options.blacklist ?? [];
        this.ignoredSelectors = options.ignoredSelectors ?? [];
        this.isPrefixSelector = new RegExp(`^${prefixSelector.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}$`);
        this.prefixRootTags = options.prefixRootTags ?? false;
        this.prefixSelector = prefixSelector;
        this.whitelist = options.whitelist ?? [];
        this.nested = options.nested ?? null;
    }
    prefixRoot(css) {
        if ((0, FileIncludeList_1.shouldIncludeFilePath)(css.source?.input?.file, this.whitelist, this.blacklist)) {
            css.walkRules((cssRule) => {
                (0, CSSRuleWrapper_1.prefixWrapCSSRule)(cssRule, this.nested, this.ignoredSelectors, this.prefixSelector, this.prefixRootTags);
            });
        }
    }
    prefix() {
        return (css) => {
            this.prefixRoot(css);
        };
    }
}
exports["default"] = PostCSSPrefixWrap;


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-urlrebase@1.4.0_postcss@8.4.32/node_modules/postcss-urlrebase/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CSSValueParser = __webpack_require__("../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/index.js")

/**
 * @type {import('postcss').PluginCreator}
 */
module.exports = (opts) => {

  const DEFAULTS = {
    skipHostRelativeUrls: true,
  }
  const config = Object.assign(DEFAULTS, opts)

  return {
    postcssPlugin: 'rebaseUrl',

    Declaration(decl) {
      // The faster way to find Declaration node
      const parsedValue = CSSValueParser(decl.value)

      let valueChanged = false
      parsedValue.walk(node => {
        if (node.type !== 'function' || node.value !== 'url') {
          return
        }

        const urlVal = node.nodes[0].value

        // bases relative URLs with rootUrl
        const basedUrl = new URL(urlVal, opts.rootUrl)

        // skip host-relative, already normalized URLs (e.g. `/images/image.jpg`, without `..`s)
        if ((basedUrl.pathname === urlVal) && config.skipHostRelativeUrls) {
          return false // skip this value
        }

        node.nodes[0].value = basedUrl.toString()
        valueChanged = true

        return false // do not walk deeper
      })

      if (valueChanged) {
        decl.value = CSSValueParser.stringify(parsedValue)
      }

    }
  }
}

module.exports.postcss = true


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__("../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js");
var walk = __webpack_require__("../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/walk.js");
var stringify = __webpack_require__("../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/stringify.js");

function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}

ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};

ValueParser.prototype.walk = function(cb, bubble) {
  walk(this.nodes, cb, bubble);
  return this;
};

ValueParser.unit = __webpack_require__("../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js");

ValueParser.walk = walk;

ValueParser.stringify = stringify;

module.exports = ValueParser;


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js":
/***/ ((module) => {

var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;

module.exports = function(input) {
  var tokens = [];
  var value = input;

  var next,
    quote,
    prev,
    token,
    escape,
    escapePos,
    whitespacePos,
    parenthesesOpenPos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;

  var name = "";
  var before = "";
  var after = "";

  while (pos < max) {
    // Whitespaces
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);

      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
        prev.sourceEndIndex += token.length;
      } else if (
        code === comma ||
        code === colon ||
        (code === slash &&
          value.charCodeAt(next + 1) !== star &&
          (!parent ||
            (parent && parent.type === "function" && parent.value !== "calc")))
      ) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          sourceEndIndex: next,
          value: token
        });
      }

      pos = next;

      // Quotes
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote: quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);
      token.sourceEndIndex = token.unclosed ? next : next + 1;
      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);

      // Comments
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      next = value.indexOf("*/", pos);

      token = {
        type: "comment",
        sourceIndex: pos,
        sourceEndIndex: next + 2
      };

      if (next === -1) {
        token.unclosed = true;
        next = value.length;
        token.sourceEndIndex = next;
      }

      token.value = value.slice(pos + 2, next);
      tokens.push(token);

      pos = next + 2;
      code = value.charCodeAt(pos);

      // Operation within calc
    } else if (
      (code === slash || code === star) &&
      parent &&
      parent.type === "function" &&
      parent.value === "calc"
    ) {
      token = value[pos];
      tokens.push({
        type: "word",
        sourceIndex: pos - before.length,
        sourceEndIndex: pos + token.length,
        value: token
      });
      pos += 1;
      code = value.charCodeAt(pos);

      // Dividers
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];

      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        sourceEndIndex: pos + token.length,
        value: token,
        before: before,
        after: ""
      });
      before = "";

      pos += 1;
      code = value.charCodeAt(pos);

      // Open parentheses
    } else if (openParentheses === code) {
      // Whitespaces after open parentheses
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      parenthesesOpenPos = pos;
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(parenthesesOpenPos + 1, next)
      };
      pos = next;

      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        // Whitespaces before closed
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (parenthesesOpenPos < whitespacePos) {
          if (pos !== whitespacePos + 1) {
            token.nodes = [
              {
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: whitespacePos + 1,
                value: value.slice(pos, whitespacePos + 1)
              }
            ];
          } else {
            token.nodes = [];
          }
          if (token.unclosed && whitespacePos + 1 !== next) {
            token.after = "";
            token.nodes.push({
              type: "space",
              sourceIndex: whitespacePos + 1,
              sourceEndIndex: next,
              value: value.slice(whitespacePos + 1, next)
            });
          } else {
            token.after = value.slice(whitespacePos + 1, next);
            token.sourceEndIndex = next;
          }
        } else {
          token.after = "";
          token.nodes = [];
        }
        pos = next + 1;
        token.sourceEndIndex = token.unclosed ? next : pos;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        token.sourceEndIndex = pos + 1;
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";

      // Close parentheses
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);

      parent.after = after;
      parent.sourceEndIndex += after.length;
      after = "";
      balanced -= 1;
      stack[stack.length - 1].sourceEndIndex = pos;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;

      // Words
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (
        next < max &&
        !(
          code <= 32 ||
          code === singleQuote ||
          code === doubleQuote ||
          code === comma ||
          code === colon ||
          code === slash ||
          code === openParentheses ||
          (code === star &&
            parent &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === slash &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === closeParentheses && balanced)
        )
      );
      token = value.slice(pos, next);

      if (openParentheses === code) {
        name = token;
      } else if (
        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&
        plus === token.charCodeAt(1) &&
        isUnicodeRange.test(token.slice(2))
      ) {
        tokens.push({
          type: "unicode-range",
          sourceIndex: pos,
          sourceEndIndex: next,
          value: token
        });
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          sourceEndIndex: next,
          value: token
        });
      }

      pos = next;
    }
  }

  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
    stack[pos].sourceEndIndex = value.length;
  }

  return stack[0].nodes;
};


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/stringify.js":
/***/ ((module) => {

function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;

  if (custom && (customResult = custom(node)) !== undefined) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify(node.nodes, custom);
    if (type !== "function") {
      return buf;
    }
    return (
      value +
      "(" +
      (node.before || "") +
      buf +
      (node.after || "") +
      (node.unclosed ? "" : ")")
    );
  }
  return value;
}

function stringify(nodes, custom) {
  var result, i;

  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}

module.exports = stringify;


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js":
/***/ ((module) => {

var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);

// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
  var code = value.charCodeAt(0);
  var nextCode;

  if (code === plus || code === minus) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    var nextNextCode = value.charCodeAt(2);

    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code === dot) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code >= 48 && code <= 57) {
    return true;
  }

  return false;
}

// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
  var pos = 0;
  var length = value.length;
  var code;
  var nextCode;
  var nextNextCode;

  if (length === 0 || !likeNumber(value)) {
    return false;
  }

  code = value.charCodeAt(pos);

  if (code === plus || code === minus) {
    pos++;
  }

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code < 48 || code > 57) {
      break;
    }

    pos += 1;
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);

  if (code === dot && nextCode >= 48 && nextCode <= 57) {
    pos += 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);
  nextNextCode = value.charCodeAt(pos + 2);

  if (
    (code === exp || code === EXP) &&
    ((nextCode >= 48 && nextCode <= 57) ||
      ((nextCode === plus || nextCode === minus) &&
        nextNextCode >= 48 &&
        nextNextCode <= 57))
  ) {
    pos += nextCode === plus || nextCode === minus ? 3 : 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  return {
    number: value.slice(0, pos),
    unit: value.slice(pos)
  };
};


/***/ }),

/***/ "../../node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/walk.js":
/***/ ((module) => {

module.exports = function walk(nodes, cb, bubble) {
  var i, max, node, result;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }

    if (
      result !== false &&
      node.type === "function" &&
      Array.isArray(node.nodes)
    ) {
      walk(node.nodes, cb, bubble);
    }

    if (bubble) {
      cb(node, i, nodes);
    }
  }
};


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/at-rule.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/container.js")

class AtRule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'atrule'
  }

  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.append(...children)
  }

  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.prepend(...children)
  }
}

module.exports = AtRule
AtRule.default = AtRule

Container.registerAtRule(AtRule)


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/comment.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Node = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/node.js")

class Comment extends Node {
  constructor(defaults) {
    super(defaults)
    this.type = 'comment'
  }
}

module.exports = Comment
Comment.default = Comment


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/container.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { isClean, my } = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/symbols.js")
let Declaration = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/declaration.js")
let Comment = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/comment.js")
let Node = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/node.js")

let parse, Rule, AtRule, Root

function cleanSource(nodes) {
  return nodes.map(i => {
    if (i.nodes) i.nodes = cleanSource(i.nodes)
    delete i.source
    return i
  })
}

function markDirtyUp(node) {
  node[isClean] = false
  if (node.proxyOf.nodes) {
    for (let i of node.proxyOf.nodes) {
      markDirtyUp(i)
    }
  }
}

class Container extends Node {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last)
      for (let node of nodes) this.proxyOf.nodes.push(node)
    }

    this.markDirty()

    return this
  }

  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween)
    if (this.nodes) {
      for (let node of this.nodes) node.cleanRaws(keepBetween)
    }
  }

  each(callback) {
    if (!this.proxyOf.nodes) return undefined
    let iterator = this.getIterator()

    let index, result
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator]
      result = callback(this.proxyOf.nodes[index], index)
      if (result === false) break

      this.indexes[iterator] += 1
    }

    delete this.indexes[iterator]
    return result
  }

  every(condition) {
    return this.nodes.every(condition)
  }

  getIterator() {
    if (!this.lastEach) this.lastEach = 0
    if (!this.indexes) this.indexes = {}

    this.lastEach += 1
    let iterator = this.lastEach
    this.indexes[iterator] = 0

    return iterator
  }

  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (!node[prop]) {
          return node[prop]
        } else if (
          prop === 'each' ||
          (typeof prop === 'string' && prop.startsWith('walk'))
        ) {
          return (...args) => {
            return node[prop](
              ...args.map(i => {
                if (typeof i === 'function') {
                  return (child, index) => i(child.toProxy(), index)
                } else {
                  return i
                }
              })
            )
          }
        } else if (prop === 'every' || prop === 'some') {
          return cb => {
            return node[prop]((child, ...other) =>
              cb(child.toProxy(), ...other)
            )
          }
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else if (prop === 'nodes') {
          return node.nodes.map(i => i.toProxy())
        } else if (prop === 'first' || prop === 'last') {
          return node[prop].toProxy()
        } else {
          return node[prop]
        }
      },

      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (prop === 'name' || prop === 'params' || prop === 'selector') {
          node.markDirty()
        }
        return true
      }
    }
  }

  index(child) {
    if (typeof child === 'number') return child
    if (child.proxyOf) child = child.proxyOf
    return this.proxyOf.nodes.indexOf(child)
  }

  insertAfter(exist, add) {
    let existIndex = this.index(exist)
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex < index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  insertBefore(exist, add) {
    let existIndex = this.index(exist)
    let type = existIndex === 0 ? 'prepend' : false
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex <= index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  normalize(nodes, sample) {
    if (typeof nodes === 'string') {
      nodes = cleanSource(parse(nodes).nodes)
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type === 'root' && this.type !== 'document') {
      nodes = nodes.nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type) {
      nodes = [nodes]
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation')
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value)
      }
      nodes = [new Declaration(nodes)]
    } else if (nodes.selector) {
      nodes = [new Rule(nodes)]
    } else if (nodes.name) {
      nodes = [new AtRule(nodes)]
    } else if (nodes.text) {
      nodes = [new Comment(nodes)]
    } else {
      throw new Error('Unknown node type in node creation')
    }

    let processed = nodes.map(i => {
      /* c8 ignore next */
      if (!i[my]) Container.rebuild(i)
      i = i.proxyOf
      if (i.parent) i.parent.removeChild(i)
      if (i[isClean]) markDirtyUp(i)
      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/\S/g, '')
        }
      }
      i.parent = this.proxyOf
      return i
    })

    return processed
  }

  prepend(...children) {
    children = children.reverse()
    for (let child of children) {
      let nodes = this.normalize(child, this.first, 'prepend').reverse()
      for (let node of nodes) this.proxyOf.nodes.unshift(node)
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  push(child) {
    child.parent = this
    this.proxyOf.nodes.push(child)
    return this
  }

  removeAll() {
    for (let node of this.proxyOf.nodes) node.parent = undefined
    this.proxyOf.nodes = []

    this.markDirty()

    return this
  }

  removeChild(child) {
    child = this.index(child)
    this.proxyOf.nodes[child].parent = undefined
    this.proxyOf.nodes.splice(child, 1)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (index >= child) {
        this.indexes[id] = index - 1
      }
    }

    this.markDirty()

    return this
  }

  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts
      opts = {}
    }

    this.walkDecls(decl => {
      if (opts.props && !opts.props.includes(decl.prop)) return
      if (opts.fast && !decl.value.includes(opts.fast)) return

      decl.value = decl.value.replace(pattern, callback)
    })

    this.markDirty()

    return this
  }

  some(condition) {
    return this.nodes.some(condition)
  }

  walk(callback) {
    return this.each((child, i) => {
      let result
      try {
        result = callback(child, i)
      } catch (e) {
        throw child.addToError(e)
      }
      if (result !== false && child.walk) {
        result = child.walk(callback)
      }

      return result
    })
  }

  walkAtRules(name, callback) {
    if (!callback) {
      callback = name
      return this.walk((child, i) => {
        if (child.type === 'atrule') {
          return callback(child, i)
        }
      })
    }
    if (name instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i)
      }
    })
  }

  walkComments(callback) {
    return this.walk((child, i) => {
      if (child.type === 'comment') {
        return callback(child, i)
      }
    })
  }

  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop
      return this.walk((child, i) => {
        if (child.type === 'decl') {
          return callback(child, i)
        }
      })
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i)
      }
    })
  }

  walkRules(selector, callback) {
    if (!callback) {
      callback = selector

      return this.walk((child, i) => {
        if (child.type === 'rule') {
          return callback(child, i)
        }
      })
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i)
      }
    })
  }

  get first() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[0]
  }

  get last() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
  }
}

Container.registerParse = dependant => {
  parse = dependant
}

Container.registerRule = dependant => {
  Rule = dependant
}

Container.registerAtRule = dependant => {
  AtRule = dependant
}

Container.registerRoot = dependant => {
  Root = dependant
}

module.exports = Container
Container.default = Container

/* c8 ignore start */
Container.rebuild = node => {
  if (node.type === 'atrule') {
    Object.setPrototypeOf(node, AtRule.prototype)
  } else if (node.type === 'rule') {
    Object.setPrototypeOf(node, Rule.prototype)
  } else if (node.type === 'decl') {
    Object.setPrototypeOf(node, Declaration.prototype)
  } else if (node.type === 'comment') {
    Object.setPrototypeOf(node, Comment.prototype)
  } else if (node.type === 'root') {
    Object.setPrototypeOf(node, Root.prototype)
  }

  node[my] = true

  if (node.nodes) {
    node.nodes.forEach(child => {
      Container.rebuild(child)
    })
  }
}
/* c8 ignore stop */


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/css-syntax-error.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let pico = __webpack_require__("../../node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.browser.js")

let terminalHighlight = __webpack_require__("?1221")

class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin) {
    super(message)
    this.name = 'CssSyntaxError'
    this.reason = message

    if (file) {
      this.file = file
    }
    if (source) {
      this.source = source
    }
    if (plugin) {
      this.plugin = plugin
    }
    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      if (typeof line === 'number') {
        this.line = line
        this.column = column
      } else {
        this.line = line.line
        this.column = line.column
        this.endLine = column.line
        this.endColumn = column.column
      }
    }

    this.setMessage()

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError)
    }
  }

  setMessage() {
    this.message = this.plugin ? this.plugin + ': ' : ''
    this.message += this.file ? this.file : '<css input>'
    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column
    }
    this.message += ': ' + this.reason
  }

  showSourceCode(color) {
    if (!this.source) return ''

    let css = this.source
    if (color == null) color = pico.isColorSupported
    if (terminalHighlight) {
      if (color) css = terminalHighlight(css)
    }

    let lines = css.split(/\r?\n/)
    let start = Math.max(this.line - 3, 0)
    let end = Math.min(this.line + 2, lines.length)

    let maxWidth = String(end).length

    let mark, aside
    if (color) {
      let { bold, gray, red } = pico.createColors(true)
      mark = text => bold(red(text))
      aside = text => gray(text)
    } else {
      mark = aside = str => str
    }

    return lines
      .slice(start, end)
      .map((line, index) => {
        let number = start + 1 + index
        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '
        if (number === this.line) {
          let spacing =
            aside(gutter.replace(/\d/g, ' ')) +
            line.slice(0, this.column - 1).replace(/[^\t]/g, ' ')
          return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^')
        }
        return ' ' + aside(gutter) + line
      })
      .join('\n')
  }

  toString() {
    let code = this.showSourceCode()
    if (code) {
      code = '\n\n' + code + '\n'
    }
    return this.name + ': ' + this.message + code
  }
}

module.exports = CssSyntaxError
CssSyntaxError.default = CssSyntaxError


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/declaration.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Node = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/node.js")

class Declaration extends Node {
  constructor(defaults) {
    if (
      defaults &&
      typeof defaults.value !== 'undefined' &&
      typeof defaults.value !== 'string'
    ) {
      defaults = { ...defaults, value: String(defaults.value) }
    }
    super(defaults)
    this.type = 'decl'
  }

  get variable() {
    return this.prop.startsWith('--') || this.prop[0] === '$'
  }
}

module.exports = Declaration
Declaration.default = Declaration


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/document.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/container.js")

let LazyResult, Processor

class Document extends Container {
  constructor(defaults) {
    // type needs to be passed to super, otherwise child roots won't be normalized correctly
    super({ type: 'document', ...defaults })

    if (!this.nodes) {
      this.nodes = []
    }
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)

    return lazy.stringify()
  }
}

Document.registerLazyResult = dependant => {
  LazyResult = dependant
}

Document.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Document
Document.default = Document


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/fromJSON.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Declaration = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/declaration.js")
let PreviousMap = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/previous-map.js")
let Comment = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/comment.js")
let AtRule = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/at-rule.js")
let Input = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/input.js")
let Root = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/root.js")
let Rule = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/rule.js")

function fromJSON(json, inputs) {
  if (Array.isArray(json)) return json.map(n => fromJSON(n))

  let { inputs: ownInputs, ...defaults } = json
  if (ownInputs) {
    inputs = []
    for (let input of ownInputs) {
      let inputHydrated = { ...input, __proto__: Input.prototype }
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap.prototype
        }
      }
      inputs.push(inputHydrated)
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source
    defaults.source = source
    if (inputId != null) {
      defaults.source.input = inputs[inputId]
    }
  }
  if (defaults.type === 'root') {
    return new Root(defaults)
  } else if (defaults.type === 'decl') {
    return new Declaration(defaults)
  } else if (defaults.type === 'rule') {
    return new Rule(defaults)
  } else if (defaults.type === 'comment') {
    return new Comment(defaults)
  } else if (defaults.type === 'atrule') {
    return new AtRule(defaults)
  } else {
    throw new Error('Unknown node type: ' + json.type)
  }
}

module.exports = fromJSON
fromJSON.default = fromJSON


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/input.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__("?fec9")
let { fileURLToPath, pathToFileURL } = __webpack_require__("?657e")
let { isAbsolute, resolve } = __webpack_require__("?09e8")
let { nanoid } = __webpack_require__("../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/non-secure/index.cjs")

let terminalHighlight = __webpack_require__("?1221")
let CssSyntaxError = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/css-syntax-error.js")
let PreviousMap = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/previous-map.js")

let fromOffsetCache = Symbol('fromOffsetCache')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(resolve && isAbsolute)

class Input {
  constructor(css, opts = {}) {
    if (
      css === null ||
      typeof css === 'undefined' ||
      (typeof css === 'object' && !css.toString)
    ) {
      throw new Error(`PostCSS received ${css} instead of CSS string`)
    }

    this.css = css.toString()

    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
      this.hasBOM = true
      this.css = this.css.slice(1)
    } else {
      this.hasBOM = false
    }

    if (opts.from) {
      if (
        !pathAvailable ||
        /^\w+:\/\//.test(opts.from) ||
        isAbsolute(opts.from)
      ) {
        this.file = opts.from
      } else {
        this.file = resolve(opts.from)
      }
    }

    if (pathAvailable && sourceMapAvailable) {
      let map = new PreviousMap(this.css, opts)
      if (map.text) {
        this.map = map
        let file = map.consumer().file
        if (!this.file && file) this.file = this.mapResolve(file)
      }
    }

    if (!this.file) {
      this.id = '<input css ' + nanoid(6) + '>'
    }
    if (this.map) this.map.file = this.from
  }

  error(message, line, column, opts = {}) {
    let result, endLine, endColumn

    if (line && typeof line === 'object') {
      let start = line
      let end = column
      if (typeof start.offset === 'number') {
        let pos = this.fromOffset(start.offset)
        line = pos.line
        column = pos.col
      } else {
        line = start.line
        column = start.column
      }
      if (typeof end.offset === 'number') {
        let pos = this.fromOffset(end.offset)
        endLine = pos.line
        endColumn = pos.col
      } else {
        endLine = end.line
        endColumn = end.column
      }
    } else if (!column) {
      let pos = this.fromOffset(line)
      line = pos.line
      column = pos.col
    }

    let origin = this.origin(line, column, endLine, endColumn)
    if (origin) {
      result = new CssSyntaxError(
        message,
        origin.endLine === undefined
          ? origin.line
          : { column: origin.column, line: origin.line },
        origin.endLine === undefined
          ? origin.column
          : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      )
    } else {
      result = new CssSyntaxError(
        message,
        endLine === undefined ? line : { column, line },
        endLine === undefined ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      )
    }

    result.input = { column, endColumn, endLine, line, source: this.css }
    if (this.file) {
      if (pathToFileURL) {
        result.input.url = pathToFileURL(this.file).toString()
      }
      result.input.file = this.file
    }

    return result
  }

  fromOffset(offset) {
    let lastLine, lineToIndex
    if (!this[fromOffsetCache]) {
      let lines = this.css.split('\n')
      lineToIndex = new Array(lines.length)
      let prevIndex = 0

      for (let i = 0, l = lines.length; i < l; i++) {
        lineToIndex[i] = prevIndex
        prevIndex += lines[i].length + 1
      }

      this[fromOffsetCache] = lineToIndex
    } else {
      lineToIndex = this[fromOffsetCache]
    }
    lastLine = lineToIndex[lineToIndex.length - 1]

    let min = 0
    if (offset >= lastLine) {
      min = lineToIndex.length - 1
    } else {
      let max = lineToIndex.length - 2
      let mid
      while (min < max) {
        mid = min + ((max - min) >> 1)
        if (offset < lineToIndex[mid]) {
          max = mid - 1
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1
        } else {
          min = mid
          break
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    }
  }

  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file
    }
    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
  }

  origin(line, column, endLine, endColumn) {
    if (!this.map) return false
    let consumer = this.map.consumer()

    let from = consumer.originalPositionFor({ column, line })
    if (!from.source) return false

    let to
    if (typeof endLine === 'number') {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine })
    }

    let fromUrl

    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL(from.source)
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
      )
    }

    let result = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    }

    if (fromUrl.protocol === 'file:') {
      if (fileURLToPath) {
        result.file = fileURLToPath(fromUrl)
      } else {
        /* c8 ignore next 2 */
        throw new Error(`file: protocol is not available in this PostCSS build`)
      }
    }

    let source = consumer.sourceContentFor(from.source)
    if (source) result.source = source

    return result
  }

  toJSON() {
    let json = {}
    for (let name of ['hasBOM', 'css', 'file', 'id']) {
      if (this[name] != null) {
        json[name] = this[name]
      }
    }
    if (this.map) {
      json.map = { ...this.map }
      if (json.map.consumerCache) {
        json.map.consumerCache = undefined
      }
    }
    return json
  }

  get from() {
    return this.file || this.id
  }
}

module.exports = Input
Input.default = Input

if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input)
}


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/lazy-result.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { isClean, my } = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/symbols.js")
let MapGenerator = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/map-generator.js")
let stringify = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/stringify.js")
let Container = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/container.js")
let Document = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/document.js")
let warnOnce = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/warn-once.js")
let Result = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/result.js")
let parse = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/parse.js")
let Root = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/root.js")

const TYPE_TO_CLASS_NAME = {
  atrule: 'AtRule',
  comment: 'Comment',
  decl: 'Declaration',
  document: 'Document',
  root: 'Root',
  rule: 'Rule'
}

const PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
}

const NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
}

const CHILDREN = 0

function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function'
}

function getEvents(node) {
  let key = false
  let type = TYPE_TO_CLASS_NAME[node.type]
  if (node.type === 'decl') {
    key = node.prop.toLowerCase()
  } else if (node.type === 'atrule') {
    key = node.name.toLowerCase()
  }

  if (key && node.append) {
    return [
      type,
      type + '-' + key,
      CHILDREN,
      type + 'Exit',
      type + 'Exit-' + key
    ]
  } else if (key) {
    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
  } else if (node.append) {
    return [type, CHILDREN, type + 'Exit']
  } else {
    return [type, type + 'Exit']
  }
}

function toStack(node) {
  let events
  if (node.type === 'document') {
    events = ['Document', CHILDREN, 'DocumentExit']
  } else if (node.type === 'root') {
    events = ['Root', CHILDREN, 'RootExit']
  } else {
    events = getEvents(node)
  }

  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node,
    visitorIndex: 0,
    visitors: []
  }
}

function cleanMarks(node) {
  node[isClean] = false
  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))
  return node
}

let postcss = {}

class LazyResult {
  constructor(processor, css, opts) {
    this.stringified = false
    this.processed = false

    let root
    if (
      typeof css === 'object' &&
      css !== null &&
      (css.type === 'root' || css.type === 'document')
    ) {
      root = cleanMarks(css)
    } else if (css instanceof LazyResult || css instanceof Result) {
      root = cleanMarks(css.root)
      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {}
        if (!opts.map.inline) opts.map.inline = false
        opts.map.prev = css.map
      }
    } else {
      let parser = parse
      if (opts.syntax) parser = opts.syntax.parse
      if (opts.parser) parser = opts.parser
      if (parser.parse) parser = parser.parse

      try {
        root = parser(css, opts)
      } catch (error) {
        this.processed = true
        this.error = error
      }

      if (root && !root[my]) {
        /* c8 ignore next 2 */
        Container.rebuild(root)
      }
    }

    this.result = new Result(processor, root, opts)
    this.helpers = { ...postcss, postcss, result: this.result }
    this.plugins = this.processor.plugins.map(plugin => {
      if (typeof plugin === 'object' && plugin.prepare) {
        return { ...plugin, ...plugin.prepare(this.result) }
      } else {
        return plugin
      }
    })
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    if (this.processed) return Promise.resolve(this.result)
    if (!this.processing) {
      this.processing = this.runAsync()
    }
    return this.processing
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  getAsyncError() {
    throw new Error('Use process(css).then(cb) to work with async plugins')
  }

  handleError(error, node) {
    let plugin = this.result.lastPlugin
    try {
      if (node) node.addToError(error)
      this.error = error
      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin
        error.setMessage()
      } else if (plugin.postcssVersion) {
        if (false) {}
      }
    } catch (err) {
      /* c8 ignore next 3 */
      // eslint-disable-next-line no-console
      if (console && console.error) console.error(err)
    }
    return error
  }

  prepareVisitors() {
    this.listeners = {}
    let add = (plugin, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = []
      this.listeners[type].push([plugin, cb])
    }
    for (let plugin of this.plugins) {
      if (typeof plugin === 'object') {
        for (let event in plugin) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
                `Try to update PostCSS (${this.processor.version} now).`
            )
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin[event] === 'object') {
              for (let filter in plugin[event]) {
                if (filter === '*') {
                  add(plugin, event, plugin[event][filter])
                } else {
                  add(
                    plugin,
                    event + '-' + filter.toLowerCase(),
                    plugin[event][filter]
                  )
                }
              }
            } else if (typeof plugin[event] === 'function') {
              add(plugin, event, plugin[event])
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0
  }

  async runAsync() {
    this.plugin = 0
    for (let i = 0; i < this.plugins.length; i++) {
      let plugin = this.plugins[i]
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        try {
          await promise
        } catch (error) {
          throw this.handleError(error)
        }
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        let stack = [toStack(root)]
        while (stack.length > 0) {
          let promise = this.visitTick(stack)
          if (isPromise(promise)) {
            try {
              await promise
            } catch (e) {
              let node = stack[stack.length - 1].node
              throw this.handleError(e, node)
            }
          }
        }
      }

      if (this.listeners.OnceExit) {
        for (let [plugin, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin
          try {
            if (root.type === 'document') {
              let roots = root.nodes.map(subRoot =>
                visitor(subRoot, this.helpers)
              )

              await Promise.all(roots)
            } else {
              await visitor(root, this.helpers)
            }
          } catch (e) {
            throw this.handleError(e)
          }
        }
      }
    }

    this.processed = true
    return this.stringify()
  }

  runOnRoot(plugin) {
    this.result.lastPlugin = plugin
    try {
      if (typeof plugin === 'object' && plugin.Once) {
        if (this.result.root.type === 'document') {
          let roots = this.result.root.nodes.map(root =>
            plugin.Once(root, this.helpers)
          )

          if (isPromise(roots[0])) {
            return Promise.all(roots)
          }

          return roots
        }

        return plugin.Once(this.result.root, this.helpers)
      } else if (typeof plugin === 'function') {
        return plugin(this.result.root, this.result)
      }
    } catch (error) {
      throw this.handleError(error)
    }
  }

  stringify() {
    if (this.error) throw this.error
    if (this.stringified) return this.result
    this.stringified = true

    this.sync()

    let opts = this.result.opts
    let str = stringify
    if (opts.syntax) str = opts.syntax.stringify
    if (opts.stringifier) str = opts.stringifier
    if (str.stringify) str = str.stringify

    let map = new MapGenerator(str, this.result.root, this.result.opts)
    let data = map.generate()
    this.result.css = data[0]
    this.result.map = data[1]

    return this.result
  }

  sync() {
    if (this.error) throw this.error
    if (this.processed) return this.result
    this.processed = true

    if (this.processing) {
      throw this.getAsyncError()
    }

    for (let plugin of this.plugins) {
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        this.walkSync(root)
      }
      if (this.listeners.OnceExit) {
        if (root.type === 'document') {
          for (let subRoot of root.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot)
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root)
        }
      }
    }

    return this.result
  }

  then(onFulfilled, onRejected) {
    if (false) {}
    return this.async().then(onFulfilled, onRejected)
  }

  toString() {
    return this.css
  }

  visitSync(visitors, node) {
    for (let [plugin, visitor] of visitors) {
      this.result.lastPlugin = plugin
      let promise
      try {
        promise = visitor(node, this.helpers)
      } catch (e) {
        throw this.handleError(e, node.proxyOf)
      }
      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
        return true
      }
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }
  }

  visitTick(stack) {
    let visit = stack[stack.length - 1]
    let { node, visitors } = visit

    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
      stack.pop()
      return
    }

    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
      let [plugin, visitor] = visitors[visit.visitorIndex]
      visit.visitorIndex += 1
      if (visit.visitorIndex === visitors.length) {
        visit.visitors = []
        visit.visitorIndex = 0
      }
      this.result.lastPlugin = plugin
      try {
        return visitor(node.toProxy(), this.helpers)
      } catch (e) {
        throw this.handleError(e, node)
      }
    }

    if (visit.iterator !== 0) {
      let iterator = visit.iterator
      let child
      while ((child = node.nodes[node.indexes[iterator]])) {
        node.indexes[iterator] += 1
        if (!child[isClean]) {
          child[isClean] = true
          stack.push(toStack(child))
          return
        }
      }
      visit.iterator = 0
      delete node.indexes[iterator]
    }

    let events = visit.events
    while (visit.eventIndex < events.length) {
      let event = events[visit.eventIndex]
      visit.eventIndex += 1
      if (event === CHILDREN) {
        if (node.nodes && node.nodes.length) {
          node[isClean] = true
          visit.iterator = node.getIterator()
        }
        return
      } else if (this.listeners[event]) {
        visit.visitors = this.listeners[event]
        return
      }
    }
    stack.pop()
  }

  walkSync(node) {
    node[isClean] = true
    let events = getEvents(node)
    for (let event of events) {
      if (event === CHILDREN) {
        if (node.nodes) {
          node.each(child => {
            if (!child[isClean]) this.walkSync(child)
          })
        }
      } else {
        let visitors = this.listeners[event]
        if (visitors) {
          if (this.visitSync(visitors, node.toProxy())) return
        }
      }
    }
  }

  warnings() {
    return this.sync().warnings()
  }

  get content() {
    return this.stringify().content
  }

  get css() {
    return this.stringify().css
  }

  get map() {
    return this.stringify().map
  }

  get messages() {
    return this.sync().messages
  }

  get opts() {
    return this.result.opts
  }

  get processor() {
    return this.result.processor
  }

  get root() {
    return this.sync().root
  }

  get [Symbol.toStringTag]() {
    return 'LazyResult'
  }
}

LazyResult.registerPostcss = dependant => {
  postcss = dependant
}

module.exports = LazyResult
LazyResult.default = LazyResult

Root.registerLazyResult(LazyResult)
Document.registerLazyResult(LazyResult)


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/list.js":
/***/ ((module) => {

"use strict";


let list = {
  comma(string) {
    return list.split(string, [','], true)
  },

  space(string) {
    let spaces = [' ', '\n', '\t']
    return list.split(string, spaces)
  },

  split(string, separators, last) {
    let array = []
    let current = ''
    let split = false

    let func = 0
    let inQuote = false
    let prevQuote = ''
    let escape = false

    for (let letter of string) {
      if (escape) {
        escape = false
      } else if (letter === '\\') {
        escape = true
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true
        prevQuote = letter
      } else if (letter === '(') {
        func += 1
      } else if (letter === ')') {
        if (func > 0) func -= 1
      } else if (func === 0) {
        if (separators.includes(letter)) split = true
      }

      if (split) {
        if (current !== '') array.push(current.trim())
        current = ''
        split = false
      } else {
        current += letter
      }
    }

    if (last || current !== '') array.push(current.trim())
    return array
  }
}

module.exports = list
list.default = list


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/map-generator.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__("?fec9")
let { dirname, relative, resolve, sep } = __webpack_require__("?09e8")
let { pathToFileURL } = __webpack_require__("?657e")

let Input = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/input.js")

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(dirname && resolve && relative && sep)

class MapGenerator {
  constructor(stringify, root, opts, cssString) {
    this.stringify = stringify
    this.mapOpts = opts.map || {}
    this.root = root
    this.opts = opts
    this.css = cssString
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute

    this.memoizedFileURLs = new Map()
    this.memoizedPaths = new Map()
    this.memoizedURLs = new Map()
  }

  addAnnotation() {
    let content

    if (this.isInline()) {
      content =
        'data:application/json;base64,' + this.toBase64(this.map.toString())
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation
    } else if (typeof this.mapOpts.annotation === 'function') {
      content = this.mapOpts.annotation(this.opts.to, this.root)
    } else {
      content = this.outputFile() + '.map'
    }
    let eol = '\n'
    if (this.css.includes('\r\n')) eol = '\r\n'

    this.css += eol + '/*# sourceMappingURL=' + content + ' */'
  }

  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file))
      let root = prev.root || dirname(prev.file)
      let map

      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text)
        if (map.sourcesContent) {
          map.sourcesContent = map.sourcesContent.map(() => null)
        }
      } else {
        map = prev.consumer()
      }

      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))
    }
  }

  clearAnnotation() {
    if (this.mapOpts.annotation === false) return

    if (this.root) {
      let node
      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
        node = this.root.nodes[i]
        if (node.type !== 'comment') continue
        if (node.text.indexOf('# sourceMappingURL=') === 0) {
          this.root.removeChild(i)
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, '')
    }
  }

  generate() {
    this.clearAnnotation()
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap()
    } else {
      let result = ''
      this.stringify(this.root, i => {
        result += i
      })
      return [result]
    }
  }

  generateMap() {
    if (this.root) {
      this.generateString()
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer()
      prev.file = this.outputFile()
      this.map = SourceMapGenerator.fromSourceMap(prev)
    } else {
      this.map = new SourceMapGenerator({ file: this.outputFile() })
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from
          ? this.toUrl(this.path(this.opts.from))
          : '<no source>'
      })
    }

    if (this.isSourcesContent()) this.setSourcesContent()
    if (this.root && this.previous().length > 0) this.applyPrevMaps()
    if (this.isAnnotation()) this.addAnnotation()

    if (this.isInline()) {
      return [this.css]
    } else {
      return [this.css, this.map]
    }
  }

  generateString() {
    this.css = ''
    this.map = new SourceMapGenerator({ file: this.outputFile() })

    let line = 1
    let column = 1

    let noSource = '<no source>'
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ''
    }

    let lines, last
    this.stringify(this.root, (str, node, type) => {
      this.css += str

      if (node && type !== 'end') {
        mapping.generated.line = line
        mapping.generated.column = column - 1
        if (node.source && node.source.start) {
          mapping.source = this.sourcePath(node)
          mapping.original.line = node.source.start.line
          mapping.original.column = node.source.start.column - 1
          this.map.addMapping(mapping)
        } else {
          mapping.source = noSource
          mapping.original.line = 1
          mapping.original.column = 0
          this.map.addMapping(mapping)
        }
      }

      lines = str.match(/\n/g)
      if (lines) {
        line += lines.length
        last = str.lastIndexOf('\n')
        column = str.length - last
      } else {
        column += str.length
      }

      if (node && type !== 'start') {
        let p = node.parent || { raws: {} }
        let childless =
          node.type === 'decl' || (node.type === 'atrule' && !node.nodes)
        if (!childless || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            mapping.source = this.sourcePath(node)
            mapping.original.line = node.source.end.line
            mapping.original.column = node.source.end.column - 1
            mapping.generated.line = line
            mapping.generated.column = column - 2
            this.map.addMapping(mapping)
          } else {
            mapping.source = noSource
            mapping.original.line = 1
            mapping.original.column = 0
            mapping.generated.line = line
            mapping.generated.column = column - 1
            this.map.addMapping(mapping)
          }
        }
      }
    })
  }

  isAnnotation() {
    if (this.isInline()) {
      return true
    }
    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation
    }
    if (this.previous().length) {
      return this.previous().some(i => i.annotation)
    }
    return true
  }

  isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline
    }

    let annotation = this.mapOpts.annotation
    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false
    }

    if (this.previous().length) {
      return this.previous().some(i => i.inline)
    }
    return true
  }

  isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map
    }
    return this.previous().length > 0
  }

  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent
    }
    if (this.previous().length) {
      return this.previous().some(i => i.withContent())
    }
    return true
  }

  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to)
    } else if (this.opts.from) {
      return this.path(this.opts.from)
    } else {
      return 'to.css'
    }
  }

  path(file) {
    if (this.mapOpts.absolute) return file
    if (file.charCodeAt(0) === 60 /* `<` */) return file
    if (/^\w+:\/\//.test(file)) return file
    let cached = this.memoizedPaths.get(file)
    if (cached) return cached

    let from = this.opts.to ? dirname(this.opts.to) : '.'

    if (typeof this.mapOpts.annotation === 'string') {
      from = dirname(resolve(from, this.mapOpts.annotation))
    }

    let path = relative(from, file)
    this.memoizedPaths.set(file, path)

    return path
  }

  previous() {
    if (!this.previousMaps) {
      this.previousMaps = []
      if (this.root) {
        this.root.walk(node => {
          if (node.source && node.source.input.map) {
            let map = node.source.input.map
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map)
            }
          }
        })
      } else {
        let input = new Input(this.css, this.opts)
        if (input.map) this.previousMaps.push(input.map)
      }
    }

    return this.previousMaps
  }

  setSourcesContent() {
    let already = {}
    if (this.root) {
      this.root.walk(node => {
        if (node.source) {
          let from = node.source.input.from
          if (from && !already[from]) {
            already[from] = true
            let fromUrl = this.usesFileUrls
              ? this.toFileUrl(from)
              : this.toUrl(this.path(from))
            this.map.setSourceContent(fromUrl, node.source.input.css)
          }
        }
      })
    } else if (this.css) {
      let from = this.opts.from
        ? this.toUrl(this.path(this.opts.from))
        : '<no source>'
      this.map.setSourceContent(from, this.css)
    }
  }

  sourcePath(node) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from)
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node.source.input.from)
    } else {
      return this.toUrl(this.path(node.source.input.from))
    }
  }

  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64')
    } else {
      return window.btoa(unescape(encodeURIComponent(str)))
    }
  }

  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path)
    if (cached) return cached

    if (pathToFileURL) {
      let fileURL = pathToFileURL(path).toString()
      this.memoizedFileURLs.set(path, fileURL)

      return fileURL
    } else {
      throw new Error(
        '`map.absolute` option is not available in this PostCSS build'
      )
    }
  }

  toUrl(path) {
    let cached = this.memoizedURLs.get(path)
    if (cached) return cached

    if (sep === '\\') {
      path = path.replace(/\\/g, '/')
    }

    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent)
    this.memoizedURLs.set(path, url)

    return url
  }
}

module.exports = MapGenerator


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/no-work-result.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let MapGenerator = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/map-generator.js")
let stringify = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/stringify.js")
let warnOnce = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/warn-once.js")
let parse = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/parse.js")
const Result = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/result.js")

class NoWorkResult {
  constructor(processor, css, opts) {
    css = css.toString()
    this.stringified = false

    this._processor = processor
    this._css = css
    this._opts = opts
    this._map = undefined
    let root

    let str = stringify
    this.result = new Result(this._processor, root, this._opts)
    this.result.css = css

    let self = this
    Object.defineProperty(this.result, 'root', {
      get() {
        return self.root
      }
    })

    let map = new MapGenerator(str, root, this._opts, css)
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate()
      if (generatedCSS) {
        this.result.css = generatedCSS
      }
      if (generatedMap) {
        this.result.map = generatedMap
      }
    }
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    return Promise.resolve(this.result)
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  sync() {
    if (this.error) throw this.error
    return this.result
  }

  then(onFulfilled, onRejected) {
    if (false) {}

    return this.async().then(onFulfilled, onRejected)
  }

  toString() {
    return this._css
  }

  warnings() {
    return []
  }

  get content() {
    return this.result.css
  }

  get css() {
    return this.result.css
  }

  get map() {
    return this.result.map
  }

  get messages() {
    return []
  }

  get opts() {
    return this.result.opts
  }

  get processor() {
    return this.result.processor
  }

  get root() {
    if (this._root) {
      return this._root
    }

    let root
    let parser = parse

    try {
      root = parser(this._css, this._opts)
    } catch (error) {
      this.error = error
    }

    if (this.error) {
      throw this.error
    } else {
      this._root = root
      return root
    }
  }

  get [Symbol.toStringTag]() {
    return 'NoWorkResult'
  }
}

module.exports = NoWorkResult
NoWorkResult.default = NoWorkResult


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/node.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { isClean, my } = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/symbols.js")
let CssSyntaxError = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/css-syntax-error.js")
let Stringifier = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/stringifier.js")
let stringify = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/stringify.js")

function cloneNode(obj, parent) {
  let cloned = new obj.constructor()

  for (let i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      /* c8 ignore next 2 */
      continue
    }
    if (i === 'proxyCache') continue
    let value = obj[i]
    let type = typeof value

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent
    } else if (i === 'source') {
      cloned[i] = value
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(j => cloneNode(j, cloned))
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value)
      cloned[i] = value
    }
  }

  return cloned
}

class Node {
  constructor(defaults = {}) {
    this.raws = {}
    this[isClean] = false
    this[my] = true

    for (let name in defaults) {
      if (name === 'nodes') {
        this.nodes = []
        for (let node of defaults[name]) {
          if (typeof node.clone === 'function') {
            this.append(node.clone())
          } else {
            this.append(node)
          }
        }
      } else {
        this[name] = defaults[name]
      }
    }
  }

  addToError(error) {
    error.postcssNode = this
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s = this.source
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
      )
    }
    return error
  }

  after(add) {
    this.parent.insertAfter(this, add)
    return this
  }

  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name]
    }
    return this
  }

  before(add) {
    this.parent.insertBefore(this, add)
    return this
  }

  cleanRaws(keepBetween) {
    delete this.raws.before
    delete this.raws.after
    if (!keepBetween) delete this.raws.between
  }

  clone(overrides = {}) {
    let cloned = cloneNode(this)
    for (let name in overrides) {
      cloned[name] = overrides[name]
    }
    return cloned
  }

  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertAfter(this, cloned)
    return cloned
  }

  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertBefore(this, cloned)
    return cloned
  }

  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts)
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      )
    }
    return new CssSyntaxError(message)
  }

  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else {
          return node[prop]
        }
      },

      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (
          prop === 'prop' ||
          prop === 'value' ||
          prop === 'name' ||
          prop === 'params' ||
          prop === 'important' ||
          /* c8 ignore next */
          prop === 'text'
        ) {
          node.markDirty()
        }
        return true
      }
    }
  }

  markDirty() {
    if (this[isClean]) {
      this[isClean] = false
      let next = this
      while ((next = next.parent)) {
        next[isClean] = false
      }
    }
  }

  next() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index + 1]
  }

  positionBy(opts, stringRepresentation) {
    let pos = this.source.start
    if (opts.index) {
      pos = this.positionInside(opts.index, stringRepresentation)
    } else if (opts.word) {
      stringRepresentation = this.toString()
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) pos = this.positionInside(index, stringRepresentation)
    }
    return pos
  }

  positionInside(index, stringRepresentation) {
    let string = stringRepresentation || this.toString()
    let column = this.source.start.column
    let line = this.source.start.line

    for (let i = 0; i < index; i++) {
      if (string[i] === '\n') {
        column = 1
        line += 1
      } else {
        column += 1
      }
    }

    return { column, line }
  }

  prev() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index - 1]
  }

  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    }
    let end = this.source.end
      ? {
        column: this.source.end.column + 1,
        line: this.source.end.line
      }
      : {
        column: start.column + 1,
        line: start.line
      }

    if (opts.word) {
      let stringRepresentation = this.toString()
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) {
        start = this.positionInside(index, stringRepresentation)
        end = this.positionInside(index + opts.word.length, stringRepresentation)
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        }
      } else if (opts.index) {
        start = this.positionInside(opts.index)
      }

      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        }
      } else if (opts.endIndex) {
        end = this.positionInside(opts.endIndex)
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1)
      }
    }

    if (
      end.line < start.line ||
      (end.line === start.line && end.column <= start.column)
    ) {
      end = { column: start.column + 1, line: start.line }
    }

    return { end, start }
  }

  raw(prop, defaultType) {
    let str = new Stringifier()
    return str.raw(this, prop, defaultType)
  }

  remove() {
    if (this.parent) {
      this.parent.removeChild(this)
    }
    this.parent = undefined
    return this
  }

  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this
      let foundSelf = false
      for (let node of nodes) {
        if (node === this) {
          foundSelf = true
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node)
          bookmark = node
        } else {
          this.parent.insertBefore(bookmark, node)
        }
      }

      if (!foundSelf) {
        this.remove()
      }
    }

    return this
  }

  root() {
    let result = this
    while (result.parent && result.parent.type !== 'document') {
      result = result.parent
    }
    return result
  }

  toJSON(_, inputs) {
    let fixed = {}
    let emitInputs = inputs == null
    inputs = inputs || new Map()
    let inputsNextIndex = 0

    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        /* c8 ignore next 2 */
        continue
      }
      if (name === 'parent' || name === 'proxyCache') continue
      let value = this[name]

      if (Array.isArray(value)) {
        fixed[name] = value.map(i => {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON(null, inputs)
          } else {
            return i
          }
        })
      } else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs)
      } else if (name === 'source') {
        let inputId = inputs.get(value.input)
        if (inputId == null) {
          inputId = inputsNextIndex
          inputs.set(value.input, inputsNextIndex)
          inputsNextIndex++
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        }
      } else {
        fixed[name] = value
      }
    }

    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())
    }

    return fixed
  }

  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor())
    }
    return this.proxyCache
  }

  toString(stringifier = stringify) {
    if (stringifier.stringify) stringifier = stringifier.stringify
    let result = ''
    stringifier(this, i => {
      result += i
    })
    return result
  }

  warn(result, text, opts) {
    let data = { node: this }
    for (let i in opts) data[i] = opts[i]
    return result.warn(text, data)
  }

  get proxyOf() {
    return this
  }
}

module.exports = Node
Node.default = Node


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/parse.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/container.js")
let Parser = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/parser.js")
let Input = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/input.js")

function parse(css, opts) {
  let input = new Input(css, opts)
  let parser = new Parser(input)
  try {
    parser.parse()
  } catch (e) {
    if (false) {}
    throw e
  }

  return parser.root
}

module.exports = parse
parse.default = parse

Container.registerParse(parse)


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Declaration = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/declaration.js")
let tokenizer = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/tokenize.js")
let Comment = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/comment.js")
let AtRule = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/at-rule.js")
let Root = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/root.js")
let Rule = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/rule.js")

const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
}

function findLastWithPosition(tokens) {
  for (let i = tokens.length - 1; i >= 0; i--) {
    let token = tokens[i]
    let pos = token[3] || token[2]
    if (pos) return pos
  }
}

class Parser {
  constructor(input) {
    this.input = input

    this.root = new Root()
    this.current = this.root
    this.spaces = ''
    this.semicolon = false
    this.customProperty = false

    this.createTokenizer()
    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }
  }

  atrule(token) {
    let node = new AtRule()
    node.name = token[1].slice(1)
    if (node.name === '') {
      this.unnamedAtrule(node, token)
    }
    this.init(node, token[2])

    let type
    let prev
    let shift
    let last = false
    let open = false
    let params = []
    let brackets = []

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()
      type = token[0]

      if (type === '(' || type === '[') {
        brackets.push(type === '(' ? ')' : ']')
      } else if (type === '{' && brackets.length > 0) {
        brackets.push('}')
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
      }

      if (brackets.length === 0) {
        if (type === ';') {
          node.source.end = this.getPosition(token[2])
          node.source.end.offset++
          this.semicolon = true
          break
        } else if (type === '{') {
          open = true
          break
        } else if (type === '}') {
          if (params.length > 0) {
            shift = params.length - 1
            prev = params[shift]
            while (prev && prev[0] === 'space') {
              prev = params[--shift]
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2])
              node.source.end.offset++
            }
          }
          this.end(token)
          break
        } else {
          params.push(token)
        }
      } else {
        params.push(token)
      }

      if (this.tokenizer.endOfFile()) {
        last = true
        break
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params)
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params)
      this.raw(node, 'params', params)
      if (last) {
        token = params[params.length - 1]
        node.source.end = this.getPosition(token[3] || token[2])
        node.source.end.offset++
        this.spaces = node.raws.between
        node.raws.between = ''
      }
    } else {
      node.raws.afterName = ''
      node.params = ''
    }

    if (open) {
      node.nodes = []
      this.current = node
    }
  }

  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens)
    if (colon === false) return

    let founded = 0
    let token
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j]
      if (token[0] !== 'space') {
        founded += 1
        if (founded === 2) break
      }
    }
    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error(
      'Missed semicolon',
      token[0] === 'word' ? token[3] + 1 : token[2]
    )
  }

  colon(tokens) {
    let brackets = 0
    let token, type, prev
    for (let [i, element] of tokens.entries()) {
      token = element
      type = token[0]

      if (type === '(') {
        brackets += 1
      }
      if (type === ')') {
        brackets -= 1
      }
      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token)
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue
        } else {
          return i
        }
      }

      prev = token
    }
    return false
  }

  comment(token) {
    let node = new Comment()
    this.init(node, token[2])
    node.source.end = this.getPosition(token[3] || token[2])
    node.source.end.offset++

    let text = token[1].slice(2, -2)
    if (/^\s*$/.test(text)) {
      node.text = ''
      node.raws.left = text
      node.raws.right = ''
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
    }
  }

  createTokenizer() {
    this.tokenizer = tokenizer(this.input)
  }

  decl(tokens, customProperty) {
    let node = new Declaration()
    this.init(node, tokens[0][2])

    let last = tokens[tokens.length - 1]
    if (last[0] === ';') {
      this.semicolon = true
      tokens.pop()
    }

    node.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    )
    node.source.end.offset++

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens)
      node.raws.before += tokens.shift()[1]
    }
    node.source.start = this.getPosition(tokens[0][2])

    node.prop = ''
    while (tokens.length) {
      let type = tokens[0][0]
      if (type === ':' || type === 'space' || type === 'comment') {
        break
      }
      node.prop += tokens.shift()[1]
    }

    node.raws.between = ''

    let token
    while (tokens.length) {
      token = tokens.shift()

      if (token[0] === ':') {
        node.raws.between += token[1]
        break
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token])
        }
        node.raws.between += token[1]
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0]
      node.prop = node.prop.slice(1)
    }

    let firstSpaces = []
    let next
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      firstSpaces.push(tokens.shift())
    }

    this.precheckMissedSemicolon(tokens)

    for (let i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i]
      if (token[1].toLowerCase() === '!important') {
        node.important = true
        let string = this.stringFrom(tokens, i)
        string = this.spacesFromEnd(tokens) + string
        if (string !== ' !important') node.raws.important = string
        break
      } else if (token[1].toLowerCase() === 'important') {
        let cache = tokens.slice(0)
        let str = ''
        for (let j = i; j > 0; j--) {
          let type = cache[j][0]
          if (str.trim().indexOf('!') === 0 && type !== 'space') {
            break
          }
          str = cache.pop()[1] + str
        }
        if (str.trim().indexOf('!') === 0) {
          node.important = true
          node.raws.important = str
          tokens = cache
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break
      }
    }

    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')

    if (hasWord) {
      node.raws.between += firstSpaces.map(i => i[1]).join('')
      firstSpaces = []
    }
    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)

    if (node.value.includes(':') && !customProperty) {
      this.checkMissedSemicolon(tokens)
    }
  }

  doubleColon(token) {
    throw this.input.error(
      'Double colon',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }

  emptyRule(token) {
    let node = new Rule()
    this.init(node, token[2])
    node.selector = ''
    node.raws.between = ''
    this.current = node
  }

  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.semicolon = false

    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.spaces = ''

    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2])
      this.current.source.end.offset++
      this.current = this.current.parent
    } else {
      this.unexpectedClose(token)
    }
  }

  endFile() {
    if (this.current.parent) this.unclosedBlock()
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.root.source.end = this.getPosition(this.tokenizer.position())
  }

  freeSemicolon(token) {
    this.spaces += token[1]
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1]
      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces
        this.spaces = ''
      }
    }
  }

  // Helpers

  getPosition(offset) {
    let pos = this.input.fromOffset(offset)
    return {
      column: pos.col,
      line: pos.line,
      offset
    }
  }

  init(node, offset) {
    this.current.push(node)
    node.source = {
      input: this.input,
      start: this.getPosition(offset)
    }
    node.raws.before = this.spaces
    this.spaces = ''
    if (node.type !== 'comment') this.semicolon = false
  }

  other(start) {
    let end = false
    let type = null
    let colon = false
    let bracket = null
    let brackets = []
    let customProperty = start[1].startsWith('--')

    let tokens = []
    let token = start
    while (token) {
      type = token[0]
      tokens.push(token)

      if (type === '(' || type === '[') {
        if (!bracket) bracket = token
        brackets.push(type === '(' ? ')' : ']')
      } else if (customProperty && colon && type === '{') {
        if (!bracket) bracket = token
        brackets.push('}')
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens, customProperty)
            return
          } else {
            break
          }
        } else if (type === '{') {
          this.rule(tokens)
          return
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop())
          end = true
          break
        } else if (type === ':') {
          colon = true
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
        if (brackets.length === 0) bracket = null
      }

      token = this.tokenizer.nextToken()
    }

    if (this.tokenizer.endOfFile()) end = true
    if (brackets.length > 0) this.unclosedBracket(bracket)

    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0]
          if (token !== 'space' && token !== 'comment') break
          this.tokenizer.back(tokens.pop())
        }
      }
      this.decl(tokens, customProperty)
    } else {
      this.unknownWord(tokens)
    }
  }

  parse() {
    let token
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()

      switch (token[0]) {
        case 'space':
          this.spaces += token[1]
          break

        case ';':
          this.freeSemicolon(token)
          break

        case '}':
          this.end(token)
          break

        case 'comment':
          this.comment(token)
          break

        case 'at-word':
          this.atrule(token)
          break

        case '{':
          this.emptyRule(token)
          break

        default:
          this.other(token)
          break
      }
    }
    this.endFile()
  }

  precheckMissedSemicolon(/* tokens */) {
    // Hook for Safe Parser
  }

  raw(node, prop, tokens, customProperty) {
    let token, type
    let length = tokens.length
    let value = ''
    let clean = true
    let next, prev

    for (let i = 0; i < length; i += 1) {
      token = tokens[i]
      type = token[0]
      if (type === 'space' && i === length - 1 && !customProperty) {
        clean = false
      } else if (type === 'comment') {
        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'
        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ',') {
            clean = false
          } else {
            value += token[1]
          }
        } else {
          clean = false
        }
      } else {
        value += token[1]
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i) => all + i[1], '')
      node.raws[prop] = { raw, value }
    }
    node[prop] = value
  }

  rule(tokens) {
    tokens.pop()

    let node = new Rule()
    this.init(node, tokens[0][2])

    node.raws.between = this.spacesAndCommentsFromEnd(tokens)
    this.raw(node, 'selector', tokens)
    this.current = node
  }

  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  // Errors

  spacesAndCommentsFromStart(tokens) {
    let next
    let spaces = ''
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      spaces += tokens.shift()[1]
    }
    return spaces
  }

  spacesFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  stringFrom(tokens, from) {
    let result = ''
    for (let i = from; i < tokens.length; i++) {
      result += tokens[i][1]
    }
    tokens.splice(from, tokens.length - from)
    return result
  }

  unclosedBlock() {
    let pos = this.current.source.start
    throw this.input.error('Unclosed block', pos.line, pos.column)
  }

  unclosedBracket(bracket) {
    throw this.input.error(
      'Unclosed bracket',
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    )
  }

  unexpectedClose(token) {
    throw this.input.error(
      'Unexpected }',
      { offset: token[2] },
      { offset: token[2] + 1 }
    )
  }

  unknownWord(tokens) {
    throw this.input.error(
      'Unknown word',
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    )
  }

  unnamedAtrule(node, token) {
    throw this.input.error(
      'At-rule without name',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }
}

module.exports = Parser


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/postcss.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");


let CssSyntaxError = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/css-syntax-error.js")
let Declaration = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/declaration.js")
let LazyResult = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/lazy-result.js")
let Container = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/container.js")
let Processor = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/processor.js")
let stringify = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/stringify.js")
let fromJSON = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/fromJSON.js")
let Document = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/document.js")
let Warning = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/warning.js")
let Comment = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/comment.js")
let AtRule = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/at-rule.js")
let Result = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/result.js")
let Input = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/input.js")
let parse = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/parse.js")
let list = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/list.js")
let Rule = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/rule.js")
let Root = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/root.js")
let Node = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/node.js")

function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0]
  }
  return new Processor(plugins)
}

postcss.plugin = function plugin(name, initializer) {
  let warningPrinted = false
  function creator(...args) {
    // eslint-disable-next-line no-console
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true
      // eslint-disable-next-line no-console
      console.warn(
        name +
          ': postcss.plugin was deprecated. Migration guide:\n' +
          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'
      )
      if (process.env.LANG && process.env.LANG.startsWith('cn')) {
        /* c8 ignore next 7 */
        // eslint-disable-next-line no-console
        console.warn(
          name +
            ': 里面 postcss.plugin 被弃用. 迁移指南:\n' +
            'https://www.w3ctech.com/topic/2226'
        )
      }
    }
    let transformer = initializer(...args)
    transformer.postcssPlugin = name
    transformer.postcssVersion = new Processor().version
    return transformer
  }

  let cache
  Object.defineProperty(creator, 'postcss', {
    get() {
      if (!cache) cache = creator()
      return cache
    }
  })

  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts)
  }

  return creator
}

postcss.stringify = stringify
postcss.parse = parse
postcss.fromJSON = fromJSON
postcss.list = list

postcss.comment = defaults => new Comment(defaults)
postcss.atRule = defaults => new AtRule(defaults)
postcss.decl = defaults => new Declaration(defaults)
postcss.rule = defaults => new Rule(defaults)
postcss.root = defaults => new Root(defaults)
postcss.document = defaults => new Document(defaults)

postcss.CssSyntaxError = CssSyntaxError
postcss.Declaration = Declaration
postcss.Container = Container
postcss.Processor = Processor
postcss.Document = Document
postcss.Comment = Comment
postcss.Warning = Warning
postcss.AtRule = AtRule
postcss.Result = Result
postcss.Input = Input
postcss.Rule = Rule
postcss.Root = Root
postcss.Node = Node

LazyResult.registerPostcss(postcss)

module.exports = postcss
postcss.default = postcss


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/previous-map.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__("?fec9")
let { existsSync, readFileSync } = __webpack_require__("?5628")
let { dirname, join } = __webpack_require__("?09e8")

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString()
  } else {
    /* c8 ignore next 2 */
    return window.atob(str)
  }
}

class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return
    this.loadAnnotation(css)
    this.inline = this.startWith(this.annotation, 'data:')

    let prev = opts.map ? opts.map.prev : undefined
    let text = this.loadMap(opts.from, prev)
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from
    }
    if (this.mapFile) this.root = dirname(this.mapFile)
    if (text) this.text = text
  }

  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer(this.text)
    }
    return this.consumerCache
  }

  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/
    let baseUri = /^data:application\/json;base64,/
    let charsetUri = /^data:application\/json;charset=utf-?8,/
    let uri = /^data:application\/json,/

    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length))
    }

    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64(text.substr(RegExp.lastMatch.length))
    }

    let encoding = text.match(/data:application\/json;([^,]+),/)[1]
    throw new Error('Unsupported source map encoding ' + encoding)
  }

  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim()
  }

  isMap(map) {
    if (typeof map !== 'object') return false
    return (
      typeof map.mappings === 'string' ||
      typeof map._mappings === 'string' ||
      Array.isArray(map.sections)
    )
  }

  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/gm)
    if (!comments) return

    // sourceMappingURLs from comments, strings, etc.
    let start = css.lastIndexOf(comments.pop())
    let end = css.indexOf('*/', start)

    if (start > -1 && end > -1) {
      // Locate the last sourceMappingURL to avoid pickin
      this.annotation = this.getAnnotationURL(css.substring(start, end))
    }
  }

  loadFile(path) {
    this.root = dirname(path)
    if (existsSync(path)) {
      this.mapFile = path
      return readFileSync(path, 'utf-8').toString().trim()
    }
  }

  loadMap(file, prev) {
    if (prev === false) return false

    if (prev) {
      if (typeof prev === 'string') {
        return prev
      } else if (typeof prev === 'function') {
        let prevPath = prev(file)
        if (prevPath) {
          let map = this.loadFile(prevPath)
          if (!map) {
            throw new Error(
              'Unable to load previous source map: ' + prevPath.toString()
            )
          }
          return map
        }
      } else if (prev instanceof SourceMapConsumer) {
        return SourceMapGenerator.fromSourceMap(prev).toString()
      } else if (prev instanceof SourceMapGenerator) {
        return prev.toString()
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev)
      } else {
        throw new Error(
          'Unsupported previous source map format: ' + prev.toString()
        )
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation)
    } else if (this.annotation) {
      let map = this.annotation
      if (file) map = join(dirname(file), map)
      return this.loadFile(map)
    }
  }

  startWith(string, start) {
    if (!string) return false
    return string.substr(0, start.length) === start
  }

  withContent() {
    return !!(
      this.consumer().sourcesContent &&
      this.consumer().sourcesContent.length > 0
    )
  }
}

module.exports = PreviousMap
PreviousMap.default = PreviousMap


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/processor.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let NoWorkResult = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/no-work-result.js")
let LazyResult = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/lazy-result.js")
let Document = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/document.js")
let Root = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/root.js")

class Processor {
  constructor(plugins = []) {
    this.version = '8.4.32'
    this.plugins = this.normalize(plugins)
  }

  normalize(plugins) {
    let normalized = []
    for (let i of plugins) {
      if (i.postcss === true) {
        i = i()
      } else if (i.postcss) {
        i = i.postcss
      }

      if (typeof i === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins)
      } else if (typeof i === 'object' && i.postcssPlugin) {
        normalized.push(i)
      } else if (typeof i === 'function') {
        normalized.push(i)
      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
        if (false) {}
      } else {
        throw new Error(i + ' is not a PostCSS plugin')
      }
    }
    return normalized
  }

  process(css, opts = {}) {
    if (
      this.plugins.length === 0 &&
      typeof opts.parser === 'undefined' &&
      typeof opts.stringifier === 'undefined' &&
      typeof opts.syntax === 'undefined'
    ) {
      return new NoWorkResult(this, css, opts)
    } else {
      return new LazyResult(this, css, opts)
    }
  }

  use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]))
    return this
  }
}

module.exports = Processor
Processor.default = Processor

Root.registerProcessor(Processor)
Document.registerProcessor(Processor)


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/result.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Warning = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/warning.js")

class Result {
  constructor(processor, root, opts) {
    this.processor = processor
    this.messages = []
    this.root = root
    this.opts = opts
    this.css = undefined
    this.map = undefined
  }

  toString() {
    return this.css
  }

  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin
      }
    }

    let warning = new Warning(text, opts)
    this.messages.push(warning)

    return warning
  }

  warnings() {
    return this.messages.filter(i => i.type === 'warning')
  }

  get content() {
    return this.css
  }
}

module.exports = Result
Result.default = Result


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/root.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/container.js")

let LazyResult, Processor

class Root extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'root'
    if (!this.nodes) this.nodes = []
  }

  normalize(child, sample, type) {
    let nodes = super.normalize(child)

    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before
        } else {
          delete sample.raws.before
        }
      } else if (this.first !== sample) {
        for (let node of nodes) {
          node.raws.before = sample.raws.before
        }
      }
    }

    return nodes
  }

  removeChild(child, ignore) {
    let index = this.index(child)

    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before
    }

    return super.removeChild(child)
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)
    return lazy.stringify()
  }
}

Root.registerLazyResult = dependant => {
  LazyResult = dependant
}

Root.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Root
Root.default = Root

Container.registerRoot(Root)


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/rule.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/container.js")
let list = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/list.js")

class Rule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'rule'
    if (!this.nodes) this.nodes = []
  }

  get selectors() {
    return list.comma(this.selector)
  }

  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null
    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')
    this.selector = values.join(sep)
  }
}

module.exports = Rule
Rule.default = Rule

Container.registerRule(Rule)


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/stringifier.js":
/***/ ((module) => {

"use strict";


const DEFAULT_RAW = {
  after: '\n',
  beforeClose: '\n',
  beforeComment: '\n',
  beforeDecl: '\n',
  beforeOpen: ' ',
  beforeRule: '\n',
  colon: ': ',
  commentLeft: ' ',
  commentRight: ' ',
  emptyBody: '',
  indent: '    ',
  semicolon: false
}

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1)
}

class Stringifier {
  constructor(builder) {
    this.builder = builder
  }

  atrule(node, semicolon) {
    let name = '@' + node.name
    let params = node.params ? this.rawValue(node, 'params') : ''

    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName
    } else if (params) {
      name += ' '
    }

    if (node.nodes) {
      this.block(node, name + params)
    } else {
      let end = (node.raws.between || '') + (semicolon ? ';' : '')
      this.builder(name + params + end, node)
    }
  }

  beforeAfter(node, detect) {
    let value
    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment')
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule')
    } else {
      value = this.raw(node, null, 'beforeClose')
    }

    let buf = node.parent
    let depth = 0
    while (buf && buf.type !== 'root') {
      depth += 1
      buf = buf.parent
    }

    if (value.includes('\n')) {
      let indent = this.raw(node, null, 'indent')
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent
      }
    }

    return value
  }

  block(node, start) {
    let between = this.raw(node, 'between', 'beforeOpen')
    this.builder(start + between + '{', node, 'start')

    let after
    if (node.nodes && node.nodes.length) {
      this.body(node)
      after = this.raw(node, 'after')
    } else {
      after = this.raw(node, 'after', 'emptyBody')
    }

    if (after) this.builder(after)
    this.builder('}', node, 'end')
  }

  body(node) {
    let last = node.nodes.length - 1
    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break
      last -= 1
    }

    let semicolon = this.raw(node, 'semicolon')
    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i]
      let before = this.raw(child, 'before')
      if (before) this.builder(before)
      this.stringify(child, last !== i || semicolon)
    }
  }

  comment(node) {
    let left = this.raw(node, 'left', 'commentLeft')
    let right = this.raw(node, 'right', 'commentRight')
    this.builder('/*' + left + node.text + right + '*/', node)
  }

  decl(node, semicolon) {
    let between = this.raw(node, 'between', 'colon')
    let string = node.prop + between + this.rawValue(node, 'value')

    if (node.important) {
      string += node.raws.important || ' !important'
    }

    if (semicolon) string += ';'
    this.builder(string, node)
  }

  document(node) {
    this.body(node)
  }

  raw(node, own, detect) {
    let value
    if (!detect) detect = own

    // Already had
    if (own) {
      value = node.raws[own]
      if (typeof value !== 'undefined') return value
    }

    let parent = node.parent

    if (detect === 'before') {
      // Hack for first rule in CSS
      if (!parent || (parent.type === 'root' && parent.first === node)) {
        return ''
      }

      // `root` nodes in `document` should use only their own raws
      if (parent && parent.type === 'document') {
        return ''
      }
    }

    // Floating child without parent
    if (!parent) return DEFAULT_RAW[detect]

    // Detect style by other nodes
    let root = node.root()
    if (!root.rawCache) root.rawCache = {}
    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect]
    }

    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect)
    } else {
      let method = 'raw' + capitalize(detect)
      if (this[method]) {
        value = this[method](root, node)
      } else {
        root.walk(i => {
          value = i.raws[own]
          if (typeof value !== 'undefined') return false
        })
      }
    }

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]

    root.rawCache[detect] = value
    return value
  }

  rawBeforeClose(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawBeforeComment(root, node) {
    let value
    root.walkComments(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeDecl(root, node) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeOpen(root) {
    let value
    root.walk(i => {
      if (i.type !== 'decl') {
        value = i.raws.between
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawBeforeRule(root) {
    let value
    root.walk(i => {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawColon(root) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '')
        return false
      }
    })
    return value
  }

  rawEmptyBody(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawIndent(root) {
    if (root.raws.indent) return root.raws.indent
    let value
    root.walk(i => {
      let p = i.parent
      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          let parts = i.raws.before.split('\n')
          value = parts[parts.length - 1]
          value = value.replace(/\S/g, '')
          return false
        }
      }
    })
    return value
  }

  rawSemicolon(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawValue(node, prop) {
    let value = node[prop]
    let raw = node.raws[prop]
    if (raw && raw.value === value) {
      return raw.raw
    }

    return value
  }

  root(node) {
    this.body(node)
    if (node.raws.after) this.builder(node.raws.after)
  }

  rule(node) {
    this.block(node, this.rawValue(node, 'selector'))
    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end')
    }
  }

  stringify(node, semicolon) {
    /* c8 ignore start */
    if (!this[node.type]) {
      throw new Error(
        'Unknown AST node type ' +
          node.type +
          '. ' +
          'Maybe you need to change PostCSS stringifier.'
      )
    }
    /* c8 ignore stop */
    this[node.type](node, semicolon)
  }
}

module.exports = Stringifier
Stringifier.default = Stringifier


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/stringify.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Stringifier = __webpack_require__("../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/stringifier.js")

function stringify(node, builder) {
  let str = new Stringifier(builder)
  str.stringify(node)
}

module.exports = stringify
stringify.default = stringify


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/symbols.js":
/***/ ((module) => {

"use strict";


module.exports.isClean = Symbol('isClean')

module.exports.my = Symbol('my')


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/tokenize.js":
/***/ ((module) => {

"use strict";


const SINGLE_QUOTE = "'".charCodeAt(0)
const DOUBLE_QUOTE = '"'.charCodeAt(0)
const BACKSLASH = '\\'.charCodeAt(0)
const SLASH = '/'.charCodeAt(0)
const NEWLINE = '\n'.charCodeAt(0)
const SPACE = ' '.charCodeAt(0)
const FEED = '\f'.charCodeAt(0)
const TAB = '\t'.charCodeAt(0)
const CR = '\r'.charCodeAt(0)
const OPEN_SQUARE = '['.charCodeAt(0)
const CLOSE_SQUARE = ']'.charCodeAt(0)
const OPEN_PARENTHESES = '('.charCodeAt(0)
const CLOSE_PARENTHESES = ')'.charCodeAt(0)
const OPEN_CURLY = '{'.charCodeAt(0)
const CLOSE_CURLY = '}'.charCodeAt(0)
const SEMICOLON = ';'.charCodeAt(0)
const ASTERISK = '*'.charCodeAt(0)
const COLON = ':'.charCodeAt(0)
const AT = '@'.charCodeAt(0)

const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g
const RE_BAD_BRACKET = /.[\r\n"'(/\\]/
const RE_HEX_ESCAPE = /[\da-f]/i

module.exports = function tokenizer(input, options = {}) {
  let css = input.css.valueOf()
  let ignore = options.ignoreErrors

  let code, next, quote, content, escape
  let escaped, escapePos, prev, n, currentToken

  let length = css.length
  let pos = 0
  let buffer = []
  let returned = []

  function position() {
    return pos
  }

  function unclosed(what) {
    throw input.error('Unclosed ' + what, pos)
  }

  function endOfFile() {
    return returned.length === 0 && pos >= length
  }

  function nextToken(opts) {
    if (returned.length) return returned.pop()
    if (pos >= length) return

    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false

    code = css.charCodeAt(pos)

    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos
        do {
          next += 1
          code = css.charCodeAt(next)
        } while (
          code === SPACE ||
          code === NEWLINE ||
          code === TAB ||
          code === CR ||
          code === FEED
        )

        currentToken = ['space', css.slice(pos, next)]
        pos = next - 1
        break
      }

      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code)
        currentToken = [controlChar, controlChar, pos]
        break
      }

      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : ''
        n = css.charCodeAt(pos + 1)
        if (
          prev === 'url' &&
          n !== SINGLE_QUOTE &&
          n !== DOUBLE_QUOTE &&
          n !== SPACE &&
          n !== NEWLINE &&
          n !== TAB &&
          n !== FEED &&
          n !== CR
        ) {
          next = pos
          do {
            escaped = false
            next = css.indexOf(')', next + 1)
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos
                break
              } else {
                unclosed('bracket')
              }
            }
            escapePos = next
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1
              escaped = !escaped
            }
          } while (escaped)

          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]

          pos = next
        } else {
          next = css.indexOf(')', pos + 1)
          content = css.slice(pos, next + 1)

          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ['(', '(', pos]
          } else {
            currentToken = ['brackets', content, pos, next]
            pos = next
          }
        }

        break
      }

      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"'
        next = pos
        do {
          escaped = false
          next = css.indexOf(quote, next + 1)
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1
              break
            } else {
              unclosed('string')
            }
          }
          escapePos = next
          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1
            escaped = !escaped
          }
        } while (escaped)

        currentToken = ['string', css.slice(pos, next + 1), pos, next]
        pos = next
        break
      }

      case AT: {
        RE_AT_END.lastIndex = pos + 1
        RE_AT_END.test(css)
        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1
        } else {
          next = RE_AT_END.lastIndex - 2
        }

        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      case BACKSLASH: {
        next = pos
        escape = true
        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1
          escape = !escape
        }
        code = css.charCodeAt(next + 1)
        if (
          escape &&
          code !== SLASH &&
          code !== SPACE &&
          code !== NEWLINE &&
          code !== TAB &&
          code !== CR &&
          code !== FEED
        ) {
          next += 1
          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1
            }
            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1
            }
          }
        }

        currentToken = ['word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      default: {
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf('*/', pos + 2) + 1
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length
            } else {
              unclosed('comment')
            }
          }

          currentToken = ['comment', css.slice(pos, next + 1), pos, next]
          pos = next
        } else {
          RE_WORD_END.lastIndex = pos + 1
          RE_WORD_END.test(css)
          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1
          } else {
            next = RE_WORD_END.lastIndex - 2
          }

          currentToken = ['word', css.slice(pos, next + 1), pos, next]
          buffer.push(currentToken)
          pos = next
        }

        break
      }
    }

    pos++
    return currentToken
  }

  function back(token) {
    returned.push(token)
  }

  return {
    back,
    endOfFile,
    nextToken,
    position
  }
}


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/warn-once.js":
/***/ ((module) => {

"use strict";
/* eslint-disable no-console */


let printed = {}

module.exports = function warnOnce(message) {
  if (printed[message]) return
  printed[message] = true

  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message)
  }
}


/***/ }),

/***/ "../../node_modules/.pnpm/postcss@8.4.32/node_modules/postcss/lib/warning.js":
/***/ ((module) => {

"use strict";


class Warning {
  constructor(text, opts = {}) {
    this.type = 'warning'
    this.text = text

    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts)
      this.line = range.start.line
      this.column = range.start.column
      this.endLine = range.end.line
      this.endColumn = range.end.column
    }

    for (let opt in opts) this[opt] = opts[opt]
  }

  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message
    }

    if (this.plugin) {
      return this.plugin + ': ' + this.text
    }

    return this.text
  }
}

module.exports = Warning
Warning.default = Warning


/***/ }),

/***/ "../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-autosize-textarea/lib/TextareaAutosize.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
exports.__esModule = true;
var React = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
var PropTypes = __webpack_require__("../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js");
var autosize = __webpack_require__("../../node_modules/.pnpm/autosize@4.0.4/node_modules/autosize/dist/autosize.js");
var _getLineHeight = __webpack_require__("../../node_modules/.pnpm/line-height@0.3.1/node_modules/line-height/lib/line-height.js");
var getLineHeight = _getLineHeight;
var RESIZED = "autosize:resized";
/**
 * A light replacement for built-in textarea component
 * which automaticaly adjusts its height to match the content
 */
var TextareaAutosizeClass = /** @class */ (function (_super) {
    __extends(TextareaAutosizeClass, _super);
    function TextareaAutosizeClass() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            lineHeight: null
        };
        _this.textarea = null;
        _this.onResize = function (e) {
            if (_this.props.onResize) {
                _this.props.onResize(e);
            }
        };
        _this.updateLineHeight = function () {
            if (_this.textarea) {
                _this.setState({
                    lineHeight: getLineHeight(_this.textarea)
                });
            }
        };
        _this.onChange = function (e) {
            var onChange = _this.props.onChange;
            _this.currentValue = e.currentTarget.value;
            onChange && onChange(e);
        };
        return _this;
    }
    TextareaAutosizeClass.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, maxRows = _a.maxRows, async = _a.async;
        if (typeof maxRows === "number") {
            this.updateLineHeight();
        }
        if (typeof maxRows === "number" || async) {
            /*
              the defer is needed to:
                - force "autosize" to activate the scrollbar when this.props.maxRows is passed
                - support StyledComponents (see #71)
            */
            setTimeout(function () { return _this.textarea && autosize(_this.textarea); });
        }
        else {
            this.textarea && autosize(this.textarea);
        }
        if (this.textarea) {
            this.textarea.addEventListener(RESIZED, this.onResize);
        }
    };
    TextareaAutosizeClass.prototype.componentWillUnmount = function () {
        if (this.textarea) {
            this.textarea.removeEventListener(RESIZED, this.onResize);
            autosize.destroy(this.textarea);
        }
    };
    TextareaAutosizeClass.prototype.render = function () {
        var _this = this;
        var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight = _a.state.lineHeight;
        var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
        return (React.createElement("textarea", __assign({}, props, { onChange: this.onChange, style: maxHeight ? __assign({}, style, { maxHeight: maxHeight }) : style, ref: function (element) {
                _this.textarea = element;
                if (typeof _this.props.innerRef === 'function') {
                    _this.props.innerRef(element);
                }
                else if (_this.props.innerRef) {
                    _this.props.innerRef.current = element;
                }
            } }), children));
    };
    TextareaAutosizeClass.prototype.componentDidUpdate = function () {
        this.textarea && autosize.update(this.textarea);
    };
    TextareaAutosizeClass.defaultProps = {
        rows: 1,
        async: false
    };
    TextareaAutosizeClass.propTypes = {
        rows: PropTypes.number,
        maxRows: PropTypes.number,
        onResize: PropTypes.func,
        innerRef: PropTypes.any,
        async: PropTypes.bool
    };
    return TextareaAutosizeClass;
}(React.Component));
exports.TextareaAutosize = React.forwardRef(function (props, ref) {
    return React.createElement(TextareaAutosizeClass, __assign({}, props, { innerRef: ref }));
});


/***/ }),

/***/ "../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-autosize-textarea/lib/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = true;
var TextareaAutosize_1 = __webpack_require__("../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-autosize-textarea/lib/TextareaAutosize.js");
exports.A = TextareaAutosize_1.TextareaAutosize;


/***/ }),

/***/ "../../node_modules/.pnpm/react-colorful@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-colorful/dist/index.mjs":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gy: () => (/* binding */ ye),
/* harmony export */   jI: () => (/* binding */ Z),
/* harmony export */   p9: () => (/* binding */ He),
/* harmony export */   xp: () => (/* binding */ ue)
/* harmony export */ });
/* unused harmony exports HexAlphaColorPicker, HexColorInput, HslColorPicker, HslStringColorPicker, HslaColorPicker, HsvColorPicker, HsvStringColorPicker, HsvaColorPicker, HsvaStringColorPicker, RgbColorPicker, RgbaColorPicker, setNonce */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
function u(){return(u=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}function c(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r.indexOf(t=a[n])>=0||(o[t]=e[t]);return o}function i(e){var t=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(e),n=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(function(e){t.current&&t.current(e)});return t.current=e,n.current}var s=function(e,r,t){return void 0===r&&(r=0),void 0===t&&(t=1),e>t?t:e<r?r:e},f=function(e){return"touches"in e},v=function(e){return e&&e.ownerDocument.defaultView||self},d=function(e,r,t){var n=e.getBoundingClientRect(),o=f(r)?function(e,r){for(var t=0;t<e.length;t++)if(e[t].identifier===r)return e[t];return e[0]}(r.touches,t):r;return{left:s((o.pageX-(n.left+v(e).pageXOffset))/n.width),top:s((o.pageY-(n.top+v(e).pageYOffset))/n.height)}},h=function(e){!f(e)&&e.preventDefault()},m=react__WEBPACK_IMPORTED_MODULE_0__.memo(function(o){var a=o.onMove,l=o.onKey,s=c(o,["onMove","onKey"]),m=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),g=i(a),p=i(l),b=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),_=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1),x=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function(){var e=function(e){h(e),(f(e)?e.touches.length>0:e.buttons>0)&&m.current?g(d(m.current,e,b.current)):t(!1)},r=function(){return t(!1)};function t(t){var n=_.current,o=v(m.current),a=t?o.addEventListener:o.removeEventListener;a(n?"touchmove":"mousemove",e),a(n?"touchend":"mouseup",r)}return[function(e){var r=e.nativeEvent,n=m.current;if(n&&(h(r),!function(e,r){return r&&!f(e)}(r,_.current)&&n)){if(f(r)){_.current=!0;var o=r.changedTouches||[];o.length&&(b.current=o[0].identifier)}n.focus(),g(d(n,r,b.current)),t(!0)}},function(e){var r=e.which||e.keyCode;r<37||r>40||(e.preventDefault(),p({left:39===r?.05:37===r?-.05:0,top:40===r?.05:38===r?-.05:0}))},t]},[p,g]),C=x[0],E=x[1],H=x[2];return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function(){return H},[H]),react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",u({},s,{onTouchStart:C,onMouseDown:C,className:"react-colorful__interactive",ref:m,onKeyDown:E,tabIndex:0,role:"slider"}))}),g=function(e){return e.filter(Boolean).join(" ")},p=function(r){var t=r.color,n=r.left,o=r.top,a=void 0===o?.5:o,l=g(["react-colorful__pointer",r.className]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:l,style:{top:100*a+"%",left:100*n+"%"}},react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:"react-colorful__pointer-fill",style:{backgroundColor:t}}))},b=function(e,r,t){return void 0===r&&(r=0),void 0===t&&(t=Math.pow(10,r)),Math.round(t*e)/t},_={grad:.9,turn:360,rad:360/(2*Math.PI)},x=function(e){return L(C(e))},C=function(e){return"#"===e[0]&&(e=e.substring(1)),e.length<6?{r:parseInt(e[0]+e[0],16),g:parseInt(e[1]+e[1],16),b:parseInt(e[2]+e[2],16),a:4===e.length?b(parseInt(e[3]+e[3],16)/255,2):1}:{r:parseInt(e.substring(0,2),16),g:parseInt(e.substring(2,4),16),b:parseInt(e.substring(4,6),16),a:8===e.length?b(parseInt(e.substring(6,8),16)/255,2):1}},E=function(e,r){return void 0===r&&(r="deg"),Number(e)*(_[r]||1)},H=function(e){var r=/hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e);return r?N({h:E(r[1],r[2]),s:Number(r[3]),l:Number(r[4]),a:void 0===r[5]?1:Number(r[5])/(r[6]?100:1)}):{h:0,s:0,v:0,a:1}},M=H,N=function(e){var r=e.s,t=e.l;return{h:e.h,s:(r*=(t<50?t:100-t)/100)>0?2*r/(t+r)*100:0,v:t+r,a:e.a}},w=function(e){return K(I(e))},y=function(e){var r=e.s,t=e.v,n=e.a,o=(200-r)*t/100;return{h:b(e.h),s:b(o>0&&o<200?r*t/100/(o<=100?o:200-o)*100:0),l:b(o/2),a:b(n,2)}},q=function(e){var r=y(e);return"hsl("+r.h+", "+r.s+"%, "+r.l+"%)"},k=function(e){var r=y(e);return"hsla("+r.h+", "+r.s+"%, "+r.l+"%, "+r.a+")"},I=function(e){var r=e.h,t=e.s,n=e.v,o=e.a;r=r/360*6,t/=100,n/=100;var a=Math.floor(r),l=n*(1-t),u=n*(1-(r-a)*t),c=n*(1-(1-r+a)*t),i=a%6;return{r:b(255*[n,u,l,l,c,n][i]),g:b(255*[c,n,n,u,l,l][i]),b:b(255*[l,l,c,n,n,u][i]),a:b(o,2)}},O=function(e){var r=/hsva?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e);return r?A({h:E(r[1],r[2]),s:Number(r[3]),v:Number(r[4]),a:void 0===r[5]?1:Number(r[5])/(r[6]?100:1)}):{h:0,s:0,v:0,a:1}},j=O,z=function(e){var r=/rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e);return r?L({r:Number(r[1])/(r[2]?100/255:1),g:Number(r[3])/(r[4]?100/255:1),b:Number(r[5])/(r[6]?100/255:1),a:void 0===r[7]?1:Number(r[7])/(r[8]?100:1)}):{h:0,s:0,v:0,a:1}},B=z,D=function(e){var r=e.toString(16);return r.length<2?"0"+r:r},K=function(e){var r=e.r,t=e.g,n=e.b,o=e.a,a=o<1?D(b(255*o)):"";return"#"+D(r)+D(t)+D(n)+a},L=function(e){var r=e.r,t=e.g,n=e.b,o=e.a,a=Math.max(r,t,n),l=a-Math.min(r,t,n),u=l?a===r?(t-n)/l:a===t?2+(n-r)/l:4+(r-t)/l:0;return{h:b(60*(u<0?u+6:u)),s:b(a?l/a*100:0),v:b(a/255*100),a:o}},A=function(e){return{h:b(e.h),s:b(e.s),v:b(e.v),a:b(e.a,2)}},S=react__WEBPACK_IMPORTED_MODULE_0__.memo(function(r){var t=r.hue,n=r.onChange,o=g(["react-colorful__hue",r.className]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:o},react__WEBPACK_IMPORTED_MODULE_0__.createElement(m,{onMove:function(e){n({h:360*e.left})},onKey:function(e){n({h:s(t+360*e.left,0,360)})},"aria-label":"Hue","aria-valuenow":b(t),"aria-valuemax":"360","aria-valuemin":"0"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(p,{className:"react-colorful__hue-pointer",left:t/360,color:q({h:t,s:100,v:100,a:1})})))}),T=react__WEBPACK_IMPORTED_MODULE_0__.memo(function(r){var t=r.hsva,n=r.onChange,o={backgroundColor:q({h:t.h,s:100,v:100,a:1})};return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:"react-colorful__saturation",style:o},react__WEBPACK_IMPORTED_MODULE_0__.createElement(m,{onMove:function(e){n({s:100*e.left,v:100-100*e.top})},onKey:function(e){n({s:s(t.s+100*e.left,0,100),v:s(t.v-100*e.top,0,100)})},"aria-label":"Color","aria-valuetext":"Saturation "+b(t.s)+"%, Brightness "+b(t.v)+"%"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(p,{className:"react-colorful__saturation-pointer",top:1-t.v/100,left:t.s/100,color:q(t)})))}),F=function(e,r){if(e===r)return!0;for(var t in e)if(e[t]!==r[t])return!1;return!0},P=function(e,r){return e.replace(/\s/g,"")===r.replace(/\s/g,"")},X=function(e,r){return e.toLowerCase()===r.toLowerCase()||F(C(e),C(r))};function Y(e,t,l){var u=i(l),c=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function(){return e.toHsva(t)}),s=c[0],f=c[1],v=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({color:t,hsva:s});(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function(){if(!e.equal(t,v.current.color)){var r=e.toHsva(t);v.current={hsva:r,color:t},f(r)}},[t,e]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function(){var r;F(s,v.current.hsva)||e.equal(r=e.fromHsva(s),v.current.color)||(v.current={hsva:s,color:r},u(r))},[s,e,u]);var d=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(e){f(function(r){return Object.assign({},r,e)})},[]);return[s,d]}var R,V="undefined"!=typeof window?react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect:react__WEBPACK_IMPORTED_MODULE_0__.useEffect,$=function(){return R||( true?__webpack_require__.nc:0)},G=function(e){R=e},J=new Map,Q=function(e){V(function(){var r=e.current?e.current.ownerDocument:document;if(void 0!==r&&!J.has(r)){var t=r.createElement("style");t.innerHTML='.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>\')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}',J.set(r,t);var n=$();n&&t.setAttribute("nonce",n),r.head.appendChild(t)}},[])},U=function(t){var n=t.className,o=t.colorModel,a=t.color,l=void 0===a?o.defaultColor:a,i=t.onChange,s=c(t,["className","colorModel","color","onChange"]),f=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);Q(f);var v=Y(o,l,i),d=v[0],h=v[1],m=g(["react-colorful",n]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",u({},s,{ref:f,className:m}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(T,{hsva:d,onChange:h}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(S,{hue:d.h,onChange:h,className:"react-colorful__last-control"}))},W={defaultColor:"000",toHsva:x,fromHsva:function(e){return w({h:e.h,s:e.s,v:e.v,a:1})},equal:X},Z=function(r){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(U,u({},r,{colorModel:W}))},ee=function(r){var t=r.className,n=r.hsva,o=r.onChange,a={backgroundImage:"linear-gradient(90deg, "+k(Object.assign({},n,{a:0}))+", "+k(Object.assign({},n,{a:1}))+")"},l=g(["react-colorful__alpha",t]),u=b(100*n.a);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:l},react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:"react-colorful__alpha-gradient",style:a}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(m,{onMove:function(e){o({a:e.left})},onKey:function(e){o({a:s(n.a+e.left)})},"aria-label":"Alpha","aria-valuetext":u+"%","aria-valuenow":u,"aria-valuemin":"0","aria-valuemax":"100"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(p,{className:"react-colorful__alpha-pointer",left:n.a,color:k(n)})))},re=function(t){var n=t.className,o=t.colorModel,a=t.color,l=void 0===a?o.defaultColor:a,i=t.onChange,s=c(t,["className","colorModel","color","onChange"]),f=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);Q(f);var v=Y(o,l,i),d=v[0],h=v[1],m=g(["react-colorful",n]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",u({},s,{ref:f,className:m}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(T,{hsva:d,onChange:h}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(S,{hue:d.h,onChange:h}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(ee,{hsva:d,onChange:h,className:"react-colorful__last-control"}))},te={defaultColor:"0001",toHsva:x,fromHsva:w,equal:X},ne=function(r){return e.createElement(re,u({},r,{colorModel:te}))},oe={defaultColor:{h:0,s:0,l:0,a:1},toHsva:N,fromHsva:y,equal:F},ae=function(r){return e.createElement(re,u({},r,{colorModel:oe}))},le={defaultColor:"hsla(0, 0%, 0%, 1)",toHsva:H,fromHsva:k,equal:P},ue=function(r){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(re,u({},r,{colorModel:le}))},ce={defaultColor:{h:0,s:0,l:0},toHsva:function(e){return N({h:e.h,s:e.s,l:e.l,a:1})},fromHsva:function(e){return{h:(r=y(e)).h,s:r.s,l:r.l};var r},equal:F},ie=function(r){return e.createElement(U,u({},r,{colorModel:ce}))},se={defaultColor:"hsl(0, 0%, 0%)",toHsva:M,fromHsva:q,equal:P},fe=function(r){return e.createElement(U,u({},r,{colorModel:se}))},ve={defaultColor:{h:0,s:0,v:0,a:1},toHsva:function(e){return e},fromHsva:A,equal:F},de=function(r){return e.createElement(re,u({},r,{colorModel:ve}))},he={defaultColor:"hsva(0, 0%, 0%, 1)",toHsva:O,fromHsva:function(e){var r=A(e);return"hsva("+r.h+", "+r.s+"%, "+r.v+"%, "+r.a+")"},equal:P},me=function(r){return e.createElement(re,u({},r,{colorModel:he}))},ge={defaultColor:{h:0,s:0,v:0},toHsva:function(e){return{h:e.h,s:e.s,v:e.v,a:1}},fromHsva:function(e){var r=A(e);return{h:r.h,s:r.s,v:r.v}},equal:F},pe=function(r){return e.createElement(U,u({},r,{colorModel:ge}))},be={defaultColor:"hsv(0, 0%, 0%)",toHsva:j,fromHsva:function(e){var r=A(e);return"hsv("+r.h+", "+r.s+"%, "+r.v+"%)"},equal:P},_e=function(r){return e.createElement(U,u({},r,{colorModel:be}))},xe={defaultColor:{r:0,g:0,b:0,a:1},toHsva:L,fromHsva:I,equal:F},Ce=function(r){return e.createElement(re,u({},r,{colorModel:xe}))},Ee={defaultColor:"rgba(0, 0, 0, 1)",toHsva:z,fromHsva:function(e){var r=I(e);return"rgba("+r.r+", "+r.g+", "+r.b+", "+r.a+")"},equal:P},He=function(r){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(re,u({},r,{colorModel:Ee}))},Me={defaultColor:{r:0,g:0,b:0},toHsva:function(e){return L({r:e.r,g:e.g,b:e.b,a:1})},fromHsva:function(e){return{r:(r=I(e)).r,g:r.g,b:r.b};var r},equal:F},Ne=function(r){return e.createElement(U,u({},r,{colorModel:Me}))},we={defaultColor:"rgb(0, 0, 0)",toHsva:B,fromHsva:function(e){var r=I(e);return"rgb("+r.r+", "+r.g+", "+r.b+")"},equal:P},ye=function(r){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(U,u({},r,{colorModel:we}))},qe=/^#?([0-9A-F]{3,8})$/i,ke=function(r){var t=r.color,l=void 0===t?"":t,s=r.onChange,f=r.onBlur,v=r.escape,d=r.validate,h=r.format,m=r.process,g=c(r,["color","onChange","onBlur","escape","validate","format","process"]),p=o(function(){return v(l)}),b=p[0],_=p[1],x=i(s),C=i(f),E=a(function(e){var r=v(e.target.value);_(r),d(r)&&x(m?m(r):r)},[v,m,d,x]),H=a(function(e){d(e.target.value)||_(v(l)),C(e)},[l,v,d,C]);return n(function(){_(v(l))},[l,v]),e.createElement("input",u({},g,{value:h?h(b):b,spellCheck:"false",onChange:E,onBlur:H}))},Ie=function(e){return"#"+e},Oe=function(r){var t=r.prefixed,n=r.alpha,o=c(r,["prefixed","alpha"]),l=a(function(e){return e.replace(/([^0-9A-F]+)/gi,"").substring(0,n?8:6)},[n]),i=a(function(e){return function(e,r){var t=qe.exec(e),n=t?t[1].length:0;return 3===n||6===n||!!r&&4===n||!!r&&8===n}(e,n)},[n]);return e.createElement(ke,u({},o,{escape:l,format:t?Ie:void 0,process:Ie,validate:i}))};
//# sourceMappingURL=index.module.js.map


/***/ }),

/***/ "../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/cjs/react-is.production.min.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");
function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}__webpack_unused_export__=h;__webpack_unused_export__=g;__webpack_unused_export__=b;__webpack_unused_export__=l;__webpack_unused_export__=d;__webpack_unused_export__=q;__webpack_unused_export__=p;__webpack_unused_export__=c;__webpack_unused_export__=f;__webpack_unused_export__=e;__webpack_unused_export__=m;
__webpack_unused_export__=n;__webpack_unused_export__=function(){return!1};__webpack_unused_export__=function(){return!1};__webpack_unused_export__=function(a){return v(a)===h};__webpack_unused_export__=function(a){return v(a)===g};__webpack_unused_export__=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===b};__webpack_unused_export__=function(a){return v(a)===l};__webpack_unused_export__=function(a){return v(a)===d};__webpack_unused_export__=function(a){return v(a)===q};__webpack_unused_export__=function(a){return v(a)===p};
__webpack_unused_export__=function(a){return v(a)===c};__webpack_unused_export__=function(a){return v(a)===f};__webpack_unused_export__=function(a){return v(a)===e};__webpack_unused_export__=function(a){return v(a)===m};__webpack_unused_export__=function(a){return v(a)===n};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};__webpack_unused_export__=v;


/***/ }),

/***/ "../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__("../../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/cjs/react-is.production.min.js");
} else {}


/***/ }),

/***/ "../../node_modules/.pnpm/remove-accents@0.5.0/node_modules/remove-accents/index.js":
/***/ ((module) => {

var characterMap = {
	"À": "A",
	"Á": "A",
	"Â": "A",
	"Ã": "A",
	"Ä": "A",
	"Å": "A",
	"Ấ": "A",
	"Ắ": "A",
	"Ẳ": "A",
	"Ẵ": "A",
	"Ặ": "A",
	"Æ": "AE",
	"Ầ": "A",
	"Ằ": "A",
	"Ȃ": "A",
	"Ả": "A",
	"Ạ": "A",
	"Ẩ": "A",
	"Ẫ": "A",
	"Ậ": "A",
	"Ç": "C",
	"Ḉ": "C",
	"È": "E",
	"É": "E",
	"Ê": "E",
	"Ë": "E",
	"Ế": "E",
	"Ḗ": "E",
	"Ề": "E",
	"Ḕ": "E",
	"Ḝ": "E",
	"Ȇ": "E",
	"Ẻ": "E",
	"Ẽ": "E",
	"Ẹ": "E",
	"Ể": "E",
	"Ễ": "E",
	"Ệ": "E",
	"Ì": "I",
	"Í": "I",
	"Î": "I",
	"Ï": "I",
	"Ḯ": "I",
	"Ȋ": "I",
	"Ỉ": "I",
	"Ị": "I",
	"Ð": "D",
	"Ñ": "N",
	"Ò": "O",
	"Ó": "O",
	"Ô": "O",
	"Õ": "O",
	"Ö": "O",
	"Ø": "O",
	"Ố": "O",
	"Ṍ": "O",
	"Ṓ": "O",
	"Ȏ": "O",
	"Ỏ": "O",
	"Ọ": "O",
	"Ổ": "O",
	"Ỗ": "O",
	"Ộ": "O",
	"Ờ": "O",
	"Ở": "O",
	"Ỡ": "O",
	"Ớ": "O",
	"Ợ": "O",
	"Ù": "U",
	"Ú": "U",
	"Û": "U",
	"Ü": "U",
	"Ủ": "U",
	"Ụ": "U",
	"Ử": "U",
	"Ữ": "U",
	"Ự": "U",
	"Ý": "Y",
	"à": "a",
	"á": "a",
	"â": "a",
	"ã": "a",
	"ä": "a",
	"å": "a",
	"ấ": "a",
	"ắ": "a",
	"ẳ": "a",
	"ẵ": "a",
	"ặ": "a",
	"æ": "ae",
	"ầ": "a",
	"ằ": "a",
	"ȃ": "a",
	"ả": "a",
	"ạ": "a",
	"ẩ": "a",
	"ẫ": "a",
	"ậ": "a",
	"ç": "c",
	"ḉ": "c",
	"è": "e",
	"é": "e",
	"ê": "e",
	"ë": "e",
	"ế": "e",
	"ḗ": "e",
	"ề": "e",
	"ḕ": "e",
	"ḝ": "e",
	"ȇ": "e",
	"ẻ": "e",
	"ẽ": "e",
	"ẹ": "e",
	"ể": "e",
	"ễ": "e",
	"ệ": "e",
	"ì": "i",
	"í": "i",
	"î": "i",
	"ï": "i",
	"ḯ": "i",
	"ȋ": "i",
	"ỉ": "i",
	"ị": "i",
	"ð": "d",
	"ñ": "n",
	"ò": "o",
	"ó": "o",
	"ô": "o",
	"õ": "o",
	"ö": "o",
	"ø": "o",
	"ố": "o",
	"ṍ": "o",
	"ṓ": "o",
	"ȏ": "o",
	"ỏ": "o",
	"ọ": "o",
	"ổ": "o",
	"ỗ": "o",
	"ộ": "o",
	"ờ": "o",
	"ở": "o",
	"ỡ": "o",
	"ớ": "o",
	"ợ": "o",
	"ù": "u",
	"ú": "u",
	"û": "u",
	"ü": "u",
	"ủ": "u",
	"ụ": "u",
	"ử": "u",
	"ữ": "u",
	"ự": "u",
	"ý": "y",
	"ÿ": "y",
	"Ā": "A",
	"ā": "a",
	"Ă": "A",
	"ă": "a",
	"Ą": "A",
	"ą": "a",
	"Ć": "C",
	"ć": "c",
	"Ĉ": "C",
	"ĉ": "c",
	"Ċ": "C",
	"ċ": "c",
	"Č": "C",
	"č": "c",
	"C̆": "C",
	"c̆": "c",
	"Ď": "D",
	"ď": "d",
	"Đ": "D",
	"đ": "d",
	"Ē": "E",
	"ē": "e",
	"Ĕ": "E",
	"ĕ": "e",
	"Ė": "E",
	"ė": "e",
	"Ę": "E",
	"ę": "e",
	"Ě": "E",
	"ě": "e",
	"Ĝ": "G",
	"Ǵ": "G",
	"ĝ": "g",
	"ǵ": "g",
	"Ğ": "G",
	"ğ": "g",
	"Ġ": "G",
	"ġ": "g",
	"Ģ": "G",
	"ģ": "g",
	"Ĥ": "H",
	"ĥ": "h",
	"Ħ": "H",
	"ħ": "h",
	"Ḫ": "H",
	"ḫ": "h",
	"Ĩ": "I",
	"ĩ": "i",
	"Ī": "I",
	"ī": "i",
	"Ĭ": "I",
	"ĭ": "i",
	"Į": "I",
	"į": "i",
	"İ": "I",
	"ı": "i",
	"Ĳ": "IJ",
	"ĳ": "ij",
	"Ĵ": "J",
	"ĵ": "j",
	"Ķ": "K",
	"ķ": "k",
	"Ḱ": "K",
	"ḱ": "k",
	"K̆": "K",
	"k̆": "k",
	"Ĺ": "L",
	"ĺ": "l",
	"Ļ": "L",
	"ļ": "l",
	"Ľ": "L",
	"ľ": "l",
	"Ŀ": "L",
	"ŀ": "l",
	"Ł": "l",
	"ł": "l",
	"Ḿ": "M",
	"ḿ": "m",
	"M̆": "M",
	"m̆": "m",
	"Ń": "N",
	"ń": "n",
	"Ņ": "N",
	"ņ": "n",
	"Ň": "N",
	"ň": "n",
	"ŉ": "n",
	"N̆": "N",
	"n̆": "n",
	"Ō": "O",
	"ō": "o",
	"Ŏ": "O",
	"ŏ": "o",
	"Ő": "O",
	"ő": "o",
	"Œ": "OE",
	"œ": "oe",
	"P̆": "P",
	"p̆": "p",
	"Ŕ": "R",
	"ŕ": "r",
	"Ŗ": "R",
	"ŗ": "r",
	"Ř": "R",
	"ř": "r",
	"R̆": "R",
	"r̆": "r",
	"Ȓ": "R",
	"ȓ": "r",
	"Ś": "S",
	"ś": "s",
	"Ŝ": "S",
	"ŝ": "s",
	"Ş": "S",
	"Ș": "S",
	"ș": "s",
	"ş": "s",
	"Š": "S",
	"š": "s",
	"Ţ": "T",
	"ţ": "t",
	"ț": "t",
	"Ț": "T",
	"Ť": "T",
	"ť": "t",
	"Ŧ": "T",
	"ŧ": "t",
	"T̆": "T",
	"t̆": "t",
	"Ũ": "U",
	"ũ": "u",
	"Ū": "U",
	"ū": "u",
	"Ŭ": "U",
	"ŭ": "u",
	"Ů": "U",
	"ů": "u",
	"Ű": "U",
	"ű": "u",
	"Ų": "U",
	"ų": "u",
	"Ȗ": "U",
	"ȗ": "u",
	"V̆": "V",
	"v̆": "v",
	"Ŵ": "W",
	"ŵ": "w",
	"Ẃ": "W",
	"ẃ": "w",
	"X̆": "X",
	"x̆": "x",
	"Ŷ": "Y",
	"ŷ": "y",
	"Ÿ": "Y",
	"Y̆": "Y",
	"y̆": "y",
	"Ź": "Z",
	"ź": "z",
	"Ż": "Z",
	"ż": "z",
	"Ž": "Z",
	"ž": "z",
	"ſ": "s",
	"ƒ": "f",
	"Ơ": "O",
	"ơ": "o",
	"Ư": "U",
	"ư": "u",
	"Ǎ": "A",
	"ǎ": "a",
	"Ǐ": "I",
	"ǐ": "i",
	"Ǒ": "O",
	"ǒ": "o",
	"Ǔ": "U",
	"ǔ": "u",
	"Ǖ": "U",
	"ǖ": "u",
	"Ǘ": "U",
	"ǘ": "u",
	"Ǚ": "U",
	"ǚ": "u",
	"Ǜ": "U",
	"ǜ": "u",
	"Ứ": "U",
	"ứ": "u",
	"Ṹ": "U",
	"ṹ": "u",
	"Ǻ": "A",
	"ǻ": "a",
	"Ǽ": "AE",
	"ǽ": "ae",
	"Ǿ": "O",
	"ǿ": "o",
	"Þ": "TH",
	"þ": "th",
	"Ṕ": "P",
	"ṕ": "p",
	"Ṥ": "S",
	"ṥ": "s",
	"X́": "X",
	"x́": "x",
	"Ѓ": "Г",
	"ѓ": "г",
	"Ќ": "К",
	"ќ": "к",
	"A̋": "A",
	"a̋": "a",
	"E̋": "E",
	"e̋": "e",
	"I̋": "I",
	"i̋": "i",
	"Ǹ": "N",
	"ǹ": "n",
	"Ồ": "O",
	"ồ": "o",
	"Ṑ": "O",
	"ṑ": "o",
	"Ừ": "U",
	"ừ": "u",
	"Ẁ": "W",
	"ẁ": "w",
	"Ỳ": "Y",
	"ỳ": "y",
	"Ȁ": "A",
	"ȁ": "a",
	"Ȅ": "E",
	"ȅ": "e",
	"Ȉ": "I",
	"ȉ": "i",
	"Ȍ": "O",
	"ȍ": "o",
	"Ȑ": "R",
	"ȑ": "r",
	"Ȕ": "U",
	"ȕ": "u",
	"B̌": "B",
	"b̌": "b",
	"Č̣": "C",
	"č̣": "c",
	"Ê̌": "E",
	"ê̌": "e",
	"F̌": "F",
	"f̌": "f",
	"Ǧ": "G",
	"ǧ": "g",
	"Ȟ": "H",
	"ȟ": "h",
	"J̌": "J",
	"ǰ": "j",
	"Ǩ": "K",
	"ǩ": "k",
	"M̌": "M",
	"m̌": "m",
	"P̌": "P",
	"p̌": "p",
	"Q̌": "Q",
	"q̌": "q",
	"Ř̩": "R",
	"ř̩": "r",
	"Ṧ": "S",
	"ṧ": "s",
	"V̌": "V",
	"v̌": "v",
	"W̌": "W",
	"w̌": "w",
	"X̌": "X",
	"x̌": "x",
	"Y̌": "Y",
	"y̌": "y",
	"A̧": "A",
	"a̧": "a",
	"B̧": "B",
	"b̧": "b",
	"Ḑ": "D",
	"ḑ": "d",
	"Ȩ": "E",
	"ȩ": "e",
	"Ɛ̧": "E",
	"ɛ̧": "e",
	"Ḩ": "H",
	"ḩ": "h",
	"I̧": "I",
	"i̧": "i",
	"Ɨ̧": "I",
	"ɨ̧": "i",
	"M̧": "M",
	"m̧": "m",
	"O̧": "O",
	"o̧": "o",
	"Q̧": "Q",
	"q̧": "q",
	"U̧": "U",
	"u̧": "u",
	"X̧": "X",
	"x̧": "x",
	"Z̧": "Z",
	"z̧": "z",
	"й":"и",
	"Й":"И",
	"ё":"е",
	"Ё":"Е",
};

var chars = Object.keys(characterMap).join('|');
var allAccents = new RegExp(chars, 'g');
var firstAccent = new RegExp(chars, '');

function matcher(match) {
	return characterMap[match];
}

var removeAccents = function(string) {
	return string.replace(allAccents, matcher);
};

var hasAccents = function(string) {
	return !!string.match(firstAccent);
};

module.exports = removeAccents;
module.exports.has = hasAccents;
module.exports.remove = removeAccents;


/***/ }),

/***/ "../../node_modules/.pnpm/showdown@1.9.1/node_modules/showdown/dist/showdown.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;;/*! showdown v 1.9.1 - 02-11-2019 */
(function(){
/**
 * Created by Tivie on 13-07-2015.
 */

function getDefaultOpts (simple) {
  'use strict';

  var defaultOptions = {
    omitExtraWLInCodeBlocks: {
      defaultValue: false,
      describe: 'Omit the default extra whiteline added to code blocks',
      type: 'boolean'
    },
    noHeaderId: {
      defaultValue: false,
      describe: 'Turn on/off generated header id',
      type: 'boolean'
    },
    prefixHeaderId: {
      defaultValue: false,
      describe: 'Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic \'section-\' prefix',
      type: 'string'
    },
    rawPrefixHeaderId: {
      defaultValue: false,
      describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
      type: 'boolean'
    },
    ghCompatibleHeaderId: {
      defaultValue: false,
      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',
      type: 'boolean'
    },
    rawHeaderId: {
      defaultValue: false,
      describe: 'Remove only spaces, \' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids',
      type: 'boolean'
    },
    headerLevelStart: {
      defaultValue: false,
      describe: 'The header blocks level start',
      type: 'integer'
    },
    parseImgDimensions: {
      defaultValue: false,
      describe: 'Turn on/off image dimension parsing',
      type: 'boolean'
    },
    simplifiedAutoLink: {
      defaultValue: false,
      describe: 'Turn on/off GFM autolink style',
      type: 'boolean'
    },
    excludeTrailingPunctuationFromURLs: {
      defaultValue: false,
      describe: 'Excludes trailing punctuation from links generated with autoLinking',
      type: 'boolean'
    },
    literalMidWordUnderscores: {
      defaultValue: false,
      describe: 'Parse midword underscores as literal underscores',
      type: 'boolean'
    },
    literalMidWordAsterisks: {
      defaultValue: false,
      describe: 'Parse midword asterisks as literal asterisks',
      type: 'boolean'
    },
    strikethrough: {
      defaultValue: false,
      describe: 'Turn on/off strikethrough support',
      type: 'boolean'
    },
    tables: {
      defaultValue: false,
      describe: 'Turn on/off tables support',
      type: 'boolean'
    },
    tablesHeaderId: {
      defaultValue: false,
      describe: 'Add an id to table headers',
      type: 'boolean'
    },
    ghCodeBlocks: {
      defaultValue: true,
      describe: 'Turn on/off GFM fenced code blocks support',
      type: 'boolean'
    },
    tasklists: {
      defaultValue: false,
      describe: 'Turn on/off GFM tasklist support',
      type: 'boolean'
    },
    smoothLivePreview: {
      defaultValue: false,
      describe: 'Prevents weird effects in live previews due to incomplete input',
      type: 'boolean'
    },
    smartIndentationFix: {
      defaultValue: false,
      description: 'Tries to smartly fix indentation in es6 strings',
      type: 'boolean'
    },
    disableForced4SpacesIndentedSublists: {
      defaultValue: false,
      description: 'Disables the requirement of indenting nested sublists by 4 spaces',
      type: 'boolean'
    },
    simpleLineBreaks: {
      defaultValue: false,
      description: 'Parses simple line breaks as <br> (GFM Style)',
      type: 'boolean'
    },
    requireSpaceBeforeHeadingText: {
      defaultValue: false,
      description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',
      type: 'boolean'
    },
    ghMentions: {
      defaultValue: false,
      description: 'Enables github @mentions',
      type: 'boolean'
    },
    ghMentionsLink: {
      defaultValue: 'https://github.com/{u}',
      description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',
      type: 'string'
    },
    encodeEmails: {
      defaultValue: true,
      description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',
      type: 'boolean'
    },
    openLinksInNewWindow: {
      defaultValue: false,
      description: 'Open all links in new windows',
      type: 'boolean'
    },
    backslashEscapesHTMLTags: {
      defaultValue: false,
      description: 'Support for HTML Tag escaping. ex: \<div>foo\</div>',
      type: 'boolean'
    },
    emoji: {
      defaultValue: false,
      description: 'Enable emoji support. Ex: `this is a :smile: emoji`',
      type: 'boolean'
    },
    underline: {
      defaultValue: false,
      description: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`',
      type: 'boolean'
    },
    completeHTMLDocument: {
      defaultValue: false,
      description: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags',
      type: 'boolean'
    },
    metadata: {
      defaultValue: false,
      description: 'Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).',
      type: 'boolean'
    },
    splitAdjacentBlockquotes: {
      defaultValue: false,
      description: 'Split adjacent blockquote blocks',
      type: 'boolean'
    }
  };
  if (simple === false) {
    return JSON.parse(JSON.stringify(defaultOptions));
  }
  var ret = {};
  for (var opt in defaultOptions) {
    if (defaultOptions.hasOwnProperty(opt)) {
      ret[opt] = defaultOptions[opt].defaultValue;
    }
  }
  return ret;
}

function allOptionsOn () {
  'use strict';
  var options = getDefaultOpts(true),
      ret = {};
  for (var opt in options) {
    if (options.hasOwnProperty(opt)) {
      ret[opt] = true;
    }
  }
  return ret;
}

/**
 * Created by Tivie on 06-01-2015.
 */

// Private properties
var showdown = {},
    parsers = {},
    extensions = {},
    globalOptions = getDefaultOpts(true),
    setFlavor = 'vanilla',
    flavor = {
      github: {
        omitExtraWLInCodeBlocks:              true,
        simplifiedAutoLink:                   true,
        excludeTrailingPunctuationFromURLs:   true,
        literalMidWordUnderscores:            true,
        strikethrough:                        true,
        tables:                               true,
        tablesHeaderId:                       true,
        ghCodeBlocks:                         true,
        tasklists:                            true,
        disableForced4SpacesIndentedSublists: true,
        simpleLineBreaks:                     true,
        requireSpaceBeforeHeadingText:        true,
        ghCompatibleHeaderId:                 true,
        ghMentions:                           true,
        backslashEscapesHTMLTags:             true,
        emoji:                                true,
        splitAdjacentBlockquotes:             true
      },
      original: {
        noHeaderId:                           true,
        ghCodeBlocks:                         false
      },
      ghost: {
        omitExtraWLInCodeBlocks:              true,
        parseImgDimensions:                   true,
        simplifiedAutoLink:                   true,
        excludeTrailingPunctuationFromURLs:   true,
        literalMidWordUnderscores:            true,
        strikethrough:                        true,
        tables:                               true,
        tablesHeaderId:                       true,
        ghCodeBlocks:                         true,
        tasklists:                            true,
        smoothLivePreview:                    true,
        simpleLineBreaks:                     true,
        requireSpaceBeforeHeadingText:        true,
        ghMentions:                           false,
        encodeEmails:                         true
      },
      vanilla: getDefaultOpts(true),
      allOn: allOptionsOn()
    };

/**
 * helper namespace
 * @type {{}}
 */
showdown.helper = {};

/**
 * TODO LEGACY SUPPORT CODE
 * @type {{}}
 */
showdown.extensions = {};

/**
 * Set a global option
 * @static
 * @param {string} key
 * @param {*} value
 * @returns {showdown}
 */
showdown.setOption = function (key, value) {
  'use strict';
  globalOptions[key] = value;
  return this;
};

/**
 * Get a global option
 * @static
 * @param {string} key
 * @returns {*}
 */
showdown.getOption = function (key) {
  'use strict';
  return globalOptions[key];
};

/**
 * Get the global options
 * @static
 * @returns {{}}
 */
showdown.getOptions = function () {
  'use strict';
  return globalOptions;
};

/**
 * Reset global options to the default values
 * @static
 */
showdown.resetOptions = function () {
  'use strict';
  globalOptions = getDefaultOpts(true);
};

/**
 * Set the flavor showdown should use as default
 * @param {string} name
 */
showdown.setFlavor = function (name) {
  'use strict';
  if (!flavor.hasOwnProperty(name)) {
    throw Error(name + ' flavor was not found');
  }
  showdown.resetOptions();
  var preset = flavor[name];
  setFlavor = name;
  for (var option in preset) {
    if (preset.hasOwnProperty(option)) {
      globalOptions[option] = preset[option];
    }
  }
};

/**
 * Get the currently set flavor
 * @returns {string}
 */
showdown.getFlavor = function () {
  'use strict';
  return setFlavor;
};

/**
 * Get the options of a specified flavor. Returns undefined if the flavor was not found
 * @param {string} name Name of the flavor
 * @returns {{}|undefined}
 */
showdown.getFlavorOptions = function (name) {
  'use strict';
  if (flavor.hasOwnProperty(name)) {
    return flavor[name];
  }
};

/**
 * Get the default options
 * @static
 * @param {boolean} [simple=true]
 * @returns {{}}
 */
showdown.getDefaultOptions = function (simple) {
  'use strict';
  return getDefaultOpts(simple);
};

/**
 * Get or set a subParser
 *
 * subParser(name)       - Get a registered subParser
 * subParser(name, func) - Register a subParser
 * @static
 * @param {string} name
 * @param {function} [func]
 * @returns {*}
 */
showdown.subParser = function (name, func) {
  'use strict';
  if (showdown.helper.isString(name)) {
    if (typeof func !== 'undefined') {
      parsers[name] = func;
    } else {
      if (parsers.hasOwnProperty(name)) {
        return parsers[name];
      } else {
        throw Error('SubParser named ' + name + ' not registered!');
      }
    }
  }
};

/**
 * Gets or registers an extension
 * @static
 * @param {string} name
 * @param {object|function=} ext
 * @returns {*}
 */
showdown.extension = function (name, ext) {
  'use strict';

  if (!showdown.helper.isString(name)) {
    throw Error('Extension \'name\' must be a string');
  }

  name = showdown.helper.stdExtName(name);

  // Getter
  if (showdown.helper.isUndefined(ext)) {
    if (!extensions.hasOwnProperty(name)) {
      throw Error('Extension named ' + name + ' is not registered!');
    }
    return extensions[name];

    // Setter
  } else {
    // Expand extension if it's wrapped in a function
    if (typeof ext === 'function') {
      ext = ext();
    }

    // Ensure extension is an array
    if (!showdown.helper.isArray(ext)) {
      ext = [ext];
    }

    var validExtension = validate(ext, name);

    if (validExtension.valid) {
      extensions[name] = ext;
    } else {
      throw Error(validExtension.error);
    }
  }
};

/**
 * Gets all extensions registered
 * @returns {{}}
 */
showdown.getAllExtensions = function () {
  'use strict';
  return extensions;
};

/**
 * Remove an extension
 * @param {string} name
 */
showdown.removeExtension = function (name) {
  'use strict';
  delete extensions[name];
};

/**
 * Removes all extensions
 */
showdown.resetExtensions = function () {
  'use strict';
  extensions = {};
};

/**
 * Validate extension
 * @param {array} extension
 * @param {string} name
 * @returns {{valid: boolean, error: string}}
 */
function validate (extension, name) {
  'use strict';

  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',
      ret = {
        valid: true,
        error: ''
      };

  if (!showdown.helper.isArray(extension)) {
    extension = [extension];
  }

  for (var i = 0; i < extension.length; ++i) {
    var baseMsg = errMsg + ' sub-extension ' + i + ': ',
        ext = extension[i];
    if (typeof ext !== 'object') {
      ret.valid = false;
      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';
      return ret;
    }

    if (!showdown.helper.isString(ext.type)) {
      ret.valid = false;
      ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + ' given';
      return ret;
    }

    var type = ext.type = ext.type.toLowerCase();

    // normalize extension type
    if (type === 'language') {
      type = ext.type = 'lang';
    }

    if (type === 'html') {
      type = ext.type = 'output';
    }

    if (type !== 'lang' && type !== 'output' && type !== 'listener') {
      ret.valid = false;
      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
      return ret;
    }

    if (type === 'listener') {
      if (showdown.helper.isUndefined(ext.listeners)) {
        ret.valid = false;
        ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
        return ret;
      }
    } else {
      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {
        ret.valid = false;
        ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
        return ret;
      }
    }

    if (ext.listeners) {
      if (typeof ext.listeners !== 'object') {
        ret.valid = false;
        ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + ' given';
        return ret;
      }
      for (var ln in ext.listeners) {
        if (ext.listeners.hasOwnProperty(ln)) {
          if (typeof ext.listeners[ln] !== 'function') {
            ret.valid = false;
            ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln +
              ' must be a function but ' + typeof ext.listeners[ln] + ' given';
            return ret;
          }
        }
      }
    }

    if (ext.filter) {
      if (typeof ext.filter !== 'function') {
        ret.valid = false;
        ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + ' given';
        return ret;
      }
    } else if (ext.regex) {
      if (showdown.helper.isString(ext.regex)) {
        ext.regex = new RegExp(ext.regex, 'g');
      }
      if (!(ext.regex instanceof RegExp)) {
        ret.valid = false;
        ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';
        return ret;
      }
      if (showdown.helper.isUndefined(ext.replace)) {
        ret.valid = false;
        ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
        return ret;
      }
    }
  }
  return ret;
}

/**
 * Validate extension
 * @param {object} ext
 * @returns {boolean}
 */
showdown.validateExtension = function (ext) {
  'use strict';

  var validateExtension = validate(ext, null);
  if (!validateExtension.valid) {
    console.warn(validateExtension.error);
    return false;
  }
  return true;
};

/**
 * showdownjs helper functions
 */

if (!showdown.hasOwnProperty('helper')) {
  showdown.helper = {};
}

/**
 * Check if var is string
 * @static
 * @param {string} a
 * @returns {boolean}
 */
showdown.helper.isString = function (a) {
  'use strict';
  return (typeof a === 'string' || a instanceof String);
};

/**
 * Check if var is a function
 * @static
 * @param {*} a
 * @returns {boolean}
 */
showdown.helper.isFunction = function (a) {
  'use strict';
  var getType = {};
  return a && getType.toString.call(a) === '[object Function]';
};

/**
 * isArray helper function
 * @static
 * @param {*} a
 * @returns {boolean}
 */
showdown.helper.isArray = function (a) {
  'use strict';
  return Array.isArray(a);
};

/**
 * Check if value is undefined
 * @static
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 */
showdown.helper.isUndefined = function (value) {
  'use strict';
  return typeof value === 'undefined';
};

/**
 * ForEach helper function
 * Iterates over Arrays and Objects (own properties only)
 * @static
 * @param {*} obj
 * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object
 */
showdown.helper.forEach = function (obj, callback) {
  'use strict';
  // check if obj is defined
  if (showdown.helper.isUndefined(obj)) {
    throw new Error('obj param is required');
  }

  if (showdown.helper.isUndefined(callback)) {
    throw new Error('callback param is required');
  }

  if (!showdown.helper.isFunction(callback)) {
    throw new Error('callback param must be a function/closure');
  }

  if (typeof obj.forEach === 'function') {
    obj.forEach(callback);
  } else if (showdown.helper.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      callback(obj[i], i, obj);
    }
  } else if (typeof (obj) === 'object') {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        callback(obj[prop], prop, obj);
      }
    }
  } else {
    throw new Error('obj does not seem to be an array or an iterable object');
  }
};

/**
 * Standardidize extension name
 * @static
 * @param {string} s extension name
 * @returns {string}
 */
showdown.helper.stdExtName = function (s) {
  'use strict';
  return s.replace(/[_?*+\/\\.^-]/g, '').replace(/\s/g, '').toLowerCase();
};

function escapeCharactersCallback (wholeMatch, m1) {
  'use strict';
  var charCodeToEscape = m1.charCodeAt(0);
  return '¨E' + charCodeToEscape + 'E';
}

/**
 * Callback used to escape characters when passing through String.replace
 * @static
 * @param {string} wholeMatch
 * @param {string} m1
 * @returns {string}
 */
showdown.helper.escapeCharactersCallback = escapeCharactersCallback;

/**
 * Escape characters in a string
 * @static
 * @param {string} text
 * @param {string} charsToEscape
 * @param {boolean} afterBackslash
 * @returns {XML|string|void|*}
 */
showdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {
  'use strict';
  // First we have to escape the escape characters so that
  // we can build a character class out of them
  var regexString = '([' + charsToEscape.replace(/([\[\]\\])/g, '\\$1') + '])';

  if (afterBackslash) {
    regexString = '\\\\' + regexString;
  }

  var regex = new RegExp(regexString, 'g');
  text = text.replace(regex, escapeCharactersCallback);

  return text;
};

/**
 * Unescape HTML entities
 * @param txt
 * @returns {string}
 */
showdown.helper.unescapeHTMLEntities = function (txt) {
  'use strict';

  return txt
    .replace(/&quot;/g, '"')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&');
};

var rgxFindMatchPos = function (str, left, right, flags) {
  'use strict';
  var f = flags || '',
      g = f.indexOf('g') > -1,
      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),
      l = new RegExp(left, f.replace(/g/g, '')),
      pos = [],
      t, s, m, start, end;

  do {
    t = 0;
    while ((m = x.exec(str))) {
      if (l.test(m[0])) {
        if (!(t++)) {
          s = x.lastIndex;
          start = s - m[0].length;
        }
      } else if (t) {
        if (!--t) {
          end = m.index + m[0].length;
          var obj = {
            left: {start: start, end: s},
            match: {start: s, end: m.index},
            right: {start: m.index, end: end},
            wholeMatch: {start: start, end: end}
          };
          pos.push(obj);
          if (!g) {
            return pos;
          }
        }
      }
    }
  } while (t && (x.lastIndex = s));

  return pos;
};

/**
 * matchRecursiveRegExp
 *
 * (c) 2007 Steven Levithan <stevenlevithan.com>
 * MIT License
 *
 * Accepts a string to search, a left and right format delimiter
 * as regex patterns, and optional regex flags. Returns an array
 * of matches, allowing nested instances of left/right delimiters.
 * Use the "g" flag to return all matches, otherwise only the
 * first is returned. Be careful to ensure that the left and
 * right format delimiters produce mutually exclusive matches.
 * Backreferences are not supported within the right delimiter
 * due to how it is internally combined with the left delimiter.
 * When matching strings whose format delimiters are unbalanced
 * to the left or right, the output is intentionally as a
 * conventional regex library with recursion support would
 * produce, e.g. "<<x>" and "<x>>" both produce ["x"] when using
 * "<" and ">" as the delimiters (both strings contain a single,
 * balanced instance of "<x>").
 *
 * examples:
 * matchRecursiveRegExp("test", "\\(", "\\)")
 * returns: []
 * matchRecursiveRegExp("<t<<e>><s>>t<>", "<", ">", "g")
 * returns: ["t<<e>><s>", ""]
 * matchRecursiveRegExp("<div id=\"x\">test</div>", "<div\\b[^>]*>", "</div>", "gi")
 * returns: ["test"]
 */
showdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {
  'use strict';

  var matchPos = rgxFindMatchPos (str, left, right, flags),
      results = [];

  for (var i = 0; i < matchPos.length; ++i) {
    results.push([
      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
      str.slice(matchPos[i].match.start, matchPos[i].match.end),
      str.slice(matchPos[i].left.start, matchPos[i].left.end),
      str.slice(matchPos[i].right.start, matchPos[i].right.end)
    ]);
  }
  return results;
};

/**
 *
 * @param {string} str
 * @param {string|function} replacement
 * @param {string} left
 * @param {string} right
 * @param {string} flags
 * @returns {string}
 */
showdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {
  'use strict';

  if (!showdown.helper.isFunction(replacement)) {
    var repStr = replacement;
    replacement = function () {
      return repStr;
    };
  }

  var matchPos = rgxFindMatchPos(str, left, right, flags),
      finalStr = str,
      lng = matchPos.length;

  if (lng > 0) {
    var bits = [];
    if (matchPos[0].wholeMatch.start !== 0) {
      bits.push(str.slice(0, matchPos[0].wholeMatch.start));
    }
    for (var i = 0; i < lng; ++i) {
      bits.push(
        replacement(
          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
          str.slice(matchPos[i].match.start, matchPos[i].match.end),
          str.slice(matchPos[i].left.start, matchPos[i].left.end),
          str.slice(matchPos[i].right.start, matchPos[i].right.end)
        )
      );
      if (i < lng - 1) {
        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
      }
    }
    if (matchPos[lng - 1].wholeMatch.end < str.length) {
      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
    }
    finalStr = bits.join('');
  }
  return finalStr;
};

/**
 * Returns the index within the passed String object of the first occurrence of the specified regex,
 * starting the search at fromIndex. Returns -1 if the value is not found.
 *
 * @param {string} str string to search
 * @param {RegExp} regex Regular expression to search
 * @param {int} [fromIndex = 0] Index to start the search
 * @returns {Number}
 * @throws InvalidArgumentError
 */
showdown.helper.regexIndexOf = function (str, regex, fromIndex) {
  'use strict';
  if (!showdown.helper.isString(str)) {
    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
  }
  if (regex instanceof RegExp === false) {
    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';
  }
  var indexOf = str.substring(fromIndex || 0).search(regex);
  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;
};

/**
 * Splits the passed string object at the defined index, and returns an array composed of the two substrings
 * @param {string} str string to split
 * @param {int} index index to split string at
 * @returns {[string,string]}
 * @throws InvalidArgumentError
 */
showdown.helper.splitAtIndex = function (str, index) {
  'use strict';
  if (!showdown.helper.isString(str)) {
    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
  }
  return [str.substring(0, index), str.substring(index)];
};

/**
 * Obfuscate an e-mail address through the use of Character Entities,
 * transforming ASCII characters into their equivalent decimal or hex entities.
 *
 * Since it has a random component, subsequent calls to this function produce different results
 *
 * @param {string} mail
 * @returns {string}
 */
showdown.helper.encodeEmailAddress = function (mail) {
  'use strict';
  var encode = [
    function (ch) {
      return '&#' + ch.charCodeAt(0) + ';';
    },
    function (ch) {
      return '&#x' + ch.charCodeAt(0).toString(16) + ';';
    },
    function (ch) {
      return ch;
    }
  ];

  mail = mail.replace(/./g, function (ch) {
    if (ch === '@') {
      // this *must* be encoded. I insist.
      ch = encode[Math.floor(Math.random() * 2)](ch);
    } else {
      var r = Math.random();
      // roughly 10% raw, 45% hex, 45% dec
      ch = (
        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)
      );
    }
    return ch;
  });

  return mail;
};

/**
 *
 * @param str
 * @param targetLength
 * @param padString
 * @returns {string}
 */
showdown.helper.padEnd = function padEnd (str, targetLength, padString) {
  'use strict';
  /*jshint bitwise: false*/
  // eslint-disable-next-line space-infix-ops
  targetLength = targetLength>>0; //floor if number or convert non-number to 0;
  /*jshint bitwise: true*/
  padString = String(padString || ' ');
  if (str.length > targetLength) {
    return String(str);
  } else {
    targetLength = targetLength - str.length;
    if (targetLength > padString.length) {
      padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
    }
    return String(str) + padString.slice(0,targetLength);
  }
};

/**
 * POLYFILLS
 */
// use this instead of builtin is undefined for IE8 compatibility
if (typeof console === 'undefined') {
  console = {
    warn: function (msg) {
      'use strict';
      alert(msg);
    },
    log: function (msg) {
      'use strict';
      alert(msg);
    },
    error: function (msg) {
      'use strict';
      throw msg;
    }
  };
}

/**
 * Common regexes.
 * We declare some common regexes to improve performance
 */
showdown.helper.regexes = {
  asteriskDashAndColon: /([*_:~])/g
};

/**
 * EMOJIS LIST
 */
showdown.helper.emojis = {
  '+1':'\ud83d\udc4d',
  '-1':'\ud83d\udc4e',
  '100':'\ud83d\udcaf',
  '1234':'\ud83d\udd22',
  '1st_place_medal':'\ud83e\udd47',
  '2nd_place_medal':'\ud83e\udd48',
  '3rd_place_medal':'\ud83e\udd49',
  '8ball':'\ud83c\udfb1',
  'a':'\ud83c\udd70\ufe0f',
  'ab':'\ud83c\udd8e',
  'abc':'\ud83d\udd24',
  'abcd':'\ud83d\udd21',
  'accept':'\ud83c\ude51',
  'aerial_tramway':'\ud83d\udea1',
  'airplane':'\u2708\ufe0f',
  'alarm_clock':'\u23f0',
  'alembic':'\u2697\ufe0f',
  'alien':'\ud83d\udc7d',
  'ambulance':'\ud83d\ude91',
  'amphora':'\ud83c\udffa',
  'anchor':'\u2693\ufe0f',
  'angel':'\ud83d\udc7c',
  'anger':'\ud83d\udca2',
  'angry':'\ud83d\ude20',
  'anguished':'\ud83d\ude27',
  'ant':'\ud83d\udc1c',
  'apple':'\ud83c\udf4e',
  'aquarius':'\u2652\ufe0f',
  'aries':'\u2648\ufe0f',
  'arrow_backward':'\u25c0\ufe0f',
  'arrow_double_down':'\u23ec',
  'arrow_double_up':'\u23eb',
  'arrow_down':'\u2b07\ufe0f',
  'arrow_down_small':'\ud83d\udd3d',
  'arrow_forward':'\u25b6\ufe0f',
  'arrow_heading_down':'\u2935\ufe0f',
  'arrow_heading_up':'\u2934\ufe0f',
  'arrow_left':'\u2b05\ufe0f',
  'arrow_lower_left':'\u2199\ufe0f',
  'arrow_lower_right':'\u2198\ufe0f',
  'arrow_right':'\u27a1\ufe0f',
  'arrow_right_hook':'\u21aa\ufe0f',
  'arrow_up':'\u2b06\ufe0f',
  'arrow_up_down':'\u2195\ufe0f',
  'arrow_up_small':'\ud83d\udd3c',
  'arrow_upper_left':'\u2196\ufe0f',
  'arrow_upper_right':'\u2197\ufe0f',
  'arrows_clockwise':'\ud83d\udd03',
  'arrows_counterclockwise':'\ud83d\udd04',
  'art':'\ud83c\udfa8',
  'articulated_lorry':'\ud83d\ude9b',
  'artificial_satellite':'\ud83d\udef0',
  'astonished':'\ud83d\ude32',
  'athletic_shoe':'\ud83d\udc5f',
  'atm':'\ud83c\udfe7',
  'atom_symbol':'\u269b\ufe0f',
  'avocado':'\ud83e\udd51',
  'b':'\ud83c\udd71\ufe0f',
  'baby':'\ud83d\udc76',
  'baby_bottle':'\ud83c\udf7c',
  'baby_chick':'\ud83d\udc24',
  'baby_symbol':'\ud83d\udebc',
  'back':'\ud83d\udd19',
  'bacon':'\ud83e\udd53',
  'badminton':'\ud83c\udff8',
  'baggage_claim':'\ud83d\udec4',
  'baguette_bread':'\ud83e\udd56',
  'balance_scale':'\u2696\ufe0f',
  'balloon':'\ud83c\udf88',
  'ballot_box':'\ud83d\uddf3',
  'ballot_box_with_check':'\u2611\ufe0f',
  'bamboo':'\ud83c\udf8d',
  'banana':'\ud83c\udf4c',
  'bangbang':'\u203c\ufe0f',
  'bank':'\ud83c\udfe6',
  'bar_chart':'\ud83d\udcca',
  'barber':'\ud83d\udc88',
  'baseball':'\u26be\ufe0f',
  'basketball':'\ud83c\udfc0',
  'basketball_man':'\u26f9\ufe0f',
  'basketball_woman':'\u26f9\ufe0f&zwj;\u2640\ufe0f',
  'bat':'\ud83e\udd87',
  'bath':'\ud83d\udec0',
  'bathtub':'\ud83d\udec1',
  'battery':'\ud83d\udd0b',
  'beach_umbrella':'\ud83c\udfd6',
  'bear':'\ud83d\udc3b',
  'bed':'\ud83d\udecf',
  'bee':'\ud83d\udc1d',
  'beer':'\ud83c\udf7a',
  'beers':'\ud83c\udf7b',
  'beetle':'\ud83d\udc1e',
  'beginner':'\ud83d\udd30',
  'bell':'\ud83d\udd14',
  'bellhop_bell':'\ud83d\udece',
  'bento':'\ud83c\udf71',
  'biking_man':'\ud83d\udeb4',
  'bike':'\ud83d\udeb2',
  'biking_woman':'\ud83d\udeb4&zwj;\u2640\ufe0f',
  'bikini':'\ud83d\udc59',
  'biohazard':'\u2623\ufe0f',
  'bird':'\ud83d\udc26',
  'birthday':'\ud83c\udf82',
  'black_circle':'\u26ab\ufe0f',
  'black_flag':'\ud83c\udff4',
  'black_heart':'\ud83d\udda4',
  'black_joker':'\ud83c\udccf',
  'black_large_square':'\u2b1b\ufe0f',
  'black_medium_small_square':'\u25fe\ufe0f',
  'black_medium_square':'\u25fc\ufe0f',
  'black_nib':'\u2712\ufe0f',
  'black_small_square':'\u25aa\ufe0f',
  'black_square_button':'\ud83d\udd32',
  'blonde_man':'\ud83d\udc71',
  'blonde_woman':'\ud83d\udc71&zwj;\u2640\ufe0f',
  'blossom':'\ud83c\udf3c',
  'blowfish':'\ud83d\udc21',
  'blue_book':'\ud83d\udcd8',
  'blue_car':'\ud83d\ude99',
  'blue_heart':'\ud83d\udc99',
  'blush':'\ud83d\ude0a',
  'boar':'\ud83d\udc17',
  'boat':'\u26f5\ufe0f',
  'bomb':'\ud83d\udca3',
  'book':'\ud83d\udcd6',
  'bookmark':'\ud83d\udd16',
  'bookmark_tabs':'\ud83d\udcd1',
  'books':'\ud83d\udcda',
  'boom':'\ud83d\udca5',
  'boot':'\ud83d\udc62',
  'bouquet':'\ud83d\udc90',
  'bowing_man':'\ud83d\ude47',
  'bow_and_arrow':'\ud83c\udff9',
  'bowing_woman':'\ud83d\ude47&zwj;\u2640\ufe0f',
  'bowling':'\ud83c\udfb3',
  'boxing_glove':'\ud83e\udd4a',
  'boy':'\ud83d\udc66',
  'bread':'\ud83c\udf5e',
  'bride_with_veil':'\ud83d\udc70',
  'bridge_at_night':'\ud83c\udf09',
  'briefcase':'\ud83d\udcbc',
  'broken_heart':'\ud83d\udc94',
  'bug':'\ud83d\udc1b',
  'building_construction':'\ud83c\udfd7',
  'bulb':'\ud83d\udca1',
  'bullettrain_front':'\ud83d\ude85',
  'bullettrain_side':'\ud83d\ude84',
  'burrito':'\ud83c\udf2f',
  'bus':'\ud83d\ude8c',
  'business_suit_levitating':'\ud83d\udd74',
  'busstop':'\ud83d\ude8f',
  'bust_in_silhouette':'\ud83d\udc64',
  'busts_in_silhouette':'\ud83d\udc65',
  'butterfly':'\ud83e\udd8b',
  'cactus':'\ud83c\udf35',
  'cake':'\ud83c\udf70',
  'calendar':'\ud83d\udcc6',
  'call_me_hand':'\ud83e\udd19',
  'calling':'\ud83d\udcf2',
  'camel':'\ud83d\udc2b',
  'camera':'\ud83d\udcf7',
  'camera_flash':'\ud83d\udcf8',
  'camping':'\ud83c\udfd5',
  'cancer':'\u264b\ufe0f',
  'candle':'\ud83d\udd6f',
  'candy':'\ud83c\udf6c',
  'canoe':'\ud83d\udef6',
  'capital_abcd':'\ud83d\udd20',
  'capricorn':'\u2651\ufe0f',
  'car':'\ud83d\ude97',
  'card_file_box':'\ud83d\uddc3',
  'card_index':'\ud83d\udcc7',
  'card_index_dividers':'\ud83d\uddc2',
  'carousel_horse':'\ud83c\udfa0',
  'carrot':'\ud83e\udd55',
  'cat':'\ud83d\udc31',
  'cat2':'\ud83d\udc08',
  'cd':'\ud83d\udcbf',
  'chains':'\u26d3',
  'champagne':'\ud83c\udf7e',
  'chart':'\ud83d\udcb9',
  'chart_with_downwards_trend':'\ud83d\udcc9',
  'chart_with_upwards_trend':'\ud83d\udcc8',
  'checkered_flag':'\ud83c\udfc1',
  'cheese':'\ud83e\uddc0',
  'cherries':'\ud83c\udf52',
  'cherry_blossom':'\ud83c\udf38',
  'chestnut':'\ud83c\udf30',
  'chicken':'\ud83d\udc14',
  'children_crossing':'\ud83d\udeb8',
  'chipmunk':'\ud83d\udc3f',
  'chocolate_bar':'\ud83c\udf6b',
  'christmas_tree':'\ud83c\udf84',
  'church':'\u26ea\ufe0f',
  'cinema':'\ud83c\udfa6',
  'circus_tent':'\ud83c\udfaa',
  'city_sunrise':'\ud83c\udf07',
  'city_sunset':'\ud83c\udf06',
  'cityscape':'\ud83c\udfd9',
  'cl':'\ud83c\udd91',
  'clamp':'\ud83d\udddc',
  'clap':'\ud83d\udc4f',
  'clapper':'\ud83c\udfac',
  'classical_building':'\ud83c\udfdb',
  'clinking_glasses':'\ud83e\udd42',
  'clipboard':'\ud83d\udccb',
  'clock1':'\ud83d\udd50',
  'clock10':'\ud83d\udd59',
  'clock1030':'\ud83d\udd65',
  'clock11':'\ud83d\udd5a',
  'clock1130':'\ud83d\udd66',
  'clock12':'\ud83d\udd5b',
  'clock1230':'\ud83d\udd67',
  'clock130':'\ud83d\udd5c',
  'clock2':'\ud83d\udd51',
  'clock230':'\ud83d\udd5d',
  'clock3':'\ud83d\udd52',
  'clock330':'\ud83d\udd5e',
  'clock4':'\ud83d\udd53',
  'clock430':'\ud83d\udd5f',
  'clock5':'\ud83d\udd54',
  'clock530':'\ud83d\udd60',
  'clock6':'\ud83d\udd55',
  'clock630':'\ud83d\udd61',
  'clock7':'\ud83d\udd56',
  'clock730':'\ud83d\udd62',
  'clock8':'\ud83d\udd57',
  'clock830':'\ud83d\udd63',
  'clock9':'\ud83d\udd58',
  'clock930':'\ud83d\udd64',
  'closed_book':'\ud83d\udcd5',
  'closed_lock_with_key':'\ud83d\udd10',
  'closed_umbrella':'\ud83c\udf02',
  'cloud':'\u2601\ufe0f',
  'cloud_with_lightning':'\ud83c\udf29',
  'cloud_with_lightning_and_rain':'\u26c8',
  'cloud_with_rain':'\ud83c\udf27',
  'cloud_with_snow':'\ud83c\udf28',
  'clown_face':'\ud83e\udd21',
  'clubs':'\u2663\ufe0f',
  'cocktail':'\ud83c\udf78',
  'coffee':'\u2615\ufe0f',
  'coffin':'\u26b0\ufe0f',
  'cold_sweat':'\ud83d\ude30',
  'comet':'\u2604\ufe0f',
  'computer':'\ud83d\udcbb',
  'computer_mouse':'\ud83d\uddb1',
  'confetti_ball':'\ud83c\udf8a',
  'confounded':'\ud83d\ude16',
  'confused':'\ud83d\ude15',
  'congratulations':'\u3297\ufe0f',
  'construction':'\ud83d\udea7',
  'construction_worker_man':'\ud83d\udc77',
  'construction_worker_woman':'\ud83d\udc77&zwj;\u2640\ufe0f',
  'control_knobs':'\ud83c\udf9b',
  'convenience_store':'\ud83c\udfea',
  'cookie':'\ud83c\udf6a',
  'cool':'\ud83c\udd92',
  'policeman':'\ud83d\udc6e',
  'copyright':'\u00a9\ufe0f',
  'corn':'\ud83c\udf3d',
  'couch_and_lamp':'\ud83d\udecb',
  'couple':'\ud83d\udc6b',
  'couple_with_heart_woman_man':'\ud83d\udc91',
  'couple_with_heart_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc68',
  'couple_with_heart_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc69',
  'couplekiss_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc68',
  'couplekiss_man_woman':'\ud83d\udc8f',
  'couplekiss_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc69',
  'cow':'\ud83d\udc2e',
  'cow2':'\ud83d\udc04',
  'cowboy_hat_face':'\ud83e\udd20',
  'crab':'\ud83e\udd80',
  'crayon':'\ud83d\udd8d',
  'credit_card':'\ud83d\udcb3',
  'crescent_moon':'\ud83c\udf19',
  'cricket':'\ud83c\udfcf',
  'crocodile':'\ud83d\udc0a',
  'croissant':'\ud83e\udd50',
  'crossed_fingers':'\ud83e\udd1e',
  'crossed_flags':'\ud83c\udf8c',
  'crossed_swords':'\u2694\ufe0f',
  'crown':'\ud83d\udc51',
  'cry':'\ud83d\ude22',
  'crying_cat_face':'\ud83d\ude3f',
  'crystal_ball':'\ud83d\udd2e',
  'cucumber':'\ud83e\udd52',
  'cupid':'\ud83d\udc98',
  'curly_loop':'\u27b0',
  'currency_exchange':'\ud83d\udcb1',
  'curry':'\ud83c\udf5b',
  'custard':'\ud83c\udf6e',
  'customs':'\ud83d\udec3',
  'cyclone':'\ud83c\udf00',
  'dagger':'\ud83d\udde1',
  'dancer':'\ud83d\udc83',
  'dancing_women':'\ud83d\udc6f',
  'dancing_men':'\ud83d\udc6f&zwj;\u2642\ufe0f',
  'dango':'\ud83c\udf61',
  'dark_sunglasses':'\ud83d\udd76',
  'dart':'\ud83c\udfaf',
  'dash':'\ud83d\udca8',
  'date':'\ud83d\udcc5',
  'deciduous_tree':'\ud83c\udf33',
  'deer':'\ud83e\udd8c',
  'department_store':'\ud83c\udfec',
  'derelict_house':'\ud83c\udfda',
  'desert':'\ud83c\udfdc',
  'desert_island':'\ud83c\udfdd',
  'desktop_computer':'\ud83d\udda5',
  'male_detective':'\ud83d\udd75\ufe0f',
  'diamond_shape_with_a_dot_inside':'\ud83d\udca0',
  'diamonds':'\u2666\ufe0f',
  'disappointed':'\ud83d\ude1e',
  'disappointed_relieved':'\ud83d\ude25',
  'dizzy':'\ud83d\udcab',
  'dizzy_face':'\ud83d\ude35',
  'do_not_litter':'\ud83d\udeaf',
  'dog':'\ud83d\udc36',
  'dog2':'\ud83d\udc15',
  'dollar':'\ud83d\udcb5',
  'dolls':'\ud83c\udf8e',
  'dolphin':'\ud83d\udc2c',
  'door':'\ud83d\udeaa',
  'doughnut':'\ud83c\udf69',
  'dove':'\ud83d\udd4a',
  'dragon':'\ud83d\udc09',
  'dragon_face':'\ud83d\udc32',
  'dress':'\ud83d\udc57',
  'dromedary_camel':'\ud83d\udc2a',
  'drooling_face':'\ud83e\udd24',
  'droplet':'\ud83d\udca7',
  'drum':'\ud83e\udd41',
  'duck':'\ud83e\udd86',
  'dvd':'\ud83d\udcc0',
  'e-mail':'\ud83d\udce7',
  'eagle':'\ud83e\udd85',
  'ear':'\ud83d\udc42',
  'ear_of_rice':'\ud83c\udf3e',
  'earth_africa':'\ud83c\udf0d',
  'earth_americas':'\ud83c\udf0e',
  'earth_asia':'\ud83c\udf0f',
  'egg':'\ud83e\udd5a',
  'eggplant':'\ud83c\udf46',
  'eight_pointed_black_star':'\u2734\ufe0f',
  'eight_spoked_asterisk':'\u2733\ufe0f',
  'electric_plug':'\ud83d\udd0c',
  'elephant':'\ud83d\udc18',
  'email':'\u2709\ufe0f',
  'end':'\ud83d\udd1a',
  'envelope_with_arrow':'\ud83d\udce9',
  'euro':'\ud83d\udcb6',
  'european_castle':'\ud83c\udff0',
  'european_post_office':'\ud83c\udfe4',
  'evergreen_tree':'\ud83c\udf32',
  'exclamation':'\u2757\ufe0f',
  'expressionless':'\ud83d\ude11',
  'eye':'\ud83d\udc41',
  'eye_speech_bubble':'\ud83d\udc41&zwj;\ud83d\udde8',
  'eyeglasses':'\ud83d\udc53',
  'eyes':'\ud83d\udc40',
  'face_with_head_bandage':'\ud83e\udd15',
  'face_with_thermometer':'\ud83e\udd12',
  'fist_oncoming':'\ud83d\udc4a',
  'factory':'\ud83c\udfed',
  'fallen_leaf':'\ud83c\udf42',
  'family_man_woman_boy':'\ud83d\udc6a',
  'family_man_boy':'\ud83d\udc68&zwj;\ud83d\udc66',
  'family_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_man_girl':'\ud83d\udc68&zwj;\ud83d\udc67',
  'family_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_man_man_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66',
  'family_man_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_man_man_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67',
  'family_man_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_man_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_man_woman_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_man_woman_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
  'family_man_woman_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_man_woman_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc66',
  'family_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc67',
  'family_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_woman_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66',
  'family_woman_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_woman_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
  'family_woman_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_woman_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'fast_forward':'\u23e9',
  'fax':'\ud83d\udce0',
  'fearful':'\ud83d\ude28',
  'feet':'\ud83d\udc3e',
  'female_detective':'\ud83d\udd75\ufe0f&zwj;\u2640\ufe0f',
  'ferris_wheel':'\ud83c\udfa1',
  'ferry':'\u26f4',
  'field_hockey':'\ud83c\udfd1',
  'file_cabinet':'\ud83d\uddc4',
  'file_folder':'\ud83d\udcc1',
  'film_projector':'\ud83d\udcfd',
  'film_strip':'\ud83c\udf9e',
  'fire':'\ud83d\udd25',
  'fire_engine':'\ud83d\ude92',
  'fireworks':'\ud83c\udf86',
  'first_quarter_moon':'\ud83c\udf13',
  'first_quarter_moon_with_face':'\ud83c\udf1b',
  'fish':'\ud83d\udc1f',
  'fish_cake':'\ud83c\udf65',
  'fishing_pole_and_fish':'\ud83c\udfa3',
  'fist_raised':'\u270a',
  'fist_left':'\ud83e\udd1b',
  'fist_right':'\ud83e\udd1c',
  'flags':'\ud83c\udf8f',
  'flashlight':'\ud83d\udd26',
  'fleur_de_lis':'\u269c\ufe0f',
  'flight_arrival':'\ud83d\udeec',
  'flight_departure':'\ud83d\udeeb',
  'floppy_disk':'\ud83d\udcbe',
  'flower_playing_cards':'\ud83c\udfb4',
  'flushed':'\ud83d\ude33',
  'fog':'\ud83c\udf2b',
  'foggy':'\ud83c\udf01',
  'football':'\ud83c\udfc8',
  'footprints':'\ud83d\udc63',
  'fork_and_knife':'\ud83c\udf74',
  'fountain':'\u26f2\ufe0f',
  'fountain_pen':'\ud83d\udd8b',
  'four_leaf_clover':'\ud83c\udf40',
  'fox_face':'\ud83e\udd8a',
  'framed_picture':'\ud83d\uddbc',
  'free':'\ud83c\udd93',
  'fried_egg':'\ud83c\udf73',
  'fried_shrimp':'\ud83c\udf64',
  'fries':'\ud83c\udf5f',
  'frog':'\ud83d\udc38',
  'frowning':'\ud83d\ude26',
  'frowning_face':'\u2639\ufe0f',
  'frowning_man':'\ud83d\ude4d&zwj;\u2642\ufe0f',
  'frowning_woman':'\ud83d\ude4d',
  'middle_finger':'\ud83d\udd95',
  'fuelpump':'\u26fd\ufe0f',
  'full_moon':'\ud83c\udf15',
  'full_moon_with_face':'\ud83c\udf1d',
  'funeral_urn':'\u26b1\ufe0f',
  'game_die':'\ud83c\udfb2',
  'gear':'\u2699\ufe0f',
  'gem':'\ud83d\udc8e',
  'gemini':'\u264a\ufe0f',
  'ghost':'\ud83d\udc7b',
  'gift':'\ud83c\udf81',
  'gift_heart':'\ud83d\udc9d',
  'girl':'\ud83d\udc67',
  'globe_with_meridians':'\ud83c\udf10',
  'goal_net':'\ud83e\udd45',
  'goat':'\ud83d\udc10',
  'golf':'\u26f3\ufe0f',
  'golfing_man':'\ud83c\udfcc\ufe0f',
  'golfing_woman':'\ud83c\udfcc\ufe0f&zwj;\u2640\ufe0f',
  'gorilla':'\ud83e\udd8d',
  'grapes':'\ud83c\udf47',
  'green_apple':'\ud83c\udf4f',
  'green_book':'\ud83d\udcd7',
  'green_heart':'\ud83d\udc9a',
  'green_salad':'\ud83e\udd57',
  'grey_exclamation':'\u2755',
  'grey_question':'\u2754',
  'grimacing':'\ud83d\ude2c',
  'grin':'\ud83d\ude01',
  'grinning':'\ud83d\ude00',
  'guardsman':'\ud83d\udc82',
  'guardswoman':'\ud83d\udc82&zwj;\u2640\ufe0f',
  'guitar':'\ud83c\udfb8',
  'gun':'\ud83d\udd2b',
  'haircut_woman':'\ud83d\udc87',
  'haircut_man':'\ud83d\udc87&zwj;\u2642\ufe0f',
  'hamburger':'\ud83c\udf54',
  'hammer':'\ud83d\udd28',
  'hammer_and_pick':'\u2692',
  'hammer_and_wrench':'\ud83d\udee0',
  'hamster':'\ud83d\udc39',
  'hand':'\u270b',
  'handbag':'\ud83d\udc5c',
  'handshake':'\ud83e\udd1d',
  'hankey':'\ud83d\udca9',
  'hatched_chick':'\ud83d\udc25',
  'hatching_chick':'\ud83d\udc23',
  'headphones':'\ud83c\udfa7',
  'hear_no_evil':'\ud83d\ude49',
  'heart':'\u2764\ufe0f',
  'heart_decoration':'\ud83d\udc9f',
  'heart_eyes':'\ud83d\ude0d',
  'heart_eyes_cat':'\ud83d\ude3b',
  'heartbeat':'\ud83d\udc93',
  'heartpulse':'\ud83d\udc97',
  'hearts':'\u2665\ufe0f',
  'heavy_check_mark':'\u2714\ufe0f',
  'heavy_division_sign':'\u2797',
  'heavy_dollar_sign':'\ud83d\udcb2',
  'heavy_heart_exclamation':'\u2763\ufe0f',
  'heavy_minus_sign':'\u2796',
  'heavy_multiplication_x':'\u2716\ufe0f',
  'heavy_plus_sign':'\u2795',
  'helicopter':'\ud83d\ude81',
  'herb':'\ud83c\udf3f',
  'hibiscus':'\ud83c\udf3a',
  'high_brightness':'\ud83d\udd06',
  'high_heel':'\ud83d\udc60',
  'hocho':'\ud83d\udd2a',
  'hole':'\ud83d\udd73',
  'honey_pot':'\ud83c\udf6f',
  'horse':'\ud83d\udc34',
  'horse_racing':'\ud83c\udfc7',
  'hospital':'\ud83c\udfe5',
  'hot_pepper':'\ud83c\udf36',
  'hotdog':'\ud83c\udf2d',
  'hotel':'\ud83c\udfe8',
  'hotsprings':'\u2668\ufe0f',
  'hourglass':'\u231b\ufe0f',
  'hourglass_flowing_sand':'\u23f3',
  'house':'\ud83c\udfe0',
  'house_with_garden':'\ud83c\udfe1',
  'houses':'\ud83c\udfd8',
  'hugs':'\ud83e\udd17',
  'hushed':'\ud83d\ude2f',
  'ice_cream':'\ud83c\udf68',
  'ice_hockey':'\ud83c\udfd2',
  'ice_skate':'\u26f8',
  'icecream':'\ud83c\udf66',
  'id':'\ud83c\udd94',
  'ideograph_advantage':'\ud83c\ude50',
  'imp':'\ud83d\udc7f',
  'inbox_tray':'\ud83d\udce5',
  'incoming_envelope':'\ud83d\udce8',
  'tipping_hand_woman':'\ud83d\udc81',
  'information_source':'\u2139\ufe0f',
  'innocent':'\ud83d\ude07',
  'interrobang':'\u2049\ufe0f',
  'iphone':'\ud83d\udcf1',
  'izakaya_lantern':'\ud83c\udfee',
  'jack_o_lantern':'\ud83c\udf83',
  'japan':'\ud83d\uddfe',
  'japanese_castle':'\ud83c\udfef',
  'japanese_goblin':'\ud83d\udc7a',
  'japanese_ogre':'\ud83d\udc79',
  'jeans':'\ud83d\udc56',
  'joy':'\ud83d\ude02',
  'joy_cat':'\ud83d\ude39',
  'joystick':'\ud83d\udd79',
  'kaaba':'\ud83d\udd4b',
  'key':'\ud83d\udd11',
  'keyboard':'\u2328\ufe0f',
  'keycap_ten':'\ud83d\udd1f',
  'kick_scooter':'\ud83d\udef4',
  'kimono':'\ud83d\udc58',
  'kiss':'\ud83d\udc8b',
  'kissing':'\ud83d\ude17',
  'kissing_cat':'\ud83d\ude3d',
  'kissing_closed_eyes':'\ud83d\ude1a',
  'kissing_heart':'\ud83d\ude18',
  'kissing_smiling_eyes':'\ud83d\ude19',
  'kiwi_fruit':'\ud83e\udd5d',
  'koala':'\ud83d\udc28',
  'koko':'\ud83c\ude01',
  'label':'\ud83c\udff7',
  'large_blue_circle':'\ud83d\udd35',
  'large_blue_diamond':'\ud83d\udd37',
  'large_orange_diamond':'\ud83d\udd36',
  'last_quarter_moon':'\ud83c\udf17',
  'last_quarter_moon_with_face':'\ud83c\udf1c',
  'latin_cross':'\u271d\ufe0f',
  'laughing':'\ud83d\ude06',
  'leaves':'\ud83c\udf43',
  'ledger':'\ud83d\udcd2',
  'left_luggage':'\ud83d\udec5',
  'left_right_arrow':'\u2194\ufe0f',
  'leftwards_arrow_with_hook':'\u21a9\ufe0f',
  'lemon':'\ud83c\udf4b',
  'leo':'\u264c\ufe0f',
  'leopard':'\ud83d\udc06',
  'level_slider':'\ud83c\udf9a',
  'libra':'\u264e\ufe0f',
  'light_rail':'\ud83d\ude88',
  'link':'\ud83d\udd17',
  'lion':'\ud83e\udd81',
  'lips':'\ud83d\udc44',
  'lipstick':'\ud83d\udc84',
  'lizard':'\ud83e\udd8e',
  'lock':'\ud83d\udd12',
  'lock_with_ink_pen':'\ud83d\udd0f',
  'lollipop':'\ud83c\udf6d',
  'loop':'\u27bf',
  'loud_sound':'\ud83d\udd0a',
  'loudspeaker':'\ud83d\udce2',
  'love_hotel':'\ud83c\udfe9',
  'love_letter':'\ud83d\udc8c',
  'low_brightness':'\ud83d\udd05',
  'lying_face':'\ud83e\udd25',
  'm':'\u24c2\ufe0f',
  'mag':'\ud83d\udd0d',
  'mag_right':'\ud83d\udd0e',
  'mahjong':'\ud83c\udc04\ufe0f',
  'mailbox':'\ud83d\udceb',
  'mailbox_closed':'\ud83d\udcea',
  'mailbox_with_mail':'\ud83d\udcec',
  'mailbox_with_no_mail':'\ud83d\udced',
  'man':'\ud83d\udc68',
  'man_artist':'\ud83d\udc68&zwj;\ud83c\udfa8',
  'man_astronaut':'\ud83d\udc68&zwj;\ud83d\ude80',
  'man_cartwheeling':'\ud83e\udd38&zwj;\u2642\ufe0f',
  'man_cook':'\ud83d\udc68&zwj;\ud83c\udf73',
  'man_dancing':'\ud83d\udd7a',
  'man_facepalming':'\ud83e\udd26&zwj;\u2642\ufe0f',
  'man_factory_worker':'\ud83d\udc68&zwj;\ud83c\udfed',
  'man_farmer':'\ud83d\udc68&zwj;\ud83c\udf3e',
  'man_firefighter':'\ud83d\udc68&zwj;\ud83d\ude92',
  'man_health_worker':'\ud83d\udc68&zwj;\u2695\ufe0f',
  'man_in_tuxedo':'\ud83e\udd35',
  'man_judge':'\ud83d\udc68&zwj;\u2696\ufe0f',
  'man_juggling':'\ud83e\udd39&zwj;\u2642\ufe0f',
  'man_mechanic':'\ud83d\udc68&zwj;\ud83d\udd27',
  'man_office_worker':'\ud83d\udc68&zwj;\ud83d\udcbc',
  'man_pilot':'\ud83d\udc68&zwj;\u2708\ufe0f',
  'man_playing_handball':'\ud83e\udd3e&zwj;\u2642\ufe0f',
  'man_playing_water_polo':'\ud83e\udd3d&zwj;\u2642\ufe0f',
  'man_scientist':'\ud83d\udc68&zwj;\ud83d\udd2c',
  'man_shrugging':'\ud83e\udd37&zwj;\u2642\ufe0f',
  'man_singer':'\ud83d\udc68&zwj;\ud83c\udfa4',
  'man_student':'\ud83d\udc68&zwj;\ud83c\udf93',
  'man_teacher':'\ud83d\udc68&zwj;\ud83c\udfeb',
  'man_technologist':'\ud83d\udc68&zwj;\ud83d\udcbb',
  'man_with_gua_pi_mao':'\ud83d\udc72',
  'man_with_turban':'\ud83d\udc73',
  'tangerine':'\ud83c\udf4a',
  'mans_shoe':'\ud83d\udc5e',
  'mantelpiece_clock':'\ud83d\udd70',
  'maple_leaf':'\ud83c\udf41',
  'martial_arts_uniform':'\ud83e\udd4b',
  'mask':'\ud83d\ude37',
  'massage_woman':'\ud83d\udc86',
  'massage_man':'\ud83d\udc86&zwj;\u2642\ufe0f',
  'meat_on_bone':'\ud83c\udf56',
  'medal_military':'\ud83c\udf96',
  'medal_sports':'\ud83c\udfc5',
  'mega':'\ud83d\udce3',
  'melon':'\ud83c\udf48',
  'memo':'\ud83d\udcdd',
  'men_wrestling':'\ud83e\udd3c&zwj;\u2642\ufe0f',
  'menorah':'\ud83d\udd4e',
  'mens':'\ud83d\udeb9',
  'metal':'\ud83e\udd18',
  'metro':'\ud83d\ude87',
  'microphone':'\ud83c\udfa4',
  'microscope':'\ud83d\udd2c',
  'milk_glass':'\ud83e\udd5b',
  'milky_way':'\ud83c\udf0c',
  'minibus':'\ud83d\ude90',
  'minidisc':'\ud83d\udcbd',
  'mobile_phone_off':'\ud83d\udcf4',
  'money_mouth_face':'\ud83e\udd11',
  'money_with_wings':'\ud83d\udcb8',
  'moneybag':'\ud83d\udcb0',
  'monkey':'\ud83d\udc12',
  'monkey_face':'\ud83d\udc35',
  'monorail':'\ud83d\ude9d',
  'moon':'\ud83c\udf14',
  'mortar_board':'\ud83c\udf93',
  'mosque':'\ud83d\udd4c',
  'motor_boat':'\ud83d\udee5',
  'motor_scooter':'\ud83d\udef5',
  'motorcycle':'\ud83c\udfcd',
  'motorway':'\ud83d\udee3',
  'mount_fuji':'\ud83d\uddfb',
  'mountain':'\u26f0',
  'mountain_biking_man':'\ud83d\udeb5',
  'mountain_biking_woman':'\ud83d\udeb5&zwj;\u2640\ufe0f',
  'mountain_cableway':'\ud83d\udea0',
  'mountain_railway':'\ud83d\ude9e',
  'mountain_snow':'\ud83c\udfd4',
  'mouse':'\ud83d\udc2d',
  'mouse2':'\ud83d\udc01',
  'movie_camera':'\ud83c\udfa5',
  'moyai':'\ud83d\uddff',
  'mrs_claus':'\ud83e\udd36',
  'muscle':'\ud83d\udcaa',
  'mushroom':'\ud83c\udf44',
  'musical_keyboard':'\ud83c\udfb9',
  'musical_note':'\ud83c\udfb5',
  'musical_score':'\ud83c\udfbc',
  'mute':'\ud83d\udd07',
  'nail_care':'\ud83d\udc85',
  'name_badge':'\ud83d\udcdb',
  'national_park':'\ud83c\udfde',
  'nauseated_face':'\ud83e\udd22',
  'necktie':'\ud83d\udc54',
  'negative_squared_cross_mark':'\u274e',
  'nerd_face':'\ud83e\udd13',
  'neutral_face':'\ud83d\ude10',
  'new':'\ud83c\udd95',
  'new_moon':'\ud83c\udf11',
  'new_moon_with_face':'\ud83c\udf1a',
  'newspaper':'\ud83d\udcf0',
  'newspaper_roll':'\ud83d\uddde',
  'next_track_button':'\u23ed',
  'ng':'\ud83c\udd96',
  'no_good_man':'\ud83d\ude45&zwj;\u2642\ufe0f',
  'no_good_woman':'\ud83d\ude45',
  'night_with_stars':'\ud83c\udf03',
  'no_bell':'\ud83d\udd15',
  'no_bicycles':'\ud83d\udeb3',
  'no_entry':'\u26d4\ufe0f',
  'no_entry_sign':'\ud83d\udeab',
  'no_mobile_phones':'\ud83d\udcf5',
  'no_mouth':'\ud83d\ude36',
  'no_pedestrians':'\ud83d\udeb7',
  'no_smoking':'\ud83d\udead',
  'non-potable_water':'\ud83d\udeb1',
  'nose':'\ud83d\udc43',
  'notebook':'\ud83d\udcd3',
  'notebook_with_decorative_cover':'\ud83d\udcd4',
  'notes':'\ud83c\udfb6',
  'nut_and_bolt':'\ud83d\udd29',
  'o':'\u2b55\ufe0f',
  'o2':'\ud83c\udd7e\ufe0f',
  'ocean':'\ud83c\udf0a',
  'octopus':'\ud83d\udc19',
  'oden':'\ud83c\udf62',
  'office':'\ud83c\udfe2',
  'oil_drum':'\ud83d\udee2',
  'ok':'\ud83c\udd97',
  'ok_hand':'\ud83d\udc4c',
  'ok_man':'\ud83d\ude46&zwj;\u2642\ufe0f',
  'ok_woman':'\ud83d\ude46',
  'old_key':'\ud83d\udddd',
  'older_man':'\ud83d\udc74',
  'older_woman':'\ud83d\udc75',
  'om':'\ud83d\udd49',
  'on':'\ud83d\udd1b',
  'oncoming_automobile':'\ud83d\ude98',
  'oncoming_bus':'\ud83d\ude8d',
  'oncoming_police_car':'\ud83d\ude94',
  'oncoming_taxi':'\ud83d\ude96',
  'open_file_folder':'\ud83d\udcc2',
  'open_hands':'\ud83d\udc50',
  'open_mouth':'\ud83d\ude2e',
  'open_umbrella':'\u2602\ufe0f',
  'ophiuchus':'\u26ce',
  'orange_book':'\ud83d\udcd9',
  'orthodox_cross':'\u2626\ufe0f',
  'outbox_tray':'\ud83d\udce4',
  'owl':'\ud83e\udd89',
  'ox':'\ud83d\udc02',
  'package':'\ud83d\udce6',
  'page_facing_up':'\ud83d\udcc4',
  'page_with_curl':'\ud83d\udcc3',
  'pager':'\ud83d\udcdf',
  'paintbrush':'\ud83d\udd8c',
  'palm_tree':'\ud83c\udf34',
  'pancakes':'\ud83e\udd5e',
  'panda_face':'\ud83d\udc3c',
  'paperclip':'\ud83d\udcce',
  'paperclips':'\ud83d\udd87',
  'parasol_on_ground':'\u26f1',
  'parking':'\ud83c\udd7f\ufe0f',
  'part_alternation_mark':'\u303d\ufe0f',
  'partly_sunny':'\u26c5\ufe0f',
  'passenger_ship':'\ud83d\udef3',
  'passport_control':'\ud83d\udec2',
  'pause_button':'\u23f8',
  'peace_symbol':'\u262e\ufe0f',
  'peach':'\ud83c\udf51',
  'peanuts':'\ud83e\udd5c',
  'pear':'\ud83c\udf50',
  'pen':'\ud83d\udd8a',
  'pencil2':'\u270f\ufe0f',
  'penguin':'\ud83d\udc27',
  'pensive':'\ud83d\ude14',
  'performing_arts':'\ud83c\udfad',
  'persevere':'\ud83d\ude23',
  'person_fencing':'\ud83e\udd3a',
  'pouting_woman':'\ud83d\ude4e',
  'phone':'\u260e\ufe0f',
  'pick':'\u26cf',
  'pig':'\ud83d\udc37',
  'pig2':'\ud83d\udc16',
  'pig_nose':'\ud83d\udc3d',
  'pill':'\ud83d\udc8a',
  'pineapple':'\ud83c\udf4d',
  'ping_pong':'\ud83c\udfd3',
  'pisces':'\u2653\ufe0f',
  'pizza':'\ud83c\udf55',
  'place_of_worship':'\ud83d\uded0',
  'plate_with_cutlery':'\ud83c\udf7d',
  'play_or_pause_button':'\u23ef',
  'point_down':'\ud83d\udc47',
  'point_left':'\ud83d\udc48',
  'point_right':'\ud83d\udc49',
  'point_up':'\u261d\ufe0f',
  'point_up_2':'\ud83d\udc46',
  'police_car':'\ud83d\ude93',
  'policewoman':'\ud83d\udc6e&zwj;\u2640\ufe0f',
  'poodle':'\ud83d\udc29',
  'popcorn':'\ud83c\udf7f',
  'post_office':'\ud83c\udfe3',
  'postal_horn':'\ud83d\udcef',
  'postbox':'\ud83d\udcee',
  'potable_water':'\ud83d\udeb0',
  'potato':'\ud83e\udd54',
  'pouch':'\ud83d\udc5d',
  'poultry_leg':'\ud83c\udf57',
  'pound':'\ud83d\udcb7',
  'rage':'\ud83d\ude21',
  'pouting_cat':'\ud83d\ude3e',
  'pouting_man':'\ud83d\ude4e&zwj;\u2642\ufe0f',
  'pray':'\ud83d\ude4f',
  'prayer_beads':'\ud83d\udcff',
  'pregnant_woman':'\ud83e\udd30',
  'previous_track_button':'\u23ee',
  'prince':'\ud83e\udd34',
  'princess':'\ud83d\udc78',
  'printer':'\ud83d\udda8',
  'purple_heart':'\ud83d\udc9c',
  'purse':'\ud83d\udc5b',
  'pushpin':'\ud83d\udccc',
  'put_litter_in_its_place':'\ud83d\udeae',
  'question':'\u2753',
  'rabbit':'\ud83d\udc30',
  'rabbit2':'\ud83d\udc07',
  'racehorse':'\ud83d\udc0e',
  'racing_car':'\ud83c\udfce',
  'radio':'\ud83d\udcfb',
  'radio_button':'\ud83d\udd18',
  'radioactive':'\u2622\ufe0f',
  'railway_car':'\ud83d\ude83',
  'railway_track':'\ud83d\udee4',
  'rainbow':'\ud83c\udf08',
  'rainbow_flag':'\ud83c\udff3\ufe0f&zwj;\ud83c\udf08',
  'raised_back_of_hand':'\ud83e\udd1a',
  'raised_hand_with_fingers_splayed':'\ud83d\udd90',
  'raised_hands':'\ud83d\ude4c',
  'raising_hand_woman':'\ud83d\ude4b',
  'raising_hand_man':'\ud83d\ude4b&zwj;\u2642\ufe0f',
  'ram':'\ud83d\udc0f',
  'ramen':'\ud83c\udf5c',
  'rat':'\ud83d\udc00',
  'record_button':'\u23fa',
  'recycle':'\u267b\ufe0f',
  'red_circle':'\ud83d\udd34',
  'registered':'\u00ae\ufe0f',
  'relaxed':'\u263a\ufe0f',
  'relieved':'\ud83d\ude0c',
  'reminder_ribbon':'\ud83c\udf97',
  'repeat':'\ud83d\udd01',
  'repeat_one':'\ud83d\udd02',
  'rescue_worker_helmet':'\u26d1',
  'restroom':'\ud83d\udebb',
  'revolving_hearts':'\ud83d\udc9e',
  'rewind':'\u23ea',
  'rhinoceros':'\ud83e\udd8f',
  'ribbon':'\ud83c\udf80',
  'rice':'\ud83c\udf5a',
  'rice_ball':'\ud83c\udf59',
  'rice_cracker':'\ud83c\udf58',
  'rice_scene':'\ud83c\udf91',
  'right_anger_bubble':'\ud83d\uddef',
  'ring':'\ud83d\udc8d',
  'robot':'\ud83e\udd16',
  'rocket':'\ud83d\ude80',
  'rofl':'\ud83e\udd23',
  'roll_eyes':'\ud83d\ude44',
  'roller_coaster':'\ud83c\udfa2',
  'rooster':'\ud83d\udc13',
  'rose':'\ud83c\udf39',
  'rosette':'\ud83c\udff5',
  'rotating_light':'\ud83d\udea8',
  'round_pushpin':'\ud83d\udccd',
  'rowing_man':'\ud83d\udea3',
  'rowing_woman':'\ud83d\udea3&zwj;\u2640\ufe0f',
  'rugby_football':'\ud83c\udfc9',
  'running_man':'\ud83c\udfc3',
  'running_shirt_with_sash':'\ud83c\udfbd',
  'running_woman':'\ud83c\udfc3&zwj;\u2640\ufe0f',
  'sa':'\ud83c\ude02\ufe0f',
  'sagittarius':'\u2650\ufe0f',
  'sake':'\ud83c\udf76',
  'sandal':'\ud83d\udc61',
  'santa':'\ud83c\udf85',
  'satellite':'\ud83d\udce1',
  'saxophone':'\ud83c\udfb7',
  'school':'\ud83c\udfeb',
  'school_satchel':'\ud83c\udf92',
  'scissors':'\u2702\ufe0f',
  'scorpion':'\ud83e\udd82',
  'scorpius':'\u264f\ufe0f',
  'scream':'\ud83d\ude31',
  'scream_cat':'\ud83d\ude40',
  'scroll':'\ud83d\udcdc',
  'seat':'\ud83d\udcba',
  'secret':'\u3299\ufe0f',
  'see_no_evil':'\ud83d\ude48',
  'seedling':'\ud83c\udf31',
  'selfie':'\ud83e\udd33',
  'shallow_pan_of_food':'\ud83e\udd58',
  'shamrock':'\u2618\ufe0f',
  'shark':'\ud83e\udd88',
  'shaved_ice':'\ud83c\udf67',
  'sheep':'\ud83d\udc11',
  'shell':'\ud83d\udc1a',
  'shield':'\ud83d\udee1',
  'shinto_shrine':'\u26e9',
  'ship':'\ud83d\udea2',
  'shirt':'\ud83d\udc55',
  'shopping':'\ud83d\udecd',
  'shopping_cart':'\ud83d\uded2',
  'shower':'\ud83d\udebf',
  'shrimp':'\ud83e\udd90',
  'signal_strength':'\ud83d\udcf6',
  'six_pointed_star':'\ud83d\udd2f',
  'ski':'\ud83c\udfbf',
  'skier':'\u26f7',
  'skull':'\ud83d\udc80',
  'skull_and_crossbones':'\u2620\ufe0f',
  'sleeping':'\ud83d\ude34',
  'sleeping_bed':'\ud83d\udecc',
  'sleepy':'\ud83d\ude2a',
  'slightly_frowning_face':'\ud83d\ude41',
  'slightly_smiling_face':'\ud83d\ude42',
  'slot_machine':'\ud83c\udfb0',
  'small_airplane':'\ud83d\udee9',
  'small_blue_diamond':'\ud83d\udd39',
  'small_orange_diamond':'\ud83d\udd38',
  'small_red_triangle':'\ud83d\udd3a',
  'small_red_triangle_down':'\ud83d\udd3b',
  'smile':'\ud83d\ude04',
  'smile_cat':'\ud83d\ude38',
  'smiley':'\ud83d\ude03',
  'smiley_cat':'\ud83d\ude3a',
  'smiling_imp':'\ud83d\ude08',
  'smirk':'\ud83d\ude0f',
  'smirk_cat':'\ud83d\ude3c',
  'smoking':'\ud83d\udeac',
  'snail':'\ud83d\udc0c',
  'snake':'\ud83d\udc0d',
  'sneezing_face':'\ud83e\udd27',
  'snowboarder':'\ud83c\udfc2',
  'snowflake':'\u2744\ufe0f',
  'snowman':'\u26c4\ufe0f',
  'snowman_with_snow':'\u2603\ufe0f',
  'sob':'\ud83d\ude2d',
  'soccer':'\u26bd\ufe0f',
  'soon':'\ud83d\udd1c',
  'sos':'\ud83c\udd98',
  'sound':'\ud83d\udd09',
  'space_invader':'\ud83d\udc7e',
  'spades':'\u2660\ufe0f',
  'spaghetti':'\ud83c\udf5d',
  'sparkle':'\u2747\ufe0f',
  'sparkler':'\ud83c\udf87',
  'sparkles':'\u2728',
  'sparkling_heart':'\ud83d\udc96',
  'speak_no_evil':'\ud83d\ude4a',
  'speaker':'\ud83d\udd08',
  'speaking_head':'\ud83d\udde3',
  'speech_balloon':'\ud83d\udcac',
  'speedboat':'\ud83d\udea4',
  'spider':'\ud83d\udd77',
  'spider_web':'\ud83d\udd78',
  'spiral_calendar':'\ud83d\uddd3',
  'spiral_notepad':'\ud83d\uddd2',
  'spoon':'\ud83e\udd44',
  'squid':'\ud83e\udd91',
  'stadium':'\ud83c\udfdf',
  'star':'\u2b50\ufe0f',
  'star2':'\ud83c\udf1f',
  'star_and_crescent':'\u262a\ufe0f',
  'star_of_david':'\u2721\ufe0f',
  'stars':'\ud83c\udf20',
  'station':'\ud83d\ude89',
  'statue_of_liberty':'\ud83d\uddfd',
  'steam_locomotive':'\ud83d\ude82',
  'stew':'\ud83c\udf72',
  'stop_button':'\u23f9',
  'stop_sign':'\ud83d\uded1',
  'stopwatch':'\u23f1',
  'straight_ruler':'\ud83d\udccf',
  'strawberry':'\ud83c\udf53',
  'stuck_out_tongue':'\ud83d\ude1b',
  'stuck_out_tongue_closed_eyes':'\ud83d\ude1d',
  'stuck_out_tongue_winking_eye':'\ud83d\ude1c',
  'studio_microphone':'\ud83c\udf99',
  'stuffed_flatbread':'\ud83e\udd59',
  'sun_behind_large_cloud':'\ud83c\udf25',
  'sun_behind_rain_cloud':'\ud83c\udf26',
  'sun_behind_small_cloud':'\ud83c\udf24',
  'sun_with_face':'\ud83c\udf1e',
  'sunflower':'\ud83c\udf3b',
  'sunglasses':'\ud83d\ude0e',
  'sunny':'\u2600\ufe0f',
  'sunrise':'\ud83c\udf05',
  'sunrise_over_mountains':'\ud83c\udf04',
  'surfing_man':'\ud83c\udfc4',
  'surfing_woman':'\ud83c\udfc4&zwj;\u2640\ufe0f',
  'sushi':'\ud83c\udf63',
  'suspension_railway':'\ud83d\ude9f',
  'sweat':'\ud83d\ude13',
  'sweat_drops':'\ud83d\udca6',
  'sweat_smile':'\ud83d\ude05',
  'sweet_potato':'\ud83c\udf60',
  'swimming_man':'\ud83c\udfca',
  'swimming_woman':'\ud83c\udfca&zwj;\u2640\ufe0f',
  'symbols':'\ud83d\udd23',
  'synagogue':'\ud83d\udd4d',
  'syringe':'\ud83d\udc89',
  'taco':'\ud83c\udf2e',
  'tada':'\ud83c\udf89',
  'tanabata_tree':'\ud83c\udf8b',
  'taurus':'\u2649\ufe0f',
  'taxi':'\ud83d\ude95',
  'tea':'\ud83c\udf75',
  'telephone_receiver':'\ud83d\udcde',
  'telescope':'\ud83d\udd2d',
  'tennis':'\ud83c\udfbe',
  'tent':'\u26fa\ufe0f',
  'thermometer':'\ud83c\udf21',
  'thinking':'\ud83e\udd14',
  'thought_balloon':'\ud83d\udcad',
  'ticket':'\ud83c\udfab',
  'tickets':'\ud83c\udf9f',
  'tiger':'\ud83d\udc2f',
  'tiger2':'\ud83d\udc05',
  'timer_clock':'\u23f2',
  'tipping_hand_man':'\ud83d\udc81&zwj;\u2642\ufe0f',
  'tired_face':'\ud83d\ude2b',
  'tm':'\u2122\ufe0f',
  'toilet':'\ud83d\udebd',
  'tokyo_tower':'\ud83d\uddfc',
  'tomato':'\ud83c\udf45',
  'tongue':'\ud83d\udc45',
  'top':'\ud83d\udd1d',
  'tophat':'\ud83c\udfa9',
  'tornado':'\ud83c\udf2a',
  'trackball':'\ud83d\uddb2',
  'tractor':'\ud83d\ude9c',
  'traffic_light':'\ud83d\udea5',
  'train':'\ud83d\ude8b',
  'train2':'\ud83d\ude86',
  'tram':'\ud83d\ude8a',
  'triangular_flag_on_post':'\ud83d\udea9',
  'triangular_ruler':'\ud83d\udcd0',
  'trident':'\ud83d\udd31',
  'triumph':'\ud83d\ude24',
  'trolleybus':'\ud83d\ude8e',
  'trophy':'\ud83c\udfc6',
  'tropical_drink':'\ud83c\udf79',
  'tropical_fish':'\ud83d\udc20',
  'truck':'\ud83d\ude9a',
  'trumpet':'\ud83c\udfba',
  'tulip':'\ud83c\udf37',
  'tumbler_glass':'\ud83e\udd43',
  'turkey':'\ud83e\udd83',
  'turtle':'\ud83d\udc22',
  'tv':'\ud83d\udcfa',
  'twisted_rightwards_arrows':'\ud83d\udd00',
  'two_hearts':'\ud83d\udc95',
  'two_men_holding_hands':'\ud83d\udc6c',
  'two_women_holding_hands':'\ud83d\udc6d',
  'u5272':'\ud83c\ude39',
  'u5408':'\ud83c\ude34',
  'u55b6':'\ud83c\ude3a',
  'u6307':'\ud83c\ude2f\ufe0f',
  'u6708':'\ud83c\ude37\ufe0f',
  'u6709':'\ud83c\ude36',
  'u6e80':'\ud83c\ude35',
  'u7121':'\ud83c\ude1a\ufe0f',
  'u7533':'\ud83c\ude38',
  'u7981':'\ud83c\ude32',
  'u7a7a':'\ud83c\ude33',
  'umbrella':'\u2614\ufe0f',
  'unamused':'\ud83d\ude12',
  'underage':'\ud83d\udd1e',
  'unicorn':'\ud83e\udd84',
  'unlock':'\ud83d\udd13',
  'up':'\ud83c\udd99',
  'upside_down_face':'\ud83d\ude43',
  'v':'\u270c\ufe0f',
  'vertical_traffic_light':'\ud83d\udea6',
  'vhs':'\ud83d\udcfc',
  'vibration_mode':'\ud83d\udcf3',
  'video_camera':'\ud83d\udcf9',
  'video_game':'\ud83c\udfae',
  'violin':'\ud83c\udfbb',
  'virgo':'\u264d\ufe0f',
  'volcano':'\ud83c\udf0b',
  'volleyball':'\ud83c\udfd0',
  'vs':'\ud83c\udd9a',
  'vulcan_salute':'\ud83d\udd96',
  'walking_man':'\ud83d\udeb6',
  'walking_woman':'\ud83d\udeb6&zwj;\u2640\ufe0f',
  'waning_crescent_moon':'\ud83c\udf18',
  'waning_gibbous_moon':'\ud83c\udf16',
  'warning':'\u26a0\ufe0f',
  'wastebasket':'\ud83d\uddd1',
  'watch':'\u231a\ufe0f',
  'water_buffalo':'\ud83d\udc03',
  'watermelon':'\ud83c\udf49',
  'wave':'\ud83d\udc4b',
  'wavy_dash':'\u3030\ufe0f',
  'waxing_crescent_moon':'\ud83c\udf12',
  'wc':'\ud83d\udebe',
  'weary':'\ud83d\ude29',
  'wedding':'\ud83d\udc92',
  'weight_lifting_man':'\ud83c\udfcb\ufe0f',
  'weight_lifting_woman':'\ud83c\udfcb\ufe0f&zwj;\u2640\ufe0f',
  'whale':'\ud83d\udc33',
  'whale2':'\ud83d\udc0b',
  'wheel_of_dharma':'\u2638\ufe0f',
  'wheelchair':'\u267f\ufe0f',
  'white_check_mark':'\u2705',
  'white_circle':'\u26aa\ufe0f',
  'white_flag':'\ud83c\udff3\ufe0f',
  'white_flower':'\ud83d\udcae',
  'white_large_square':'\u2b1c\ufe0f',
  'white_medium_small_square':'\u25fd\ufe0f',
  'white_medium_square':'\u25fb\ufe0f',
  'white_small_square':'\u25ab\ufe0f',
  'white_square_button':'\ud83d\udd33',
  'wilted_flower':'\ud83e\udd40',
  'wind_chime':'\ud83c\udf90',
  'wind_face':'\ud83c\udf2c',
  'wine_glass':'\ud83c\udf77',
  'wink':'\ud83d\ude09',
  'wolf':'\ud83d\udc3a',
  'woman':'\ud83d\udc69',
  'woman_artist':'\ud83d\udc69&zwj;\ud83c\udfa8',
  'woman_astronaut':'\ud83d\udc69&zwj;\ud83d\ude80',
  'woman_cartwheeling':'\ud83e\udd38&zwj;\u2640\ufe0f',
  'woman_cook':'\ud83d\udc69&zwj;\ud83c\udf73',
  'woman_facepalming':'\ud83e\udd26&zwj;\u2640\ufe0f',
  'woman_factory_worker':'\ud83d\udc69&zwj;\ud83c\udfed',
  'woman_farmer':'\ud83d\udc69&zwj;\ud83c\udf3e',
  'woman_firefighter':'\ud83d\udc69&zwj;\ud83d\ude92',
  'woman_health_worker':'\ud83d\udc69&zwj;\u2695\ufe0f',
  'woman_judge':'\ud83d\udc69&zwj;\u2696\ufe0f',
  'woman_juggling':'\ud83e\udd39&zwj;\u2640\ufe0f',
  'woman_mechanic':'\ud83d\udc69&zwj;\ud83d\udd27',
  'woman_office_worker':'\ud83d\udc69&zwj;\ud83d\udcbc',
  'woman_pilot':'\ud83d\udc69&zwj;\u2708\ufe0f',
  'woman_playing_handball':'\ud83e\udd3e&zwj;\u2640\ufe0f',
  'woman_playing_water_polo':'\ud83e\udd3d&zwj;\u2640\ufe0f',
  'woman_scientist':'\ud83d\udc69&zwj;\ud83d\udd2c',
  'woman_shrugging':'\ud83e\udd37&zwj;\u2640\ufe0f',
  'woman_singer':'\ud83d\udc69&zwj;\ud83c\udfa4',
  'woman_student':'\ud83d\udc69&zwj;\ud83c\udf93',
  'woman_teacher':'\ud83d\udc69&zwj;\ud83c\udfeb',
  'woman_technologist':'\ud83d\udc69&zwj;\ud83d\udcbb',
  'woman_with_turban':'\ud83d\udc73&zwj;\u2640\ufe0f',
  'womans_clothes':'\ud83d\udc5a',
  'womans_hat':'\ud83d\udc52',
  'women_wrestling':'\ud83e\udd3c&zwj;\u2640\ufe0f',
  'womens':'\ud83d\udeba',
  'world_map':'\ud83d\uddfa',
  'worried':'\ud83d\ude1f',
  'wrench':'\ud83d\udd27',
  'writing_hand':'\u270d\ufe0f',
  'x':'\u274c',
  'yellow_heart':'\ud83d\udc9b',
  'yen':'\ud83d\udcb4',
  'yin_yang':'\u262f\ufe0f',
  'yum':'\ud83d\ude0b',
  'zap':'\u26a1\ufe0f',
  'zipper_mouth_face':'\ud83e\udd10',
  'zzz':'\ud83d\udca4',

  /* special emojis :P */
  'octocat':  '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
  'showdown': '<span style="font-family: \'Anonymous Pro\', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>'
};

/**
 * Created by Estevao on 31-05-2015.
 */

/**
 * Showdown Converter class
 * @class
 * @param {object} [converterOptions]
 * @returns {Converter}
 */
showdown.Converter = function (converterOptions) {
  'use strict';

  var
      /**
       * Options used by this converter
       * @private
       * @type {{}}
       */
      options = {},

      /**
       * Language extensions used by this converter
       * @private
       * @type {Array}
       */
      langExtensions = [],

      /**
       * Output modifiers extensions used by this converter
       * @private
       * @type {Array}
       */
      outputModifiers = [],

      /**
       * Event listeners
       * @private
       * @type {{}}
       */
      listeners = {},

      /**
       * The flavor set in this converter
       */
      setConvFlavor = setFlavor,

      /**
       * Metadata of the document
       * @type {{parsed: {}, raw: string, format: string}}
       */
      metadata = {
        parsed: {},
        raw: '',
        format: ''
      };

  _constructor();

  /**
   * Converter constructor
   * @private
   */
  function _constructor () {
    converterOptions = converterOptions || {};

    for (var gOpt in globalOptions) {
      if (globalOptions.hasOwnProperty(gOpt)) {
        options[gOpt] = globalOptions[gOpt];
      }
    }

    // Merge options
    if (typeof converterOptions === 'object') {
      for (var opt in converterOptions) {
        if (converterOptions.hasOwnProperty(opt)) {
          options[opt] = converterOptions[opt];
        }
      }
    } else {
      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +
      ' was passed instead.');
    }

    if (options.extensions) {
      showdown.helper.forEach(options.extensions, _parseExtension);
    }
  }

  /**
   * Parse extension
   * @param {*} ext
   * @param {string} [name='']
   * @private
   */
  function _parseExtension (ext, name) {

    name = name || null;
    // If it's a string, the extension was previously loaded
    if (showdown.helper.isString(ext)) {
      ext = showdown.helper.stdExtName(ext);
      name = ext;

      // LEGACY_SUPPORT CODE
      if (showdown.extensions[ext]) {
        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +
          'Please inform the developer that the extension should be updated!');
        legacyExtensionLoading(showdown.extensions[ext], ext);
        return;
        // END LEGACY SUPPORT CODE

      } else if (!showdown.helper.isUndefined(extensions[ext])) {
        ext = extensions[ext];

      } else {
        throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
      }
    }

    if (typeof ext === 'function') {
      ext = ext();
    }

    if (!showdown.helper.isArray(ext)) {
      ext = [ext];
    }

    var validExt = validate(ext, name);
    if (!validExt.valid) {
      throw Error(validExt.error);
    }

    for (var i = 0; i < ext.length; ++i) {
      switch (ext[i].type) {

        case 'lang':
          langExtensions.push(ext[i]);
          break;

        case 'output':
          outputModifiers.push(ext[i]);
          break;
      }
      if (ext[i].hasOwnProperty('listeners')) {
        for (var ln in ext[i].listeners) {
          if (ext[i].listeners.hasOwnProperty(ln)) {
            listen(ln, ext[i].listeners[ln]);
          }
        }
      }
    }

  }

  /**
   * LEGACY_SUPPORT
   * @param {*} ext
   * @param {string} name
   */
  function legacyExtensionLoading (ext, name) {
    if (typeof ext === 'function') {
      ext = ext(new showdown.Converter());
    }
    if (!showdown.helper.isArray(ext)) {
      ext = [ext];
    }
    var valid = validate(ext, name);

    if (!valid.valid) {
      throw Error(valid.error);
    }

    for (var i = 0; i < ext.length; ++i) {
      switch (ext[i].type) {
        case 'lang':
          langExtensions.push(ext[i]);
          break;
        case 'output':
          outputModifiers.push(ext[i]);
          break;
        default:// should never reach here
          throw Error('Extension loader error: Type unrecognized!!!');
      }
    }
  }

  /**
   * Listen to an event
   * @param {string} name
   * @param {function} callback
   */
  function listen (name, callback) {
    if (!showdown.helper.isString(name)) {
      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');
    }

    if (typeof callback !== 'function') {
      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');
    }

    if (!listeners.hasOwnProperty(name)) {
      listeners[name] = [];
    }
    listeners[name].push(callback);
  }

  function rTrimInputText (text) {
    var rsp = text.match(/^\s*/)[0].length,
        rgx = new RegExp('^\\s{0,' + rsp + '}', 'gm');
    return text.replace(rgx, '');
  }

  /**
   * Dispatch an event
   * @private
   * @param {string} evtName Event name
   * @param {string} text Text
   * @param {{}} options Converter Options
   * @param {{}} globals
   * @returns {string}
   */
  this._dispatch = function dispatch (evtName, text, options, globals) {
    if (listeners.hasOwnProperty(evtName)) {
      for (var ei = 0; ei < listeners[evtName].length; ++ei) {
        var nText = listeners[evtName][ei](evtName, text, this, options, globals);
        if (nText && typeof nText !== 'undefined') {
          text = nText;
        }
      }
    }
    return text;
  };

  /**
   * Listen to an event
   * @param {string} name
   * @param {function} callback
   * @returns {showdown.Converter}
   */
  this.listen = function (name, callback) {
    listen(name, callback);
    return this;
  };

  /**
   * Converts a markdown string into HTML
   * @param {string} text
   * @returns {*}
   */
  this.makeHtml = function (text) {
    //check if text is not falsy
    if (!text) {
      return text;
    }

    var globals = {
      gHtmlBlocks:     [],
      gHtmlMdBlocks:   [],
      gHtmlSpans:      [],
      gUrls:           {},
      gTitles:         {},
      gDimensions:     {},
      gListLevel:      0,
      hashLinkCounts:  {},
      langExtensions:  langExtensions,
      outputModifiers: outputModifiers,
      converter:       this,
      ghCodeBlocks:    [],
      metadata: {
        parsed: {},
        raw: '',
        format: ''
      }
    };

    // This lets us use ¨ trema as an escape char to avoid md5 hashes
    // The choice of character is arbitrary; anything that isn't
    // magic in Markdown will work.
    text = text.replace(/¨/g, '¨T');

    // Replace $ with ¨D
    // RegExp interprets $ as a special character
    // when it's in a replacement string
    text = text.replace(/\$/g, '¨D');

    // Standardize line endings
    text = text.replace(/\r\n/g, '\n'); // DOS to Unix
    text = text.replace(/\r/g, '\n'); // Mac to Unix

    // Stardardize line spaces
    text = text.replace(/\u00A0/g, '&nbsp;');

    if (options.smartIndentationFix) {
      text = rTrimInputText(text);
    }

    // Make sure text begins and ends with a couple of newlines:
    text = '\n\n' + text + '\n\n';

    // detab
    text = showdown.subParser('detab')(text, options, globals);

    /**
     * Strip any lines consisting only of spaces and tabs.
     * This makes subsequent regexs easier to write, because we can
     * match consecutive blank lines with /\n+/ instead of something
     * contorted like /[ \t]*\n+/
     */
    text = text.replace(/^[ \t]+$/mg, '');

    //run languageExtensions
    showdown.helper.forEach(langExtensions, function (ext) {
      text = showdown.subParser('runExtension')(ext, text, options, globals);
    });

    // run the sub parsers
    text = showdown.subParser('metadata')(text, options, globals);
    text = showdown.subParser('hashPreCodeTags')(text, options, globals);
    text = showdown.subParser('githubCodeBlocks')(text, options, globals);
    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
    text = showdown.subParser('hashCodeTags')(text, options, globals);
    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);
    text = showdown.subParser('blockGamut')(text, options, globals);
    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);
    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);

    // attacklab: Restore dollar signs
    text = text.replace(/¨D/g, '$$');

    // attacklab: Restore tremas
    text = text.replace(/¨T/g, '¨');

    // render a complete html document instead of a partial if the option is enabled
    text = showdown.subParser('completeHTMLDocument')(text, options, globals);

    // Run output modifiers
    showdown.helper.forEach(outputModifiers, function (ext) {
      text = showdown.subParser('runExtension')(ext, text, options, globals);
    });

    // update metadata
    metadata = globals.metadata;
    return text;
  };

  /**
   * Converts an HTML string into a markdown string
   * @param src
   * @param [HTMLParser] A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.
   * @returns {string}
   */
  this.makeMarkdown = this.makeMd = function (src, HTMLParser) {

    // replace \r\n with \n
    src = src.replace(/\r\n/g, '\n');
    src = src.replace(/\r/g, '\n'); // old macs

    // due to an edge case, we need to find this: > <
    // to prevent removing of non silent white spaces
    // ex: <em>this is</em> <strong>sparta</strong>
    src = src.replace(/>[ \t]+</, '>¨NBSP;<');

    if (!HTMLParser) {
      if (window && window.document) {
        HTMLParser = window.document;
      } else {
        throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM');
      }
    }

    var doc = HTMLParser.createElement('div');
    doc.innerHTML = src;

    var globals = {
      preList: substitutePreCodeTags(doc)
    };

    // remove all newlines and collapse spaces
    clean(doc);

    // some stuff, like accidental reference links must now be escaped
    // TODO
    // doc.innerHTML = doc.innerHTML.replace(/\[[\S\t ]]/);

    var nodes = doc.childNodes,
        mdDoc = '';

    for (var i = 0; i < nodes.length; i++) {
      mdDoc += showdown.subParser('makeMarkdown.node')(nodes[i], globals);
    }

    function clean (node) {
      for (var n = 0; n < node.childNodes.length; ++n) {
        var child = node.childNodes[n];
        if (child.nodeType === 3) {
          if (!/\S/.test(child.nodeValue)) {
            node.removeChild(child);
            --n;
          } else {
            child.nodeValue = child.nodeValue.split('\n').join(' ');
            child.nodeValue = child.nodeValue.replace(/(\s)+/g, '$1');
          }
        } else if (child.nodeType === 1) {
          clean(child);
        }
      }
    }

    // find all pre tags and replace contents with placeholder
    // we need this so that we can remove all indentation from html
    // to ease up parsing
    function substitutePreCodeTags (doc) {

      var pres = doc.querySelectorAll('pre'),
          presPH = [];

      for (var i = 0; i < pres.length; ++i) {

        if (pres[i].childElementCount === 1 && pres[i].firstChild.tagName.toLowerCase() === 'code') {
          var content = pres[i].firstChild.innerHTML.trim(),
              language = pres[i].firstChild.getAttribute('data-language') || '';

          // if data-language attribute is not defined, then we look for class language-*
          if (language === '') {
            var classes = pres[i].firstChild.className.split(' ');
            for (var c = 0; c < classes.length; ++c) {
              var matches = classes[c].match(/^language-(.+)$/);
              if (matches !== null) {
                language = matches[1];
                break;
              }
            }
          }

          // unescape html entities in content
          content = showdown.helper.unescapeHTMLEntities(content);

          presPH.push(content);
          pres[i].outerHTML = '<precode language="' + language + '" precodenum="' + i.toString() + '"></precode>';
        } else {
          presPH.push(pres[i].innerHTML);
          pres[i].innerHTML = '';
          pres[i].setAttribute('prenum', i.toString());
        }
      }
      return presPH;
    }

    return mdDoc;
  };

  /**
   * Set an option of this Converter instance
   * @param {string} key
   * @param {*} value
   */
  this.setOption = function (key, value) {
    options[key] = value;
  };

  /**
   * Get the option of this Converter instance
   * @param {string} key
   * @returns {*}
   */
  this.getOption = function (key) {
    return options[key];
  };

  /**
   * Get the options of this Converter instance
   * @returns {{}}
   */
  this.getOptions = function () {
    return options;
  };

  /**
   * Add extension to THIS converter
   * @param {{}} extension
   * @param {string} [name=null]
   */
  this.addExtension = function (extension, name) {
    name = name || null;
    _parseExtension(extension, name);
  };

  /**
   * Use a global registered extension with THIS converter
   * @param {string} extensionName Name of the previously registered extension
   */
  this.useExtension = function (extensionName) {
    _parseExtension(extensionName);
  };

  /**
   * Set the flavor THIS converter should use
   * @param {string} name
   */
  this.setFlavor = function (name) {
    if (!flavor.hasOwnProperty(name)) {
      throw Error(name + ' flavor was not found');
    }
    var preset = flavor[name];
    setConvFlavor = name;
    for (var option in preset) {
      if (preset.hasOwnProperty(option)) {
        options[option] = preset[option];
      }
    }
  };

  /**
   * Get the currently set flavor of this converter
   * @returns {string}
   */
  this.getFlavor = function () {
    return setConvFlavor;
  };

  /**
   * Remove an extension from THIS converter.
   * Note: This is a costly operation. It's better to initialize a new converter
   * and specify the extensions you wish to use
   * @param {Array} extension
   */
  this.removeExtension = function (extension) {
    if (!showdown.helper.isArray(extension)) {
      extension = [extension];
    }
    for (var a = 0; a < extension.length; ++a) {
      var ext = extension[a];
      for (var i = 0; i < langExtensions.length; ++i) {
        if (langExtensions[i] === ext) {
          langExtensions[i].splice(i, 1);
        }
      }
      for (var ii = 0; ii < outputModifiers.length; ++i) {
        if (outputModifiers[ii] === ext) {
          outputModifiers[ii].splice(i, 1);
        }
      }
    }
  };

  /**
   * Get all extension of THIS converter
   * @returns {{language: Array, output: Array}}
   */
  this.getAllExtensions = function () {
    return {
      language: langExtensions,
      output: outputModifiers
    };
  };

  /**
   * Get the metadata of the previously parsed document
   * @param raw
   * @returns {string|{}}
   */
  this.getMetadata = function (raw) {
    if (raw) {
      return metadata.raw;
    } else {
      return metadata.parsed;
    }
  };

  /**
   * Get the metadata format of the previously parsed document
   * @returns {string}
   */
  this.getMetadataFormat = function () {
    return metadata.format;
  };

  /**
   * Private: set a single key, value metadata pair
   * @param {string} key
   * @param {string} value
   */
  this._setMetadataPair = function (key, value) {
    metadata.parsed[key] = value;
  };

  /**
   * Private: set metadata format
   * @param {string} format
   */
  this._setMetadataFormat = function (format) {
    metadata.format = format;
  };

  /**
   * Private: set metadata raw text
   * @param {string} raw
   */
  this._setMetadataRaw = function (raw) {
    metadata.raw = raw;
  };
};

/**
 * Turn Markdown link shortcuts into XHTML <a> tags.
 */
showdown.subParser('anchors', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('anchors.before', text, options, globals);

  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {
    if (showdown.helper.isUndefined(title)) {
      title = '';
    }
    linkId = linkId.toLowerCase();

    // Special case for explicit empty url
    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
      url = '';
    } else if (!url) {
      if (!linkId) {
        // lower-case and turn embedded newlines into spaces
        linkId = linkText.toLowerCase().replace(/ ?\n/g, ' ');
      }
      url = '#' + linkId;

      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {
        url = globals.gUrls[linkId];
        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {
          title = globals.gTitles[linkId];
        }
      } else {
        return wholeMatch;
      }
    }

    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance
    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);

    var result = '<a href="' + url + '"';

    if (title !== '' && title !== null) {
      title = title.replace(/"/g, '&quot;');
      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance
      title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
      result += ' title="' + title + '"';
    }

    // optionLinksInNewWindow only applies
    // to external links. Hash links (#) open in same page
    if (options.openLinksInNewWindow && !/^#/.test(url)) {
      // escaped _
      result += ' rel="noopener noreferrer" target="¨E95Eblank"';
    }

    result += '>' + linkText + '</a>';

    return result;
  };

  // First, handle reference-style links: [link text] [id]
  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);

  // Next, inline-style links: [link text](url "optional title")
  // cases with crazy urls like ./image/cat1).png
  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
    writeAnchorTag);

  // normal cases
  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
    writeAnchorTag);

  // handle reference-style shortcuts: [link text]
  // These must come last in case you've also got [link test][1]
  // or [link test](/foo)
  text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);

  // Lastly handle GithubMentions if option is enabled
  if (options.ghMentions) {
    text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (wm, st, escape, mentions, username) {
      if (escape === '\\') {
        return st + mentions;
      }

      //check if options.ghMentionsLink is a string
      if (!showdown.helper.isString(options.ghMentionsLink)) {
        throw new Error('ghMentionsLink option must be a string');
      }
      var lnk = options.ghMentionsLink.replace(/\{u}/g, username),
          target = '';
      if (options.openLinksInNewWindow) {
        target = ' rel="noopener noreferrer" target="¨E95Eblank"';
      }
      return st + '<a href="' + lnk + '"' + target + '>' + mentions + '</a>';
    });
  }

  text = globals.converter._dispatch('anchors.after', text, options, globals);
  return text;
});

// url allowed chars [a-z\d_.~:/?#[]@!$&'()*+,;=-]

var simpleURLRegex  = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
    simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
    delimUrlRegex   = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
    simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi,
    delimMailRegex  = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,

    replaceLink = function (options) {
      'use strict';
      return function (wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
        link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
        var lnkTxt = link,
            append = '',
            target = '',
            lmc    = leadingMagicChars || '',
            tmc    = trailingMagicChars || '';
        if (/^www\./i.test(link)) {
          link = link.replace(/^www\./i, 'http://www.');
        }
        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
          append = trailingPunctuation;
        }
        if (options.openLinksInNewWindow) {
          target = ' rel="noopener noreferrer" target="¨E95Eblank"';
        }
        return lmc + '<a href="' + link + '"' + target + '>' + lnkTxt + '</a>' + append + tmc;
      };
    },

    replaceMail = function (options, globals) {
      'use strict';
      return function (wholeMatch, b, mail) {
        var href = 'mailto:';
        b = b || '';
        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);
        if (options.encodeEmails) {
          href = showdown.helper.encodeEmailAddress(href + mail);
          mail = showdown.helper.encodeEmailAddress(mail);
        } else {
          href = href + mail;
        }
        return b + '<a href="' + href + '">' + mail + '</a>';
      };
    };

showdown.subParser('autoLinks', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('autoLinks.before', text, options, globals);

  text = text.replace(delimUrlRegex, replaceLink(options));
  text = text.replace(delimMailRegex, replaceMail(options, globals));

  text = globals.converter._dispatch('autoLinks.after', text, options, globals);

  return text;
});

showdown.subParser('simplifiedAutoLinks', function (text, options, globals) {
  'use strict';

  if (!options.simplifiedAutoLink) {
    return text;
  }

  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);

  if (options.excludeTrailingPunctuationFromURLs) {
    text = text.replace(simpleURLRegex2, replaceLink(options));
  } else {
    text = text.replace(simpleURLRegex, replaceLink(options));
  }
  text = text.replace(simpleMailRegex, replaceMail(options, globals));

  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);

  return text;
});

/**
 * These are all the transformations that form block-level
 * tags like paragraphs, headers, and list items.
 */
showdown.subParser('blockGamut', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('blockGamut.before', text, options, globals);

  // we parse blockquotes first so that we can have headings and hrs
  // inside blockquotes
  text = showdown.subParser('blockQuotes')(text, options, globals);
  text = showdown.subParser('headers')(text, options, globals);

  // Do Horizontal Rules:
  text = showdown.subParser('horizontalRule')(text, options, globals);

  text = showdown.subParser('lists')(text, options, globals);
  text = showdown.subParser('codeBlocks')(text, options, globals);
  text = showdown.subParser('tables')(text, options, globals);

  // We already ran _HashHTMLBlocks() before, in Markdown(), but that
  // was to escape raw HTML in the original Markdown source. This time,
  // we're escaping the markup we've just created, so that we don't wrap
  // <p> tags around block-level tags.
  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
  text = showdown.subParser('paragraphs')(text, options, globals);

  text = globals.converter._dispatch('blockGamut.after', text, options, globals);

  return text;
});

showdown.subParser('blockQuotes', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);

  // add a couple extra lines after the text and endtext mark
  text = text + '\n\n';

  var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;

  if (options.splitAdjacentBlockquotes) {
    rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
  }

  text = text.replace(rgx, function (bq) {
    // attacklab: hack around Konqueror 3.5.4 bug:
    // "----------bug".replace(/^-/g,"") == "bug"
    bq = bq.replace(/^[ \t]*>[ \t]?/gm, ''); // trim one level of quoting

    // attacklab: clean up hack
    bq = bq.replace(/¨0/g, '');

    bq = bq.replace(/^[ \t]+$/gm, ''); // trim whitespace-only lines
    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);
    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse

    bq = bq.replace(/(^|\n)/g, '$1  ');
    // These leading spaces screw with <pre> content, so we need to fix that:
    bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (wholeMatch, m1) {
      var pre = m1;
      // attacklab: hack around Konqueror 3.5.4 bug:
      pre = pre.replace(/^  /mg, '¨0');
      pre = pre.replace(/¨0/g, '');
      return pre;
    });

    return showdown.subParser('hashBlock')('<blockquote>\n' + bq + '\n</blockquote>', options, globals);
  });

  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);
  return text;
});

/**
 * Process Markdown `<pre><code>` blocks.
 */
showdown.subParser('codeBlocks', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);

  // sentinel workarounds for lack of \A and \Z, safari\khtml bug
  text += '¨0';

  var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=¨0))/g;
  text = text.replace(pattern, function (wholeMatch, m1, m2) {
    var codeblock = m1,
        nextChar = m2,
        end = '\n';

    codeblock = showdown.subParser('outdent')(codeblock, options, globals);
    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
    codeblock = showdown.subParser('detab')(codeblock, options, globals);
    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing newlines

    if (options.omitExtraWLInCodeBlocks) {
      end = '';
    }

    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';

    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;
  });

  // strip sentinel
  text = text.replace(/¨0/, '');

  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);
  return text;
});

/**
 *
 *   *  Backtick quotes are used for <code></code> spans.
 *
 *   *  You can use multiple backticks as the delimiters if you want to
 *     include literal backticks in the code span. So, this input:
 *
 *         Just type ``foo `bar` baz`` at the prompt.
 *
 *       Will translate to:
 *
 *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
 *
 *    There's no arbitrary limit to the number of backticks you
 *    can use as delimters. If you need three consecutive backticks
 *    in your code, use four for delimiters, etc.
 *
 *  *  You can use spaces to get literal backticks at the edges:
 *
 *         ... type `` `bar` `` ...
 *
 *       Turns to:
 *
 *         ... type <code>`bar`</code> ...
 */
showdown.subParser('codeSpans', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('codeSpans.before', text, options, globals);

  if (typeof text === 'undefined') {
    text = '';
  }
  text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
    function (wholeMatch, m1, m2, m3) {
      var c = m3;
      c = c.replace(/^([ \t]*)/g, '');	// leading whitespace
      c = c.replace(/[ \t]*$/g, '');	// trailing whitespace
      c = showdown.subParser('encodeCode')(c, options, globals);
      c = m1 + '<code>' + c + '</code>';
      c = showdown.subParser('hashHTMLSpans')(c, options, globals);
      return c;
    }
  );

  text = globals.converter._dispatch('codeSpans.after', text, options, globals);
  return text;
});

/**
 * Create a full HTML document from the processed markdown
 */
showdown.subParser('completeHTMLDocument', function (text, options, globals) {
  'use strict';

  if (!options.completeHTMLDocument) {
    return text;
  }

  text = globals.converter._dispatch('completeHTMLDocument.before', text, options, globals);

  var doctype = 'html',
      doctypeParsed = '<!DOCTYPE HTML>\n',
      title = '',
      charset = '<meta charset="utf-8">\n',
      lang = '',
      metadata = '';

  if (typeof globals.metadata.parsed.doctype !== 'undefined') {
    doctypeParsed = '<!DOCTYPE ' +  globals.metadata.parsed.doctype + '>\n';
    doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
    if (doctype === 'html' || doctype === 'html5') {
      charset = '<meta charset="utf-8">';
    }
  }

  for (var meta in globals.metadata.parsed) {
    if (globals.metadata.parsed.hasOwnProperty(meta)) {
      switch (meta.toLowerCase()) {
        case 'doctype':
          break;

        case 'title':
          title = '<title>' +  globals.metadata.parsed.title + '</title>\n';
          break;

        case 'charset':
          if (doctype === 'html' || doctype === 'html5') {
            charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
          } else {
            charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
          }
          break;

        case 'language':
        case 'lang':
          lang = ' lang="' + globals.metadata.parsed[meta] + '"';
          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
          break;

        default:
          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
      }
    }
  }

  text = doctypeParsed + '<html' + lang + '>\n<head>\n' + title + charset + metadata + '</head>\n<body>\n' + text.trim() + '\n</body>\n</html>';

  text = globals.converter._dispatch('completeHTMLDocument.after', text, options, globals);
  return text;
});

/**
 * Convert all tabs to spaces
 */
showdown.subParser('detab', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('detab.before', text, options, globals);

  // expand first n-1 tabs
  text = text.replace(/\t(?=\t)/g, '    '); // g_tab_width

  // replace the nth with two sentinels
  text = text.replace(/\t/g, '¨A¨B');

  // use the sentinel to anchor our regex so it doesn't explode
  text = text.replace(/¨B(.+?)¨A/g, function (wholeMatch, m1) {
    var leadingText = m1,
        numSpaces = 4 - leadingText.length % 4;  // g_tab_width

    // there *must* be a better way to do this:
    for (var i = 0; i < numSpaces; i++) {
      leadingText += ' ';
    }

    return leadingText;
  });

  // clean up sentinels
  text = text.replace(/¨A/g, '    ');  // g_tab_width
  text = text.replace(/¨B/g, '');

  text = globals.converter._dispatch('detab.after', text, options, globals);
  return text;
});

showdown.subParser('ellipsis', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('ellipsis.before', text, options, globals);

  text = text.replace(/\.\.\./g, '…');

  text = globals.converter._dispatch('ellipsis.after', text, options, globals);

  return text;
});

/**
 * Turn emoji codes into emojis
 *
 * List of supported emojis: https://github.com/showdownjs/showdown/wiki/Emojis
 */
showdown.subParser('emoji', function (text, options, globals) {
  'use strict';

  if (!options.emoji) {
    return text;
  }

  text = globals.converter._dispatch('emoji.before', text, options, globals);

  var emojiRgx = /:([\S]+?):/g;

  text = text.replace(emojiRgx, function (wm, emojiCode) {
    if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {
      return showdown.helper.emojis[emojiCode];
    }
    return wm;
  });

  text = globals.converter._dispatch('emoji.after', text, options, globals);

  return text;
});

/**
 * Smart processing for ampersands and angle brackets that need to be encoded.
 */
showdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);

  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
  // http://bumppo.net/projects/amputator/
  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, '&amp;');

  // Encode naked <'s
  text = text.replace(/<(?![a-z\/?$!])/gi, '&lt;');

  // Encode <
  text = text.replace(/</g, '&lt;');

  // Encode >
  text = text.replace(/>/g, '&gt;');

  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);
  return text;
});

/**
 * Returns the string, with after processing the following backslash escape sequences.
 *
 * attacklab: The polite way to do this is with the new escapeCharacters() function:
 *
 *    text = escapeCharacters(text,"\\",true);
 *    text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
 *
 * ...but we're sidestepping its use of the (slow) RegExp constructor
 * as an optimization for Firefox.  This function gets called a LOT.
 */
showdown.subParser('encodeBackslashEscapes', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);

  text = text.replace(/\\(\\)/g, showdown.helper.escapeCharactersCallback);
  text = text.replace(/\\([`*_{}\[\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);

  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);
  return text;
});

/**
 * Encode/escape certain characters inside Markdown code runs.
 * The point is that in code, these characters are literals,
 * and lose their special Markdown meanings.
 */
showdown.subParser('encodeCode', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('encodeCode.before', text, options, globals);

  // Encode all ampersands; HTML entities are not
  // entities within a Markdown code span.
  text = text
    .replace(/&/g, '&amp;')
  // Do the angle bracket song and dance:
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
  // Now, escape characters that are magic in Markdown:
    .replace(/([*_{}\[\]\\=~-])/g, showdown.helper.escapeCharactersCallback);

  text = globals.converter._dispatch('encodeCode.after', text, options, globals);
  return text;
});

/**
 * Within tags -- meaning between < and > -- encode [\ ` * _ ~ =] so they
 * don't conflict with their use in Markdown for code, italics and strong.
 */
showdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);

  // Build a regex to find HTML tags.
  var tags     = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
      comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;

  text = text.replace(tags, function (wholeMatch) {
    return wholeMatch
      .replace(/(.)<\/?code>(?=.)/g, '$1`')
      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
  });

  text = text.replace(comments, function (wholeMatch) {
    return wholeMatch
      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
  });

  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);
  return text;
});

/**
 * Handle github codeblocks prior to running HashHTML so that
 * HTML contained within the codeblock gets escaped properly
 * Example:
 * ```ruby
 *     def hello_world(x)
 *       puts "Hello, #{x}"
 *     end
 * ```
 */
showdown.subParser('githubCodeBlocks', function (text, options, globals) {
  'use strict';

  // early exit if option is not enabled
  if (!options.ghCodeBlocks) {
    return text;
  }

  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);

  text += '¨0';

  text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (wholeMatch, delim, language, codeblock) {
    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\n';

    // First parse the github code block
    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
    codeblock = showdown.subParser('detab')(codeblock, options, globals);
    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing whitespace

    codeblock = '<pre><code' + (language ? ' class="' + language + ' language-' + language + '"' : '') + '>' + codeblock + end + '</code></pre>';

    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);

    // Since GHCodeblocks can be false positives, we need to
    // store the primitive text and the parsed text in a global var,
    // and then return a token
    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
  });

  // attacklab: strip sentinel
  text = text.replace(/¨0/, '');

  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);
});

showdown.subParser('hashBlock', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashBlock.before', text, options, globals);
  text = text.replace(/(^\n+|\n+$)/g, '');
  text = '\n\n¨K' + (globals.gHtmlBlocks.push(text) - 1) + 'K\n\n';
  text = globals.converter._dispatch('hashBlock.after', text, options, globals);
  return text;
});

/**
 * Hash and escape <code> elements that should not be parsed as markdown
 */
showdown.subParser('hashCodeTags', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);

  var repFunc = function (wholeMatch, match, left, right) {
    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
    return '¨C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';
  };

  // Hash naked <code>
  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\b[^>]*>', '</code>', 'gim');

  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);
  return text;
});

showdown.subParser('hashElement', function (text, options, globals) {
  'use strict';

  return function (wholeMatch, m1) {
    var blockText = m1;

    // Undo double lines
    blockText = blockText.replace(/\n\n/g, '\n');
    blockText = blockText.replace(/^\n/, '');

    // strip trailing blank lines
    blockText = blockText.replace(/\n+$/g, '');

    // Replace the element text with a marker ("¨KxK" where x is its key)
    blockText = '\n\n¨K' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\n\n';

    return blockText;
  };
});

showdown.subParser('hashHTMLBlocks', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);

  var blockTags = [
        'pre',
        'div',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'blockquote',
        'table',
        'dl',
        'ol',
        'ul',
        'script',
        'noscript',
        'form',
        'fieldset',
        'iframe',
        'math',
        'style',
        'section',
        'header',
        'footer',
        'nav',
        'article',
        'aside',
        'address',
        'audio',
        'canvas',
        'figure',
        'hgroup',
        'output',
        'video',
        'p'
      ],
      repFunc = function (wholeMatch, match, left, right) {
        var txt = wholeMatch;
        // check if this html element is marked as markdown
        // if so, it's contents should be parsed as markdown
        if (left.search(/\bmarkdown\b/) !== -1) {
          txt = left + globals.converter.makeHtml(match) + right;
        }
        return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
      };

  if (options.backslashEscapesHTMLTags) {
    // encode backslash escaped HTML tags
    text = text.replace(/\\<(\/?[^>]+?)>/g, function (wm, inside) {
      return '&lt;' + inside + '&gt;';
    });
  }

  // hash HTML Blocks
  for (var i = 0; i < blockTags.length; ++i) {

    var opTagPos,
        rgx1     = new RegExp('^ {0,3}(<' + blockTags[i] + '\\b[^>]*>)', 'im'),
        patLeft  = '<' + blockTags[i] + '\\b[^>]*>',
        patRight = '</' + blockTags[i] + '>';
    // 1. Look for the first position of the first opening HTML tag in the text
    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {

      // if the HTML tag is \ escaped, we need to escape it and break


      //2. Split the text in that position
      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),
          //3. Match recursively
          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');

      // prevent an infinite loop
      if (newSubText1 === subTexts[1]) {
        break;
      }
      text = subTexts[0].concat(newSubText1);
    }
  }
  // HR SPECIAL CASE
  text = text.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
    showdown.subParser('hashElement')(text, options, globals));

  // Special case for standalone HTML comments
  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {
    return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
  }, '^ {0,3}<!--', '-->', 'gm');

  // PHP and ASP-style processor instructions (<?...?> and <%...%>)
  text = text.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
    showdown.subParser('hashElement')(text, options, globals));

  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);
  return text;
});

/**
 * Hash span elements that should not be parsed as markdown
 */
showdown.subParser('hashHTMLSpans', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);

  function hashHTMLSpan (html) {
    return '¨C' + (globals.gHtmlSpans.push(html) - 1) + 'C';
  }

  // Hash Self Closing tags
  text = text.replace(/<[^>]+?\/>/gi, function (wm) {
    return hashHTMLSpan(wm);
  });

  // Hash tags without properties
  text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (wm) {
    return hashHTMLSpan(wm);
  });

  // Hash tags with properties
  text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (wm) {
    return hashHTMLSpan(wm);
  });

  // Hash self closing tags without />
  text = text.replace(/<[^>]+?>/gi, function (wm) {
    return hashHTMLSpan(wm);
  });

  /*showdown.helper.matchRecursiveRegExp(text, '<code\\b[^>]*>', '</code>', 'gi');*/

  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);
  return text;
});

/**
 * Unhash HTML spans
 */
showdown.subParser('unhashHTMLSpans', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);

  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
    var repText = globals.gHtmlSpans[i],
        // limiter to prevent infinite loop (assume 10 as limit for recurse)
        limit = 0;

    while (/¨C(\d+)C/.test(repText)) {
      var num = RegExp.$1;
      repText = repText.replace('¨C' + num + 'C', globals.gHtmlSpans[num]);
      if (limit === 10) {
        console.error('maximum nesting of 10 spans reached!!!');
        break;
      }
      ++limit;
    }
    text = text.replace('¨C' + i + 'C', repText);
  }

  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);
  return text;
});

/**
 * Hash and escape <pre><code> elements that should not be parsed as markdown
 */
showdown.subParser('hashPreCodeTags', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);

  var repFunc = function (wholeMatch, match, left, right) {
    // encode html entities
    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
  };

  // Hash <pre><code>
  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>', '^ {0,3}</code>\\s*</pre>', 'gim');

  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);
  return text;
});

showdown.subParser('headers', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('headers.before', text, options, globals);

  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),

      // Set text-style headers:
      //	Header 1
      //	========
      //
      //	Header 2
      //	--------
      //
      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;

  text = text.replace(setextRegexH1, function (wholeMatch, m1) {

    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
        hLevel = headerLevelStart,
        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
    return showdown.subParser('hashBlock')(hashBlock, options, globals);
  });

  text = text.replace(setextRegexH2, function (matchFound, m1) {
    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
        hLevel = headerLevelStart + 1,
        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
    return showdown.subParser('hashBlock')(hashBlock, options, globals);
  });

  // atx-style headers:
  //  # Header 1
  //  ## Header 2
  //  ## Header 2 with closing hashes ##
  //  ...
  //  ###### Header 6
  //
  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;

  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {
    var hText = m2;
    if (options.customizedHeaderId) {
      hText = m2.replace(/\s?\{([^{]+?)}\s*$/, '');
    }

    var span = showdown.subParser('spanGamut')(hText, options, globals),
        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m2) + '"',
        hLevel = headerLevelStart - 1 + m1.length,
        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';

    return showdown.subParser('hashBlock')(header, options, globals);
  });

  function headerId (m) {
    var title,
        prefix;

    // It is separate from other options to allow combining prefix and customized
    if (options.customizedHeaderId) {
      var match = m.match(/\{([^{]+?)}\s*$/);
      if (match && match[1]) {
        m = match[1];
      }
    }

    title = m;

    // Prefix id to prevent causing inadvertent pre-existing style matches.
    if (showdown.helper.isString(options.prefixHeaderId)) {
      prefix = options.prefixHeaderId;
    } else if (options.prefixHeaderId === true) {
      prefix = 'section-';
    } else {
      prefix = '';
    }

    if (!options.rawPrefixHeaderId) {
      title = prefix + title;
    }

    if (options.ghCompatibleHeaderId) {
      title = title
        .replace(/ /g, '-')
        // replace previously escaped chars (&, ¨ and $)
        .replace(/&amp;/g, '')
        .replace(/¨T/g, '')
        .replace(/¨D/g, '')
        // replace rest of the chars (&~$ are repeated as they might have been escaped)
        // borrowed from github's redcarpet (some they should produce similar results)
        .replace(/[&+$,\/:;=?@"#{}|^¨~\[\]`\\*)(%.!'<>]/g, '')
        .toLowerCase();
    } else if (options.rawHeaderId) {
      title = title
        .replace(/ /g, '-')
        // replace previously escaped chars (&, ¨ and $)
        .replace(/&amp;/g, '&')
        .replace(/¨T/g, '¨')
        .replace(/¨D/g, '$')
        // replace " and '
        .replace(/["']/g, '-')
        .toLowerCase();
    } else {
      title = title
        .replace(/[^\w]/g, '')
        .toLowerCase();
    }

    if (options.rawPrefixHeaderId) {
      title = prefix + title;
    }

    if (globals.hashLinkCounts[title]) {
      title = title + '-' + (globals.hashLinkCounts[title]++);
    } else {
      globals.hashLinkCounts[title] = 1;
    }
    return title;
  }

  text = globals.converter._dispatch('headers.after', text, options, globals);
  return text;
});

/**
 * Turn Markdown link shortcuts into XHTML <a> tags.
 */
showdown.subParser('horizontalRule', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);

  var key = showdown.subParser('hashBlock')('<hr />', options, globals);
  text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
  text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
  text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);

  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);
  return text;
});

/**
 * Turn Markdown image shortcuts into <img> tags.
 */
showdown.subParser('images', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('images.before', text, options, globals);

  var inlineRegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
      crazyRegExp       = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
      base64RegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
      referenceRegExp   = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
      refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;

  function writeImageTagBase64 (wholeMatch, altText, linkId, url, width, height, m5, title) {
    url = url.replace(/\s/g, '');
    return writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title);
  }

  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {

    var gUrls   = globals.gUrls,
        gTitles = globals.gTitles,
        gDims   = globals.gDimensions;

    linkId = linkId.toLowerCase();

    if (!title) {
      title = '';
    }
    // Special case for explicit empty url
    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
      url = '';

    } else if (url === '' || url === null) {
      if (linkId === '' || linkId === null) {
        // lower-case and turn embedded newlines into spaces
        linkId = altText.toLowerCase().replace(/ ?\n/g, ' ');
      }
      url = '#' + linkId;

      if (!showdown.helper.isUndefined(gUrls[linkId])) {
        url = gUrls[linkId];
        if (!showdown.helper.isUndefined(gTitles[linkId])) {
          title = gTitles[linkId];
        }
        if (!showdown.helper.isUndefined(gDims[linkId])) {
          width = gDims[linkId].width;
          height = gDims[linkId].height;
        }
      } else {
        return wholeMatch;
      }
    }

    altText = altText
      .replace(/"/g, '&quot;')
    //altText = showdown.helper.escapeCharacters(altText, '*_', false);
      .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
    //url = showdown.helper.escapeCharacters(url, '*_', false);
    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
    var result = '<img src="' + url + '" alt="' + altText + '"';

    if (title && showdown.helper.isString(title)) {
      title = title
        .replace(/"/g, '&quot;')
      //title = showdown.helper.escapeCharacters(title, '*_', false);
        .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
      result += ' title="' + title + '"';
    }

    if (width && height) {
      width  = (width === '*') ? 'auto' : width;
      height = (height === '*') ? 'auto' : height;

      result += ' width="' + width + '"';
      result += ' height="' + height + '"';
    }

    result += ' />';

    return result;
  }

  // First, handle reference-style labeled images: ![alt text][id]
  text = text.replace(referenceRegExp, writeImageTag);

  // Next, handle inline images:  ![alt text](url =<width>x<height> "optional title")

  // base64 encoded images
  text = text.replace(base64RegExp, writeImageTagBase64);

  // cases with crazy urls like ./image/cat1).png
  text = text.replace(crazyRegExp, writeImageTag);

  // normal cases
  text = text.replace(inlineRegExp, writeImageTag);

  // handle reference-style shortcuts: ![img text]
  text = text.replace(refShortcutRegExp, writeImageTag);

  text = globals.converter._dispatch('images.after', text, options, globals);
  return text;
});

showdown.subParser('italicsAndBold', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);

  // it's faster to have 3 separate regexes for each case than have just one
  // because of backtracing, in some cases, it could lead to an exponential effect
  // called "catastrophic backtrace". Ominous!

  function parseInside (txt, left, right) {
    /*
    if (options.simplifiedAutoLink) {
      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
    }
    */
    return left + txt + right;
  }

  // Parse underscores
  if (options.literalMidWordUnderscores) {
    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
      return parseInside (txt, '<strong><em>', '</em></strong>');
    });
    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
      return parseInside (txt, '<strong>', '</strong>');
    });
    text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function (wm, txt) {
      return parseInside (txt, '<em>', '</em>');
    });
  } else {
    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
    });
    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
    });
    text = text.replace(/_([^\s_][\s\S]*?)_/g, function (wm, m) {
      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)
      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
    });
  }

  // Now parse asterisks
  if (options.literalMidWordAsterisks) {
    text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (wm, lead, txt) {
      return parseInside (txt, lead + '<strong><em>', '</em></strong>');
    });
    text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (wm, lead, txt) {
      return parseInside (txt, lead + '<strong>', '</strong>');
    });
    text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (wm, lead, txt) {
      return parseInside (txt, lead + '<em>', '</em>');
    });
  } else {
    text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
    });
    text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
    });
    text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function (wm, m) {
      // !/^\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)
      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
    });
  }


  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);
  return text;
});

/**
 * Form HTML ordered (numbered) and unordered (bulleted) lists.
 */
showdown.subParser('lists', function (text, options, globals) {
  'use strict';

  /**
   * Process the contents of a single ordered or unordered list, splitting it
   * into individual list items.
   * @param {string} listStr
   * @param {boolean} trimTrailing
   * @returns {string}
   */
  function processListItems (listStr, trimTrailing) {
    // The $g_list_level global keeps track of when we're inside a list.
    // Each time we enter a list, we increment it; when we leave a list,
    // we decrement. If it's zero, we're not in a list anymore.
    //
    // We do this because when we're not inside a list, we want to treat
    // something like this:
    //
    //    I recommend upgrading to version
    //    8. Oops, now this line is treated
    //    as a sub-list.
    //
    // As a single paragraph, despite the fact that the second line starts
    // with a digit-period-space sequence.
    //
    // Whereas when we're inside a list (or sub-list), that line will be
    // treated as the start of a sub-list. What a kludge, huh? This is
    // an aspect of Markdown's syntax that's hard to parse perfectly
    // without resorting to mind-reading. Perhaps the solution is to
    // change the syntax rules such that sub-lists must start with a
    // starting cardinal number; e.g. "1." or "a.".
    globals.gListLevel++;

    // trim trailing blank lines:
    listStr = listStr.replace(/\n{2,}$/, '\n');

    // attacklab: add sentinel to emulate \z
    listStr += '¨0';

    var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
        isParagraphed = (/\n[ \t]*\n(?!¨0)/.test(listStr));

    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,
    // which is a syntax breaking change
    // activating this option reverts to old behavior
    if (options.disableForced4SpacesIndentedSublists) {
      rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0|\2([*+-]|\d+[.])[ \t]+))/gm;
    }

    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
      checked = (checked && checked.trim() !== '');

      var item = showdown.subParser('outdent')(m4, options, globals),
          bulletStyle = '';

      // Support for github tasklists
      if (taskbtn && options.tasklists) {
        bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
        item = item.replace(/^[ \t]*\[(x|X| )?]/m, function () {
          var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
          if (checked) {
            otp += ' checked';
          }
          otp += '>';
          return otp;
        });
      }

      // ISSUE #312
      // This input: - - - a
      // causes trouble to the parser, since it interprets it as:
      // <ul><li><li><li>a</li></li></li></ul>
      // instead of:
      // <ul><li>- - a</li></ul>
      // So, to prevent it, we will put a marker (¨A)in the beginning of the line
      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser
      item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (wm2) {
        return '¨A' + wm2;
      });

      // m1 - Leading line or
      // Has a double return (multi paragraph) or
      // Has sublist
      if (m1 || (item.search(/\n{2,}/) > -1)) {
        item = showdown.subParser('githubCodeBlocks')(item, options, globals);
        item = showdown.subParser('blockGamut')(item, options, globals);
      } else {
        // Recursion for sub-lists:
        item = showdown.subParser('lists')(item, options, globals);
        item = item.replace(/\n$/, ''); // chomp(item)
        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);

        // Colapse double linebreaks
        item = item.replace(/\n\n+/g, '\n\n');
        if (isParagraphed) {
          item = showdown.subParser('paragraphs')(item, options, globals);
        } else {
          item = showdown.subParser('spanGamut')(item, options, globals);
        }
      }

      // now we need to remove the marker (¨A)
      item = item.replace('¨A', '');
      // we can finally wrap the line in list item tags
      item =  '<li' + bulletStyle + '>' + item + '</li>\n';

      return item;
    });

    // attacklab: strip sentinel
    listStr = listStr.replace(/¨0/g, '');

    globals.gListLevel--;

    if (trimTrailing) {
      listStr = listStr.replace(/\s+$/, '');
    }

    return listStr;
  }

  function styleStartNumber (list, listType) {
    // check if ol and starts by a number different than 1
    if (listType === 'ol') {
      var res = list.match(/^ *(\d+)\./);
      if (res && res[1] !== '1') {
        return ' start="' + res[1] + '"';
      }
    }
    return '';
  }

  /**
   * Check and parse consecutive lists (better fix for issue #142)
   * @param {string} list
   * @param {string} listType
   * @param {boolean} trimTrailing
   * @returns {string}
   */
  function parseConsecutiveLists (list, listType, trimTrailing) {
    // check if we caught 2 or more consecutive lists by mistake
    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa
    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm,
        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm,
        counterRxg = (listType === 'ul') ? olRgx : ulRgx,
        result = '';

    if (list.search(counterRxg) !== -1) {
      (function parseCL (txt) {
        var pos = txt.search(counterRxg),
            style = styleStartNumber(list, listType);
        if (pos !== -1) {
          // slice
          result += '\n\n<' + listType + style + '>\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\n';

          // invert counterType and listType
          listType = (listType === 'ul') ? 'ol' : 'ul';
          counterRxg = (listType === 'ul') ? olRgx : ulRgx;

          //recurse
          parseCL(txt.slice(pos));
        } else {
          result += '\n\n<' + listType + style + '>\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\n';
        }
      })(list);
    } else {
      var style = styleStartNumber(list, listType);
      result = '\n\n<' + listType + style + '>\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\n';
    }

    return result;
  }

  /** Start of list parsing **/
  text = globals.converter._dispatch('lists.before', text, options, globals);
  // add sentinel to hack around khtml/safari bug:
  // http://bugs.webkit.org/show_bug.cgi?id=11231
  text += '¨0';

  if (globals.gListLevel) {
    text = text.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
      function (wholeMatch, list, m2) {
        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
        return parseConsecutiveLists(list, listType, true);
      }
    );
  } else {
    text = text.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
      function (wholeMatch, m1, list, m3) {
        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
        return parseConsecutiveLists(list, listType, false);
      }
    );
  }

  // strip sentinel
  text = text.replace(/¨0/, '');
  text = globals.converter._dispatch('lists.after', text, options, globals);
  return text;
});

/**
 * Parse metadata at the top of the document
 */
showdown.subParser('metadata', function (text, options, globals) {
  'use strict';

  if (!options.metadata) {
    return text;
  }

  text = globals.converter._dispatch('metadata.before', text, options, globals);

  function parseMetadataContents (content) {
    // raw is raw so it's not changed in any way
    globals.metadata.raw = content;

    // escape chars forbidden in html attributes
    // double quotes
    content = content
      // ampersand first
      .replace(/&/g, '&amp;')
      // double quotes
      .replace(/"/g, '&quot;');

    content = content.replace(/\n {4}/g, ' ');
    content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (wm, key, value) {
      globals.metadata.parsed[key] = value;
      return '';
    });
  }

  text = text.replace(/^\s*«««+(\S*?)\n([\s\S]+?)\n»»»+\n/, function (wholematch, format, content) {
    parseMetadataContents(content);
    return '¨M';
  });

  text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (wholematch, format, content) {
    if (format) {
      globals.metadata.format = format;
    }
    parseMetadataContents(content);
    return '¨M';
  });

  text = text.replace(/¨M/g, '');

  text = globals.converter._dispatch('metadata.after', text, options, globals);
  return text;
});

/**
 * Remove one level of line-leading tabs or spaces
 */
showdown.subParser('outdent', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('outdent.before', text, options, globals);

  // attacklab: hack around Konqueror 3.5.4 bug:
  // "----------bug".replace(/^-/g,"") == "bug"
  text = text.replace(/^(\t|[ ]{1,4})/gm, '¨0'); // attacklab: g_tab_width

  // attacklab: clean up hack
  text = text.replace(/¨0/g, '');

  text = globals.converter._dispatch('outdent.after', text, options, globals);
  return text;
});

/**
 *
 */
showdown.subParser('paragraphs', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('paragraphs.before', text, options, globals);
  // Strip leading and trailing lines:
  text = text.replace(/^\n+/g, '');
  text = text.replace(/\n+$/g, '');

  var grafs = text.split(/\n{2,}/g),
      grafsOut = [],
      end = grafs.length; // Wrap <p> tags

  for (var i = 0; i < end; i++) {
    var str = grafs[i];
    // if this is an HTML marker, copy it
    if (str.search(/¨(K|G)(\d+)\1/g) >= 0) {
      grafsOut.push(str);

    // test for presence of characters to prevent empty lines being parsed
    // as paragraphs (resulting in undesired extra empty paragraphs)
    } else if (str.search(/\S/) >= 0) {
      str = showdown.subParser('spanGamut')(str, options, globals);
      str = str.replace(/^([ \t]*)/g, '<p>');
      str += '</p>';
      grafsOut.push(str);
    }
  }

  /** Unhashify HTML blocks */
  end = grafsOut.length;
  for (i = 0; i < end; i++) {
    var blockText = '',
        grafsOutIt = grafsOut[i],
        codeFlag = false;
    // if this is a marker for an html block...
    // use RegExp.test instead of string.search because of QML bug
    while (/¨(K|G)(\d+)\1/.test(grafsOutIt)) {
      var delim = RegExp.$1,
          num   = RegExp.$2;

      if (delim === 'K') {
        blockText = globals.gHtmlBlocks[num];
      } else {
        // we need to check if ghBlock is a false positive
        if (codeFlag) {
          // use encoded version of all text
          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);
        } else {
          blockText = globals.ghCodeBlocks[num].codeblock;
        }
      }
      blockText = blockText.replace(/\$/g, '$$$$'); // Escape any dollar signs

      grafsOutIt = grafsOutIt.replace(/(\n\n)?¨(K|G)\d+\2(\n\n)?/, blockText);
      // Check if grafsOutIt is a pre->code
      if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
        codeFlag = true;
      }
    }
    grafsOut[i] = grafsOutIt;
  }
  text = grafsOut.join('\n');
  // Strip leading and trailing lines:
  text = text.replace(/^\n+/g, '');
  text = text.replace(/\n+$/g, '');
  return globals.converter._dispatch('paragraphs.after', text, options, globals);
});

/**
 * Run extension
 */
showdown.subParser('runExtension', function (ext, text, options, globals) {
  'use strict';

  if (ext.filter) {
    text = ext.filter(text, globals.converter, options);

  } else if (ext.regex) {
    // TODO remove this when old extension loading mechanism is deprecated
    var re = ext.regex;
    if (!(re instanceof RegExp)) {
      re = new RegExp(re, 'g');
    }
    text = text.replace(re, ext.replace);
  }

  return text;
});

/**
 * These are all the transformations that occur *within* block-level
 * tags like paragraphs, headers, and list items.
 */
showdown.subParser('spanGamut', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('spanGamut.before', text, options, globals);
  text = showdown.subParser('codeSpans')(text, options, globals);
  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);
  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);

  // Process anchor and image tags. Images must come first,
  // because ![foo][f] looks like an anchor.
  text = showdown.subParser('images')(text, options, globals);
  text = showdown.subParser('anchors')(text, options, globals);

  // Make links out of things like `<http://example.com/>`
  // Must come after anchors, because you can use < and >
  // delimiters in inline links like [this](<url>).
  text = showdown.subParser('autoLinks')(text, options, globals);
  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);
  text = showdown.subParser('emoji')(text, options, globals);
  text = showdown.subParser('underline')(text, options, globals);
  text = showdown.subParser('italicsAndBold')(text, options, globals);
  text = showdown.subParser('strikethrough')(text, options, globals);
  text = showdown.subParser('ellipsis')(text, options, globals);

  // we need to hash HTML tags inside spans
  text = showdown.subParser('hashHTMLSpans')(text, options, globals);

  // now we encode amps and angles
  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);

  // Do hard breaks
  if (options.simpleLineBreaks) {
    // GFM style hard breaks
    // only add line breaks if the text does not contain a block (special case for lists)
    if (!/\n\n¨K/.test(text)) {
      text = text.replace(/\n+/g, '<br />\n');
    }
  } else {
    // Vanilla hard breaks
    text = text.replace(/  +\n/g, '<br />\n');
  }

  text = globals.converter._dispatch('spanGamut.after', text, options, globals);
  return text;
});

showdown.subParser('strikethrough', function (text, options, globals) {
  'use strict';

  function parseInside (txt) {
    if (options.simplifiedAutoLink) {
      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
    }
    return '<del>' + txt + '</del>';
  }

  if (options.strikethrough) {
    text = globals.converter._dispatch('strikethrough.before', text, options, globals);
    text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });
    text = globals.converter._dispatch('strikethrough.after', text, options, globals);
  }

  return text;
});

/**
 * Strips link definitions from text, stores the URLs and titles in
 * hash references.
 * Link defs are in the form: ^[id]: url "optional title"
 */
showdown.subParser('stripLinkDefinitions', function (text, options, globals) {
  'use strict';

  var regex       = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=¨0))/gm,
      base64Regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=¨0)|(?=\n\[))/gm;

  // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
  text += '¨0';

  var replaceFunc = function (wholeMatch, linkId, url, width, height, blankLines, title) {
    linkId = linkId.toLowerCase();
    if (url.match(/^data:.+?\/.+?;base64,/)) {
      // remove newlines
      globals.gUrls[linkId] = url.replace(/\s/g, '');
    } else {
      globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive
    }

    if (blankLines) {
      // Oops, found blank lines, so it's not a title.
      // Put back the parenthetical statement we stole.
      return blankLines + title;

    } else {
      if (title) {
        globals.gTitles[linkId] = title.replace(/"|'/g, '&quot;');
      }
      if (options.parseImgDimensions && width && height) {
        globals.gDimensions[linkId] = {
          width:  width,
          height: height
        };
      }
    }
    // Completely remove the definition from the text
    return '';
  };

  // first we try to find base64 link references
  text = text.replace(base64Regex, replaceFunc);

  text = text.replace(regex, replaceFunc);

  // attacklab: strip sentinel
  text = text.replace(/¨0/, '');

  return text;
});

showdown.subParser('tables', function (text, options, globals) {
  'use strict';

  if (!options.tables) {
    return text;
  }

  var tableRgx       = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm,
      //singeColTblRgx = /^ {0,3}\|.+\|\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n(?: {0,3}\|.+\|\n)+(?:\n\n|¨0)/gm;
      singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|¨0)/gm;

  function parseStyles (sLine) {
    if (/^:[ \t]*--*$/.test(sLine)) {
      return ' style="text-align:left;"';
    } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
      return ' style="text-align:right;"';
    } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
      return ' style="text-align:center;"';
    } else {
      return '';
    }
  }

  function parseHeaders (header, style) {
    var id = '';
    header = header.trim();
    // support both tablesHeaderId and tableHeaderId due to error in documentation so we don't break backwards compatibility
    if (options.tablesHeaderId || options.tableHeaderId) {
      id = ' id="' + header.replace(/ /g, '_').toLowerCase() + '"';
    }
    header = showdown.subParser('spanGamut')(header, options, globals);

    return '<th' + id + style + '>' + header + '</th>\n';
  }

  function parseCells (cell, style) {
    var subText = showdown.subParser('spanGamut')(cell, options, globals);
    return '<td' + style + '>' + subText + '</td>\n';
  }

  function buildTable (headers, cells) {
    var tb = '<table>\n<thead>\n<tr>\n',
        tblLgn = headers.length;

    for (var i = 0; i < tblLgn; ++i) {
      tb += headers[i];
    }
    tb += '</tr>\n</thead>\n<tbody>\n';

    for (i = 0; i < cells.length; ++i) {
      tb += '<tr>\n';
      for (var ii = 0; ii < tblLgn; ++ii) {
        tb += cells[i][ii];
      }
      tb += '</tr>\n';
    }
    tb += '</tbody>\n</table>\n';
    return tb;
  }

  function parseTable (rawTable) {
    var i, tableLines = rawTable.split('\n');

    for (i = 0; i < tableLines.length; ++i) {
      // strip wrong first and last column if wrapped tables are used
      if (/^ {0,3}\|/.test(tableLines[i])) {
        tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, '');
      }
      if (/\|[ \t]*$/.test(tableLines[i])) {
        tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, '');
      }
      // parse code spans first, but we only support one line code spans
      tableLines[i] = showdown.subParser('codeSpans')(tableLines[i], options, globals);
    }

    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),
        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),
        rawCells = [],
        headers = [],
        styles = [],
        cells = [];

    tableLines.shift();
    tableLines.shift();

    for (i = 0; i < tableLines.length; ++i) {
      if (tableLines[i].trim() === '') {
        continue;
      }
      rawCells.push(
        tableLines[i]
          .split('|')
          .map(function (s) {
            return s.trim();
          })
      );
    }

    if (rawHeaders.length < rawStyles.length) {
      return rawTable;
    }

    for (i = 0; i < rawStyles.length; ++i) {
      styles.push(parseStyles(rawStyles[i]));
    }

    for (i = 0; i < rawHeaders.length; ++i) {
      if (showdown.helper.isUndefined(styles[i])) {
        styles[i] = '';
      }
      headers.push(parseHeaders(rawHeaders[i], styles[i]));
    }

    for (i = 0; i < rawCells.length; ++i) {
      var row = [];
      for (var ii = 0; ii < headers.length; ++ii) {
        if (showdown.helper.isUndefined(rawCells[i][ii])) {

        }
        row.push(parseCells(rawCells[i][ii], styles[ii]));
      }
      cells.push(row);
    }

    return buildTable(headers, cells);
  }

  text = globals.converter._dispatch('tables.before', text, options, globals);

  // find escaped pipe characters
  text = text.replace(/\\(\|)/g, showdown.helper.escapeCharactersCallback);

  // parse multi column tables
  text = text.replace(tableRgx, parseTable);

  // parse one column tables
  text = text.replace(singeColTblRgx, parseTable);

  text = globals.converter._dispatch('tables.after', text, options, globals);

  return text;
});

showdown.subParser('underline', function (text, options, globals) {
  'use strict';

  if (!options.underline) {
    return text;
  }

  text = globals.converter._dispatch('underline.before', text, options, globals);

  if (options.literalMidWordUnderscores) {
    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
      return '<u>' + txt + '</u>';
    });
    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
      return '<u>' + txt + '</u>';
    });
  } else {
    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
    });
    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
    });
  }

  // escape remaining underscores to prevent them being parsed by italic and bold
  text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);

  text = globals.converter._dispatch('underline.after', text, options, globals);

  return text;
});

/**
 * Swap back in all the special characters we've hidden.
 */
showdown.subParser('unescapeSpecialChars', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);

  text = text.replace(/¨E(\d+)E/g, function (wholeMatch, m1) {
    var charCodeToReplace = parseInt(m1);
    return String.fromCharCode(charCodeToReplace);
  });

  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);
  return text;
});

showdown.subParser('makeMarkdown.blockquote', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    var children = node.childNodes,
        childrenLength = children.length;

    for (var i = 0; i < childrenLength; ++i) {
      var innerTxt = showdown.subParser('makeMarkdown.node')(children[i], globals);

      if (innerTxt === '') {
        continue;
      }
      txt += innerTxt;
    }
  }
  // cleanup
  txt = txt.trim();
  txt = '> ' + txt.split('\n').join('\n> ');
  return txt;
});

showdown.subParser('makeMarkdown.codeBlock', function (node, globals) {
  'use strict';

  var lang = node.getAttribute('language'),
      num  = node.getAttribute('precodenum');
  return '```' + lang + '\n' + globals.preList[num] + '\n```';
});

showdown.subParser('makeMarkdown.codeSpan', function (node) {
  'use strict';

  return '`' + node.innerHTML + '`';
});

showdown.subParser('makeMarkdown.emphasis', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    txt += '*';
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '*';
  }
  return txt;
});

showdown.subParser('makeMarkdown.header', function (node, globals, headerLevel) {
  'use strict';

  var headerMark = new Array(headerLevel + 1).join('#'),
      txt = '';

  if (node.hasChildNodes()) {
    txt = headerMark + ' ';
    var children = node.childNodes,
        childrenLength = children.length;

    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
  }
  return txt;
});

showdown.subParser('makeMarkdown.hr', function () {
  'use strict';

  return '---';
});

showdown.subParser('makeMarkdown.image', function (node) {
  'use strict';

  var txt = '';
  if (node.hasAttribute('src')) {
    txt += '![' + node.getAttribute('alt') + '](';
    txt += '<' + node.getAttribute('src') + '>';
    if (node.hasAttribute('width') && node.hasAttribute('height')) {
      txt += ' =' + node.getAttribute('width') + 'x' + node.getAttribute('height');
    }

    if (node.hasAttribute('title')) {
      txt += ' "' + node.getAttribute('title') + '"';
    }
    txt += ')';
  }
  return txt;
});

showdown.subParser('makeMarkdown.links', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes() && node.hasAttribute('href')) {
    var children = node.childNodes,
        childrenLength = children.length;
    txt = '[';
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '](';
    txt += '<' + node.getAttribute('href') + '>';
    if (node.hasAttribute('title')) {
      txt += ' "' + node.getAttribute('title') + '"';
    }
    txt += ')';
  }
  return txt;
});

showdown.subParser('makeMarkdown.list', function (node, globals, type) {
  'use strict';

  var txt = '';
  if (!node.hasChildNodes()) {
    return '';
  }
  var listItems       = node.childNodes,
      listItemsLenght = listItems.length,
      listNum = node.getAttribute('start') || 1;

  for (var i = 0; i < listItemsLenght; ++i) {
    if (typeof listItems[i].tagName === 'undefined' || listItems[i].tagName.toLowerCase() !== 'li') {
      continue;
    }

    // define the bullet to use in list
    var bullet = '';
    if (type === 'ol') {
      bullet = listNum.toString() + '. ';
    } else {
      bullet = '- ';
    }

    // parse list item
    txt += bullet + showdown.subParser('makeMarkdown.listItem')(listItems[i], globals);
    ++listNum;
  }

  // add comment at the end to prevent consecutive lists to be parsed as one
  txt += '\n<!-- -->\n';
  return txt.trim();
});

showdown.subParser('makeMarkdown.listItem', function (node, globals) {
  'use strict';

  var listItemTxt = '';

  var children = node.childNodes,
      childrenLenght = children.length;

  for (var i = 0; i < childrenLenght; ++i) {
    listItemTxt += showdown.subParser('makeMarkdown.node')(children[i], globals);
  }
  // if it's only one liner, we need to add a newline at the end
  if (!/\n$/.test(listItemTxt)) {
    listItemTxt += '\n';
  } else {
    // it's multiparagraph, so we need to indent
    listItemTxt = listItemTxt
      .split('\n')
      .join('\n    ')
      .replace(/^ {4}$/gm, '')
      .replace(/\n\n+/g, '\n\n');
  }

  return listItemTxt;
});



showdown.subParser('makeMarkdown.node', function (node, globals, spansOnly) {
  'use strict';

  spansOnly = spansOnly || false;

  var txt = '';

  // edge case of text without wrapper paragraph
  if (node.nodeType === 3) {
    return showdown.subParser('makeMarkdown.txt')(node, globals);
  }

  // HTML comment
  if (node.nodeType === 8) {
    return '<!--' + node.data + '-->\n\n';
  }

  // process only node elements
  if (node.nodeType !== 1) {
    return '';
  }

  var tagName = node.tagName.toLowerCase();

  switch (tagName) {

    //
    // BLOCKS
    //
    case 'h1':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 1) + '\n\n'; }
      break;
    case 'h2':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 2) + '\n\n'; }
      break;
    case 'h3':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 3) + '\n\n'; }
      break;
    case 'h4':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 4) + '\n\n'; }
      break;
    case 'h5':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 5) + '\n\n'; }
      break;
    case 'h6':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 6) + '\n\n'; }
      break;

    case 'p':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.paragraph')(node, globals) + '\n\n'; }
      break;

    case 'blockquote':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.blockquote')(node, globals) + '\n\n'; }
      break;

    case 'hr':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.hr')(node, globals) + '\n\n'; }
      break;

    case 'ol':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ol') + '\n\n'; }
      break;

    case 'ul':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ul') + '\n\n'; }
      break;

    case 'precode':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.codeBlock')(node, globals) + '\n\n'; }
      break;

    case 'pre':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.pre')(node, globals) + '\n\n'; }
      break;

    case 'table':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.table')(node, globals) + '\n\n'; }
      break;

    //
    // SPANS
    //
    case 'code':
      txt = showdown.subParser('makeMarkdown.codeSpan')(node, globals);
      break;

    case 'em':
    case 'i':
      txt = showdown.subParser('makeMarkdown.emphasis')(node, globals);
      break;

    case 'strong':
    case 'b':
      txt = showdown.subParser('makeMarkdown.strong')(node, globals);
      break;

    case 'del':
      txt = showdown.subParser('makeMarkdown.strikethrough')(node, globals);
      break;

    case 'a':
      txt = showdown.subParser('makeMarkdown.links')(node, globals);
      break;

    case 'img':
      txt = showdown.subParser('makeMarkdown.image')(node, globals);
      break;

    default:
      txt = node.outerHTML + '\n\n';
  }

  // common normalization
  // TODO eventually

  return txt;
});

showdown.subParser('makeMarkdown.paragraph', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
  }

  // some text normalization
  txt = txt.trim();

  return txt;
});

showdown.subParser('makeMarkdown.pre', function (node, globals) {
  'use strict';

  var num  = node.getAttribute('prenum');
  return '<pre>' + globals.preList[num] + '</pre>';
});

showdown.subParser('makeMarkdown.strikethrough', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    txt += '~~';
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '~~';
  }
  return txt;
});

showdown.subParser('makeMarkdown.strong', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    txt += '**';
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '**';
  }
  return txt;
});

showdown.subParser('makeMarkdown.table', function (node, globals) {
  'use strict';

  var txt = '',
      tableArray = [[], []],
      headings   = node.querySelectorAll('thead>tr>th'),
      rows       = node.querySelectorAll('tbody>tr'),
      i, ii;
  for (i = 0; i < headings.length; ++i) {
    var headContent = showdown.subParser('makeMarkdown.tableCell')(headings[i], globals),
        allign = '---';

    if (headings[i].hasAttribute('style')) {
      var style = headings[i].getAttribute('style').toLowerCase().replace(/\s/g, '');
      switch (style) {
        case 'text-align:left;':
          allign = ':---';
          break;
        case 'text-align:right;':
          allign = '---:';
          break;
        case 'text-align:center;':
          allign = ':---:';
          break;
      }
    }
    tableArray[0][i] = headContent.trim();
    tableArray[1][i] = allign;
  }

  for (i = 0; i < rows.length; ++i) {
    var r = tableArray.push([]) - 1,
        cols = rows[i].getElementsByTagName('td');

    for (ii = 0; ii < headings.length; ++ii) {
      var cellContent = ' ';
      if (typeof cols[ii] !== 'undefined') {
        cellContent = showdown.subParser('makeMarkdown.tableCell')(cols[ii], globals);
      }
      tableArray[r].push(cellContent);
    }
  }

  var cellSpacesCount = 3;
  for (i = 0; i < tableArray.length; ++i) {
    for (ii = 0; ii < tableArray[i].length; ++ii) {
      var strLen = tableArray[i][ii].length;
      if (strLen > cellSpacesCount) {
        cellSpacesCount = strLen;
      }
    }
  }

  for (i = 0; i < tableArray.length; ++i) {
    for (ii = 0; ii < tableArray[i].length; ++ii) {
      if (i === 1) {
        if (tableArray[i][ii].slice(-1) === ':') {
          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, '-') + ':';
        } else {
          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, '-');
        }
      } else {
        tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);
      }
    }
    txt += '| ' + tableArray[i].join(' | ') + ' |\n';
  }

  return txt.trim();
});

showdown.subParser('makeMarkdown.tableCell', function (node, globals) {
  'use strict';

  var txt = '';
  if (!node.hasChildNodes()) {
    return '';
  }
  var children = node.childNodes,
      childrenLength = children.length;

  for (var i = 0; i < childrenLength; ++i) {
    txt += showdown.subParser('makeMarkdown.node')(children[i], globals, true);
  }
  return txt.trim();
});

showdown.subParser('makeMarkdown.txt', function (node) {
  'use strict';

  var txt = node.nodeValue;

  // multiple spaces are collapsed
  txt = txt.replace(/ +/g, ' ');

  // replace the custom ¨NBSP; with a space
  txt = txt.replace(/¨NBSP;/g, ' ');

  // ", <, > and & should replace escaped html entities
  txt = showdown.helper.unescapeHTMLEntities(txt);

  // escape markdown magic characters
  // emphasis, strong and strikethrough - can appear everywhere
  // we also escape pipe (|) because of tables
  // and escape ` because of code blocks and spans
  txt = txt.replace(/([*_~|`])/g, '\\$1');

  // escape > because of blockquotes
  txt = txt.replace(/^(\s*)>/g, '\\$1>');

  // hash character, only troublesome at the beginning of a line because of headers
  txt = txt.replace(/^#/gm, '\\#');

  // horizontal rules
  txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, '$1\\$2$3');

  // dot, because of ordered lists, only troublesome at the beginning of a line when preceded by an integer
  txt = txt.replace(/^( {0,3}\d+)\./gm, '$1\\.');

  // +, * and -, at the beginning of a line becomes a list, so we need to escape them also (asterisk was already escaped)
  txt = txt.replace(/^( {0,3})([+-])/gm, '$1\\$2');

  // images and links, ] followed by ( is problematic, so we escape it
  txt = txt.replace(/]([\s]*)\(/g, '\\]$1\\(');

  // reference URIs must also be escaped
  txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, '\\[$1]:');

  return txt;
});

var root = this;

// AMD Loader
if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    'use strict';
    return showdown;
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

// CommonJS/nodeJS Loader
} else {}
}).call(this);

//# sourceMappingURL=showdown.js.map


/***/ }),

/***/ "../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/non-secure/index.cjs":
/***/ ((module) => {

let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = ''
    let i = size
    while (i--) {
      id += alphabet[(Math.random() * alphabet.length) | 0]
    }
    return id
  }
}
let nanoid = (size = 21) => {
  let id = ''
  let i = size
  while (i--) {
    id += urlAlphabet[(Math.random() * 64) | 0]
  }
  return id
}
module.exports = { nanoid, customAlphabet }


/***/ })

}]);